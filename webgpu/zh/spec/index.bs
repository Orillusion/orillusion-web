<pre class='metadata'>
Title: WebGPU
Shortname: webgpu
Level: None
Status: w3c/ED
Group: webgpu
ED: https://gpuweb.github.io/gpuweb/
TR: https://www.w3.org/TR/webgpu/
Repository: gpuweb/gpuweb
!Participate: <a href="https://github.com/gpuweb/gpuweb/issues/new">File an issue</a> (<a href="https://github.com/gpuweb/gpuweb/issues">open issues</a>)

!Translator: 赵凌云，lingyun.zhao@orillusion.com
!Translator: 薛沛，pei.xue@orillusion.com
Editor: Dzmitry Malyshau, Mozilla https://www.mozilla.org, dmalyshau@mozilla.com, w3cid 96977
Editor: Kai Ninomiya, Google https://www.google.com, kainino@google.com, w3cid 99487
Editor: Brandon Jones, Google https://www.google.com, bajones@google.com, w3cid 87824
Former Editor: Justin Fan, Apple https://www.apple.com, justin_fan@apple.com, w3cid 115633
Abstract: WebGPU API翻译文档。本翻译非官方翻译。（WebGPU 公开了一个 API，用于在图形处理单元上执行操作，例如渲染和计算。）
Markup Shorthands: markdown yes
Markup Shorthands: dfn yes
Markup Shorthands: idl yes
Markup Shorthands: css no
Assume Explicit For: yes
</pre>

<pre class=biblio>
{
  "WGSL": {
    "authors": [
      "David Neto",
      "Myles C. Maxfield"
    ],
    "href": "https://gpuweb.github.io/gpuweb/wgsl/",
    "title": "WebGPU Shading Language",
    "status": "Editor's Draft",
    "publisher": "W3C",
    "deliveredBy": [
      "https://github.com/gpuweb/gpuweb"
    ]
  },
  "SourceMap": {
    "authors": [
      "John Lenz",
      "Nick Fitzgerald"
    ],
    "href": "https://sourcemaps.info/spec.html",
    "title": "Source Map Revision 3 Proposal"
  }
}
</pre>

<pre class="link-defaults">
spec:html;
    type:interface; text:Navigator
spec:webidl;
    type:interface; text:Promise
</pre>

<pre class='anchors'>
spec: ECMA-262; urlPrefix: https://tc39.es/ecma262/#
    type: dfn
        text: 代理; url: agent
        text: surrounding agent; url: surrounding-agent
        text: 代理集群; url: sec-agent-clusters
spec: webidl; urlPrefix: https://heycam.github.io/webidl/#
    type: dfn
        text: resolve; url: resolve
spec: web-apis; urlPrefix: https://html.spec.whatwg.org/multipage/webappapis.html#
    type: dfn
        text: cross-origin isolated capability; url: concept-settings-object-cross-origin-isolated-capability
spec: canvas; urlPrefix: https://html.spec.whatwg.org/multipage/canvas.html#
    type: dfn
        text: origin-clean; url: concept-canvas-origin-clean
        text: placeholder canvas element; url: offscreencanvas-placeholder
        text: canvas context mode; url: concept-canvas-context-mode
        text: OffscreenCanvas context mode; url: offscreencanvas-context-mode
        text: check the usability of the image argument; url: check-the-usability-of-the-image-argument
spec: WGSL; urlPrefix: https://gpuweb.github.io/gpuweb/wgsl/#
    type: dfn
        text: location; url: input-output-locations
        text: interpolation; url: interpolation
        text: minimum binding size; url: minimum-binding-size
        text: 管线可重写; url: pipeline-overridable
        text: 管线可重写常量标识符字符串; url: pipeline-overridable-constant-identifier-string
        text: pipeline-overridable constant has a default value; url: pipeline-overridable-constant-has-a-default-value
        text: statically accessed; url: statically-accessed
        text: wgsl-declaration; url: declaration
        text: wgsl-type; url: type
        text: pipeline output; url: pipeline-output
        text: pipeline input; url: pipeline-input
        text: builtin; url: builtin-variables
        text: channel formats; url: channel-formats
        text: invalid memory reference; url: invalid-memory-reference
        text: shader-creation error; url: shader-creation-error
        text: 管线创建错误; url: pipeline-creation-error
        text: store type; url: store-type
        text: runtime-sized; url: runtime-sized
        text: SizeOf; url: sizeof
</pre>

<style>
/* Make <dl> blocks more distinct from their surroundings. */
main dl:not(.switch) {
    border-left: thin solid #f3e48c;
    padding-left: .5em;
}

/** In switches, make multiple consecutive <dd> entries distinguishable. */
dl.switch > dd {
    display: list-item;
    list-style: square;
}

/* <p> by default has these margins. Update ul/ol/dl to match,
 * since they are also put in places where paragraphs go. */
p, ul, ol, dl {
    margin: 1em 0;
}

/* The new spec template doesn't put a box around algorithms anymore. */
/* Add a similar box for Valid Usage requirements. */
div.algorithm, div.validusage {
    margin: .5em 0;
    padding: .5em;
    border-width: thin;
    border-style: solid;
    border-radius: .5em;
}
div.validusage {
    border-color: #88e;
}
div.algorithm {
    border-color: #ddd;
}

/* Box for Valid Usage requirements. */
div.validusage {
    padding: .5em;
    border: thin solid #88e !important;
    border-radius: .5em;
}
/*
 * If the Valid Usage requirements are the first child of a *-timeline block give it a larger top
 * margin to prevent the block labels from overlapping.
 */
.content-timeline>.validusage:first-child,
.device-timeline>.validusage:first-child,
.queue-timeline>.validusage:first-child {
    margin-top: 1.5em;
}

/*
 * Boxes for steps that occur on a particular timeline.
 */
div.content-timeline, div.device-timeline, div.queue-timeline {
    padding: .5em;
    border-radius: .5em;
}
.content-timeline {
    background: rgba(0, 255, 0, 0.05);
    background: var(--tint-green);
}
.device-timeline {
    background: rgba(255, 0, 0, 0.05);
    background: var(--tint-red);
}
.queue-timeline {
    background: rgba(255, 0, 255, 0.05);
    background: var(--tint-purple);
}

/*
 * Stylistic labels, for clarity of presentation of these blocks.
 *
 * NOTE: This text is non-accessible and non-selectable; surrounding
 * text must also explain the context.
 */
.validusage, .content-timeline, .device-timeline, .queue-timeline {
    position: relative;
}
.validusage::before,
.content-timeline::before,
.device-timeline::before,
.queue-timeline::before {
    font-weight: bold;
    font-style: italic;
    font-size: 130%;
    color: rgba(0, 0, 0, 0.15);
    color: var(--watermark-text);
    position: absolute;
    right: .3em;
    top: -.1em;
}
.validusage::before {
    content: "Valid Usage";
}
.content-timeline::before {
    content: "Content Timeline";
}
.device-timeline::before {
    content: "Device Timeline";
}
.queue-timeline::before {
    content: "Queue Timeline";
}

/*
 * Ensure that argumentdef blocks don't overflow algorithm section borders. This is made far harder
 * than it needs to be because the top-level W3C stylesheet has several @media + min-width variants
 * that mark themselves as !important and then proceed to do the wrong thing.
 */
@media screen and (min-width: 78em) {
    body:not(.toc-inline) .algorithm .overlarge {
        margin-right: auto !important;
    }
}
@media screen and (min-width: 90em) {
    body:not(.toc-inline) .algorithm .overlarge {
        margin-right: auto !important;
    }
}
.algorithm .overlarge {
    margin-right: auto !important;
}

/*
 * The default algorithm style has a caption that doesn't suit this spec's
 * formatting particularly well. Hide it.
 */
.algorithm .argumentdef {
    margin-top: 0;
}
.algorithm .argumentdef>caption {
    display: none;
}

/*
 * Add vertical lines to demarcate multi-column cells.
 */
table.data td[colspan] {
    border-left-style: dotted;
    border-right-style: dotted;
}

table.data.no-colspan-center td[colspan],
table.data.no-colspan-center th[colspan] {
    text-align: unset;
}

table.data tr.row-continuation td,
table.data tr.row-continuation th {
    border-top: none;
}

/*
 * Sticky table headers.
 */
.overlarge {
    /* position: sticky doesn't work inside scrollable elements. */
    overflow-x: unset;
}
thead.stickyheader th, th.stickyheader {
    position: sticky;
    top: 0;
    background: #f8f8f8;
    background: var(--stickyheader-background);
}

/*
 * Darkmode colors
 */
:root {
    --watermark-text: rgba(0, 0, 0, 15%);
    --stickyheader-background: #f8f8f8;
    --tint-red: rgba(255, 0, 0, 6%);
    --tint-green: rgba(0, 255, 0, 10%);
    --tint-blue: rgba(0, 0, 255, 5%);
    --tint-purple: rgba(255, 0, 255, 5%);
}
@media (prefers-color-scheme:dark) {
    :root {
        --watermark-text: rgba(255, 255, 255, 25%);
        --stickyheader-background: #181818;
        --tint-red: rgba(255, 0, 0, 20%);
        --tint-green: rgba(0, 255, 0, 18%);
        --tint-blue: rgba(0, 130, 255, 24%);
        --tint-purple: rgba(255, 0, 255, 22%);
    }
}

</style>

# 介绍 # {#intro}

*本节内容为非标准的*

[图形处理单元](https://en.wikipedia.org/wiki/Graphics_processing_unit)，简称GPU，对于在个人计算中实现丰富的渲染和计算应用程序至关重要。
WebGPU 是将 GPU 硬件能力公开给 web 的一组 API。该API设计自底向上有效地映射到（2014 年后）原生 GPU API。WebGPU 与 [WebGL](https://www.khronos.org/webgl/) 没有关系，也不对应到 OpenGL ES。

WebGPU 将物理 GPU 硬件视为 {{GPUAdapter}}。 它通过 {{GPUDevice}} 对适配器进行连接，{{GPUDevice}} 可以用来管理资源，同时设备的 {{GPUQueue}} 可以用来执行指令。 {{GPUDevice}} 可能有自己的内存，可以高速访问处理单元。 {{GPUBuffer}} 和 {{GPUTexture}} 是 GPU 内存中的两种<dfn dfn>物理资源</dfn>。 {{GPUCommandBuffer}} 和 {{GPURenderBundle}} 是用来存储用户记录指令的容器。 {{GPUShaderModule}} 用来存储 [=着色器=] 代码。 其他资源，将按照 GPU 使用 [=物理资源=] 的方式进行配置，例如 {{GPUSampler}} 或 {{GPUBindGroup}}。

GPU 可以通过将数据导入[=管线=]的方式，来执行 {{GPUCommandBuffer}} 中编码的指令，这是不易编程时期和可编程时期的混合。 可编程时期，GPU可以运行<dfn dfn>着色器</dfn>语言，着色器语言是专为在 GPU 硬件上运行而设计的特殊程序。[=管线=]的大部分状态通过 {{GPURenderPipeline}} 或 {{GPUComputePipeline}} 对象来定义。 不在这些 [=管线=] 对象中的状态，是在编码时通过使用指令设置的，例如 {{GPUCommandEncoder/beginRenderPass()}} 或 {{GPURenderPassEncoder/setBlendConstant()}}。


# 恶意使用注意事项 # {#malicious-use}

*本节内容为非标准的* 本节描述了在 Web 上公开此 API 相关的风险

## 安全 ## {#security}

WebGPU 的安全标准与 Web 环境的安全标准一样，同样需要严格执行。实现安全标准的一般做法是在所有指令到达 GPU 之前对其进行严格验证，确保一个页面只能访问该页面自己的数据。

### 基于 CPU 的未定义行为 ### {#security-cpu-ub}

WebGPU 的实现是针对特定的目标平台，将用户提交的工作任务转换为 API 指令。这些API指令的合法使用规则由原生 API 进行明确。（例如，参见 [vkCreateDescriptorSetLayout](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/vkCreateDescriptorSetLayout.html)）如果不遵守合法的使用规则，通常不保证 API 指令的执行结果。这称为“未定义行为”，黑客可以利用这种行为来访问没有权限的内存或强制驱动程序执行恶意代码。

为了禁止不安全的使用，任何被用户提交的工作任务，都需要被定义在WebGPU允许的行为范围内。一个 WebGPU 的实现必须验证用户提交的所有工作任务，只有合法的工作任务才能被驱动程序执行。 本文档明确了所有错误场景和异常处理方法。例如，在 {{GPUCommandEncoder/copyBufferToBuffer()}} 的“源”和“目标”中指定具有交叉范围的相同缓冲区，会导致  {{GPUCommandEncoder}} 产生错误，并且不会执行后续的其他操作。

请查看 [[#errors-and-debugging]] 有关报错处理的更多信息。

## 基于 GPU 的未定义行为 ## {#security-gpu-ub}

WebGPU [=着色器=] 程序由 GPU 硬件内部的计算单元执行。 在原生 API 中，某些着色器指令可能会导致 GPU 上出现未定义的行为。为了解决这个问题，着色器指令集及其定义的行为都是由 WebGPU 严格定义的。 当着色器代码被提供给 {{GPUDevice/createShaderModule()}} 时， WebGPU 的实现必须在执行任何转换前（到特定于平台的着色器）对代码进行验证。

## 未初始化的数据 ## {#security-uninitialized}

通常，分配新内存可能会暴露系统上运行的其他应用程序的剩余数据。为了解决这个问题，WebGPU 会在概念上将所有资源初始化为零，但是如果开发人员手动做了初始化操作，在实际中可能会跳过此步骤。这些需要被初始化的内容包括着色器内的变量和共享工作组中的内存。

清除工作组内存的精确机制可能因平台而异。如果某个平台的原生 API 不提供清除工作组内存的机制，WebGPU 在此平台的实现将对计算着色器的处理转换为: 首先清除所有调用，同步确认所有调用都被清除后，再继续执行开发人员的代码。

## 着色器中的越界访问 ## {#security-shader}

[=着色器=]程序可以对[=物理资源=]进行直接访问（例如，作为 {{GPUBufferBindingType/"uniform"}} {{GPUBufferBinding}}），或通过<dfn dfn>纹理单元</dfn>对[=物理资源=]进行访问，这里的纹理单元是指处理纹理坐标转换的固定功能硬件块。API 端的验证只能保证将所有的输入提供给着色器，并且保证这些输入都有正确的用法和类型。
如果没有调用[=纹理单元=]，主机 API 端不能保证数据在边界内访问。

Issue: 定义主机 API 与着色器 API 有什么不同

为了防止着色器访问了应用程序没有权限的 GPU 内存，WebGPU 的实现可能会在驱动程序中启用特殊模式（称为“鲁棒性缓冲区访问”），这种特殊访问模式保证了着色器的访问在缓冲区边界内。

另一种防止着色器越界访问的方法是，WebGPU 的实现，可以通过插入手动边界检查来转换着色器代码。当采用这种方法时，越界检查仅适用于数组索引。着色器结构的普通字段访问不需要被检查，因为 {{GPUBufferBindingLayout/minBindingSize}} 的验证在主机端完成。

如果着色器尝试在[=物理资源=]边界之外加载数据，WebGPU 的实现可以允许：
  1. 在资源边界内的另一个位置返回一个值
  2. 返回带有任意“X”的“(0, 0, 0, X)”的值向量
  3. 部分丢弃绘制或调度调用

如果着色器尝试在[=物理资源=]边界之外写入数据，WebGPU 的实现可以允许：
  1. 将值写入资源边界内的另一个位置
  2. 丢弃写操作
  3. 部分丢弃绘制或调度调用

## 无效数据 ## {#security-invalid-data}

将 [浮点数](https://en.wikipedia.org/wiki/IEEE_754) 数据从 CPU 上传到 GPU 时，或者在 GPU 上生成浮点数，我们最终可能会得到一个不对应的二进制表示的有效数字，例如无穷大或 NaN（非数字）。 这种情况下的 GPU 行为是受限于 GPU 硬件实现的精度，这里的 GPU 硬件实现是基于 IEEE-754 标准的。 WebGPU 保证引入无效的浮点数只会影响算术计算的结果，不会有其他副作用。

### 驱动程序错误 ### {#security-driver-bugs}

GPU 驱动程序像任何其他软件一样容易出现错误。 如果发生错误，黑客可能会利用驱动程序的错误行为来访问没有权限的数据。为了降低风险，WebGPU 工作组将与 GPU 厂商进行协调，将 WebGPU 一致性测试套件 (CTS) 作为其驱动程序测试流程的一部分进行集成，这和 WebGL 的驱动程序测试方法类似。 WebGPU 的实现将为一些已发现的错误提供规避方法，并在无法规避已知错误的驱动程序上禁用WebGPU。

### 定时攻击 ### {#security-timing}

WebGPU 通过 Web Workers 进行多线程使用。 因此，WebGPU 的设计是避免用户遭遇到现代的高精度定时攻击。 一些对象，比如 {{GPUBuffer}} 或 {{GPUQueue}} ，具有同时被访问的共享状态。因此可能会发生竞争条件，类似于多个 Web Workers 同时访问同一个的 “SharedArrayBuffer”，这种情况下线程调度是可见的。

WebGPU 解决这个问题的方法是，只有当[跨域隔离](https://web.dev/coop-coep/)规则开启后，再将反序列化（或共享）对象的能力只赋予[=代理集群=]中的[=代理=]，此限制符合对抗恶意使用“SharedArrayBuffer”的 [缓解措施](https://hacks.mozilla.org/2020/07/safely-reviving-shared-memory/)。同样，用户代理也可以序列化[=代理=]共享任何句柄以完全防止任何并发。

总结来说，WebGPU 共享状态下可能遭受到的竞争攻击是 `SharedArrayBuffer` 攻击的一小部分。

WebGPU 还指定了 {{GPUFeatureName/"timestamp-query"}} 功能，给 GPU 操作提供高精度计时。 该功能是可选的，一个 WebGPU 的实现可能会只暴露在那些受信任的场景中。 或者，计时查询结果可以由计算着色器处理并对齐到较低的精度。

### 行锤攻击 ### {#security-rowhammer}

[行锤](https://en.wikipedia.org/wiki/Row_hammer) 是利用 DRAM 单元中的状态泄漏来进行的一类攻击。 它可以被用[在 GPU 上](https://www.vusec.net/projects/glitch/)。 WebGPU 没有任何特定的缓解措施，主要依赖于平台级解决方案，例如减少内存刷新间隔。

## 拒绝服务 ## {#security-dos}

WebGPU 应用程序可以访问 GPU 内存和计算单元。 WebGPU 实现可能会限制
应用程序的可用 GPU 内存，以保持其他应用程序的响应。对于 GPU 处理时间，WebGPU 实现可能会设置“看门狗”计时器，以确保应用程序不会导致 GPU 无响应超过几秒钟。这些措施与 WebGL 中使用的措施类似。

## 工作负载识别 ## {#security-workload-identification}

在同一台机器上运行的不同程序（和网页）之间，存在共享的受限全局资源，WebGPU 提供对这些资源的访问能力。 基于这些共享资源的使用模式，应用程序可以尝试间接探测这些全局资源是如何受限的，以便推断由其他打开的网页执行的工作负载。这些问题通常与 Javascript 面对的问题类似，例如系统内存和 CPU 执行吞吐量。 WebGPU 不提供任何对此额外的
缓解措施。

### 内存资源 ### {#security-memory-resources}

WebGPU 暴露了机器全局内存堆中，例如 VRAM，的错误分配能力。通过尝试分配内存资源和检测内存分配是否失败，使系统剩余可用内存的大小（对于给定的堆类型）可以被探测到。

GPU 内部有一个或多个（通常只有两个）内存堆，由所有正在运行的应用程序共享。 当堆耗尽时，WebGPU 将无法创建资源。这些内存堆的分配是可见的，这可能使得恶意应用程序猜测哪些堆被其他应用程序使用，以及这些应用程序从中分配了多少资源。

### 计算资源 ### {#security-computation-resources}

如果一个站点与另一个站点同时使用 WebGPU，那么这个站点会发现处理一些工作的时间增加了。 例如，如果一个站点不断提交计算工作任务并跟踪队列上工作的完成情况，可能会观察到其他工作任务也开始使用 GPU。

GPU 有许多可以独立测试的部分，例如算术单元、纹理采样单元、原子单元等。恶意应用程序可能会感知到其中一些单元受到压力，并通过分析应力模式来试图猜测另一个应用的工作量。 这与实际 Javascript 的 CPU 执行方式相似。

## 隐私 ## {#security-privacy}

WebGPU 可以暴露许多关于底层 GPU 架构和设备几何结构的细节。这包括可用的物理适配器，对 GPU 和 CPU 可以使用的资源的许多限制（例如最大纹理大小），以及任何可选的特定于硬件的可用能力。

用户代理没有义务暴露真正的硬件限制，他们完全控制了有多少机器细节可以被暴露。 减少指纹识别的一种策略是分箱，将所有目标平台放入几个 bin 中。 一般来说，暴露硬件限制的隐私影响与 WebGL 的隐私影响相匹配。

[=limit/默认=]限制也特意设置得足够宽松，以允许大多数应用程序在不需要请求更高权限的情况下工作。 API 的所有使用都根据请求的限制进行验证，所以实际的硬件功能不会偶然暴露给用户。

### 特定于机器的工件 ### {#security-machine-artifacts}

存在于一些特定于机器的光栅化/精度工件和性能差异，他们在 WebGL 中同样也可以观察到的。 这些特定于机器的工件适用于光栅化覆盖和模式、着色器阶段之间变化的插值精度、计算单元调度、以及执行的更多方面。

通常，光栅化和精确指纹在大多数或所有供应商的设备中都是相同的。性能差异比较棘手，但差异也相对较小（与 JS 执行性能一样）。

### 机器特定性能 ### {#security-machine-performance}

区分用户的另一个因素是衡量 GPU 上特定操作的性能。即使计时精度较低，重复执行操作也可以显示用户的机器在执行特定工作任务下的速度是否很快。这是一个相当常见的向量（存在于 WebGL 和 Javascript 中），但它也是低信号且相对难以真正标准化的。

WebGPU 计算管线公开了对 GPU 的访问，不受固定功能硬件的阻碍。这给唯一设备指纹带来了额外的风险。 用户代理可以采取措施将逻辑 GPU 调用与实际计算单元分离以降低这种风险。

### 用户代理状态 ### {#security-user-agent-state}

本规范没有定义任何额外的用户代理状态。
但是，需要用户代理提供编译缓存给大开销的编译，如 {{GPUShaderModule}}、{{GPURenderPipeline}} 和 {{GPUComputePipeline}}。这些缓存对于提高 WebGPU 应用程序在第一次访问加载后的加载时间很重要。

对于规范来说，这些缓存在极其快速的编译中难以辨别，但是对于应用程序来说，很容易衡量 {{GPUDevice/createComputePipelineAsync()}} 需要多长时间来执行。这可能会跨源泄漏信息（例如“用户是否使用此特定着色器访问了站点”），因此用户代理应遵循 [存储分区](https://github.com/privacycg/storage-partitioning) 中的最佳实践。

系统的 GPU 驱动程序也可能有自己的编译着色器和管线缓存。 用户代理
可能希望尽可能禁用这些，或者采用使 GPU 驱动程序认为它们不同的方法，将每个分区的数据添加到着色器。

### 适配器标识符 ### {#privacy-adapter-identifiers}

Issue: 描述公开适配器信息的注意事项

注意：预计 WebGPU 将公开某些级别的信息，以识别正在使用的 GPU 适配器的类型。
这是指纹信息的潜在来源，但过去使用 WebGL 的经验表明，在某种程度上，有必要使开发人员能够创建健壮的应用程序并有效地响应用户问题。

# 基本概念 # {#fundamentals}

## 公约 ## {#api-conventions}

### 点符号语法 ### {#dot-syntax}

在此规范中，使用了通常在编程语言中被使用的 `.` ("点符号")语法。短语“`Foo.Bar`”的意思是“`Foo`中的 `Bar`成员”。

在JavaScript中被采用的 `?.`（“可选链操作符”）语法也会用到。短语“Foo?.Bar”意思是，“如果 `Foo` 为 `null` 或 `undefined` ,则结果为 `undefined`; 否则，结果返回 `Foo.Bar` ”。

例如， `buffer` 是一个{{GPUBuffer}}， `buffer？.[[device]].[[adapter]]` 的意思是，“如果 `buffer` 为 `null` 或 `undefined` ，则buffer是 `undefined` ；否则，返回buffer内部的 `[[adapter]]` 内部的 `[[device]]` 。”

### 内部对象 ### {#webgpu-internal-objects}

<dfn dfn>内部对象</dfn>是一个概念性的，未暴露的 WebGPU 对象。[=内部对象=]追踪一个 API 对象的状态，并且包含了所有潜在的 API 实现。如果一个特定[=内部对象=]的状态可以从多个[=代理=]中并行地被改变，那么这些改变对于所有[=代理=]来说，总是最小的可执行单元。

Note: 一个 "[=代理=]" 指一个 Javascript “线程”（即. 主线程，或 Web Worker）。

### WebGPU 接口 ### {#webgpu-interfaces}

一个<dfn dfn>WebGPU 接口</dfn>是一个封装了[=内部对象=]的暴露接口。[=内部对象=]的状态通过 WebGPU 提供的接口进行改变。

所有包含 {{GPUObjectBase}} 的接口是一个[=WebGPU 接口=]。

<script type=idl>
interface mixin GPUObjectBase {
    attribute USVString? label;
};
</script>

{{GPUObjectBase}}有以下属性:

<dl dfn-type=attribute dfn-for=GPUObjectBase>
    : <dfn>label</dfn>
    ::
        标签，在开发工具（比如错误/告警消息，浏览器开发工具，平台调试工具）中被使用，并用来给开发者识别底层[=内部对象=]。标签没有特定的格式，所以不能可靠的被机器解析。

        在任何情况下，开发者可以自由选择是否使用该标签字段。
</dl>

{{GPUObjectBase}} 有以下内部槽位:

<dl dfn-type=attribute dfn-for=GPUObjectBase>
    : <dfn>\[[device]]</dfn>, of type [=device=], readonly
    ::
        一个内部槽位包含一个[=设备=]，该[=设备=]同时拥有[=内部对象=]。
</dl>

### 对象描述符 ### {#object-descriptors}

一个<dfn dfn>对象描述符</dfn>包含创建对象需要的信息，通常是通过 {{GPUDevice}} 中的某一个 `create*` 方法创建的。

<script type=idl>
dictionary GPUObjectDescriptorBase {
    USVString label;
};
</script>

{{GPUObjectDescriptorBase}} 有以下成员:

<dl dfn-type=dict-member dfn-for=GPUObjectDescriptorBase>
    : <dfn>label</dfn>
    ::
        {{GPUObjectBase/label|GPUObjectBase.label}} 的初始值。
</dl>

## 无效内部对象 &amp; 传染无效性 ## {#invalidity}

WebGPU 中的对象创建操作在内部是异步的，因此它们不会因异常而失败。相反，返回的对象可能引用<dfn dfn>有效</dfn>或<dfn dfn>无效</dfn>的[=内部对象=]。[=无效=]的对象可能永远不会在以后变得[=有效=]。一些对象可能在其生命周期内变得[=无效=]，而大多数可能仅在创建时才[=无效=]。

如果无法创建对象，则对象从创建时就[=无效=]。例如，如果[=对象描述符=]没有描述有效的对象，或者没有足够的内存来分配资源，就会发生这种情况。

*大多数*类型的[=内部对象=]在创建后不会变为[=无效=]，但仍然可能变得不可用，例如 如果拥有设备[=丢失设备|丢失=]或{{GPUDevice/destroy()|销毁}}，或者对象具有特殊的内部状态，如缓冲区状态已损坏。

某些类型的[=内部对象=]在创建后*可能*会变得[=无效=]；具体来说，比如设备、适配器和命令/传递/捆绑编码器。

<div>
    当且仅当满足以下要求时，一个给定的{{GPUObjectBase}} |对象|能与|目标对象|<dfn abstract-op>一起有效被使用</dfn>:

    <div class=validusage>
        - |对象| 必须为 [=有效=].
        - |对象|.{{GPUObjectBase/[[device]]}} 必须为 [=有效=].
        - |对象|.{{GPUObjectBase/[[device]]}} 必须等于 |目标对象|.{{GPUObjectBase/[[device]]}}.
    </div>
</div>

## 坐标系 ## {#coordinate-systems}

  - Y轴在标准化设备坐标 (NDC) 中向上：NDC 中的点(-1.0, -1.0)位于NDC的左下角。 此外，NDC中的x和y应介于-1.0和1.0之间（含），而 NDC中的z应介于0.0和1.0之间（含）。NDC中超出此范围的顶点不会引入任何错误，但会被剪裁。
  - Y轴在[=帧缓冲区=]坐标、视口坐标和片元/像素坐标中向下：origin(0, 0) 位于这些坐标系中的左上角。
  - 窗口/当前坐标匹配[=帧缓冲区=]坐标。
  - 纹理坐标中的origin(0, 0)的UV表示纹理内存中的第一个纹素（最低字节）。

Note: WebGPU 的坐标系与图形管道中的 DirectX 坐标系相匹配。

## 编程模型 ## {#programming-model}

### 时间线 ### {#programming-model-timelines}

*本节内容为非标准的*

前端有用户代理、后端有 GPU 的计算机系统具有并行工作在不同时间线上的组件：

: <dfn dfn>内容时间线</dfn>
:: 与 Web 脚本的执行相关联。 它包括调用本规范描述的所有方法。

    <div class=content-timeline>
        在内容时间线上执行的步骤如下所示。
    </div>

: <dfn dfn>设备时间线</dfn>
:: 与用户代理发出的 GPU 设备操作相关联。它包括创建显卡适配器、设备和 GPU 资源及状态对象，从控制 GPU 的用户代理部分的角度来看，这些操作通常是同步操作，但可以存在于单独的操作系统进程中。

    <div class=device-timeline>
        在设备时间线上执行的步骤如下所示。
    </div>

: <dfn dfn>队列时间线</dfn>
:: 与在 GPU 的计算单元上执行操作相关。它包括在 GPU 上运行的实际绘制、复制和计算任务。

    <div class=queue-timeline>
        在队列时间线上执行的步骤如下所示。
    </div>

在本规范中，当结果值取决于发生在除[=内容时间线=]以外的任何时间线上的工作时，将使用异步操作。它们由 JavaScript 中的回调和承诺表示。

<div class="example">
{{GPUComputePassEncoder/dispatch(x, y, z)|GPUComputePassEncoder.dispatch()}}:

  1. 用户通过调用发生在[=内容时间线=]上的 {{GPUComputePassEncoder}} 方法对 `dispatch` 命令进行编码。
  2. 用户调用 {{GPUQueue/submit(commandBuffers)|GPUQueue.submit()}} ，将 {{GPUCommandBuffer}} 移交给用户代理，用户代理通过调用操作系统驱动程序在[=设备时间线=]上执行低级提交。
  3. 在[=队列时间线=]上，提交由 GPU 调度程序分发到实际计算单元上执行。

</div>
<div class="example">
{{GPUDevice/createBuffer(descriptor)|GPUDevice.createBuffer()}}:

  1. 在[=内容时间线=]上，用户填写一个 {{GPUBufferDescriptor}}，并用它创建一个 {{GPUBuffer}}。
  2. 用户代理在[=设备时间线=]上创建一个低级缓冲区。

</div>
<div class="example">
{{GPUBuffer/mapAsync()|GPUBuffer.mapAsync()}}:

  1. 用户请求在[=内容时间线=]上映射 {{GPUBuffer}}，并得到一个promise的返回值。
  2. 用户代理检查缓冲区当前是否被 GPU 使用，并在使用结束时提醒自己再次检查。
  3. 在使用缓冲区完成在[=队列时间线=]上的 GPU 操作后，用户代理将其映射到内存并[=决议=]这个 promise。

</div>

### 内存模型 ### {#programming-model-memory}

*本节内容为非标准的*

一旦在应用程序初始化例程中获得了{{GPUDevice}}，我们可以将 <dfn dfn>WebGPU 平台</dfn>描述为由以下层组成：
  1. 实现规范的用户代理。
  2. 具有用于此设备的低级原生 API 驱动程序的操作系统。
  3. 实际的 CPU 和 GPU 硬件。

[=WebGPU 平台=]的每一层可能有不同的内存类型，用户代理在实现规范时需要考虑：
  - GPU 驱动程序通常无法访问脚本拥有的内存，例如脚本创建的 {{ArrayBuffer}}。
  - 用户代理可能有不同的进程，负责运行内容，以及与GPU驱动程序的通信。在这种情况下，用户代理使用进程间的共享内存来传输数据。
  - 专用 GPU 拥有自己的高带宽内存，而集成 GPU 通常与系统共享内存。

大多数[=物理资源=]分配在对 GPU 计算或渲染高效的内存类型中。当用户需要向 GPU 提供新数据时，数据可能首先需要跨越进程边界才能到达与 GPU 驱动程序通信的用户代理部分。然后这些数据可能需要对驱动程序可见，因此有时需要复制这些数据到驱动程序分配的暂存内存中。最后，这些数据可能需要被转移到专用 GPU 内存中，从而可能将内部布局更改为对 GPU 进行操作最高效的布局。

所有这些转换都是由用户代理的 WebGPU 实现完成。

Note: 这个例子描述了最坏的情况，而在实践中实现可能不需要跨越进程边界，或者可能能够将驱动程序管理的内存通过 `ArrayBuffer` 直接暴露给用户，从而避免任何数据复制。

### 多线程 ### {#programming-model-multi-threading}

### 资源使用 ### {#programming-model-resource-usages}

[=物理资源=]可以和<dfn dfn>内部使用</dfn>一起在 GPU 上被使用:
<dl dfn-type=dfn dfn-for="internal usage">
    : <dfn>输入</dfn>
    ::  填入为绘制或调度调用数据的缓冲。保留内容。被缓冲区 {{GPUBufferUsage/INDEX}}、缓冲区 {{GPUBufferUsage/VERTEX}}，或缓冲区 {{GPUBufferUsage/INDIRECT}}允许。
    : <dfn>常量</dfn>
    ::  从着色器的角度来看是常量的资源绑定。保留内容。缓冲区 {{GPUBufferUsage/UNIFORM}} 或纹理 {{GPUTextureUsage/TEXTURE_BINDING}} 允许。
    : <dfn>存储</dfn>
    ::  可写入存储的资源绑定。被缓冲区 {{GPUBufferUsage/STORAGE}} 或纹理 {{GPUTextureUsage/STORAGE_BINDING}} 允许。
    : <dfn>只读存储</dfn>
    ::  只读存储的资源绑定。保留内容。被缓冲区 {{GPUBufferUsage/STORAGE}} 允许。
    : <dfn>附件</dfn>
    :: 在渲染过程中用作输出附件的纹理。被纹理 {{GPUTextureUsage/RENDER_ATTACHMENT}} 允许。
    : <dfn>只读附件</dfn>
    :: 在渲染过程中用作只读附件的纹理。被纹理 {{GPUTextureUsage/RENDER_ATTACHMENT}} 允许。
</dl>

纹理可能由单独的[=mipmap levels=]和[=array layers=]组成，它们可以在任何给定时间以不同的方式被使用。每个这样的<dfn dfn>纹理子资源</dfn>都由纹理、[=mipmap levels=]和（仅适用于 {{GPUTextureDimension/2d}} 纹理的）[=array layer=]和[=aspect=]唯一标识。

我们定义<dfn dfn>子资源</dfn>可以是整个缓冲区，也可以是[=纹理子资源=]。

<div>
一些[=内部使用=]与其他用法兼容。[=子资源=]可以处于将多种用途组合在一起的状态。 当（且仅当）满足以下任何规则时，我们认为列表|U|是<dfn dfn>兼容使用列表</dfn>：
    - |U|中的每个用法都是[=internal usage/输入=]，[=internal usage/内容=]，[=internal usage/自读存储=]，或[=internal usage/只读附件=]。
    - |U|中的每个用法都是[=internal usage/存储=]。
    - |U|只包含一个元素：[=internal usage/附件=]。
</div>

强制将对资源的使用仅组合到[=兼容使用列表=]中，可以让 API 限制使用内存时可能发生数据竞争的时间。该属性使对 WebGPU 编写的应用程序更有可能在不同平台上运行而无需修改。

通常，当实现以不同于当前使用允许的方式处理使用[=子资源=]的操作时，资源会被转换到新状态。 在某些情况下，例如在开放的 {{GPURenderPassEncoder}} 中，由于硬件限制，这种转换是不可能的。我们将这些地方定义为<dfn dfn>使用范围</dfn>。

**主要的使用规则**是，对于任何一个[=子资源=]，该子资源在一个[=使用范围=]内的[=内部使用=]列表必须是一个[=兼容使用列表=]。

例如，在同一 {{GPURenderPassEncoder}} 中绑定相同的缓冲区用于[=internal usage/存储=]和[=internal usage/输入=]将使编码器以及拥有的 {{GPUCommandEncoder}} 进入错误状态。这种用法组合不会形成[=兼容使用列表=]。

Note: 允许在单个[=使用范围=]内出现多个可写存储缓冲区/纹理使用的竞争条件。

提供给 {{GPURenderPassColorAttachment/view|GPURenderPassColorAttachment.view}} 和 {{GPURenderPassColorAttachment/resolveTarget|GPURenderPassColorAttachment.resolveTarget}} 的视图中包含的纹理[=子资源=]被视为用作此渲染通道[=使用范围=]的[=internal usage/附件=]。

[=纹理子资源=]的<dfn dfn>物理大小</dfn>是[=纹理子资源=]在纹素中的维度，包括可能的额外填充，以在[=子资源=]中形成完整的[=纹素块=]。

  - 对于基于像素的 {{GPUTextureFormat|GPUTextureFormats}}，[=物理大小=]始终等于采样硬件中使用的[=纹理子资源=]的大小。
  - 基于块的压缩 {{GPUTextureFormat|GPUTextureFormats}} 中的[=纹理=]始终具有[=mipmap level=] 0，其 {{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/size}} 是[=纹素块大小=]的倍数，但较低的[=mipmap level=]可能不是[=纹素块大小=]的倍数，可以使用填充到整数倍。

<div class="example">
考虑一个BC格式的 {{GPUTexture}}，其 {{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/size}} 为{60, 60, 1}，在[=mipmap level=] 2 上对 {{GPUTexture}} 进行采样时，采样硬件使用{15, 15, 1}作为[=纹理子资源=]的大小 ，而其[=物理大小=]为 {16, 16, 1}，因为块压缩算法只能在 4x4 纹素块上运行。
</div>

### 同步 ### {#programming-model-synchronization}

对于[=物理资源=]的每个[=子资源=]，其[=内部使用=]的标识集在[=队列时间线=]上被跟踪。

Issue: 本章节将会被修订以支持多个队列。

在[=队列时间线=]上，有一个有序的[=使用范围=]序列。 在每个范围的持续时间内，任何给定[=子资源=]的[=内部使用=]标识集是恒定的。 [=子资源=]可以在[=使用范围=]之间的边界转换为新的使用。

本规范定义了以下[=使用范围=]：

- 在一个通道之外（在 {{GPUCommandEncoder}} 中），每个（非状态设置）指令都是一个使用范围（例如 {{GPUCommandEncoder/copyBufferToTexture()}}）。
- 在一个计算通道中，每个调度指令（{{GPUComputePassEncoder/dispatch()}} 或 {{GPUComputePassEncoder/dispatchIndirect()}}）都是一个使用范围。 如果一个子资源可以被指令访问，则该子资源在使用范围内“使用”。 在调度中，对于每个绑定组可以被当下 {{GPUComputePipeline}} 中的 {{GPUPipelineBase/[[layout]]}} 使用，同时该绑定组引用的每个[=子资源=]也都在使用范围内“使用”。 状态设置计算通道指令，如 {{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)}}，不直接影响使用范围； 反而，这些指令可以更改在调度指令中被检查的状态。
- 一个渲染通道是一个使用范围。如果子资源被任何（状态设置或非状态设置）指令引用，则该子资源在使用范围内“使用”。 例如，在 {{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)}} 中， `bindGroup` 中的每个子资源都在渲染通道的使用范围内“使用”。

Issue: 上面说的应该是[=GPU 指令=]。 但是我们还没有办法引用特定的 GPU 指令（比如 dispatch）。

<div class=note>
    上述规则意味着以下示例资源使用**包含**在[=使用范围验证=]中：

    - 在渲染通道中，任何 {{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)|setBindGroup()}} 调用中使用的子资源，无论是绑定的管道着色器或是实际上依赖于这些绑定的布局，还是被另一个“set”调用遮蔽的绑定组。
    - 在任何 {{GPURenderEncoderBase/setVertexBuffer()|setVertexBuffer()}} 调用中使用的缓冲区，无论是否有任何绘制调用依赖于该缓冲区，或者该缓冲区是否被另一个“set”调用遮蔽。
    - 在任何 {{GPURenderEncoderBase/setIndexBuffer()|setIndexBuffer()}} 调用中使用的缓冲区，无论是否有任何绘制调用依赖于该缓冲区，或者该缓冲区是否被另一个“set”调用遮蔽。
    - 在 {GPURenderPassDescriptor}} 中被 {{GPUCommandEncoder/beginRenderPass()|beginRenderPass()}} 用作颜色附件、决议附件或深度/模板附件的纹理子资源，无论着色器是否实际上依赖于这些附件。
    - 用于可见性为 0 的绑定组条目的资源，或仅对计算阶段可见但在渲染通道中使用的资源（反之亦然）。
</div>

在指令编码期间，子资源的每次使用都被记录在指令缓冲区的某一个[=使用范围=]中。对于每个[=使用范围=]，实现通过组合所有[=内部使用=]标识的列表来执行<dfn dfn>使用范围验证</dfn>，这些内部使用标识的列表来自使用范围中的每个[=子资源=]。 如果这些列表中的任何一个不属于 [=兼容使用列表=]，则 {{GPUCommandEncoder/finish()|GPUCommandEncoder.finish()}} 在当前错误范围内生成 {{GPUValidationError}}。

## 核心内部对象 ## {#core-internal-objects}

### 显卡适配器 ### {#adapters}

<dfn dfn>显卡适配器</dfn>标识系统上的 WebGPU 实现：浏览器底层平台上的计算/渲染功能实例，以及浏览器在该功能之上的 WebGPU 实现实例。

[=显卡适配器=]并不唯一的表示底层实现：多次调用 {{GPU/requestAdapter()}} 每次都会返回不同的适配器对象。

[=显卡适配器=]对象可能随时变为[=无效=]。这发生在“[=丢失设备=]”和“[=标记适配器过时=]”中。无效的显卡适配器无法创建新[=设备=]。

Note: 这种机制确保各种显卡适配器对场景的创建看起来与应用程序相似，因此更易以较少的测试保持更多场景的鲁棒性：首次初始化、由于未插入适配器而重新初始化、由于测试 {{GPUDevice/destroy()|GPUDevice.destroy()}} 调用而重新初始化等。这种机制还确保应用程序使用最新的系统状态，并以此来决定使用哪个适配器。

如果[=显卡适配器=]出现了显著的性能警告来换取更广泛的兼容性、更可预测的行为或更好的隐私性的某种组合，则可以将其视为<dfn>应急适配器</dfn>。 不需要在每个系统上都有可用的[=应急适配器=]。

[=显卡适配器=]具有以下内部插槽：
<dl dfn-type=attribute dfn-for=adapter>
    : <dfn>\[[features]]</dfn>, of type [=ordered set=]&lt;{{GPUFeatureName}}&gt;, readonly
    ::
        可以用作创建显卡适配器上设备的[=特性=]。

    : <dfn>\[[limits]]</dfn>, of type [=supported limits=], readonly
    ::
        [=limit/更好|最好=]限制用作创建显卡适配器上的设备。
        每个适配器限制必须与[=可支持的限制=]中的默认值相同或[=limit/更好=]。

    : <dfn>\[[fallback]]</dfn>, of type boolean
    ::
        如果设为 `true`, 则显卡适配器为[=应急适配器=]。
</dl>

[=显卡适配器=]通过 {{GPUAdapter}} 暴露出来。

### 设备 ### {#devices}

<dfn dfn>设备</dfn>是[=显卡适配器=]的逻辑实例，[=内部对象=]通过设备被创建。设备可以在多个[=代理=]（例如专用 workers）之间共享。

[=设备=]是从其创建的所有[=内部对象=]的唯一所有者：当[=设备=][=丢失设备|丢失=]或{{GPUDevice/destroy()|销毁}}时，设备和在其上创建的所有对象变得隐式[$一起有效被使用|不可用$]，（直接对象，例如 {{GPUDevice/createTexture()}}，或间接对象，例如 {GPUTexture/createView()}}）。

Issue: 定义“所有权”。

[=设备=]有以下内部插槽:

<dl dfn-type=attribute dfn-for=device>
    : <dfn>\[[adapter]]</dfn>, of type [=adapter=], readonly
    ::
        创建此设备的[=显卡适配器=]。

    : <dfn>\[[features]]</dfn>, of type [=ordered set=]&lt;{{GPUFeatureName}}&gt;, readonly
    ::
        可在此设备上使用的[=特性=]。不能使用附加特性，即使底层[=显卡适配器=]可以支持它们。

    : <dfn>\[[limits]]</dfn>, of type [=supported limits=], readonly
    ::
        可在此设备上使用的限制。 没有[=limit/更好=]的限制可以使用，即使底层[=显卡适配器=]可以支持它们。
</dl>

<div>
    当使用 {{GPUDeviceDescriptor}} 描述符从[=显卡适配器=]创建<dfn dfn>新设备</dfn>时：

    - 设置 |device|.{{device/[[adapter]]}} 为 |adapter|.

    - 设置 |device|.{{device/[[features]]}} 为 |descriptor|.{{GPUDeviceDescriptor/requiredFeatures}} 中值的[=ordered set|集=]。

    - 让 |device|.{{device/[[limits]]}} 成为具有默认值的[=可支持的限制=]对象。对于 |descriptor|.{{GPUDeviceDescriptor/requiredLimits}} 中的每个(|key|, |value|) 对，将 |device|.{{device/[[limits]]}} 中 key 对应的成员设置为[=limit/更好=]的|值|或[=可支持的限制=]中的默认值。
</div>

任何时候用户代理需要撤销对设备的访问，都会调用[=丢失设备=]（设备，`undefined`）。

<div>
    <dfn dfn>丢失设备</dfn>(|设备|, |原因|):

    1. 使 |device|.{{device/[[adapter]]}} [=无效=]。
    2. 使 |device| [=无效=]。
    3. Issue: 解释如何从|设备|中获得它的“主” {{GPUDevice}}。
    4. 决议 |device|.{{GPUDevice/lost}} 返回一个新的{{GPUDeviceLostInfo}}，
        {{GPUDeviceLostInfo/reason}} 设置为 |reason|，并将
        {{GPUDeviceLostInfo/message}} 设置成一个实现定义值。

        Note: {{GPUDeviceLostInfo/message}} 不应泄露不必要的用户/系统信息，也永远不应被应用程序解析。
</div>

[=设备=]通过 {{GPUDevice}} 暴露。

## 可选功能 ## {#optional-capabilities}

WebGPU [=显卡适配器=]和[=设备=]具有描述不同实现之间，不同的 WebGPU 功能的<dfn dfn>能力</dfn>，不同的 WebGPU 功能通常是由于硬件或系统软件限制。[=能力=]要么是一个[=特性=]，要么是一个[=限制=]。

### 特性 ### {#features}

<dfn dfn>特性</dfn>是一组可选的 WebGPU 功能，通常是由于硬件或系统软件限制，并非所有实现都支持。

每个 {{GPUAdapter}} 暴露一组可用特性。只有这些特性可能在 {{GPUAdapter/requestDevice()}} 中被请求。

仅当在设备创建时请求该特性，作为该特性一部分的功能才能被使用。 通过可选特性添加到现有词典中的词典成员在 WebIDL 级别始终是可选的； 如果未启用该特性，则不得将此类成员设置为非默认值。

Note: 虽然启用特性不会添加新的 IDL 必需字段，但可能不一定与现有代码向后兼容。 一个可选特性可以启用新的验证，使以前有效的代码无效。

有关每个特性启用的功能的描述，请参阅[[#feature-index|特性索引]]。

### 限制 ### {#limits}

每个<dfn dfn>限制</dfn>都是在设备上使用 WebGPU 的数字限制。

<dfn dfn>可支持的限制</dfn>对象对每个定义的限制都有一个值。 每个[=显卡适配器=]都有一组受[=可支持的限制=]，并且{{GPUDeviceDescriptor/requiredLimits|创建}}的[=设备=]具有特定的[=可支持的限制=]。 无论适配器的限制如何，都会强制执行设备限制。

每个限制都有一个<dfn dfn for=limit>默认</dfn>值。每个[=显卡适配器=]都保证支持默认值或[=limit/更好=]。如果是在 {{GPUDeviceDescriptor/requiredLimits}}）中未明确指定值，则使用默认值。

一个极限值可能比另一个<dfn dfn for=limit>更好</dfn>。[=limit/更好=]的限制值总是会放宽验证，从而使更多的程序有效。对于每个[=限制等级=]，都定义了“更好”。

不同的限制有不同的<dfn dfn lt="limit class">限制等级</dfn>：

<dl dfn-type=dfn dfn-for="limit class">
    : <dfn>最大</dfn>
    ::
        该限制对传递给 API 的某些值强制执行最大值。

        值越高[=limit/更好=]。

        只能设置为≥[=limit/默认=]值的值。较低的值被限制为[=limit/默认=]值。

    : <dfn>对齐</dfn>
    ::
        该限制对传递给 API 的某些值强制执行最小对齐； 也就是说，该值必须是限制的倍数。

        值越小[=limit/更好=]。

        只能设置为≤[=limit/默认=]值，且为2的幂的值。不是2的幂的值是无效的。2的较高幂被限制为[=limit/默认=]值。
</dl>

Note: 设置“更好”的限制不一定是可取的，因为它们可能会影响性能。因此，为了提高跨设备和实现的可移植性，应用程序通常应该请求适用于其内容的“最差”限制（理想情况下，默认值）。

<table class="data no-colspan-center" dfn-type=attribute dfn-for="supported limits">
    <thead>
        <tr><th>限制名称 <th>类型 <th>[=限制等级=] <th>[=limit/默认=]值
    </thead>

    <tr><td><dfn>maxTextureDimension1D</dfn>
        <td>{{GPUSize32}} <td>[=limit class/最大=]<td>8192
    <tr class=row-continuation><td colspan=4>
        通过 {{GPUTextureDescriptor/dimension}} {{GPUTextureDimension/"1d"}} 创建的[=纹理=]，所允许的 {{GPUTextureDescriptor/size}}.[=Extent3D/width=] 的最大值。

    <tr><td><dfn>maxTextureDimension2D</dfn>
        <td>{{GPUSize32}} <td>[=limit class/最大=]<td>8192
    <tr class=row-continuation><td colspan=4>
        通过 {{GPUTextureDescriptor/dimension}} {{GPUTextureDimension/"2d"}} 创建的[=纹理=]，所允许的 {{GPUTextureDescriptor/size}}.[=Extent3D/width=] 和 {{GPUTextureDescriptor/size}}.[=Extent3D/height=] 的最大值。

    <tr><td><dfn>maxTextureDimension3D</dfn>
        <td>{{GPUSize32}} <td>[=limit class/最大=] <td>2048
    <tr class=row-continuation><td colspan=4>
        通过 {{GPUTextureDescriptor/dimension}} {{GPUTextureDimension/"3d"}} 创建的[=纹理=]，所允许的 {{GPUTextureDescriptor/size}}.[=Extent3D/width=], {{GPUTextureDescriptor/size}}.[=Extent3D/height=] 和 {{GPUTextureDescriptor/size}}.[=Extent3D/depthOrArrayLayers=] 的最大值。

    <tr><td><dfn>maxTextureArrayLayers</dfn>
        <td>{{GPUSize32}} <td>[=limit class/最大=] <td>256
    <tr class=row-continuation><td colspan=4>
        通过 {{GPUTextureDescriptor/dimension}} {{GPUTextureDimension/"1d"}} 或 {{GPUTextureDimension/"2d"}} 创建的[=纹理=]，所允许的 {{GPUTextureDescriptor/size}}.[=Extent3D/depthOrArrayLayers=] 的最大值。

    <tr><td><dfn>maxBindGroups</dfn>
        <td>{{GPUSize32}} <td>[=limit class/最大=] <td>4
    <tr class=row-continuation><td colspan=4>
        创建 {{GPUPipelineLayout}} 时，{{GPUPipelineLayoutDescriptor/bindGroupLayouts}} 中所允许的 {{GPUBindGroupLayout|GPUBindGroupLayouts}} 的最大值。

    <tr><td><dfn>maxDynamicUniformBuffersPerPipelineLayout</dfn>
        <td>{{GPUSize32}} <td>[=limit class/最大=] <td>8
    <tr class=row-continuation><td colspan=4>
        {{GPUPipelineLayout}} 中 {{GPUBindGroupLayoutEntry}} 输入接口的最大数量，这些输入接口是具有动态偏移的统一缓冲区。 详见[=超出绑定槽限制=]。

    <tr><td><dfn>maxDynamicStorageBuffersPerPipelineLayout</dfn>
        <td>{{GPUSize32}} <td>[=limit class/最大=] <td>4
    <tr class=row-continuation><td colspan=4>
        {{GPUPipelineLayout}} 中 {{GPUBindGroupLayoutEntry}} 条目的最大数量，这些条目是具有动态偏移的存储缓冲区。 详见[=超出绑定槽限制=]。

    <tr><td><dfn>maxSampledTexturesPerShaderStage</dfn>
        <td>{{GPUSize32}} <td>[=limit class/最大=] <td>16
    <tr class=row-continuation><td colspan=4>
        对每个可能的 {{GPUShaderStage}} `阶段`，{{GPUPipelineLayout}} 中作为采样纹理的 {{GPUBindGroupLayoutEntry}} 条目的最大数量。详见[=超出绑定槽限制=]。

    <tr><td><dfn>maxSamplersPerShaderStage</dfn>
        <td>{{GPUSize32}} <td>[=limit class/最大=] <td>16
    <tr class=row-continuation><td colspan=4>
        对每个可能的 {{GPUShaderStage}} `阶段`，{{GPUPipelineLayout}} 中作为采样器的 {{GPUBindGroupLayoutEntry}} 条目的最大数量。详见[=超出绑定槽限制=]。

    <tr><td><dfn>maxStorageBuffersPerShaderStage</dfn>
        <td>{{GPUSize32}} <td>[=limit class/最大=] <td>8
    <tr class=row-continuation><td colspan=4>
        对每个可能的 {{GPUShaderStage}} `阶段`，{{GPUPipelineLayout}} 中作为存储缓冲区的 {{GPUBindGroupLayoutEntry}} 条目的最大数量。详见[=超出绑定槽限制=]。

    <tr><td><dfn>maxStorageTexturesPerShaderStage</dfn>
        <td>{{GPUSize32}} <td>[=limit class/最大=] <td>4
    <tr class=row-continuation><td colspan=4>
        对每个可能的 {{GPUShaderStage}} `阶段`，{{GPUPipelineLayout}} 中作为存储纹理的 {{GPUBindGroupLayoutEntry}} 条目的最大数量。详见[=超出绑定槽限制=]。

    <tr><td><dfn>maxUniformBuffersPerShaderStage</dfn>
        <td>{{GPUSize32}} <td>[=limit class/最大=] <td>12
    <tr class=row-continuation><td colspan=4>
        对每个可能的 {{GPUShaderStage}} `阶段`，{{GPUPipelineLayout}} 中作为统一缓冲区的 {{GPUBindGroupLayoutEntry}} 条目的最大数量。详见[=超出绑定槽限制=]。

    <tr><td><dfn>maxUniformBufferBindingSize</dfn>
        <td>{{GPUSize32}} <td>[=limit class/最大=] <td>16384
    <tr class=row-continuation><td colspan=4>
        用 {{GPUBindGroupLayoutEntry}}|条目|做绑定的最大 {{GPUBufferBinding}}.{{GPUBufferBinding/size}}，这个条目 |entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/type}} 为 {{GPUBufferBindingType/"uniform"}}。

    <tr><td><dfn>maxStorageBufferBindingSize</dfn>
        <td>{{GPUSize32}} <td>[=limit class/最大=] <td> 134217728 (128 MiB)
    <tr class=row-continuation><td colspan=4>
        用 {{GPUBindGroupLayoutEntry}}|条目|做绑定的最大 {{GPUBufferBinding}}.{{GPUBufferBinding/size}}，这个条目 |entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/type}} 为 {{GPUBufferBindingType/"storage"}} 或 {{GPUBufferBindingType/"read-only-storage"}}。

    <tr><td><dfn>minUniformBufferOffsetAlignment</dfn>
        <td>{{GPUSize32}} <td>[=limit class/对齐=] <td>256
    <tr class=row-continuation><td colspan=4>
        用 {{GPUBindGroupLayoutEntry}}|条目|做绑定时，{{GPUBufferBinding}}.{{GPUBufferBinding/offset}} 和 {{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)|setBindGroup}} |dynamicOffsets| 参数所需的对齐方式，这个条目 |entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/type}} 为 {{GPUBufferBindingType/"uniform"}}。

    <tr><td><dfn>minStorageBufferOffsetAlignment</dfn>
        <td>{{GPUSize32}} <td>[=limit class/对齐=] <td>256
    <tr class=row-continuation><td colspan=4>
         用 {{GPUBindGroupLayoutEntry}}|条目|做绑定时，{{GPUBufferBinding}}.{{GPUBufferBinding/offset}} 和 {{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)|setBindGroup}} |dynamicOffsets| 参数所需的对齐方式，这个条目 |entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/type}} 为 {{GPUBufferBindingType/"storage"}} 或 {{GPUBufferBindingType/"read-only-storage"}}。

    <tr><td><dfn>maxVertexBuffers</dfn>
        <td>{{GPUSize32}} <td>[=limit class/最大=] <td>8
    <tr class=row-continuation><td colspan=4>
        创建 {{GPURenderPipeline}} 时 {{GPUVertexState/buffers}} 的最大值。

    <tr><td><dfn>maxVertexAttributes</dfn>
        <td>{{GPUSize32}} <td>[=limit class/最大=] <td>16
    <tr class=row-continuation><td colspan=4>
        创建 {{GPURenderPipeline}} 时在所有 {{GPUVertexState/buffers}} 中 {{GPUVertexBufferLayout/attributes}} 的最大值。

    <tr><td><dfn>maxVertexBufferArrayStride</dfn>
        <td>{{GPUSize32}} <td>[=limit class/最大=] <td>2048
    <tr class=row-continuation><td colspan=4>
        创建 {{GPURenderPipeline}} 时 {{GPUVertexBufferLayout/arrayStride}} 所允许的的最大值。

    <tr><td><dfn>maxInterStageShaderComponents</dfn>
        <td>{{GPUSize32}} <td>[=limit class/最大=] <td>60
    <tr class=row-continuation><td colspan=4>
        用于内部阶段间通信的输入或输出变量的最大允许组件数（如顶点输出或片段输入）。

    <tr><td><dfn>maxComputeWorkgroupStorageSize</dfn>
        <td>{{GPUSize32}} <td>[=limit class/最大=] <td>16352
    <tr class=row-continuation><td colspan=4>
        用于计算阶段 {{GPUShaderModule}} 入口点的最大字节数。

    <tr><td><dfn>maxComputeInvocationsPerWorkgroup</dfn>
        <td>{{GPUSize32}} <td>[=limit class/最大=] <td>256
    <tr class=row-continuation><td colspan=4>
        计算阶段 {{GPUShaderModule}} 入口点的 `workgroup_size` 维度乘积的最大值。

    <tr><td><dfn>maxComputeWorkgroupSizeX</dfn>
        <td>{{GPUSize32}} <td>[=limit class/最大=] <td>256
    <tr class=row-continuation><td colspan=4>
        计算阶段 {{GPUShaderModule}} 入口点的 `workgroup_size` X 维度的最大值。

    <tr><td><dfn>maxComputeWorkgroupSizeY</dfn>
        <td>{{GPUSize32}} <td>[=limit class/最大=] <td>256
    <tr class=row-continuation><td colspan=4>
        计算阶段 {{GPUShaderModule}} 入口点的 `workgroup_size` Y 维度的最大值。

    <tr><td><dfn>maxComputeWorkgroupSizeZ</dfn>
        <td>{{GPUSize32}} <td>[=limit class/最大=] <td>64
    <tr class=row-continuation><td colspan=4>
        计算阶段 {{GPUShaderModule}} 入口点的 `workgroup_size` Z 维度的最大值。

    <tr><td><dfn>maxComputeWorkgroupsPerDimension</dfn>
        <td>{{GPUSize32}} <td>[=limit class/最大=] <td>65535
    <tr class=row-continuation><td colspan=4>
        {{GPUComputePassEncoder/dispatch(x, y, z)}} 参数的最大值。

</table>

Issue: 我们需要有一个最大的每像素渲染目标尺寸吗？

#### <dfn interface>GPUSupportedLimits</dfn> #### {#gpu-supportedlimits}

{{GPUSupportedLimits}} 暴露一个显卡适配器或设备支持的[=限制=]。详见 {{GPUAdapter/limits|GPUAdapter.limits}} 和 {{GPUDevice/limits|GPUDevice.limits}}.

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUSupportedLimits {
    readonly attribute unsigned long maxTextureDimension1D;
    readonly attribute unsigned long maxTextureDimension2D;
    readonly attribute unsigned long maxTextureDimension3D;
    readonly attribute unsigned long maxTextureArrayLayers;
    readonly attribute unsigned long maxBindGroups;
    readonly attribute unsigned long maxDynamicUniformBuffersPerPipelineLayout;
    readonly attribute unsigned long maxDynamicStorageBuffersPerPipelineLayout;
    readonly attribute unsigned long maxSampledTexturesPerShaderStage;
    readonly attribute unsigned long maxSamplersPerShaderStage;
    readonly attribute unsigned long maxStorageBuffersPerShaderStage;
    readonly attribute unsigned long maxStorageTexturesPerShaderStage;
    readonly attribute unsigned long maxUniformBuffersPerShaderStage;
    readonly attribute unsigned long long maxUniformBufferBindingSize;
    readonly attribute unsigned long long maxStorageBufferBindingSize;
    readonly attribute unsigned long minUniformBufferOffsetAlignment;
    readonly attribute unsigned long minStorageBufferOffsetAlignment;
    readonly attribute unsigned long maxVertexBuffers;
    readonly attribute unsigned long maxVertexAttributes;
    readonly attribute unsigned long maxVertexBufferArrayStride;
    readonly attribute unsigned long maxInterStageShaderComponents;
    readonly attribute unsigned long maxComputeWorkgroupStorageSize;
    readonly attribute unsigned long maxComputeInvocationsPerWorkgroup;
    readonly attribute unsigned long maxComputeWorkgroupSizeX;
    readonly attribute unsigned long maxComputeWorkgroupSizeY;
    readonly attribute unsigned long maxComputeWorkgroupSizeZ;
    readonly attribute unsigned long maxComputeWorkgroupsPerDimension;
};
</script>

#### <dfn interface>GPUSupportedFeatures</dfn> #### {#gpu-supportedfeatures}

{{GPUSupportedFeatures}} 是一个[=setlike=] 接口。这个接口的[=set entries=]是一个显卡适配器或设备支持的[=特性=]的 {GPUFeatureName}} 值。这个接口必须只包含 {{GPUFeatureName}} 枚举中的字符串。

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUSupportedFeatures {
    readonly setlike<DOMString>;
};
</script>

<div class="note">
Note: {{GPUSupportedFeatures}} 的[=set entries=]的类型是 {{DOMString}}，以允许用户代理优雅地处理有效的 {{GPUFeatureName}}s，这些{{GPUFeatureName}}s在规范的后续版本中添加，但用户代理尚未更新以识别。如果设置的条目类型是 {{GPUFeatureName}}，以下代码将产生{{TypeError}} 而不是报告 `false`：

<div class="example">
    检查对无法识别的功能的支持：
    <pre highlight="js">
        if (adapter.features.has('unknown-feature')) {
            // Use unknown-feature
        } else {
            console.warn('unknown-feature is not supported by this adapter.');
        }
    </pre>
</div>
</div>

## 源限制 ## {#origin-restrictions}

WebGPU 允许访问存储在图像、视频和画布中的图像数据。跨域媒体的使用受到限制，因为着色器可用于间接推断已上传到 GPU 的纹理内容。

如果图像源<l spec=html>[=is not origin-clean=]</l>，则 WebGPU 不允许上传图像源。

这也意味着使用 WebGPU 渲染的画布的[=origin-clean=]标识永远不会设置为 `false`。

有关为图像和视频元素发出 CORS 请求的更多信息，请参阅：

- [[html#cors-settings-attributes]]
- [[html#the-img-element]] <{img}>
- [[html#media-elements]] {{HTMLMediaElement}}

## 颜色空间和编码 ## {#color-spaces}

WebGPU 不提供颜色管理。 WebGPU 中的所有值（例如纹理元素）都是原始数值，而不是颜色管理的颜色值。

WebGPU 有颜色管理的输出（通过 {{GPUCanvasConfiguration}}）和输入（通过 {{GPUQueue/copyExternalImageToTexture()}} 和 {GPUDevice/importExternalTexture()}}）接口。因此，必须在 WebGPU 数值和外部颜色值之间进行颜色转换。每个这样的接口点在本地定义一个编码（颜色空间、传递函数和alpha预乘），通过这个编码过程对 WebGPU 数值进行解析。

如果由引用的 CSS 定义，来表示其空间之外的颜色值（色度和亮度），则每个颜色空间都在扩展范围内定义。

<script type=idl>
enum GPUPredefinedColorSpace {
    "srgb",
};
</script>

Issue: 可能用 PredefinedColorSpace 来替换，但请注意，这样做意味着当项目被添加到上游规范中的枚举时，新的 WebGPU 功能会自动添加。

Issue(gpuweb/gpuweb#1715): 考虑将srgb编码图像上传到线性编码纹理的路径。

<dl dfn-type=enum-value dfn-for=GPUPredefinedColorSpace>
    : <dfn>"srgb"</dfn>
    :: CSS预定义颜色空间<a value for=color()>srgb</a>。
</dl>

### 色彩空间转换 ### {#color-space-conversions}

根据上述定义，通过将颜色在一个空间中的表示转换为另一个空间中的表示，可以在空间之间转换颜色。

如果源值少于4个通道，则剩余的绿色/蓝色/Alpha 通道在转换颜色空间/编码和 alpha 预乘之前，根据需要分别为设置为 `0, 0, 1`。转换后，如果目的地需要少于4个通道，则多余的通道会被忽略。

颜色在转换过程中不会有损地强制执行：如果源颜色值超出目标色彩空间的色域范围（例如，如果将显示P3图像转换为sRGB），从一个色彩空间至另一个色彩空间的颜色转换会导致值超出范围[0, 1]。

# 初始化 # {#initialization}

## navigator.gpu ## {#navigator-gpu}

{{GPU}} 对象分别通过 {{Navigator}} 和 {{WorkerNavigator}} 接口在 {{Window}} 和 {{DedicatedWorkerGlobalScope}} 上下文中可用，
并通过 `navigator.gpu` 被暴露：

<script type=idl>
interface mixin NavigatorGPU {
    [SameObject, SecureContext] readonly attribute GPU gpu;
};
Navigator includes NavigatorGPU;
WorkerNavigator includes NavigatorGPU;
</script>

## GPU ## {#gpu-interface}

<dfn interface>GPU</dfn> 是进入 WebGPU 的入口。

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPU {
    Promise<GPUAdapter?> requestAdapter(optional GPURequestAdapterOptions options = {});
};
</script>

{{GPU}} 的获取有如下方法:

<dl dfn-type=method dfn-for=GPU>
    : <dfn>requestAdapter(options)</dfn>
    ::
         从用户代理请求 [=显卡适配器=]。
         用户代理选择是否返回适配器，如果返回，
         根据提供的选项进行选择。

        <div algorithm=GPU.requestAdapter>
            **调用:** {{GPU}} |this|.

            **参数:**
            <pre class=argumentdef for="GPU/requestAdapter(options)">
                |options|: 用来选择显卡适配器的标准
            </pre>

            **返回:** {{Promise}}&lt;{{GPUAdapter}}?&gt;

            1. 让 |promise| 成为一个 [=a new promise=].
            1. 在 |this| [=设备时间线=]上执行以下步骤 :
                <div class=device-timeline>
                    1. 如果用户代理选择返回一个适配器，用户代理应该:
                        1. 创建一个[=有效=]的[=显卡适配器=] |adapter|，根据[[#adapter-selection]]规则和 |options| 标准进行选择。

                        1. 如果 |adapter| 满足[=应急适配器=]的标准，设定 |adapter|.{{adapter/[[fallback]]}} 为 `true`.

                        1. 使用新的 {{GPUAdapter}} 封装 |adapter|，来[=决议=] |promise|.

                    1. 否则, |promise| [=决议=]为 `null`.
                </div>
            1. 返回 |promise|.

            <!-- 如果我们添加方法来发出无效的适配器请求（除了那些
                                   违反 IDL 规则），指定他们拒绝承诺。 -->
        </div>
</dl>

{{GPU}} 有以下内部插槽:

<dl dfn-type=attribute dfn-for=GPU>
    : <dfn>\[[previously_returned_adapters]]</dfn>, of type [=ordered set=]&lt;[=adapter=]&gt;
    ::
         通过 {{GPU/requestAdapter()}} 返回的[=显卡适配器=]集。
         在[=标记适配器过时=]中，显卡适配器被使用，然后被清除。
</dl>

当系统状态发生任何变化，并可能影响任何 {{GPU/requestAdapter()}} 的调用结果时，用户代理*应该*[=标记适配器过时=]。 例如：

- 添加/移除物理适配器（通过插头、驱动程序更新、TDR 等）
- 系统的电源配置已更改（笔记本电脑已拔下电源，电源设置已更改等）

此外，[=标记适配器过时=]可以随时被调用。即使没有系统状态改变，用户代理也可以经常选择调用（例如，最后一次调用 {{GPUAdapter/requestDevice()}} 后几秒）。这对格式良好的应用程序没有影响，模糊了真实的系统状态变化，并使
开发人员更清楚的了解了，在调用 {{GPUAdapter/requestDevice()}} 之前，总是需要再次调用 {{GPU/requestAdapter()}}。

<div algorithm>
    <dfn dfn>标记适配器过时</dfn>:

    1. 对于在 `navigator.gpu.`{{GPU/[[previously_returned_adapters]]}} 中的每一个|adapter|:
        1. 使|adapter|.{{GPUAdapter/[[adapter]]}} [=无效=]。
    1. [=list/清空=] `navigator.gpu.`{{GPU/[[previously_returned_adapters]]}}.

    Issue: 如果引入了 `adaptersAdded`/`adapterschanged` 事件，请在此处更新。</div>

<div class="example">
    无提示的获取一个 {{GPUAdapter}}:
    <pre highlight="js">
        const gpuAdapter = await navigator.gpu.requestAdapter();
    </pre>
</div>

### 适配器选择 ### {#adapter-selection}

<dfn dictionary>GPURequestAdapterOptions</dfn>
向用户代理提供提示，指示了适合应用程序的配置。

<script type=idl>
dictionary GPURequestAdapterOptions {
    GPUPowerPreference powerPreference;
    boolean forceFallbackAdapter = false;
};
</script>

<script type=idl>
enum GPUPowerPreference {
    "low-power",
    "high-performance",
};
</script>

{{GPURequestAdapterOptions}} 有以下选择:

<dl dfn-type=dict-member dfn-for=GPURequestAdapterOptions>
    : <dfn>powerPreference</dfn>
    ::
        可选的提供一个提示，指示应从系统的可用适配器中选择什么类的[=显卡适配器=]。

        这个提示的值可能会影响选择哪个适配器，但不能影响是否返回适配器。

        Note: 此提示的主要用途是影响多 GPU 系统中使用的 GPU。例如，一些笔记本电脑有一个低功耗的集成 GPU 和一个高性能的独立 GPU。

        Note: 根据确切的硬件配置，例如电池状态和连接的显示器或可移动 GPU，用户代理可能会选择不同的[=显卡适配器=]给定相同的电源首选项。通常，给定相同的硬件配置和状态以及 “powerPreference”，用户代理可能会选择相同的适配器。

        必须是以下值之一:

        <dl dfn-type=enum-value dfn-for=GPUPowerPreference>
            : `undefined` (or not present)
            ::
                不提供任何提示给用户代理.

            : <dfn>"low-power"</dfn>
            ::
                指示一个将节能优先于性能的请求。

                Note: 通常，如果不太可能受到绘图性能的限制，则内容应使用这种配置； 例如，如果它每秒只渲染一帧，使用简单的着色器只绘制相对简单的几何图形，或者使用小的 HTML 画布元素。如果内容允许，鼓励开发人员使用此值，因为它可以显著提高便携式设备的电池寿命。

            : <dfn>"high-performance"</dfn>
            ::
                指示一个将性能优先于功耗的请求。

                Note: 通过选择这个值，开发人员应该了解，对于在生成的适配器上创建的[=设备=]，用户代理更有可能强制设备丢失，以便通过切换到低功率适配器来节省功率。仅在绝对必要时鼓励开发人员指定此值，因为这种设置可能会显着缩短便携式设备的电池寿命。
        </dl>

    : <dfn>forceFallbackAdapter</dfn>
    ::
        当设置为 `true` 时表示只能返回[=应急适配器=]。 如果用户代理不支持[=应急适配器=]，会导致 {{GPU/requestAdapter()}} 返回 `null`。

        Note: 如果 {{GPURequestAdapterOptions/forceFallbackAdapter}} 被设置为 `false`，并且没有其他合适的 [=显卡适配器=]可用或用户代理选择返回一个[=应急适配器=]，{{GPU/requestAdapter()}} 仍可能返回[=应急适配器=]。希望阻止其应用程序在[=应急适配器=]上运行的开发人员，应在请求 {{GPUDevice}} 之前检查 {{GPUAdapter}}.{{GPUAdapter/isFallbackAdapter}} 属性。
</dl>

## <dfn interface>GPUAdapter</dfn> ## {#gpu-adapter}

一个 {{GPUAdapter}} 封装了一个[=显卡适配器=]，并描述其能力（[=特性=]和[=限制=]）。

使用 {{GPU/requestAdapter()}} 来获取 {{GPUAdapter}}。

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUAdapter {
    readonly attribute DOMString name;
    [SameObject] readonly attribute GPUSupportedFeatures features;
    [SameObject] readonly attribute GPUSupportedLimits limits;
    readonly attribute boolean isFallbackAdapter;

    Promise<GPUDevice> requestDevice(optional GPUDeviceDescriptor descriptor = {});
};
</script>

{{GPUAdapter}} 有以下属性:

<dl dfn-type=attribute dfn-for=GPUAdapter>
    : <dfn>name</dfn>
    ::
        标识适配器的可读名称。
        内容是实现定义的。

    : <dfn>features</dfn>
    ::
        `this`.{{GPUAdapter/[[adapter]]}}.{{adapter/[[features]]}} 中值的集合。

    : <dfn>limits</dfn>
    ::
        `this`.{{GPUAdapter/[[adapter]]}}.{{adapter/[[limits]]}} 中的限值。

    : <dfn>isFallbackAdapter</dfn>
    ::
        返回 {{GPUAdapter/[[adapter]]}}.{{adapter/[[fallback]]}} 的值。
</dl>

{{GPUAdapter}} 有以下内部插槽:

<dl dfn-type=attribute dfn-for=GPUAdapter>
    : <dfn>\[[adapter]]</dfn>, of type [=adapter=], readonly
    ::
        此 {{GPUAdapter}} 所指的[=显卡适配器=]。
</dl>

{{GPUAdapter}} 有以下方法:

<dl dfn-type=method dfn-for=GPUAdapter>
    : <dfn>requestDevice(descriptor)</dfn>
    ::
        向[=显卡适配器=]请求一个[=设备=].

        <div algorithm=GPUAdapter.requestDevice>
            **调用:** {{GPUAdapter}} |this|.

            **参数:**
            <pre class=argumentdef for="GPUAdapter/requestDevice(descriptor)">
                |descriptor|: 要请求的 {{GPUDevice}} 的描述。
            </pre>

            **返回:** {{Promise}}&lt;{{GPUDevice}}&gt;

            1. 让 |promise| 成为一个 [=a new promise=].
            1. 让 |adapter| 作为 |this|.{{GPUAdapter/[[adapter]]}}.
            3. 在[=设备时间线=]上执行以下步骤:
                <div class=device-timeline>
                    1. 如果以下任意条件没有满足，通过生成 {{TypeError}} [=reject=] |promise|，然后停止运行。

                        <div class=validusage>
                            - |descriptor|.{{GPUDeviceDescriptor/requiredFeatures}} 中的值的集合，必须是 |adapter|.{{adapter/[[features]]}} 中值的子集.
                        </div>

                        Note: 如果是浏览器根本不知道的特性名称（在其 {{GPUFeatureName}} 定义中），则会产生相同的错误。这将浏览器不支持某个特性时的行为与特定适配器不支持某个特性时的行为融合在一起。

                    1. 如果以下任意条件没有满足，通过生成 {{OperationError}} [=reject=] |promise|，然后停止运行。

                        <div class=validusage>
                            - |descriptor|.{{GPUDeviceDescriptor/requiredLimits}} 中的每一个key，必须是[=支持的限制=]中的成员的一个.

                            - 对于[=支持的限制=]中的每个keys中的限制名称 |key|：使 |value| 为 |descriptor|.{{GPUDeviceDescriptor/requiredLimits}}[|key|].
                                - |value| 必须不比 |adapter|.{{adapter/[[limits]]}} 中的限制值[=limit/更好=]。
                                - 如果限制的[=limit class|等级=]为[=limit class/对齐=]，|value| 必须为2的幂。
                        </div>

                    1. 如果 |adapter| 为[=无效=]，或者用户代理无法满足请求：

                        1. 让 |device| 成为一个新的[=设备=].
                        1. [=丢失设备=](|device|, `undefined`).

                            Note: 这将使 |adapter| [=无效=], 如果之前不是。

                            Note: 发生这种情况时，用户代理应考虑在大多数或所有情况下发出开发人员可见的警告。
                            应用程序应该从 {{GPU/requestAdapter()}} 开始执行重新初始化逻辑。

                        1. 用一个新的 {{GPUDevice}} 来封装 |device|，并[=决议=] |promise|，然后停止运行。

                    1.  用一个新的 {{GPUDevice}} 对象封装[=新设备=]，并[=决议=] |promise|，新设备具有 |descriptor| 描述的功能。
                </div>
            1. 返回 |promise|.

        </div>
</dl>

<div class="example">
    请求具有默认特性和限制的 {{GPUDevice}}：
    <pre highlight="js">
        const gpuAdapter = await navigator.gpu.requestAdapter();
        const gpuDevice = await gpuAdapter.requestDevice();
    </pre>
</div>

### <dfn dictionary>GPUDeviceDescriptor</dfn> ### {#gpudevicedescriptor}

{{GPUDeviceDescriptor}} 描述一个设备请求。

<script type=idl>
dictionary GPUDeviceDescriptor : GPUObjectDescriptorBase {
    sequence<GPUFeatureName> requiredFeatures = [];
    record<DOMString, GPUSize64> requiredLimits = {};
};
</script>

{{GPUDeviceDescriptor}} 有以下成员:

<dl dfn-type=dict-member dfn-for=GPUDeviceDescriptor>
    : <dfn>requiredFeatures</dfn>
    ::
        指定设备请求所需的[=特性=]。如果适配器无法提供这些特性，则请求将失败。

        由生成的设备上的 API 调用验证时，将允许不多不少完全指定的一组特性。

    : <dfn>requiredLimits</dfn>
    ::
        指定设备请求所需的[=限制=]。如果适配器无法提供这些限制，则请求将失败。

        每个key必须是[=支持的限制=]的成员名称。正如指定的限制，没有[=limit/更好=]或更糟，才会被允许由生成的设备上的 API 调用验证。

        <!-- 如果我们需要 GPUSize32/GPUSize64 以外的限制类型，我们可以在将来将值类型更改为 `double` 或 `any`，
        并明确写出类型转换（参考 WebIDL 规范）。
        或者将整个类型更改为 `any` 并添加回一个 `dictionary GPULimits` 并通过引用 WebIDL 定义整个对象的转换。 -->
</dl>

<div class="example">
    如果支持，请求一个具有 {{GPUFeatureName/"texture-compression-astc"}} 特性的 {{GPUDevice}}：
    <pre highlight="js">
        const gpuAdapter = await navigator.gpu.requestAdapter();

        const requiredFeatures = [];
        if (gpuAdapter.features.has('texture-compression-astc')) {
            requiredFeatures.push('texture-compression-astc')
        }

        const gpuDevice = await gpuAdapter.requestDevice({
            requiredFeatures
        });
    </pre>
</div>

#### <dfn enum>GPUFeatureName</dfn> #### {#gpufeaturename}

每个 {{GPUFeatureName}} 标识一组功能，这组功能如果可用，则允许额外使用 WebGPU，否则这些 WebGPU 的额外使用被视为无效。

<script type=idl>
enum GPUFeatureName {
    "depth-clip-control",
    "depth24unorm-stencil8",
    "depth32float-stencil8",
    "texture-compression-bc",
    "texture-compression-etc2",
    "texture-compression-astc",
    "timestamp-query",
    "indirect-first-instance",
};
</script>

## <dfn interface>GPUDevice</dfn> ## {#gpu-device}

一个 {{GPUDevice}} 封装了一个[=设备=]，并暴露了该设备的功能。

{{GPUDevice}} 用来创建 [=WebGPU 接口=]的顶层接口。

使用 {{GPUAdapter/requestDevice()}}，来获得 {{GPUDevice}}。

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUDevice : EventTarget {
    [SameObject] readonly attribute GPUSupportedFeatures features;
    [SameObject] readonly attribute GPUSupportedLimits limits;

    [SameObject] readonly attribute GPUQueue queue;

    undefined destroy();

    GPUBuffer createBuffer(GPUBufferDescriptor descriptor);
    GPUTexture createTexture(GPUTextureDescriptor descriptor);
    GPUSampler createSampler(optional GPUSamplerDescriptor descriptor = {});
    GPUExternalTexture importExternalTexture(GPUExternalTextureDescriptor descriptor);

    GPUBindGroupLayout createBindGroupLayout(GPUBindGroupLayoutDescriptor descriptor);
    GPUPipelineLayout createPipelineLayout(GPUPipelineLayoutDescriptor descriptor);
    GPUBindGroup createBindGroup(GPUBindGroupDescriptor descriptor);

    GPUShaderModule createShaderModule(GPUShaderModuleDescriptor descriptor);
    GPUComputePipeline createComputePipeline(GPUComputePipelineDescriptor descriptor);
    GPURenderPipeline createRenderPipeline(GPURenderPipelineDescriptor descriptor);
    Promise<GPUComputePipeline> createComputePipelineAsync(GPUComputePipelineDescriptor descriptor);
    Promise<GPURenderPipeline> createRenderPipelineAsync(GPURenderPipelineDescriptor descriptor);

    GPUCommandEncoder createCommandEncoder(optional GPUCommandEncoderDescriptor descriptor = {});
    GPURenderBundleEncoder createRenderBundleEncoder(GPURenderBundleEncoderDescriptor descriptor);

    GPUQuerySet createQuerySet(GPUQuerySetDescriptor descriptor);
};
GPUDevice includes GPUObjectBase;
</script>

{{GPUDevice}} 有以下属性:

<dl dfn-type=attribute dfn-for=GPUDevice>
    : <dfn>features</dfn>
    ::
        包含设备支持的特性（即创建时具有的特性）的 {{GPUFeatureName}} 值的集合。

    : <dfn>limits</dfn>
    ::
        暴露设备支持的限制（同时也是创建时具有的限制）。

    : <dfn>queue</dfn>
    ::
        此设备的主要 {{GPUQueue}}。
</dl>

{{GPUDevice}} 的 {{GPUObjectBase/[[device]]}} 是 {{GPUDevice}} 引用的[=设备=]。

{{GPUDevice}} 具有上面的 WebIDL 定义中列出的方法。此处未定义的内容在本文档的其他地方进行了定义。

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>destroy()</dfn>
    ::
        销毁[=设备=]，防止对其进行进一步操作。未完成的异步操作将失败。

        <div algorithm=GPUDevice.destroy()>
            **调用:** {{GPUDevice}} |this|.

            1. [=丢失设备=](|this|.{{GPUObjectBase/[[device]]}},
                {{GPUDeviceLostReason/"destroyed"}}).
        </div>

        Note: 由于此设备上不能发生进一步的操作，因此实现可以释放资源分配，并立即中止未完成的异步操作。
</dl>

{{GPUDevice}} 对象是 [=serializable objects=]。

Issue(gpuweb/gpuweb#354): 完成定义多线程 API，并将“[Serializable]”添加回接口。

<div algorithm>
    <dfn abstract-op>序列化 GPUDevice 对象的步骤</dfn>；给定 |value|, |serialized|，|forStorage|:
     1. 设置 |serialized|.agentCluster 为[=surrounding agent=] 的[=代理集群=]。
     1. 如果 |serialized|.agentCluster 的[=cross-origin isolated capability=] 为 false，则返回 “{{DataCloneError}}”。
     1. 如果 |forStorage| 是 `true`，返回 “{{DataCloneError}}”。
     1. 将 |serialized|.device 设置为 |value|.{{GPUObjectBase/[[device]]}} 的值。
</div>

<div algorithm>
    <dfn abstract-op> 反序列化 GPUDevice 对象的步骤</dfn>；给定 |serialized| 和 |value|:
     1. 如果 |serialized|.agentCluster 不是[=surrounding agent=] 的[=代理集群=]，则返回 “{{DataCloneError}}”。
     1. 将 |value|.{{GPUObjectBase/[[device]]}} 设置为 |serialized|.device。
</div>

Issue: `GPUDevice` 并不真正需要跨域策略限制。无论如何，应该可以从多个代理使用。一旦我们描述了缓冲区、纹理和队列的序列化 - COOP+COEP 逻辑应该被移到那里。

## 示例 ## {#initialization-examples}

<div class="example">
    一个更具有鲁棒性的的请求 {{GPUAdapter}} 和 {{GPUDevice}} 的示例，该示例还包含了错误处理：
    <pre highlight="js">
        let gpuDevice = null;

        async function initializeWebGPU() {
            // Check to ensure the user agent supports WebGPU.
            if (!('gpu' in navigator)) {
                console.error('User agent doesn't support WebGPU.');
                return false;
            }

            // Request an adapter.
            const gpuAdapter = await navigator.gpu.requestAdapter();

            // requestAdapter may resolve with null if no suitable adapters are found.
            if (!gpuAdapter) {
                console.error('No WebGPU adapters found.');
                return false;
            }

            // Request a device.
            // Note that the promise will reject if invalid options are passed to the optional
            // dictionary. To avoid the promise rejecting always check any features and limits
            // against the adapters features and limits prior to calling requestDevice().
            gpuDevice = await gpuAdapter.requestDevice();

            // requestDevice will never return null, but if a valid device request can't be
            // fulfilled for some reason it may resolve to a device which has already been lost.
            // Additionally, devices can be lost at any time after creation for a variety of reasons
            // (ie: browser resource management, driver updates), so it's a good idea to always
            // handle lost devices gracefully.
            gpuDevice.lost.then((info) => {
                console.error(\`WebGPU device was lost: ${info.message}\`);

                gpuDevice = null;

                // Many causes for lost devices are transient, so applications should try getting a
                // new device once a previous one has been lost unless the loss was caused by the
                // application intentionally destroying the device. Note that any WebGPU resources
                // created with the previous device (buffers, textures, etc) will need to be
                // re-created with the new one.
                if (info.reason != 'destroyed') {
                    initializeWebGPU();
                }
            });

            onWebGPUInitialized();

            return true;
        }

        function onWebGPUInitialized() {
            // Begin creating WebGPU resources here...
        }

        initializeWebGPU();
    </pre>
</div>

# 缓冲区 # {#buffers}

## <dfn interface>GPUBuffer</dfn> ## {#buffer-interface}

Issue: 定义<dfn dfn>缓冲区</dfn> (内部对象)

{{GPUBuffer}} 表示可用于 GPU 操作的内存块。数据以线性布局存储，这意味着分配的每个字节都可以由其从 {{GPUBuffer}} 开始的偏移量寻址，并且受到操作的对齐约束限制。一些 {{GPUBuffer|GPUBuffers}} 可以被映射，这使得内存块可以通过一个{{ArrayBuffer}}访问并调用它的映射。

{{GPUBuffer|GPUBuffers}} 是通过 {{GPUDevice/createBuffer(descriptor)|GPUDevice.createBuffer(descriptor)}} 创建的，
创建后会返回一个处于 [=buffer state/已映射=] 或 [=buffer state/未映射=]状态的新缓冲区。

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUBuffer {
    Promise<undefined> mapAsync(GPUMapModeFlags mode, optional GPUSize64 offset = 0, optional GPUSize64 size);
    ArrayBuffer getMappedRange(optional GPUSize64 offset = 0, optional GPUSize64 size);
    undefined unmap();

    undefined destroy();
};
GPUBuffer includes GPUObjectBase;
</script>

{{GPUBuffer}}有如下内部插槽:

<dl dfn-type=attribute dfn-for="GPUBuffer">
    : <dfn>\[[size]]</dfn> of type {{GPUSize64}}.
    ::
        {{GPUBuffer}} 被分配的长度（以字节为单位）。

    : <dfn>\[[usage]]</dfn> of type {{GPUBufferUsageFlags}}.
    ::
        此 {{GPUBuffer}} 被允许的使用。

    : <dfn>\[[state]]</dfn> of type [=buffer state=].
    ::
        {{GPUBuffer}} 的当前状态。

    : <dfn>\[[mapping]]</dfn> of type {{ArrayBuffer}} or {{Promise}} or `null`.
    ::
        此 {{GPUBuffer}} 的映射。{{ArrayBuffer}} 不能直接被访问，而是通过视图去访问，称为映射范围，被存储在 {{GPUBuffer/[[mapped_ranges]]}} 中。

        Issue(gpuweb/gpuweb#605): 在 `DataBlock`方面指定 {{GPUBuffer/[[mapping]]}} 类似于 `AllocateArrayBuffer`？

    : <dfn>\[[mapping_range]]</dfn> of type [=list=]&lt;{{unsigned long long}}&gt; or `null`.
    ::
        此被映射的 {{GPUBuffer}} 的范围。

    : <dfn>\[[mapped_ranges]]</dfn> of type [=list=]&lt;{{ArrayBuffer}}&gt; or `null`.
    ::
        {{ArrayBuffer}}s 通过 {{GPUBuffer/getMappedRange}} 返回给应用程序。这些 {{ArrayBuffer}}s 会被追踪，以便在 {{GPUBuffer/unmap}} 被调用时可以将其分离。

    : <dfn>\[[map_mode]]</dfn> of type {{GPUMapModeFlags}}.
    ::
        最后一次调用 {{GPUBuffer/mapAsync()}} 的 {{GPUMapModeFlags}}（如果有）。
</dl>

Issue: {{GPUBuffer/[[usage]]}} 与 {{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/usage}} 的命名不同。我们应该让两种命名保持一致。

每个 {{GPUBuffer}} 在[=内容时间线=]上都有一个当前的<dfn dfn>缓冲区状态</dfn>，它是以下几项之一：

 - "<dfn dfn for="buffer state">已映射</dfn>" 此时 {{GPUBuffer}} 中的内容可以被用作 CPU 操作。
 - "<dfn dfn for="buffer state">在创建时被映射</dfn>" 此时 {{GPUBuffer}} 刚刚被创建，并且其中的内容可以被 CPU 操作。
 - "<dfn dfn for="buffer state">待映射</dfn>" 此时 {{GPUBuffer}} 正在被处理使得它的内容可以被 CPU 操作。
 - "<dfn dfn for="buffer state">未映射</dfn>" 此时 {{GPUBuffer}} 允许 GPU 操作。
 - "<dfn dfn for="buffer state">被销毁</dfn>" 此时 {{GPUBuffer}} 不允许除了 {{GPUBuffer/destroy}} 之外的任何操作。

Note: 一旦创建了 {{GPUBuffer}}，{{GPUBuffer/[[size]]}} 和 {{GPUBuffer/[[usage]]}} 是不可变的。

<div class=note>
    Note: {{GPUBuffer}} 有一个具有以下状态的状态机。（({{GPUBuffer/[[mapping]]}}, {{GPUBuffer/[[mapping_range]]}}, 并且 {{GPUBuffer/[[mapped_ranges]]}} 在未指定时为空。）

     - [=buffer state/未映射=]且[=buffer state/被销毁=]状态。
     - [=buffer state/已映射=]或[=buffer state/在创建时被映射=]状态，同时包含一个类型为 {{GPUBuffer/[[mapping]]}} 的 {{ArrayBuffer}}，一个 {{GPUBuffer/[[mapping_range]]}} 中两个数字的序列，和一个 {{GPUBuffer/[[mapped_ranges]]}} 中 {{ArrayBuffer}} 的序列。
     - [=buffer state/待映射=]状态，同时包含一个类型为 {{GPUBuffer/[[mapping]]}} 的 {{Promise}}。
</div>

{{GPUBuffer}} 是对一个内部缓冲区对象的引用。

Issue(gpuweb/gpuweb#354): 完成定义多线程 API 并将 `[Serializable]`添加回接口。

## 缓冲区创建 ## {#buffer-creation}

### {{GPUBufferDescriptor}} ### {#GPUBufferDescriptor}

指定了创建 {{GPUBuffer}} 用到的选项。

<script type=idl>
dictionary GPUBufferDescriptor : GPUObjectDescriptorBase {
    required GPUSize64 size;
    required GPUBufferUsageFlags usage;
    boolean mappedAtCreation = false;
};
</script>

- {{GPUBufferDescriptor/mappedAtCreation}} 保证即使缓冲区最终创建失败，缓冲区仍然看起来好像可以在映射的范围内写入/读取，直到缓冲区回到未映射状态。

<div>
    <dfn abstract-op>校验 GPUBufferDescriptor</dfn>(device, descriptor)
        1. 如果设备缺失，返回 `false`.
        2. 如果 |descriptor| 的 {{GPUBufferDescriptor/usage}} 中任何一个标志位都不属于设备的 [[allowed buffer usages]]，返回 `false`。
        3. 如果 |descriptor| 的 {{GPUBufferDescriptor/usage}} 中的 {{GPUBufferUsage/MAP_READ}} 和 {{GPUBufferUsage/MAP_WRITE}} 标志位都有值，返回 `false`。
        4. 返回 `true`.
</div>

### 缓冲区使用 ### {#buffer-usage}

<script type=idl>
typedef [EnforceRange] unsigned long GPUBufferUsageFlags;
[Exposed=(Window, DedicatedWorker)]
namespace GPUBufferUsage {
    const GPUFlagsConstant MAP_READ      = 0x0001;
    const GPUFlagsConstant MAP_WRITE     = 0x0002;
    const GPUFlagsConstant COPY_SRC      = 0x0004;
    const GPUFlagsConstant COPY_DST      = 0x0008;
    const GPUFlagsConstant INDEX         = 0x0010;
    const GPUFlagsConstant VERTEX        = 0x0020;
    const GPUFlagsConstant UNIFORM       = 0x0040;
    const GPUFlagsConstant STORAGE       = 0x0080;
    const GPUFlagsConstant INDIRECT      = 0x0100;
    const GPUFlagsConstant QUERY_RESOLVE = 0x0200;
};
</script>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createBuffer(descriptor)</dfn>
    ::
        创建一个 {{GPUBuffer}}。

        <div algorithm=GPUDevice.createBuffer>
            **调用:** {{GPUDevice}} |this|.

            **参数:**
            <pre class=argumentdef for="GPUDevice/createBuffer(descriptor)">
                |descriptor|: 要创建的 {{GPUBuffer}} 的描述。
            </pre>

            **返回:** {{GPUBuffer}}

            1. 如果以下任何条件没有满足，返回一个错误缓冲区并停止。
                <div class=validusage>
                    - |this| 是一个[=有效=] {{GPUDevice}}。
                    - |descriptor|.{{GPUBufferDescriptor/usage}} 必须不为 0。
                    - |descriptor|.{{GPUBufferDescriptor/usage}} 是 |this|.[[allowed buffer usages]] 的一个子集。
                    - 如果 |descriptor|.{{GPUBufferDescriptor/usage}} 包含 {{GPUBufferUsage/MAP_READ}}:
                        - |descriptor|.{{GPUBufferDescriptor/usage}} 不包含除了 {{GPUBufferUsage/COPY_DST}} 之外的其他标识。
                    - 如果 |descriptor|.{{GPUBufferDescriptor/usage}} 包含 {{GPUBufferUsage/MAP_WRITE}}:
                        - |descriptor|.{{GPUBufferDescriptor/usage}} 不包含除了 {{GPUBufferUsage/COPY_SRC}} 之外的其他标识。
                    - 如果 |descriptor|.{{GPUBufferDescriptor/mappedAtCreation}} 为 `true`:
                        - |descriptor|.{{GPUBufferDescriptor/size}} 是 4 的倍数。

                    Issue(gpuweb/gpuweb#605): 解释什么是 {{GPUDevice}} 的 `[[allowed buffer usages]]`.
                </div>
            
            Note: 如果缓冲区创建失败，并且 |descriptor|.{{GPUBufferDescriptor/mappedAtCreation}} 为 `false`，对 {{GPUBuffer/mapAsync()}} 的任何调用都将被拒绝，因此开始映射中分配的任何资源都可以并且可能会被丢弃或回收。

            1. 使 |b| 为一个新的 {{GPUBuffer}} 对象.
            2. 将 |b|.{{GPUBuffer/[[size]]}} 设置为 |descriptor|.{{GPUBufferDescriptor/size}}.
            3. 将 |b|.{{GPUBuffer/[[usage]]}} 设置为 |descriptor|.{{GPUBufferDescriptor/usage}}.
            4. 如果 |descriptor|.{{GPUBufferDescriptor/mappedAtCreation}} 值为 `true`:

                1. 将 |b|.{{GPUBuffer/[[mapping]]}} 设置为一个新的大小为 |b|.{{GPUBuffer/[[size]]}} 的 {{ArrayBuffer}}。
                2. 将 |b|.{{GPUBuffer/[[mapping_range]]}} 设置为 `[0, descriptor.size]`.
                3. 将 |b|.{{GPUBuffer/[[mapped_ranges]]}} 设置为 `[]`.
                4. 将 |b|.{{GPUBuffer/[[state]]}} 设置为[=buffer state/在创建时被映射=]状态.

                否则:

                1. 将 |b|.{{GPUBuffer/[[mapping]]}} 设置为 `null`。
                2. 将 |b|.{{GPUBuffer/[[mapping_range]]}} 设置为 `null`。
                3. 将 |b|.{{GPUBuffer/[[mapped_ranges]]}} 设置为 `null`。
                4. 将 |b|.{{GPUBuffer/[[state]]}} 设置为[=buffer state/未映射=]状态。

            5. 将 |b| 分配的每个字节设置为零。
            6. 返回 |b|.

            Note: 在 {{GPUBufferDescriptor/usage}} 中没有 {{GPUBufferUsage/MAP_READ}} 或 {{GPUBufferUsage/MAP_WRITE}} 的情况下，将 {{GPUBufferDescriptor/mappedAtCreation}} 设置为 `true`是有效的。这可用于设置缓冲区的初始数据。

        </div>

</dl>

<div class="example">
    创建一个 128 字节，并且可以被写入的统一缓冲区：
    <pre highlight="js">
        const buffer = gpuDevice.createBuffer({
            size: 128,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
        });
    </pre>
</div>

## 缓冲区销毁 ## {#buffer-destruction}

不再需要 {{GPUBuffer}} 的应用程序可以选择通过调用 {{GPUBuffer/destroy()}，在垃圾回收之前，丢弃对缓冲区的访问。销毁缓冲区的同时，也使缓冲区回到未映射状态，释放为映射分配的任何内存。

Note: 一旦先前提交的所有使用 {{GPUBuffer}} 的操作完成，用户代理可以回收与 {{GPUBuffer}} 关联的 GPU 内存。

<dl dfn-type=method dfn-for=GPUBuffer>
    : <dfn>destroy()</dfn>
    ::
        销毁 {{GPUBuffer}}.

        <div algorithm=GPUBuffer.destroy>
            **调用:** {{GPUBuffer}} |this|.

            **返回:** {{undefined}}
            1. 如果 |this|.{{GPUBuffer/[[state]]}} 不是[=buffer state/未映射=]或[=buffer state/被销毁=]
                1. 执行取消映射 |this| 的步骤。

            2. 设置 |this|.{{GPUBuffer/[[state]]}} 为[=buffer state/被销毁=].
        </div>
</dl>

## 缓冲区映射 ## {#buffer-mapping}


应用程序可以请求映射 {{GPUBuffer}}，使得这些应用程序可以通过 ArrayBuffers 访问其内容，这些 ArrayBuffers 代表了 {{GPUBuffer}} 的部分分配。使用 {{GPUBuffer/mapAsync()}} 异步请求映射 {{GPUBuffer}}，使得户代理可以确保 GPU 在应用程序可以访问其内容之前完成对 {{GPUBuffer}} 的使用。一旦 {{GPUBuffer}} 被映射，应用程序就可以使用 {{GPUBuffer/getMappedRange}} 同步请求访问其内容范围。已映射的 {{GPUBuffer}} 不能被 GPU 使用，并且必须在被使用到的工作任务提交到[=队列时间线=]之前，使用 {{GPUBuffer/unmap}} 使其回到未映射状态。

Issue(gpuweb/gpuweb#605): 添加客户端校验，使已映射缓冲区只能在其映射的 worker 上取消映射和销毁。同样 {{GPUBuffer/getMappedRange}} 只能在该 worker 上被调用。

<script type=idl>
typedef [EnforceRange] unsigned long GPUMapModeFlags;
[Exposed=(Window, DedicatedWorker)]
namespace GPUMapMode {
    const GPUFlagsConstant READ  = 0x0001;
    const GPUFlagsConstant WRITE = 0x0002;
};
</script>

<dl dfn-type=method dfn-for=GPUBuffer>
    : <dfn>mapAsync(mode, offset, size)</dfn>
    ::
        映射 {{GPUBuffer}} 的给定范围，并在 {{GPUBuffer}} 的内容准备好可以使用 {{GPUBuffer/getMappedRange()}} 访问时，决议返回的 Promise。

        <div algorithm=GPUBuffer.mapAsync>
            **调用:** {{GPUBuffer}} |this|.

            **参数:**
            <pre class=argumentdef for="GPUBuffer/mapAsync(mode, offset, size)">
                |mode|: 缓冲区是否应当被映射为读取或写入。
                |offset|: 以字节为单位的缓冲区到要映射的范围起始位置的偏移量。
                |size|: 以字节为单位的要映射的范围大小。
            </pre>

            **返回:** {{Promise}}&lt;{{undefined}}&gt;

            Issue(gpuweb/gpuweb#605): 一旦我们有了错误单子的描述，即刻处理错误缓冲区。

            1. 如果 |size| 字段丢失:
                1. 使 |rangeSize| 为 max(0, |this|.{{GPUBuffer/[[size]]}} - |offset|)。

                否则, 使 |rangeSize| 为 |size|。

            2. 如果以下任何条件未被满足:
                <div class=validusage>
                    - |this| 为[=有效=] {{GPUBuffer}}。
                        TODO: 检查被销毁状态?
                    - |offset| 是 8 的倍数。
                    - |rangeSize| 是 4 的倍数。
                    - |offset| + |rangeSize| 等于或小于 |this|.{{GPUBuffer/[[size]]}}。
                    - |this|.{{GPUBuffer/[[state]]}} 为 [=buffer state/未映射=]状态。
                    - |mode| 明确包含 {{GPUMapMode/READ}} 或 {{GPUMapMode/WRITE}} 之一。
                    - 如果 |mode| 包含 {{GPUMapMode/READ}}，则 |this|.{{GPUBuffer/[[usage]]}} 必须包含 {{GPUBufferUsage/MAP_READ}}。
                    - 如果 |mode| 包含 {GPUMapMode/WRITE}}，则 |this|.{{GPUBuffer/[[usage]]}} 必须包含 {{GPUBufferUsage/MAP_WRITE}}.

                    Issue: 我们是否需要对仅包含有效标识的 |mode| 做校验？
                </div>

                接下来:
                1. 记录当前范围内的校验错误。
                2. 返回 [=a promise rejected with=] 一个[=设备时间线=]上的 {{OperationError}}。

            3. 使 |p| 为一个新的 {{Promise}}。
            4. 设置 |this|.{{GPUBuffer/[[mapping]]}} 为 |p|。
            5. 设置 |this|.{{GPUBuffer/[[state]]}} 为[=buffer state/待映射=]。
            6. 设置 |this|.{{GPUBuffer/[[map_mode]]}} 为 |mode|。
            7. 在默认队列上的[=队列时间线=]对操作进行入队操作，该行为将执行以下操作:
                <div class=queue-timeline>
                    1. 如果 |this|.{{GPUBuffer/[[state]]}} 为[=buffer state/待映射=]状态:

                        1. 使 |m| 为一个新的大小为 |rangeSize| 的 {{ArrayBuffer}}。
                        2. 将 |m| 的内容设置为 |this| 分配的内容，从偏移 |offset| 开始分配，且分配 |rangeSize| 字节。
                        3. 将 |this|.{{GPUBuffer/[[mapping]]}} 设置为 |m|.
                        4. 将 |this|.{{GPUBuffer/[[state]]}} 设置为[=buffer state/已映射=].
                        5. 将 |this|.{{GPUBuffer/[[mapping_range]]}} 设置为 <code>[|offset|, |offset| + |rangeSize|]</code>.
                        6. 将 |this|.{{GPUBuffer/[[mapped_ranges]]}} 设置为 `[]`.

                    2. Resolve |p|.
                </div>
            8. 返回 |p|。
        </div>

    : <dfn>getMappedRange(offset, size)</dfn>
    ::
        返回一个带有给定范围内 {{GPUBuffer}} 内容的 {{ArrayBuffer}}。

        <div algorithm=GPUBuffer.getMappedRange>
            **调用:** {{GPUBuffer}} |this|.

            **参数:**
            <pre class=argumentdef for="GPUBuffer/getMappedRange(offset, size)">
                |offset|: 以字节为单位的缓冲区偏移量，返回缓冲区内容的位置。
                |size|: 以字节为单位的，要返回的 {{ArrayBuffer}} 大小。
            </pre>

            **返回:** {{ArrayBuffer}}

            1. 如果 |size| 缺失:
                1. 使 |rangeSize| 为 max(0, |this|.{{GPUBuffer/[[size]]}} - |offset|)。

                否则, 使 |rangeSize| 为 |size|。

            2. 如果任何以下条件未满足, 产生一个 {{OperationError}} 异常并停止。
                <div class=validusage>
                    - |this|.{{GPUBuffer/[[state]]}} 为[=buffer state/已映射=]或[=buffer state/在创建时被映射=]。
                    - |offset| 是 8 的倍数。
                    - |rangeSize| 是 4 的倍数。
                    - |offset| 等于或大于 |this|.{{GPUBuffer/[[mapping_range]]}}[0]。
                    - |offset| + |rangeSize| 小于或等于 |this|.{{GPUBuffer/[[mapping_range]]}}[1].
                    - [|offset|, |offset| + |rangeSize|) 不与另一个 |this|.{{GPUBuffer/[[mapped_ranges]]}} 范围重叠。

                    Note: 获取[=buffer state/在创建时被映射=]的 {{GPUBuffer}} 的映射范围总是有效的，即使它是[=无效的=]，因为[=内容时间线=]可能不知道它是无效的。

                    Issue: 考虑将 mapAsync 偏移量对齐到 8 以匹配此值。
                </div>

            3. 使 |m| 为一个新的大小为 |rangeSize| 的 {{ArrayBuffer}}，指向 |this|.{{GPUBuffer/[[mapping]]}} 的内容偏移量 |offset| - |this|.{{GPUBuffer/[[mapping_range]]}}[0]。

            4. 添加 ([=list/Append=]) |m| 至 |this|.{{GPUBuffer/[[mapped_ranges]]}}。

            5. 返回|m|。
        </div>

    : <dfn>unmap()</dfn>
    ::
        对已映射的 {{GPUBuffer}} 范围取消映射，并且使得其内容可以重新被 GPU 使用。

        <div algorithm=GPUBuffer.unmap>
            **调用:** {{GPUBuffer}} |this|.

            **返回:** {{undefined}}

            1. 如果以下任何需求没有满足，产生一个校验错误并停止。
                <div class=validusage>
                    - |this|.{{GPUBuffer/[[state]]}} 必须为[=buffer state/在创建时被映射=]，[=buffer state/待映射=]，或[=buffer state/已映射=].

                    Note: 取消一个状态为[=buffer state/在创建时被映射=]的 {{GPUBuffer}} [=无效=]映射是有效的，因为[=内容时间线=]可能不知道它是个错误的 {{GPUBuffer}}。这允许释放临时 {{GPUBuffer/[[mapping]]}} 内存。
                </div>

            2. 如果 |this|.{{GPUBuffer/[[state]]}} 为[=buffer state/待映射=]:

                1. [=拒绝=] {{GPUBuffer/[[mapping]]}}，产生一个 {{AbortError}}。
                1. 设置 |this|.{{GPUBuffer/[[mapping]]}} 为 `null`。

            3. 如果 |this|.{{GPUBuffer/[[state]]}} 为[=buffer state/已映射=]或[=buffer state/在创建时被映射=]:

                1. 如果以下两条件之一成立:

                    - |this|.{{GPUBuffer/[[state]]}} 为[=buffer state/在创建时被映射=]
                    - |this|.{{GPUBuffer/[[state]]}} 为[=buffer state/已映射=]并且 |this|.{{GPUBuffer/[[map_mode]]}} 包含 {{GPUMapMode/WRITE}}

                    则接下来:
                    1. 在默认队列的[=队列时间线=]上将操作入队，该操作将 |this|.{{GPUBuffer/[[mapping_range]]}} 的 |this| 分配更新为 |this|.{{GPUBuffer/[[mapping]]}} 的内容。

                2. 将 |this|.{{GPUBuffer/[[mapped_ranges]]}} 中的每个 {{ArrayBuffer}} 与其内容分离。
                3. 将 |this|.{{GPUBuffer/[[mapping]]}} 设置为 `null`.
                4. 将 |this|.{{GPUBuffer/[[mapping_range]]}} 设置为 `null`.
                5. 将 |this|.{{GPUBuffer/[[mapped_ranges]]}} 设置为 `null`.

            4. 将 |this|.{{GPUBuffer/[[state]]}} 设置为[=buffer state/未映射=].

            Note: 当 {{GPUBufferUsage/MAP_READ}} 缓冲区（目前未在创建时被映射）被取消映射时，应用程序对映射范围 {{ArrayBuffer}} 所做的任何本地修改都将被丢弃，并且不会影响后续映射的内容。
        </div>
</dl>


# 纹理和纹理视图 # {#textures}

Issue: 定义<dfn dfn>纹理</dfn>（内部对象）

Issue: 定义 <dfn dfn>mipmap level</dfn>, <dfn dfn>array layer</dfn>, <dfn dfn>aspect</dfn>, <dfn dfn>slice</dfn>（概念）

## <dfn interface>GPUTexture</dfn> ## {#texture-interface}

{{GPUTexture|GPUTextures}} 是通过创建 {{GPUDevice/createTexture(descriptor)|GPUDevice.createTexture(descriptor)}} 返回的一个新的纹理。

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUTexture {
    GPUTextureView createView(optional GPUTextureViewDescriptor descriptor = {});

    undefined destroy();
};
GPUTexture includes GPUObjectBase;
</script>

{{GPUTexture}} 有以下内部插槽:

<dl dfn-type=attribute dfn-for="GPUTexture">
    : <dfn>\[[descriptor]]</dfn>, {{GPUTextureDescriptor}} 类型
    ::
        {{GPUTextureDescriptor}} 描述这个纹理.

        {{GPUTextureDescriptor}} 的所有可选字段都已定义。

    : <dfn>\[[destroyed]]</dfn>, `boolean` 类型, 初始设定为 false
    ::
        如果纹理被破坏，该纹理就不能再用于任何操作，并且其底层内存可以被释放。
</dl>

<div algorithm>
    <dfn abstract-op>compute render extent</dfn>(baseSize, mipLevel)

    **参数:**
        - {{GPUExtent3D}} |baseSize|
        - {{GPUSize32}} |mipLevel|

    **返回:** {{GPUExtent3DDict}}

    1. 让 |extent| 成为一个新的 {{GPUExtent3DDict}} 对象。
    1. 设置 |extent|.{{GPUExtent3DDict/width}} 为 max(1, |baseSize|.[=Extent3D/width=] &Gt; |mipLevel|).
    1. 设置 |extent|.{{GPUExtent3DDict/height}} 为 max(1, |baseSize|.[=Extent3D/height=] &Gt; |mipLevel|).
    1. 设置 |extent|.{{GPUExtent3DDict/depthOrArrayLayers}} 为 1.
    1. 返回 |extent|.
</div>

Issue: 与描述抽样的规范部分共享此定义。

### 纹理创建 ### {#texture-creation}

<script type=idl>
dictionary GPUTextureDescriptor : GPUObjectDescriptorBase {
    required GPUExtent3D size;
    GPUIntegerCoordinate mipLevelCount = 1;
    GPUSize32 sampleCount = 1;
    GPUTextureDimension dimension = "2d";
    required GPUTextureFormat format;
    required GPUTextureUsageFlags usage;
    sequence<GPUTextureFormat> viewFormats = [];
};
</script>

<dl dfn-type=dict-member dfn-for=GPUTextureDescriptor>
    : <dfn>viewFormats</dfn>
    ::
        当在此纹理（除了纹理的实际格式 {{GPUTextureDescriptor/format}}）调用 {{GPUTexture/createView()}} 时，指定了何种视图 {{GPUTextureViewDescriptor/format}} 值可以被允许。

        Note: 将格式添加到此列表可能会对性能产生相当大的影响，具体取决于用户的系统。最好避免不必要地添加格式。

        此列表中的格式与纹理格式一起必须为[=纹理视图格式可兼容的=]。

        <div algorithm>
            两个{{GPUTextureFormat}}s |format| 和 |viewFormat| 为<dfn dfn for=>纹理视图格式可兼容的</dfn>当:

            - |format| 等于 |viewFormat|, 或
            - |format| 和 |viewFormat| 的区别仅在于它们是否为 `srgb` 格式（拥有 `-srgb` 后缀）。

            Issue(gpuweb/gpuweb#168): 定义更大的兼容性类。
        </div>

</dl>

<script type=idl>
enum GPUTextureDimension {
    "1d",
    "2d",
    "3d",
};
</script>

<script type=idl>
typedef [EnforceRange] unsigned long GPUTextureUsageFlags;
[Exposed=(Window, DedicatedWorker)]
namespace GPUTextureUsage {
    const GPUFlagsConstant COPY_SRC          = 0x01;
    const GPUFlagsConstant COPY_DST          = 0x02;
    const GPUFlagsConstant TEXTURE_BINDING   = 0x04;
    const GPUFlagsConstant STORAGE_BINDING   = 0x08;
    const GPUFlagsConstant RENDER_ATTACHMENT = 0x10;
};
</script>

<div algorithm>
    <dfn abstract-op>maximum mipLevel count</dfn>(dimension, size)
    **参数:**
        - {{GPUTextureDescriptor/dimension}} |dimension|
        - {{GPUTextureDescriptor/size}} |size|

    1. 计算最大维度值 |m|:
        - 如果 |dimension| 是:
            <dl class="switch">
                : {{GPUTextureDimension/"1d"}}
                :: 返回 1。

                : {{GPUTextureDimension/"2d"}}
                :: 设定 |m| = max(|size|.[=Extent3D/width=], |size|.[=Extent3D/height=]).

                : {{GPUTextureDimension/"3d"}}
                :: 设定 |m| = max(max(|size|.[=Extent3D/width=], |size|.[=Extent3D/height=]), |size|.[=Extent3D/depthOrArrayLayer=]).
            </dl>
    1. 返回 floor(log<sub>2</sub>(|m|)) + 1.
</div>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createTexture(descriptor)</dfn>
    ::
        创建一个 {{GPUTexture}}.

        <div algorithm=GPUDevice.createTexture>
            **调用:** {{GPUDevice}} this.

            **参数:**
            <pre class=argumentdef for="GPUDevice/createTexture(descriptor)">
                |descriptor|: 针对要创建的 {{GPUTexture}} 的描述。
            </pre>

            **返回:** {{GPUTexture}}

            1. 在 |this| 的[=设备时间线=]上执行以下步骤:
                <div class=device-timeline>
                    1. 如果 |descriptor|.{{GPUTextureDescriptor/format}} 是一个需要某个特性的 {{GPUTextureFormat}}（参见 [[#texture-format-caps]])，但 |this|.{{GPUObjectBase/[[device]]}}.{{device/[[features]]}} 没有[=list/包含=]该特性，返回 {{TypeError}}。
                    1. 如果不满足以下任何要求:
                        <div class=validusage>
                            - |this| 必须是[=有效=] {{GPUDevice}}.
                            - |descriptor|.{{GPUTextureDescriptor/usage}} 必须不为 0。
                            - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/width=],
                                |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/height=],
                                和 |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/depthOrArrayLayers=] 必须大于零。
                            - |descriptor|.{{GPUTextureDescriptor/mipLevelCount}} 必须大于零。
                            - |descriptor|.{{GPUTextureDescriptor/sampleCount}} 必须为 1 或 4。

                            - 如果 |descriptor|.{{GPUTextureDescriptor/dimension}} 是:
                                <dl class="switch">
                                    : {{GPUTextureDimension/"1d"}}
                                    ::
                                        - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/width=] 必须小于或等于
                                            |this|.{{GPUDevice/limits}}.{{GPUSupportedLimits/maxTextureDimension1D}}。
                                        - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/height=] 必须为 1。
                                        - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/depthOrArrayLayers=] 必须为 1。
                                        - |descriptor|.{{GPUTextureDescriptor/sampleCount}} 必须为1。
                                        - |descriptor|.{{GPUTextureDescriptor/format}} 必须不为[=压缩格式=]或[=深度-模板格式=]。

                                    : {{GPUTextureDimension/"2d"}}
                                    ::
                                        - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/width=] 必须小于或等于
                                            |this|.{{GPUDevice/limits}}.{{GPUSupportedLimits/maxTextureDimension2D}}。
                                        - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/height=] 必须小于或等于
                                            |this|.{{GPUDevice/limits}}.{{GPUSupportedLimits/maxTextureDimension2D}}。
                                        - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/depthOrArrayLayers=] 必须小于或等于
                                            |this|.{{GPUDevice/limits}}.{{GPUSupportedLimits/maxTextureArrayLayers}}。

                                    : {{GPUTextureDimension/"3d"}}
                                    ::
                                        - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/width=] 必须小于或等于
                                            |this|.{{GPUDevice/limits}}.{{GPUSupportedLimits/maxTextureDimension3D}}.
                                        - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/height=] 必须小于或等于
                                            |this|.{{GPUDevice/limits}}.{{GPUSupportedLimits/maxTextureDimension3D}}.
                                        - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/depthOrArrayLayers=] 必须小于或等于
                                            |this|.{{GPUDevice/limits}}.{{GPUSupportedLimits/maxTextureDimension3D}}.
                                        - |descriptor|.{{GPUTextureDescriptor/sampleCount}} 必须为 1。
                                        - |descriptor|.{{GPUTextureDescriptor/format}} 必须不为[=压缩格式=]或[=深度-模板格式=]。
                                </dl>
                            - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/width=] 必须是[=纹素块宽度=]的倍数。
                            - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/height=]必须是[=纹素块高度=]的倍数。

                            - 如果 |descriptor|.{{GPUTextureDescriptor/sampleCount}} > 1:
                                - |descriptor|.{{GPUTextureDescriptor/mipLevelCount}} 必须为 1。
                                - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/depthOrArrayLayers=] 必须为 1。
                                - |descriptor|.{{GPUTextureDescriptor/usage}} 必须不包含 {{GPUTextureUsage/STORAGE_BINDING}} 位.
                                - |descriptor|.{{GPUTextureDescriptor/format}} 必须为[=可渲染格式=]并根据 [[#texture-format-caps]] 支持多重采样。

                            - |descriptor|.{{GPUTextureDescriptor/mipLevelCount}} 必须小于或等于
                                [$maximum mipLevel count$](|descriptor|.{{GPUTextureDescriptor/dimension}}, |descriptor|.{{GPUTextureDescriptor/size}}).

                            - |descriptor|.{{GPUTextureDescriptor/usage}} 必须为 {{GPUTextureUsage}} 的值的组合。
                            - 如果 |descriptor|.{{GPUTextureDescriptor/usage}} 包含 {{GPUTextureUsage/RENDER_ATTACHMENT}} 位,
                                |descriptor|.{{GPUTextureDescriptor/format}} 必须为[=可渲染格式=].
                            - If |descriptor|.{{GPUTextureDescriptor/usage}} 包含 {{GPUTextureUsage/STORAGE_BINDING}} 位,
                                |descriptor|.{{GPUTextureDescriptor/format}} 必须在带有 {{GPUTextureUsage/STORAGE_BINDING}} 功能的
                                [[#plain-color-formats]] 表格中列出。

                        </div>

                        Then:
                            1. 在当前范围内生成带有相应错误消息的 {{GPUValidationError}}。
                            1. 返回一个新的[=无效=] {{GPUTexture}}。

                    1. 让 |t| 成为一个新的 {{GPUTexture}} 对象.
                    1. 设定 |t|.{{GPUTexture/[[descriptor]]}} 为 |descriptor|.
                    1. 返回 |t|.
                </div>
        </div>
</dl>

<div class="example">
    创建一个具有一个 array layer 和一个 mip level 的 16x16，RGBA，2D纹理：
    <pre highlight="js">
        const texture = gpuDevice.createTexture({
            size: { width: 16, height: 16 },
            format: 'rgba8unorm',
            usage: GPUTextureUsage.TEXTURE_BINDING,
        });
    </pre>
</div>

### 纹理破坏 ### {#texture-destruction}

不再需要 {{GPUTexture}} 的应用程序，可以通过调用 {{GPUTexture/destroy()}} 选择在垃圾收集之前失去对它的访问权限。

Note: 这允许用户代理在所有先前提交的，并使用了相关的 GPU 内存的操作完成后，回收与 {{GPUTexture}} 相关的 GPU 内存。

<dl dfn-type=method dfn-for=GPUTexture>
    : <dfn>destroy()</dfn>
    ::
        摧毁 {{GPUTexture}}.

        <div algorithm=GPUTexture.destroy>
            **调用:** {{GPUTexture}} |this|.

            **返回:** {{undefined}}

            1. 设置 |this|.{{GPUTexture/[[destroyed]]}} 为 true.
        </div>
</dl>

## <dfn interface>GPUTextureView</dfn> ## {#gpu-textureview}

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUTextureView {
};
GPUTextureView includes GPUObjectBase;
</script>

{{GPUTextureView}} 有以下内部插槽:

<dl dfn-type=attribute dfn-for="GPUTextureView">
    : <dfn>\[[texture]]</dfn>
    ::
        这是视图所在的 {{GPUTexture}}。

    : <dfn>\[[descriptor]]</dfn>
    ::
        {{GPUTextureViewDescriptor}} 描绘这个纹理视图.

        {{GPUTextureViewDescriptor}} 的所有可选字段都已定义。
    : <dfn>\[[renderExtent]]</dfn>
    ::
        对于可渲染视图，这是用于渲染的有效 {{GPUExtent3DDict}}。

        Note: 这个程度取决于 {{GPUTextureViewDescriptor/baseMipLevel}}.

</dl>

### 纹理视图创建 ### {#texture-view-creation}

<script type=idl>
dictionary GPUTextureViewDescriptor : GPUObjectDescriptorBase {
    GPUTextureFormat format;
    GPUTextureViewDimension dimension;
    GPUTextureAspect aspect = "all";
    GPUIntegerCoordinate baseMipLevel = 0;
    GPUIntegerCoordinate mipLevelCount;
    GPUIntegerCoordinate baseArrayLayer = 0;
    GPUIntegerCoordinate arrayLayerCount;
};
</script>

<script type=idl>
enum GPUTextureViewDimension {
    "1d",
    "2d",
    "2d-array",
    "cube",
    "cube-array",
    "3d",
};
</script>

<dl dfn-type=enum-value dfn-for=GPUTextureViewDimension>
    : <dfn>"1d"</dfn>
    ::
        纹理被视为一维图像。
        对应 WGSL 类型：
        - `texture_1d`
        - `texture_storage_1d`

    : <dfn>"2d"</dfn>
    ::
        纹理被视为单二维图像。
        对应 WGSL 类型：

        - `texture_2d`
        - `texture_storage_2d`
        - `texture_multisampled_2d`
        - `texture_depth_2d`
        - `texture_depth_multisampled_2d`

    : <dfn>"2d-array"</dfn>
    ::
        纹理被视为二维图像数组。
        对应 WGSL 类型：

        - `texture_2d_array`
        - `texture_storage_2d_array`
        - `texture_depth_2d_array`

    : <dfn>"cube"</dfn>
    ::
        纹理被视为立方体贴图。
        该视图有 6 个数组层，对应于立方体的 [+X, -X, +Y, -Y, +Z, -Z] 面。

        对应 WGSL 类型：

        - `texture_cube`
        - `texture_depth_cube`

    : <dfn>"cube-array"</dfn>
    ::
        纹理被视为一个包含 n 个立方体贴图的打包阵列，每个贴图有 6 个阵列层，对应于立方体的 [+X, -X, +Y, -Y, +Z, -Z] 面。

        对应 WGSL 类型：

        - `texture_cube_array`
        - `texture_depth_cube_array`

    : <dfn>"3d"</dfn>
    ::
        纹理被视为 3 维图像。

        对应 WGSL 类型：

        - `texture_3d`
        - `texture_storage_3d`
</dl>

<script type=idl>
enum GPUTextureAspect {
    "all",
    "stencil-only",
    "depth-only",
};
</script>

<dl dfn-type=method dfn-for=GPUTexture>
    : <dfn>createView(descriptor)</dfn>
    ::
        创建一个 {{GPUTextureView}}.

        <div algorithm=GPUTexture.createView>
            **调用:** {{GPUTexture}} |this|.

            **参数:**
            <pre class=argumentdef for="GPUTexture/createView(descriptor)">
                |descriptor|: 描述要创建的 {{GPUTextureView}}。
            </pre>

            **返回:** |view|, {{GPUTextureView}} 类型。

            1. 设置 |descriptor| 为带有|descriptor| 的 [$resolving GPUTextureViewDescriptor defaults$] 返回值。
            1. 在 |this| 的[=设备时间线=]上发布以下指令:
                <div class=device-timeline>
                    1. 如果不满足以下任何要求:
                        <div class=validusage>
                            - |this| 是[=有效=]的
                            - 如果 |descriptor|.{{GPUTextureViewDescriptor/aspect}} 是
                                <dl class="switch">
                                    : {{GPUTextureAspect/"stencil-only"}}
                                    :: |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/format}} 必须为一个具有模板宽高比的[=深度-模板格式=]。

                                    : {{GPUTextureAspect/"depth-only"}}
                                    :: |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/format}} 必须为一个具有深度宽高比的[=深度-模板格式=]。

                                </dl>
                            - |descriptor|.{{GPUTextureViewDescriptor/mipLevelCount}} 必须 &gt; 0.
                            - |descriptor|.{{GPUTextureViewDescriptor/baseMipLevel}} +
                                |descriptor|.{{GPUTextureViewDescriptor/mipLevelCount}} 必须 &le;
                                |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/mipLevelCount}}.
                            - |descriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} 必须 &gt; 0.
                            - |descriptor|.{{GPUTextureViewDescriptor/baseArrayLayer}} +
                                |descriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} 必须 &le;
                                the [$array layer count$] of |this|.
                            - |descriptor|.{{GPUTextureViewDescriptor/format}} 必须等于 |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/format}} 或 |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/viewFormats}} 中的一个格式。
                            - 如果 |descriptor|.{{GPUTextureViewDescriptor/dimension}} 是:
                                <dl class="switch">
                                    : {{GPUTextureViewDimension/"1d"}}
                                    :: |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/dimension}} 必须是 {{GPUTextureDimension/"1d"}}.
                                    :: |descriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} 必须是 `1`.

                                    : {{GPUTextureViewDimension/"2d"}}
                                    :: |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/dimension}} 必须是 {{GPUTextureDimension/"2d"}}.
                                    :: |descriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} 必须是 `1`.

                                    : {{GPUTextureViewDimension/"2d-array"}}
                                    :: |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/dimension}} 必须是 {{GPUTextureDimension/"2d"}}.

                                    : {{GPUTextureViewDimension/"cube"}}
                                    :: |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/dimension}} 必须是 {{GPUTextureDimension/"2d"}}.
                                    :: |descriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} 必须是 `6`.
                                    :: |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/size}}.[=Extent3D/width=] 必须是
                                        |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/size}}.[=Extent3D/height=].

                                    : {{GPUTextureViewDimension/"cube-array"}}
                                    :: |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/dimension}} 必须是 {{GPUTextureDimension/"2d"}}.
                                    :: |descriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} 必须是 `6` 的倍数。
                                    :: |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/size}}.[=Extent3D/width=] 必须是
                                        |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/size}}.[=Extent3D/height=].

                                    : {{GPUTextureViewDimension/"3d"}}
                                    :: |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/dimension}} 必须是 {{GPUTextureDimension/"3d"}}.
                                    :: |descriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} 必须是 `1`.
                                </dl>
                        </div>

                        Then:
                            1. 在当前范围内生成一个 {{GPUValidationError}} 并带有适当的错误消息。
                            1. 返回一个新的[=无效=] {{GPUTextureView}}。

                    1. 让 |view| 成为一个新的 {{GPUTextureView}} 对象。
                    1. 设置 |view|.{{GPUTextureView/[[texture]]}} 为 |this|。
                    1. 设置 |view|.{{GPUTextureView/[[descriptor]]}} 为 |descriptor|.
                    1. 如果 |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/usage}} 包含 {{GPUTextureUsage/RENDER_ATTACHMENT}}:
                        1. 让 |renderExtent| 为 [$compute render extent$](|this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/size}}, |descriptor|.{{GPUTextureViewDescriptor/baseMipLevel}}).
                        1. 设置 |view|.{{GPUTextureView/[[renderExtent]]}} 为 |renderExtent|.
                    1. 返回 |view|.
                </div>
        </div>
</dl>

<div algorithm>
    When <dfn abstract-op>resolving GPUTextureViewDescriptor defaults</dfn> for {{GPUTextureViewDescriptor}}
    |descriptor| 运行一下步骤：

    1. 让 |resolved| 成为一个 |descriptor| 的副本。
    1. 如果 |resolved|.{{GPUTextureViewDescriptor/format}} 是 `undefined`,
        设置 |resolved|.{{GPUTextureViewDescriptor/format}} 为 |texture|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/format}}.
    1. 如果 |resolved|.{{GPUTextureViewDescriptor/mipLevelCount}} 是 `undefined`,
        设置 |resolved|.{{GPUTextureViewDescriptor/mipLevelCount}} 为 |texture|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/mipLevelCount}}
        &minus; {{GPUTextureViewDescriptor/baseMipLevel}}.
    1. 如果 |resolved|.{{GPUTextureViewDescriptor/dimension}} 是 `undefined` 并且
        |texture|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/dimension}} 是:
        <dl class="switch">
            : {{GPUTextureDimension/"1d"}}
            :: 设置 |resolved|.{{GPUTextureViewDescriptor/dimension}} 为 {{GPUTextureViewDimension/"1d"}}.

            : {{GPUTextureDimension/"2d"}}
            :: 设置 |resolved|.{{GPUTextureViewDescriptor/dimension}} 为 {{GPUTextureViewDimension/"2d"}}.

            : {{GPUTextureDimension/"3d"}}
            :: 设置 |resolved|.{{GPUTextureViewDescriptor/dimension}} 为 {{GPUTextureViewDimension/"3d"}}.
        </dl>
    1. 如果 |resolved|.{{GPUTextureViewDescriptor/arrayLayerCount}} 为 `undefined` 并且
        |resolved|.{{GPUTextureViewDescriptor/dimension}} 是:
        <dl class="switch">
            : {{GPUTextureViewDimension/"1d"}}, {{GPUTextureViewDimension/"2d"}}, or
                {{GPUTextureViewDimension/"3d"}}
            :: 设置 |resolved|.{{GPUTextureViewDescriptor/arrayLayerCount}} 为 `1`.

            : {{GPUTextureViewDimension/"cube"}}
            :: 设置 |resolved|.{{GPUTextureViewDescriptor/arrayLayerCount}} 为 `6`.

            : {{GPUTextureViewDimension/"2d-array"}} 或者 {{GPUTextureViewDimension/"cube-array"}}
            :: 设置 |resolved|.{{GPUTextureViewDescriptor/arrayLayerCount}} 为
                |texture|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/size}}.[=Extent3D/depthOrArrayLayers=] &minus;
                {{GPUTextureViewDescriptor/baseArrayLayer}}.
        </dl>

    1. 返回 |resolved|.
</div>

<div algorithm>
    要确定 {{GPUTexture}} |texture| 的 <dfn abstract-op>array layer count</dfn>，请运行
    以下步骤：

        1. 如果 |texture|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/dimension}} 是:
            <dl class="switch">
                : {{GPUTextureDimension/"1d"}} 或者 {{GPUTextureDimension/"3d"}}
                :: 返回 `1`.

                : {{GPUTextureDimension/"2d"}}
                :: 返回 |texture|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/size}}.[=Extent3D/depthOrArrayLayers=].
            </dl>
</div>

<div algorithm>
    - Let {{GPUTextureViewDescriptor}} |aDescriptor| = |a|.{{GPUTextureView/[[descriptor]]}}.
    - Let {{GPUTextureViewDescriptor}} |bDescriptor| = |b|.{{GPUTextureView/[[descriptor]]}}.
    - [=Assert=]: |aDescriptor|.{{GPUTextureViewDescriptor/mipLevelCount}} 不为 `undefined`.
    - [=Assert=]: |bDescriptor|.{{GPUTextureViewDescriptor/mipLevelCount}} 不为 `undefined`.
    - [=Assert=]: |aDescriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} 不为 `undefined`.
    - [=Assert=]: |bDescriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} 不为 `undefined`.

    当且仅当以下条件为真，两个 {{GPUTextureView}} 对象 |a| 和 |b| 被作为 <dfn dfn>texture-view-aliasing</dfn>

    - |a|.{{GPUTextureView/[[texture]]}} == |b|.{{GPUTextureView/[[texture]]}}.
    - |aDescriptor|.{{GPUTextureViewDescriptor/aspect}} == {{GPUTextureAspect/"all"}}, 或
        |bDescriptor|.{{GPUTextureViewDescriptor/aspect}} == {{GPUTextureAspect/"all"}}, 或
        |aDescriptor|.{{GPUTextureViewDescriptor/aspect}} == |bDescriptor|.{{GPUTextureViewDescriptor/aspect}}.
    - |aDescriptor|.{{GPUTextureViewDescriptor/baseMipLevel}} 和
        |aDescriptor|.{{GPUTextureViewDescriptor/mipLevelCount}} 构成的区间与
        |bDescriptor|.{{GPUTextureViewDescriptor/baseMipLevel}} 和
        |bDescriptor|.{{GPUTextureViewDescriptor/mipLevelCount}} 构成的区间相交.
    - The range formed by
        |aDescriptor|.{{GPUTextureViewDescriptor/baseArrayLayer}} 和
        |aDescriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} 构成的区间与
        |bDescriptor|.{{GPUTextureViewDescriptor/baseArrayLayer}} 和
        |bDescriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} 构成的区间相交.

    问题: 用“一组子资源”算法来描述这个算法。
</div>

## 纹理格式 ## {#texture-formats}

格式的名称指定了组件的顺序、每个组件的位数、和组件的数据类型。

  * `r`, `g`, `b`, `a` = red, green, blue, alpha
  * `unorm` = unsigned normalized
  * `snorm` = signed normalized
  * `uint` = unsigned int
  * `sint` = signed int
  * `float` = floating point

如果格式具有 “-srgb” 后缀，则在着色器中读取和写入颜色值期间应用从伽马到线性的 sRGB 转换，反之亦然。 压缩纹理格式由[=特性=]提供。其命名应遵循此处的约定，以纹理名称作为前缀。 例如 `etc2-rgba8unorm`。

<dfn dfn>纹素块</dfn> 是基于像素的 {{GPUTextureFormat}} 中纹理的单个可寻址元素，以及基于块的压缩 {{GPUTextureFormat}} 中纹理的单个压缩块。

<dfn dfn>纹素块宽度</dfn> 和 <dfn dfn>纹素块高度</dfn> 指定了一个[=纹素块=]的尺寸。
   - 对于基于像素的 {{GPUTextureFormat}}s，[=纹素块宽度=]和[=纹素块高度=]始终为 1。
   - 对于基于块压缩的 {{GPUTextureFormat}}s，[=纹素块宽度=]是一个[=纹素块=]里每一行的纹素数量，[=纹素块高度=]是一个[=纹素块=]中纹素行的数量。

{{GPUTextureFormat}} 的<dfn dfn>纹素块大小</dfn>是存储一个[=纹素块=]的字节数。
除了 {{GPUTextureFormat/"stencil8"}}、{{GPUTextureFormat/"depth24plus"}} 和 {{GPUTextureFormat/"depth24plus-stencil8"} 之外，每个 {{GPUTextureFormat}} 的[=纹素块大小=]是恒定的。

<script type=idl>
enum GPUTextureFormat {
    // 8-bit 格式
    "r8unorm",
    "r8snorm",
    "r8uint",
    "r8sint",

    // 16-bit 格式
    "r16uint",
    "r16sint",
    "r16float",
    "rg8unorm",
    "rg8snorm",
    "rg8uint",
    "rg8sint",

    // 32-bit 格式
    "r32uint",
    "r32sint",
    "r32float",
    "rg16uint",
    "rg16sint",
    "rg16float",
    "rgba8unorm",
    "rgba8unorm-srgb",
    "rgba8snorm",
    "rgba8uint",
    "rgba8sint",
    "bgra8unorm",
    "bgra8unorm-srgb",
    // Packed 32-bit formats
    "rgb9e5ufloat",
    "rgb10a2unorm",
    "rg11b10ufloat",

    // 64-bit 格式
    "rg32uint",
    "rg32sint",
    "rg32float",
    "rgba16uint",
    "rgba16sint",
    "rgba16float",

    // 128-bit 格式
    "rgba32uint",
    "rgba32sint",
    "rgba32float",

    // 深度/模板格式
    "stencil8",
    "depth16unorm",
    "depth24plus",
    "depth24plus-stencil8",
    "depth32float",

    // "depth24unorm-stencil8"特性
    "depth24unorm-stencil8",

    // "depth32float-stencil8"特性
    "depth32float-stencil8",

    // BC 压缩模式非常有用，如果设备和用户代理同时支持 "texture-compression-bc"
    // 并且在 RequestDevice 中被开启。
    "bc1-rgba-unorm",
    "bc1-rgba-unorm-srgb",
    "bc2-rgba-unorm",
    "bc2-rgba-unorm-srgb",
    "bc3-rgba-unorm",
    "bc3-rgba-unorm-srgb",
    "bc4-r-unorm",
    "bc4-r-snorm",
    "bc5-rg-unorm",
    "bc5-rg-snorm",
    "bc6h-rgb-ufloat",
    "bc6h-rgb-float",
    "bc7-rgba-unorm",
    "bc7-rgba-unorm-srgb",

    // 如果设备/用户代理支持并在 requestDevice 中启用 “texture-compression-etc2”，则 ETC2 压缩格式可用。
    "etc2-rgb8unorm",
    "etc2-rgb8unorm-srgb",
    "etc2-rgb8a1unorm",
    "etc2-rgb8a1unorm-srgb",
    "etc2-rgba8unorm",
    "etc2-rgba8unorm-srgb",
    "eac-r11unorm",
    "eac-r11snorm",
    "eac-rg11unorm",
    "eac-rg11snorm",

    // 如果设备/用户代理支持并在 requestDevice 中启用 “texture-compression-astc”，则 ASTC 压缩格式可用。
    "astc-4x4-unorm",
    "astc-4x4-unorm-srgb",
    "astc-5x4-unorm",
    "astc-5x4-unorm-srgb",
    "astc-5x5-unorm",
    "astc-5x5-unorm-srgb",
    "astc-6x5-unorm",
    "astc-6x5-unorm-srgb",
    "astc-6x6-unorm",
    "astc-6x6-unorm-srgb",
    "astc-8x5-unorm",
    "astc-8x5-unorm-srgb",
    "astc-8x6-unorm",
    "astc-8x6-unorm-srgb",
    "astc-8x8-unorm",
    "astc-8x8-unorm-srgb",
    "astc-10x5-unorm",
    "astc-10x5-unorm-srgb",
    "astc-10x6-unorm",
    "astc-10x6-unorm-srgb",
    "astc-10x8-unorm",
    "astc-10x8-unorm-srgb",
    "astc-10x10-unorm",
    "astc-10x10-unorm-srgb",
    "astc-12x10-unorm",
    "astc-12x10-unorm-srgb",
    "astc-12x12-unorm",
    "astc-12x12-unorm-srgb",
};
</script>

{{GPUTextureFormat/"depth24plus"}}) 和 {{GPUTextureFormat/"depth24plus-stencil8"}}) 的深度组件格式可以实现为 24 位无符号归一化值（“depth24unorm”）或 32 位 IEEE 754 浮点值（比如 {{GPUTextureFormat/"depth32float"}}）。

Issue: 在 GPUAdapter(?) 上添加一些东西来估计每像素的字节数 {{GPUTextureFormat/"stencil8"}}、{{GPUTextureFormat/"depth24plus-stencil8"}} 和 {{GPUTextureFormat/"depth32float-stencil8"}}。

{{GPUTextureFormat/stencil8}} 格式可以实现为一个真正的“stencil8”或“depth24stencil8”，其中深度方面是
隐藏且无法访问的。

Note: 虽然对于可表示范围（0.0 到 1.0）中的所有值，depth32float 通道的精度严格高于 depth24unorm 通道的精度，但请注意，可表示值的集合不是精确的超集：
对于 depth24unorm，1 ULP 的常数值为 1 / (2<sup>24</sup> &minus; 1);
对于 depth32float，1 ULP 的变量值不大于 1 / (2<sup>24</sup>)。

<dfn>可渲染格式</dfn>要么是<dfn>颜色可渲染格式</dfn>，要么是[=深度-模板格式=]。
如果在 [[#plain-color-formats]] 中列出了具有 {{GPUTextureUsage/RENDER_ATTACHMENT}} 功能的格式，则它是可渲染颜色的格式。任何其他格式都不是颜色可渲染的格式。所有[=深度-模板格式=]都可渲染。

## <dfn interface>GPUExternalTexture</dfn> ## {#gpu-external-texture}

{{GPUExternalTexture}} 是打包了外部视频对象的可采样纹理。 {{GPUExternalTexture}} 对象的内容可能不会改变，无论是从 WebGPU 内部（仅可采样）还是从 WebGPU 外部（例如由于视频帧推进）。

Issue: 使用画布更新此描述。

{{GPUExternalTexture}} 使用 {{GPUBindGroupLayoutEntry/externalTexture}} 绑定组布局的输入成员，被绑定到绑定组布局。外部纹理使用多个绑定槽：参见[=超出绑定槽限制=]。

<div class=note>
    外部纹理*可以*在不创建导入源的副本的情况下实现，但这取决于实现定义的因素。底层表示的所有权可能是独占的，也可能与其他所有者（例如视频解码器）共享，但这对应用程序不可见。

    外部纹理的底层表示是不可见的（采样行为除外），但通常可能包括

    - 最多三个 2D 数据平面（例如 RGBA、Y+UV、Y+U+V）。
    - 在从这些平面（裁剪和旋转）读取之前转换坐标的元数据。
    - 用于将值转换为指定输出颜色空间（矩阵、伽马、3D LUT）的元数据。

    使用的配置可能在时间、系统、用户代理、媒体源、或单个视频源的帧中发生变化。为了用于尽可能多的表示，对于*每个*外部纹理，绑定保守地使用以下内容：

    - 三个采样纹理绑定（最多 3 个平面），
    - 一个用于 3D LUT 的采样纹理绑定，
    - 一个采样器绑定来采样 3D LUT，以及
    - 一种统一的元数据缓冲区绑定。
</div>

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUExternalTexture {
};
GPUExternalTexture includes GPUObjectBase;
</script>

{{GPUExternalTexture}} 有以下内部插槽:

<dl dfn-type=attribute dfn-for="GPUExternalTexture">
    : <dfn>\[[destroyed]]</dfn>, `boolean` 格式
    ::
        表示对象是否被摧毁 (不能被使用)。初始被设定为 `false`.

        <!-- 如果 GPUExternalTexture 变成 Serializable，则把其移动到内部对象 -->
</dl>

### 导入外部纹理 ### {#external-texture-creation}

外部纹理是使用 {{GPUDevice/importExternalTexture()}} 从外部视频对象创建的。

Issue: 使用画布更新此描述。

外部纹理作为一个微任务，会被自动销毁，而不是像其他资源一样被手动销毁或被当垃圾收集。

<script type=idl>
dictionary GPUExternalTextureDescriptor : GPUObjectDescriptorBase {
    required HTMLVideoElement source;
    GPUPredefinedColorSpace colorSpace = "srgb";
};
</script>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>importExternalTexture(descriptor)</dfn>
    ::
        创建一个 {{GPUExternalTexture}} 包装提供的图像源。

        <div algorithm=GPUDevice.importExternalTexture>
            **调用:** {{GPUDevice}} this.

            **参数:**
            <pre class=argumentdef for="GPUDevice/importExternalTexture(descriptor)">
                |descriptor|: 提供外部图像源对象（和任何创建选项）。
            </pre>

            **返回:** {{GPUExternalTexture}}

            1. 让 |source| 成为 |descriptor|.{{GPUExternalTextureDescriptor/source}}.

            1. 让 |usability| 是 检查图像参数的可用性|检查 |source| 的可用性的结果 （这可能会引发异常）。

            1. 如果 |usability| 是 `bad`, 返回一个 {{InvalidStateError}} 并停止运行。

            1. 如果 |source| <l spec=html>[=is not origin-clean=]</l>, 返回一个 {{SecurityError}} 并停止运行。

            1. 让 |data| 是 |source| 的当前图像内容转换的结果进入未预乘 alpha 颜色空间 |descriptor|.{{GPUExternalTextureDescriptor/colorSpace}}。

            此 [[#color-space-conversions|may result]] 值超出范围 [0, 1]。如果需要做夹紧保护，可以在取样后进行。

                Note: 这被描述为一个副本，但可以作为对只读基础数据的引用，以及稍后执行转换的适当元数据来实现。

            1. 让 |result| 是一个新的 {{GPUExternalTexture}} 对象包装 |data|。

            1. [=Queue a microtask=] 将 |result|.{{GPUExternalTexture/[[destroyed]]}} 设置为 `true`，并释放底层资源。

                Issue: 这是否过于严格？

            1. 返回 |result|.
        </div>
</dl>

<div class="example">
    <pre highlight="js">
        const externalTexture = gpuDevice.importExternalTexture({
            source: videoElement
        });
    </pre>
</div>

### 采样外部纹理 ### {#external-texture-sampling}

外部纹理在 WGSL 中用 `texture_external` 表示，可以使用 `textureLoad` 和 `textureSampleLevel`。

提供给 `textureSampleLevel` 的 `sampler` 用于对底层纹理进行采样。结果在 {{GPUExternalTextureDescriptor/colorSpace}} 设置的颜色空间中。对于任何给定的外部纹理，采样器（和过滤）是在从底层值转换到指定颜色空间之前还是之后应用，这取决于实现。

Note: 如果内部表示是 RGBA 平面，则采样的行为与常规 2D 纹理相同。如果有多个底层平面（例如 Y+UV），则在从 YUV 转换到指定颜色空间之前，使用采样器分别对每个底层纹理进行采样。


# 采样器 # {#samplers}

## <dfn interface>GPUSampler</dfn> ## {#sampler-interface}

一个 {{GPUSampler}} 对着色器中的变换和过滤信息进行编码，从而解析了纹理资源数据。

{{GPUSampler|GPUSamplers}} 通过 {{GPUDevice/createSampler(descriptor)|GPUDevice.createSampler(optional descriptor)}} 被创建，返回一个新的采样器对象。

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUSampler {
};
GPUSampler includes GPUObjectBase;
</script>

{{GPUSampler}} 有以下内部插槽:

<dl dfn-type=attribute dfn-for="GPUSampler">
    : <dfn>\[[descriptor]]</dfn>, of type {{GPUSamplerDescriptor}}, readonly
    ::
        用于创建 {{GPUSampler}} 的 {{GPUSamplerDescriptor}}。

    : <dfn>\[[isComparison]]</dfn> of type {{boolean}}.
    ::
        用于表示 {GPUSampler}} 是否被当作比较采样器。

    : <dfn>\[[isFiltering]]</dfn> of type {{boolean}}.
    ::
        用于表示 {{GPUSampler}} 是否对纹理的多个样本进行加权。
</dl>

## 采样器创建 ## {#sampler-creation}

### {{GPUSamplerDescriptor}} ### {#GPUSamplerDescriptor}

{{GPUSamplerDescriptor}} 指定用于创建 {{GPUSampler}} 的选项。

<script type=idl>
dictionary GPUSamplerDescriptor : GPUObjectDescriptorBase {
    GPUAddressMode addressModeU = "clamp-to-edge";
    GPUAddressMode addressModeV = "clamp-to-edge";
    GPUAddressMode addressModeW = "clamp-to-edge";
    GPUFilterMode magFilter = "nearest";
    GPUFilterMode minFilter = "nearest";
    GPUFilterMode mipmapFilter = "nearest";
    float lodMinClamp = 0;
    float lodMaxClamp = 32;
    GPUCompareFunction compare;
    [Clamp] unsigned short maxAnisotropy = 1;
};
</script>

- {{GPUSamplerDescriptor/addressModeU}}、{{GPUSamplerDescriptor/addressModeV}}，和 {{GPUSamplerDescriptor/addressModeW}} 分别指定纹理宽度、高度和深度坐标的地址模式。
- {{GPUSamplerDescriptor/magFilter}} 指定样本足迹小于或等于一个纹素时的采样行为。
- {{GPUSamplerDescriptor/minFilter}} 指定样本足迹大于一个纹素时的采样行为。
- {{GPUSamplerDescriptor/mipmapFilter}} 指定在两个 mipmap 层之间进行采样的行为。
- {{GPUSamplerDescriptor/lodMinClamp}} 和 {{GPUSamplerDescriptor/lodMaxClamp}} 分别指定了细节的最小层级和最大层级，对纹理进行采样时在内部使用。
- 如果提供了 {{GPUSamplerDescriptor/compare}}，则采样器将是具有指定 {{GPUCompareFunction}} 的比较采样器。
- {{GPUSamplerDescriptor/maxAnisotropy}} 指定采样器使用的最大各向异性值限制。

    Note: 大多数实现支持范围在 1 到 16 之间的 {{GPUSamplerDescriptor/maxAnisotropy}} 值，包括 1 和 16。

Issue: 解释 LOD 是如何计算的，以及平台之间是否存在差异。

Issue: 解释什么是各向异性采样。

{{GPUAddressMode}} 描述了采样器在采样足迹超出采样纹理边界时的行为。

Issue: 更详细地描述“样本足迹”。

<script type=idl>
enum GPUAddressMode {
    "clamp-to-edge",
    "repeat",
    "mirror-repeat",
};
</script>

<dl dfn-type="enum-value" dfn-for=GPUAddressMode>
    : <dfn>"clamp-to-edge"</dfn>
    ::
        纹理坐标被限制在 0.0 和 1.0 之间，包括 0.0 和 1.0。

    : <dfn>"repeat"</dfn>
    ::
        纹理坐标换行到纹理的另一侧。

    : <dfn>"mirror-repeat"</dfn>
    ::
        纹理坐标换行到纹理的另一侧，但当坐标的整数部分为奇数时，纹理会翻转。
</dl>

{{GPUFilterMode}} 描述了采样器在样本足迹与一个纹素不完全匹配时的行为。

<script type=idl>
enum GPUFilterMode {
    "nearest",
    "linear",
};
</script>

<dl dfn-type="enum-value" dfn-for=GPUFilterMode>
    : <dfn>"nearest"</dfn>
    ::
        返回最接近纹理坐标的纹素值。

    : <dfn>"linear"</dfn>
    ::
        在每个维度中选择两个纹素并返回它们值之间的线性插值。
</dl>

{{GPUCompareFunction}} 指定比较采样器的行为。如果在着色器中使用比较采样器，则将输入值与采样的纹理值进行比较，并将此比较测试的结果（0.0f表示通过，或1.0f表示失败）用于过滤操作。

Issue: 描述过滤如何与比较采样相互作用。

<script type=idl>
enum GPUCompareFunction {
    "never",
    "less",
    "equal",
    "less-equal",
    "greater",
    "not-equal",
    "greater-equal",
    "always",
};
</script>

<dl dfn-type="enum-value" dfn-for=GPUCompareFunction>
    : <dfn>"never"</dfn>
    ::
        从不通过比较测试。

    : <dfn>"less"</dfn>
    ::
        如果提供的值小于采样值，则通过比较测试。

    : <dfn>"equal"</dfn>
    ::
        如果提供的值等于采样值，则通过比较测试。

    : <dfn>"less-equal"</dfn>
    ::
        如果提供的值小于等于采样值，则通过比较测试。

    : <dfn>"greater"</dfn>
    ::
        如果提供的值大于采样值，则通过比较测试。
    : <dfn>"not-equal"</dfn>
    ::
        如果提供的值不等于采样值，则通过比较测试。

    : <dfn>"greater-equal"</dfn>
    ::
        如果提供的值大于等于采样值，则通过比较测试。

    : <dfn>"always"</dfn>
    ::
        永远通过比较测试。
</dl>

<div>
    <dfn abstract-op>validating GPUSamplerDescriptor</dfn>(device, descriptor)
    **参数:**
        - {{GPUDevice}} |device|
        - {{GPUSamplerDescriptor}} |descriptor|

    **返回:** {{boolean}}

    当且仅当满足下列条件时，返回 `true`：
        - |device| 是有效的。
        - |descriptor|.{{GPUSamplerDescriptor/lodMinClamp}} 大于等于 0.
        - |descriptor|.{{GPUSamplerDescriptor/lodMaxClamp}} 大于等于 |descriptor|.{{GPUSamplerDescriptor/lodMinClamp}}。
        - |descriptor|.{{GPUSamplerDescriptor/maxAnisotropy}} 大于等于 1。
        - 当 |descriptor|.{{GPUSamplerDescriptor/maxAnisotropy}} 大于 1 时，|descriptor|.{{GPUSamplerDescriptor/magFilter}}, |descriptor|.{{GPUSamplerDescriptor/minFilter}}，和 |descriptor|.{{GPUSamplerDescriptor/mipmapFilter}} 必须等于 {{GPUFilterMode/"linear"}}。
</div>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createSampler(descriptor)</dfn>
    ::
        创建一个 {{GPUBindGroupLayout}}。

        <div algorithm=GPUDevice.createSampler>
            **调用:** {{GPUDevice}} this.

            **参数:**
            <pre class=argumentdef for="GPUDevice/createSampler(descriptor)">
                |descriptor|: 要创建的 {{GPUSampler}} 的描述。
            </pre>

            **返回:** {{GPUSampler}}

            1. 使 |s| 为一个新的 {{GPUSampler}} 对象。
            2. 将| s|.{{GPUSampler/[[descriptor]]}} 设置为 |descriptor|.
            3. 如果 |s|.{{GPUSampler/[[descriptor]]}} 的 {{GPUSamplerDescriptor/compare}} 属性为 `null` 或者 undefined，将 |s|.{{GPUSampler/[[isComparison]]}} 设置为 `false`，否则，设置为 `true`。
            4. 如果 {{GPUSamplerDescriptor/minFilter}}，{{GPUSamplerDescriptor/magFilter}} 或 {{GPUSamplerDescriptor/mipmapFilter}} 中没有一个值为 {{GPUFilterMode/"linear"}}，则将 |s|.{{GPUSampler/[[isFiltering]]}} 设置为 `false`，否则，设置为 `true`。
            5. 返回 |s|。

            <div class=validusage dfn-for=GPUDevice.createSampler>
                <dfn abstract-op>有效使用</dfn>
                - 如果 |descriptor| 不是 `null`或 undefined：
                    - 如果 [$validating GPUSamplerDescriptor$](this, |descriptor|) 返回 `false`：
                        1. 在当前范围内生成一个 {{GPUValidationError}} 并带有恰当的错误消息。
                        2. 返回一个新的[=无效=] {{GPUSampler}} 并且返回结果。
            </div>
        </div>
</dl>

<div class="example">
    创建一个执行三线性过滤并重复纹理坐标的 {{GPUSampler}}：
    <pre highlight="js">
        const sampler = gpuDevice.createSampler({
            addressModeU: 'repeat',
            addressModeV: 'repeat',
            magFilter: 'linear',
            minFilter: 'linear',
            mipmapFilter: 'linear',
        });
    </pre>
</div>

# 资源绑定 # {#bindings}

## <dfn interface>GPUBindGroupLayout</dfn> ## {#bind-group-layout}

{{GPUBindGroupLayout}} 定义了一种接口，这种接口在 {{GPUBindGroup}} 中绑定了一组资源，并在着色器阶段的可被访问。

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUBindGroupLayout {
};
GPUBindGroupLayout includes GPUObjectBase;
</script>

{{GPUBindGroupLayout}} 有以下内部插槽:

<dl dfn-type=attribute dfn-for=GPUBindGroupLayout>
    : <dfn>\[[descriptor]]</dfn>
    ::
</dl>

### 创建 ### {#bind-group-layout-creation}

{{GPUBindGroupLayout}} 是通过 {{GPUDevice/createBindGroupLayout()|GPUDevice.createBindGroupLayout()}} 创建的。

<script type=idl>
dictionary GPUBindGroupLayoutDescriptor : GPUObjectDescriptorBase {
    required sequence<GPUBindGroupLayoutEntry> entries;
};
</script>

{{GPUBindGroupLayoutEntry}} 描述了要包含在 {{GPUBindGroupLayout}} 中的单个着色器资源绑定。

<script type=idl>
typedef [EnforceRange] unsigned long GPUShaderStageFlags;
[Exposed=(Window, DedicatedWorker)]
namespace GPUShaderStage {
    const GPUFlagsConstant VERTEX   = 0x1;
    const GPUFlagsConstant FRAGMENT = 0x2;
    const GPUFlagsConstant COMPUTE  = 0x4;
};

dictionary GPUBindGroupLayoutEntry {
    required GPUIndex32 binding;
    required GPUShaderStageFlags visibility;

    GPUBufferBindingLayout buffer;
    GPUSamplerBindingLayout sampler;
    GPUTextureBindingLayout texture;
    GPUStorageTextureBindingLayout storageTexture;
    GPUExternalTextureBindingLayout externalTexture;
};
</script>

{{GPUBindGroupLayoutEntry}} 词典有以下成员：

<dl dfn-type=dict-member dfn-for=GPUBindGroupLayoutEntry>
    : <dfn>binding</dfn>
    ::
        {{GPUBindGroupLayoutEntry}} 中资源绑定的唯一标识符、相应的 {{GPUBindGroupEntry}} 和 {{GPUShaderModule}}。

    : <dfn>visibility</dfn>
    ::
        {{GPUShaderStage}} 成员的比特集。
        每个设置位表示 {{GPUBindGroupLayoutEntry}} 的资源
        可以从关联的着色器阶段访问。

    : <dfn>buffer</dfn>
    ::
        当不是 `undefined` 时，表示这个 {{GPUBindGroupLayoutEntry}} 的 [=binding resource type=]
        是 {{GPUBufferBinding}}。

    : <dfn>sampler</dfn>
    ::
        当不是 `undefined` 时，表示这个 {{GPUBindGroupLayoutEntry}} 的 [=binding resource type=]
        是 {{GPUSampler}}。

    : <dfn>texture</dfn>
    ::
        当不是 `undefined` 时，表示这个 {{GPUBindGroupLayoutEntry}} 的 [=binding resource type=]
        是 {{GPUTextureView}}。

    : <dfn>storageTexture</dfn>
    ::
        当不是 `undefined` 时，表示这个 {{GPUBindGroupLayoutEntry}} 的 [=binding resource type=]
        是 {{GPUTextureView}}。

    : <dfn>externalTexture</dfn>
    ::
        当不是 `undefined` 时，表示这个 {{GPUBindGroupLayoutEntry}} 的 [=binding resource type=]
        是 {{GPUExternalTexture}}。
</dl>

{{GPUBindGroupLayoutEntry}} 的[=绑定成员=]由被定义了的 {{GPUBindGroupLayoutEntry}} 成员决定：{{GPUBindGroupLayoutEntry/buffer}}、{{GPUBindGroupLayoutEntry/sampler}}、
{{GPUBindGroupLayoutEntry/texture}}、{{GPUBindGroupLayoutEntry/storageTexture}} 或
{{GPUBindGroupLayoutEntry/externalTexture}}。对于任何给定的 {{GPUBindGroupLayoutEntry}}，只能定义一个绑定成员。
每个成员都有一个关联的 {{GPUBindingResource}} 类型，每个[=绑定类型=]都有一个关联的[=内部使用=]，如下表所示：

<table class="data" style="white-space: nowrap">
    <thead>
        <tr>
            <th><dfn dfn>绑定成员</dfn>
            <th><dfn dfn lt="资源绑定类型">资源类型</dfn>
            <th><dfn dfn>绑定类型</dfn><br>
            <th><dfn dfn>绑定使用</dfn>
    </thead>
    <tr>
        <td rowspan=3>{{GPUBindGroupLayoutEntry/buffer}}
        <td rowspan=3>{{GPUBufferBinding}}
        <td>{{GPUBufferBindingType/"uniform"}}
        <td>[=internal usage/常量=]
    <tr>
        <td>{{GPUBufferBindingType/"storage"}}
        <td>[=internal usage/存储=]
    <tr>
        <td>{{GPUBufferBindingType/"read-only-storage"}}
        <td>[=internal usage/只读存储=]

    <tr>
        <td rowspan=3>{{GPUBindGroupLayoutEntry/sampler}}
        <td rowspan=3>{{GPUSampler}}
        <td>{{GPUSamplerBindingType/"filtering"}}
        <td rowspan=3>[=internal usage/常量=]
    <tr>
        <td>{{GPUSamplerBindingType/"non-filtering"}}
    <tr>
        <td>{{GPUSamplerBindingType/"comparison"}}

    <tr>
        <td rowspan=5>{{GPUBindGroupLayoutEntry/texture}}
        <td rowspan=5>{{GPUTextureView}}
        <td>{{GPUTextureSampleType/"float"}}
        <td rowspan=5>[=internal usage/常量=]
    <tr>
        <td>{{GPUTextureSampleType/"unfilterable-float"}}
    <tr>
        <td>{{GPUTextureSampleType/"depth"}}
    <tr>
        <td>{{GPUTextureSampleType/"sint"}}
    <tr>
        <td>{{GPUTextureSampleType/"uint"}}

    <tr>
        <td>{{GPUBindGroupLayoutEntry/storageTexture}}
        <td>{{GPUTextureView}}
        <td>{{GPUStorageTextureAccess/"write-only"}}
        <td>[=internal usage/存储=]

    <tr>
        <td>{{GPUBindGroupLayoutEntry/externalTexture}}
        <td>{{GPUExternalTexture}}
        <td>
        <td>[=internal usage/常量=]
</table>

<div algorithm>
    如果用于一个限制的插槽数超过|限制|中支持的值，{{GPUBindGroupLayoutEntry}} 值的|条目|[=列表=]<dfn>超出绑定槽限制</dfn>， 这些绑定槽限制来自于[=支持的限制=]的|限制|。每个条目可以使用多个槽来实现多个限制。

    1. 对于每个在|条目|中的 |entry| , 如果:
        <dl class=switch>
            : |entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/type}} 是 {{GPUBufferBindingType/"uniform"}}，并且 |entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/hasDynamicOffset}} 是 `true`
            ::  1 个 {{supported limits/maxDynamicUniformBuffersPerPipelineLayout}} 槽会被使用。
            : |entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/type}} 是 {{GPUBufferBindingType/"storage"}}，并且 |entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/hasDynamicOffset}} 是 `true`
            ::  1 个 {{supported limits/maxDynamicStorageBuffersPerPipelineLayout}} 槽会被使用。
        </dl>
    1. 对于在 &laquo; {{GPUShaderStage/VERTEX}}, {{GPUShaderStage/FRAGMENT}}, {{GPUShaderStage/COMPUTE}} &raquo; 中的每个着色器阶段 |stage|:
        1. 对于每个在|条目| 中的 |entry|，并且 |entry|.{{GPUBindGroupLayoutEntry/visibility}} 中包含了 |stage|, 如果:
            <dl class=switch>
                : |entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/type}} 是 {{GPUBufferBindingType/"uniform"}}
                ::  1 个 {{supported limits/maxUniformBuffersPerShaderStage}} 槽会被使用。
                : |entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/type}} 是 {{GPUBufferBindingType/"storage"}} 或者 {{GPUBufferBindingType/"read-only-storage"}}
                ::  1 个 {{supported limits/maxStorageBuffersPerShaderStage}} 槽会被使用。
                : |entry|.{{GPUBindGroupLayoutEntry/sampler}} 不是 `未定义`
                ::  1 个 {{supported limits/maxSamplersPerShaderStage}} 槽会被使用。
                : |entry|.{{GPUBindGroupLayoutEntry/texture}} 不是 `未定义`
                ::  1 个 {{supported limits/maxSampledTexturesPerShaderStage}} 槽会被使用。
                : |entry|.{{GPUBindGroupLayoutEntry/storageTexture}} 不是 `未定义`
                ::  1 个 {{supported limits/maxStorageTexturesPerShaderStage}} 槽会被使用。
                : |entry|.{{GPUBindGroupLayoutEntry/externalTexture}} 不是 `未定义`
                ::
                    4 个 {{supported limits/maxSampledTexturesPerShaderStage}} 槽，1 个 {{supported limits/maxSamplersPerShaderStage}} 槽， 和 1 个 {{supported limits/maxUniformBuffersPerShaderStage}} 槽会被使用。
            </dl>
</div>

<script type=idl>
enum GPUBufferBindingType {
    "uniform",
    "storage",
    "read-only-storage",
};

dictionary GPUBufferBindingLayout {
    GPUBufferBindingType type = "uniform";
    boolean hasDynamicOffset = false;
    GPUSize64 minBindingSize = 0;
};
</script>

{{GPUBufferBindingLayout}} 词典有以下成员:

<dl dfn-type=dict-member dfn-for=GPUBufferBindingLayout>
    : <dfn>type</dfn>
    ::
        指示绑定到此绑定的缓冲区所需的类型。

    : <dfn>hasDynamicOffset</dfn>
    ::
        指示此绑定是否需要动态偏移量。

    : <dfn>minBindingSize</dfn>
    ::
        指示最小缓冲区绑定大小。

        绑定始终在 {{GPUDevice/createBindGroup()}} 中针对此大小进行验证。

        如果该值* 不是 * `0`，则需要额外创建管线来[$validating shader binding|验证$]这个值对于着色器中声明的绑定足够大。

        如果该值* 是 * `0`，则需要另外绘制/调度指令来[$Validate encoder bind groups|验证$] {{GPUBindGroup}} 中的每个绑定对于着色器中声明的绑定都足够大。

        Note: 对于为早期验证指定的其他绑定相关字段，类似的执行时间验证在理论上是可能的，例如目前只能在管线创建中进行验证的 {{GPUTextureBindingLayout/sampleType}} 和 {{GPUStorageTextureBindingLayout/format}}。然而，这种执行时间验证可能成本高昂或不必要的复杂，因此仅适用于具有最符合人体工程学影响的 {{GPUBufferBindingLayout/minBindingSize}}。
</dl>

<script type=idl>
enum GPUSamplerBindingType {
    "filtering",
    "non-filtering",
    "comparison",
};

dictionary GPUTextureBindingLayout {
    GPUTextureSampleType sampleType = "float";
    GPUTextureViewDimension viewDimension = "2d";
    boolean multisampled = false;
};
</script>

Issue(https://github.com/gpuweb/gpuweb/issues/851): 考虑使 {{GPUTextureBindingLayout/sampleType}} 真正可选。

{{GPUTextureBindingLayout}} 词典有以下成员:

<dl dfn-type=dict-member dfn-for=GPUTextureBindingLayout>
    : <dfn>sampleType</dfn>
    ::
        指示绑定到此绑定的纹理视图所需的类型。
    : <dfn>viewDimension</dfn>
    ::
        指示绑定到此绑定的纹理视图所需的 {{GPUTextureViewDescriptor/dimension}}。
        <!-- https://github.com/gpuweb/gpuweb/pull/339 -->

    : <dfn>multisampled</dfn>
    ::
        指示绑定到此绑定的纹理视图是否必须进行多重采样。
</dl>

<script type=idl>
enum GPUTextureSampleType {
  "float",
  "unfilterable-float",
  "depth",
  "sint",
  "uint",
};

dictionary GPUTextureBindingLayout {
    GPUTextureSampleType sampleType = "float";
    GPUTextureViewDimension viewDimension = "2d";
    boolean multisampled = false;
};
</script>

问题(https://github.com/gpuweb/gpuweb/issues/851): 如何使 {{GPUTextureBindingLayout/sampleType}} 真正可选。

{{GPUTextureBindingLayout}} 词典有以下成员:

<dl dfn-type=dict-member dfn-for=GPUTextureBindingLayout>
    : <dfn>sampleType</dfn>
    ::
        指示绑定到此绑定的纹理视图所需的类型。
    : <dfn>viewDimension</dfn>
    ::
        指示绑定到此绑定的纹理视图所需的 {{GPUTextureViewDescriptor/dimension}}。
        <!-- https://github.com/gpuweb/gpuweb/pull/339 -->

    : <dfn>multisampled</dfn>
    ::
        指示绑定到此绑定的纹理视图是否必须进行多重采样。
</dl>

<script type=idl>
enum GPUStorageTextureAccess {
    "write-only",
};

dictionary GPUStorageTextureBindingLayout {
    GPUStorageTextureAccess access = "write-only";
    required GPUTextureFormat format;
    GPUTextureViewDimension viewDimension = "2d";
};
</script>

Issue(https://github.com/gpuweb/gpuweb/issues/851): 考虑时 {{GPUStorageTextureBindingLayout/format}} 真正可选。

{{GPUStorageTextureBindingLayout}} 词典有以下成员:

<dl dfn-type=dict-member dfn-for=GPUStorageTextureBindingLayout>
    : <dfn>access</dfn>
    ::
        指示绑定到此绑定的纹理视图是否将绑定为只读或只写访问。
    : <dfn>format</dfn>
    ::
        绑定到此绑定的纹理视图所需的 {{GPUTextureViewDescriptor/format}}。
    : <dfn>viewDimension</dfn>
    ::
        指示绑定到此绑定的纹理视图所需的 {{GPUTextureViewDescriptor/dimension}}。
        <!-- https://github.com/gpuweb/gpuweb/pull/339 -->
</dl>

<script type=idl>
dictionary GPUExternalTextureBindingLayout {
};
</script>

{{GPUBindGroupLayout}} 对象有以下内部插槽:

<dl dfn-type=attribute dfn-for="GPUBindGroupLayout">
    : <dfn>\[[entryMap]]</dfn> of type [=ordered map=]&lt;{{GPUSize32}}, {{GPUBindGroupLayoutEntry}}&gt.
    ::
        指向 {{GPUBindGroupLayoutEntry}} 的绑定索引映射，此 {{GPUBindGroupLayout}} 描述了该映射。

    : <dfn>\[[dynamicOffsetCount]]</dfn> of type {{GPUSize32}}.
    ::
        此 {{GPUBindGroupLayout}} 中具有动态偏移量的缓冲区绑定数。
    : <dfn>\[[exclusivePipeline]]</dfn> of type {{GPUPipelineBase}}?, initially `null`.
    ::
        创建此 {{GPUBindGroupLayout}} 的管道，如果该管道是作为 [[#default-pipeline-layout|default pipeline layout]] 的一部分创建的。
        如果不是 `null`，则使用此 {{GPUBindGroupLayout}} 创建的 {{GPUBindGroup}} 只能与指定的 {{GPUPipelineBase}} 一起使用。
</dl>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createBindGroupLayout(descriptor)</dfn>
    ::
        创建一个 {{GPUBindGroupLayout}}。

        <div algorithm=GPUDevice.createBindGroupLayout>
            **调用:** {{GPUDevice}} |this|.

            **参数:**
            <pre class=argumentdef for="GPUDevice/createBindGroupLayout(descriptor)">
                |descriptor|: 要创建的 {{GPUBindGroupLayout}} 的描述。
            </pre>

            **返回:** {{GPUBindGroupLayout}}

            1. 让 |layout| 是一个新的有效的 {{GPUBindGroupLayout}} 对象。
            1. 设置 |layout|.{{GPUBindGroupLayout/[[descriptor]]}} 为 |descriptor|.
            1. 在 |this| 的[=设备时间线=]上发出以下步骤:
                <div class=device-timeline>
                    1. 如果一下任一条件没有被满足:
                        <div class=validusage>
                            - |this| 是一个[=有效=] {{GPUDevice}}.
                            - 在 |descriptor| 中每一个条目的 {{GPUBindGroupLayoutEntry/binding}} 是唯一的。
                            - |descriptor| 中每个条目的 {{GPUBindGroupLayoutEntry/binding}} 必须 < 65536。
                            - |descriptor|.{{GPUBindGroupLayoutDescriptor/entries}} 必须不能
                                [=超过绑定槽限制=]，该绑定槽限制为 |this|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}。
                            - |descriptor|.{{GPUBindGroupLayoutDescriptor/entries}} 中每一个条目的 {{GPUBindGroupLayoutEntry}}:
                                - 设定 |bufferLayout| 为 |entry|.{{GPUBindGroupLayoutEntry/buffer}}
                                - 设定 |samplerLayout| 为 |entry|.{{GPUBindGroupLayoutEntry/sampler}}
                                - 设定 |textureLayout| 为 |entry|.{{GPUBindGroupLayoutEntry/texture}}
                                - 设定 |storageTextureLayout| 为 |entry|.{{GPUBindGroupLayoutEntry/storageTexture}}

                                - |bufferLayout|，|samplerLayout|，|textureLayout|，或 |storageTextureLayout| 其中的一个不是`未定义`的。

                                - 如果 |entry|.{{GPUBindGroupLayoutEntry/visibility}} 中包含 {{GPUShaderStage/VERTEX}}:
                                    - |entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/type}} 必须不能是 {{GPUBufferBindingType/"storage"}}.
                                    - |entry|.{{GPUBindGroupLayoutEntry/storageTexture}}?.{{GPUStorageTextureBindingLayout/access}} 必须不能是 {{GPUStorageTextureAccess/"write-only"}}.

                                - 如果 |textureLayout| 不是`未定义`的，并且 |textureLayout|.{{GPUTextureBindingLayout/multisampled}} 是 `true`:
                                    - |textureLayout|.{{GPUTextureBindingLayout/viewDimension}} 是 {{GPUTextureViewDimension/"2d"}}.
                                    - |textureLayout|.{{GPUTextureBindingLayout/sampleType}} 不是 {{GPUTextureSampleType/"float"}} 或者 {{GPUTextureSampleType/"depth"}}.

                                - 如果 |storageTextureLayout| 不是`未定义`的:
                                    - |storageTextureLayout|.{{GPUStorageTextureBindingLayout/viewDimension}} 不是 {{GPUTextureViewDimension/"cube"}} 或 {{GPUTextureViewDimension/"cube-array"}}.
                                    - |storageTextureLayout|.{{GPUStorageTextureBindingLayout/format}} 必须是可以支持存储使用的格式。
                        </div>

                        然后:
                            1. 在当前范围内生成带有适当错误消息的 {{GPUValidationError}}。
                            1. 使 |layout| [=无效=]，并且返回 |layout|。

                    1. 设置 |layout|.{{GPUBindGroupLayout/[[dynamicOffsetCount]]}} 为 |descriptor| 中条目的个数，同时 {{GPUBindGroupLayoutEntry/buffer}} 不是`未定义`，并且 {{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/hasDynamicOffset}} 是 `true`.
                    1. 针对在 |descriptor|.{{GPUBindGroupLayoutDescriptor/entries}} 中的每个 {{GPUBindGroupLayoutEntry}} |entry|
                        :
                        1. 插入 |entry| 和 |entry|.{{GPUBindGroupLayoutEntry/binding}} 的密匙到 |layout|.{{GPUBindGroupLayout/[[entryMap]]}}.
                </div>
            1. 返回 |layout|.

        </div>
</dl>

### 兼容性 ### {#bind-group-compatibility}

<div algorithm>
两个 {{GPUBindGroupLayout}} 对象 |a| 和 |b| 是 <dfn dfn>组等效的</dfn>
当且仅当满足以下所有条件：
    - |a|.{{GPUBindGroupLayout/[[exclusivePipeline]]}} == |b|.{{GPUBindGroupLayout/[[exclusivePipeline]]}}.
    - 对于任何绑定编号 |binding|，满足以下条件之一：
        - 编号在 |a|.{{GPUBindGroupLayout/[[entryMap]]}} 和 |b|.{{GPUBindGroupLayout/[[entryMap]]}} 中都丢失了。
        - |a|.{{GPUBindGroupLayout/[[entryMap]]}}[|binding|] == |b|.{{GPUBindGroupLayout/[[entryMap]]}}[|binding|]
</div>

如果绑定组布局是[=组等效的=]，则可以在所有内容中被互换使用。

## <dfn interface>GPUBindGroup</dfn> ## {#gpu-bind-group}

{{GPUBindGroup}} 定义了一组要绑定到一起使用的资源，并定义了如何在着色器阶段使用这些资源。

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUBindGroup {
};
GPUBindGroup includes GPUObjectBase;
</script>

### 绑定组创建 ### {#bind-group-creation}

一个 {{GPUBindGroup}} 通过 {{GPUDevice/createBindGroup()|GPUDevice.createBindGroup()}} 被创建。

<script type=idl>
dictionary GPUBindGroupDescriptor : GPUObjectDescriptorBase {
    required GPUBindGroupLayout layout;
    required sequence<GPUBindGroupEntry> entries;
};
</script>

{{GPUBindGroupEntry}} 描述了要绑定在 {{GPUBindGroup}} 中的单个资源。

<script type=idl>
typedef (GPUSampler or GPUTextureView or GPUBufferBinding or GPUExternalTexture) GPUBindingResource;

dictionary GPUBindGroupEntry {
    required GPUIndex32 binding;
    required GPUBindingResource resource;
};
</script>

<script type=idl>
dictionary GPUBufferBinding {
    required GPUBuffer buffer;
    GPUSize64 offset = 0;
    GPUSize64 size;
};
</script>

  * {{GPUBufferBinding/size}}: 如果未定义，则指定一个范围，从 {{GPUBufferBinding/offset}} 开始并在缓冲区末尾结束。

一个 {{GPUBindGroup}} 对象有以下内部插槽:

<dl dfn-type=attribute dfn-for="GPUBindGroup">
    : <dfn>\[[layout]]</dfn> of type {{GPUBindGroupLayout}}.
    ::
        与此 {{GPUBindGroup}} 关联的 {{GPUBindGroupLayout}}。

    : <dfn>\[[entries]]</dfn> of type sequence<{{GPUBindGroupEntry}}>.
    ::
        此 {{GPUBindGroup}} 描述的 {{GPUBindGroupEntry}} 集。

    : <dfn>\[[usedResources]]</dfn> of type [=ordered map=]&lt;[=subresource=], [=list=]&lt;[=internal usage=]&gt;&gt;.
    ::
        此绑定组使用的缓冲区和纹理集[=子资源=]，与[=内部使用=]标志的列表相关联。
</dl>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createBindGroup(descriptor)</dfn>
    ::
        创建一个 {{GPUBindGroup}}.

        <div algorithm=GPUDevice.createBindGroup>
            **调用:** {{GPUDevice}} |this|.

            **参数:**
            <pre class=argumentdef for="GPUDevice/createBindGroup(descriptor)">
                |descriptor|: 要创建的 {{GPUBindGroup}} 的描述。
            </pre>

            **返回:** {{GPUBindGroup}}

            1. 设定 |bindGroup| 为一个新的有效的 {{GPUBindGroup}} 对象。
            1. 设定 |limits| 为 |this|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}。
            1. 在 |this| 的[=设备时间线=]发布一下步骤:
                <div class=device-timeline>
                    1. 如果以下任一条件没有被满足：
                        <div class=validusage>
                            - |descriptor|.{{GPUBindGroupDescriptor/layout}} 可以与 |this| [$一起有效被使用$]。
                            - |descriptor|.{{GPUBindGroupDescriptor/layout}} 的 {{GPUBindGroupLayoutDescriptor/entries}} 的数量和 |descriptor|.{{GPUBindGroupDescriptor/entries}} 的数量完全相等。

                            对于每一个 |descriptor|.{{GPUBindGroupDescriptor/entries}} 中的 {{GPUBindGroupEntry}} |bindingDescriptor|:
                                - 设定 |resource| 为 |bindingDescriptor|.{{GPUBindGroupEntry/resource}}。
                                - 在 |descriptor|.{{GPUBindGroupDescriptor/layout}}.{{GPUBindGroupLayoutDescriptor/entries}} 中，只有一个 {{GPUBindGroupLayoutEntry}} |layoutBinding|，使得 |layoutBinding|.{{GPUBindGroupLayoutEntry/binding}} 等于 |bindingDescriptor|.{{GPUBindGroupEntry/binding}}。

                                - 如果为 |layoutBinding| 定义的[=绑定成员=]是
                                    <dl class="switch">
                                        : {{GPUBindGroupLayoutEntry/sampler}}
                                        ::
                                            - |resource| 是一个 {{GPUSampler}}.
                                            - |resource| 可以与 |this| [$一起有效被使用$]。
                                            - 如果 |layoutBinding|.{{GPUBindGroupLayoutEntry/sampler}}.{{GPUSamplerBindingLayout/type}} 是:
                                                <dl class="switch">
                                                    : {{GPUSamplerBindingType/"filtering"}}
                                                    :: |resource|.{{GPUSampler/[[isComparison]]}} 是 `false`.

                                                    : {{GPUSamplerBindingType/"non-filtering"}}
                                                    ::
                                                        |resource|.{{GPUSampler/[[isFiltering]]}} 是 `false`.
                                                        |resource|.{{GPUSampler/[[isComparison]]}} 是 `false`.

                                                    : {{GPUSamplerBindingType/"comparison"}}
                                                    :: |resource|.{{GPUSampler/[[isComparison]]}} 是 `true`.
                                                </dl>

                                        : {{GPUBindGroupLayoutEntry/texture}}
                                        ::
                                            - |resource| 是一个 {{GPUTextureView}}。
                                            - |resource| 可以与 |this| [$一起有效被使用$]。
                                            - 设置 |texture| 为 |resource|.{{GPUTextureView/[[texture]]}}.
                                            - |layoutBinding|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/viewDimension}} 与 |resource| 的 {{GPUTextureViewDescriptor/dimension}} 相等。
                                            - |layoutBinding|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/sampleType}} 是与 |resource| 的 {{GPUTextureViewDescriptor/format}} [[#texture-format-caps|兼容的]]。
                                            - |texture| 的 {{GPUTextureDescriptor/usage}} 包含 {{GPUTextureUsage/TEXTURE_BINDING}}.
                                            - 如果 |layoutBinding|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/multisampled}} 是 `true`, |texture| 的 {{GPUTextureDescriptor/sampleCount}} &gt; `1`, 否则 |texture| 的 {{GPUTextureDescriptor/sampleCount}} 为 `1`.

                                        : {{GPUBindGroupLayoutEntry/storageTexture}}
                                        ::
                                            - |resource| 是一个 {{GPUTextureView}}。
                                            - |resource| 可以与 |this| [$一起有效被使用$]。
                                            - 设置 |texture| 为 |resource|.{{GPUTextureView/[[texture]]}}.
                                            - |layoutBinding|.{{GPUBindGroupLayoutEntry/storageTexture}}.{{GPUStorageTextureBindingLayout/viewDimension}} 与 |resource| 的 {{GPUTextureViewDescriptor/dimension}} 相等。
                                            - |layoutBinding|.{{GPUBindGroupLayoutEntry/storageTexture}}.{{GPUStorageTextureBindingLayout/format}} 与 |resource|.{{GPUTextureView/[[descriptor]]}}.{{GPUTextureViewDescriptor/format}} 相等。
                                            - |texture| 的 {{GPUTextureDescriptor/usage}} 包含 {{GPUTextureUsage/STORAGE_BINDING}}。
                                            - |resource|.{{GPUTextureView/[[descriptor]]}}.{{GPUTextureViewDescriptor/mipLevelCount}} 必须为 1。

                                        :  {{GPUBindGroupLayoutEntry/buffer}}
                                        ::
                                            - |resource| 是一个 {{GPUBufferBinding}}.
                                            - |resource|.{{GPUBufferBinding/buffer}} 可以与 |this| [$一起有效被使用$]。
                                            - |resource|.{{GPUBufferBinding/offset}} 指定的绑定部分和 |resource|.{{GPUBufferBinding/size}} 驻留在缓冲区内，并且具有非零值。
                                            - [$有效的缓冲区绑定大小$](|resource|)，大于或等于 |layoutBinding|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/minBindingSize}}.

                                            - 如果 |layoutBinding|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/type}} 是
                                                <dl class="switch">
                                                    : {{GPUBufferBindingType/"uniform"}}
                                                    :: |resource|.{{GPUBufferBinding/buffer}}.{{GPUBufferDescriptor/usage}} 包含 {{GPUBufferUsage/UNIFORM}}。
                                                    :: [$有效的缓冲区绑定大小$](|resource|) &le; |limits|.{{supported limits/maxUniformBufferBindingSize}}。
                                                    :: |resource|.{{GPUBufferBinding/offset}} 是 |limits|.{{supported limits/minUniformBufferOffsetAlignment}} 的倍数。
                                                    : {{GPUBufferBindingType/"storage"}} 或者 {{GPUBufferBindingType/"read-only-storage"}}
                                                    :: |resource|.{{GPUBufferBinding/buffer}}.{{GPUBufferDescriptor/usage}} 包含 {{GPUBufferUsage/STORAGE}}。
                                                    :: [$有效的缓冲区绑定大小$](|resource|) &le; |limits|.{{supported limits/maxStorageBufferBindingSize}}.
                                                    :: |resource|.{{GPUBufferBinding/offset}} 是 |limits|.{{supported limits/minStorageBufferOffsetAlignment}} 的倍数。
                                                    :  {{GPUBindGroupLayoutEntry/externalTexture}}
                                                    ::
                                                        - |resource| 是一个 {{GPUExternalTexture}}.
                                                        - |resource| 可以与 |this| [$一起有效被使用$]。
                                                </dl>

                                    </dl>

                        </div>

                        然后:
                            1. 在当前范围内生成带有适当错误消息的 {{GPUValidationError}}。
                            1. 使 |bindGroup| [=无效=]，并返回 |bindGroup|.

                    1. 设置 |bindGroup|.{{GPUBindGroup/[[layout]]}} = |descriptor|.{{GPUBindGroupDescriptor/layout}}.
                    1. 设置 |bindGroup|.{{GPUBindGroup/[[entries]]}} = |descriptor|.{{GPUBindGroupDescriptor/entries}}.
                    1. 设置 |bindGroup|.{{GPUBindGroup/[[usedResources]]}} = {}.

                    1. 针对在 |descriptor|.{{GPUBindGroupDescriptor/entries}} 中的每一个 {{GPUBindGroupEntry}} |bindingDescriptor|:
                        1. 设定 |internalUsage| 为 |layoutBinding| 的[=绑定使用=]。
                        1. |resource| 中看到的每个[=子资源=]，被作为 |internalUsage| 添加到 {{GPUBindGroup/[[usedResources]]}} 。
                </div>
            1. 返回 |bindGroup|.

        </div>
</dl>

<div algorithm>
    <dfn abstract-op>有效的缓冲区绑定大小</dfn>(binding)
        1. 如果 |binding|.{{GPUBufferBinding/size}} 为`未定义`:
            1. 返回 max(0, |binding|.{{GPUBufferBinding/buffer}}.{{GPUBuffer/[[size]]}} - |binding|.{{GPUBufferBinding/offset}});
        1. 返回 |binding|.{{GPUBufferBinding/size}}.
</div>

<div algorithm>
    当且仅当以下条件为真，两个 {{GPUBufferBinding}} 对象 |a| 和 |b| 被作为 <dfn dfn>缓冲区-绑定-混叠</dfn>：

    - |a|.{{GPUBufferBinding/buffer}} == |b|.{{GPUBufferBinding/buffer}}
    - |a|.{{GPUBufferBinding/offset}} 和 |a|.{{GPUBufferBinding/size}} 构成的区间与 |b|.{{GPUBufferBinding/offset}} 和 |b|.{{GPUBufferBinding/size}} 构成的区间相交。

    Issue: 定义如果大小可以为未定义时，区间如何被 offset/size 构成。
</div>

## <dfn interface>GPUPipelineLayout</dfn> ## {#pipeline-layout}

{{GPUPipelineLayout}} 定义了在 {{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)|setBindGroup}} 的指令编码期间，设置的所有 {{GPUBindGroup}} 对象的资源，与由 {{GPURenderEncoderBase/setPipeline(pipeline)|GPURenderEncoderBase.setPipeline}} 或 {{GPUComputePassEncoder/setPipeline(pipeline)|GPUComputePassEncoder.setPipeline}} 设置的管道着色器之间的映射。

资源的完整绑定地址可以定义为以下三项：
   1. 着色器阶段蒙版，资源可见
   2. 绑定组索引
   3. 绑定号码

这个地址的组成部分也可以看作是一个管道的绑定空间。 {{GPUBindGroup}}（带有相应的 {{GPUBindGroupLayout}}）覆盖了固定绑定组索引的空间。 包含的绑定需要是着色器在此绑定组索引处使用的资源的超集。

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUPipelineLayout {
};
GPUPipelineLayout includes GPUObjectBase;
</script>

{{GPUPipelineLayout}} 有以下内部插槽：

<dl dfn-type=attribute dfn-for="GPUPipelineLayout">
    : <dfn>\[[bindGroupLayouts]]</dfn> of type [=list=]&lt;{{GPUBindGroupLayout}}&gt;.
    ::
        在 {{GPUPipelineLayoutDescriptor/bindGroupLayouts|GPUPipelineLayoutDescriptor.bindGroupLayouts}} 中创建时提供的 {{GPUBindGroupLayout}} 对象。
</dl>

Note: 对许多 {{GPURenderPipeline}} 或 {{GPUComputePipeline}} 管道使用相同的 {{GPUPipelineLayout}} 可以保证用户代理在这些管道之间切换时不需要在内部重新绑定任何资源。

<div class="example">
{{GPUComputePipeline}} 对象 X 是由 {{GPUPipelineLayout/[[bindGroupLayouts]]|GPUPipelineLayout.bindGroupLayouts}} A, B, C 创建。
{{GPUComputePipeline}} 对象 Y 是由 {{GPUPipelineLayout/[[bindGroupLayouts]]|GPUPipelineLayout.bindGroupLayouts}} A, D, C 创建。
假设指令编码序列有两个调度：

  1. {{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)|setBindGroup(0, ...)}}
  1. {{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)|setBindGroup(1, ...)}}
  1. {{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)|setBindGroup(2, ...)}}
  1. {{GPUComputePassEncoder/setPipeline(pipeline)|setPipeline(X)}}
  1. {{GPUComputePassEncoder/dispatch(x, y, z)|dispatch()}}
  1. {{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)|setBindGroup(1, ...)}}
  1. {{GPUComputePassEncoder/setPipeline(pipeline)|setPipeline(Y)}}
  1. {{GPUComputePassEncoder/dispatch(x, y, z)|dispatch()}}

在这种场景下，用户代理将不得不重新绑定组插槽 2 以进行第二次调度，即使 {{GPUBindGroupLayout}} 在 {{GPUPipelineLayout/[[bindGroupLayouts]]|GPUPipelineLayout.bindGrouplayouts}} 的索引 2 处，或 {{GPUBindGroup}} 插槽 2 处都没有被更改。
</div>

Issue: 是否应将此示例和注释移至某些“最佳实践”文档？

Note: {{GPUPipelineLayout}} 的预期用途是将最常见和最不频繁更改的绑定组放置在布局的“底部”，这意味着较低的绑定组插槽编号，例如 0 或 1。绑定频繁的组需要在绘制调用之间改变，其索引应该越高。这个通用指南允许用户代理最小化绘制调用之间的状态变化，从而降低 CPU 开销。

### 创建 ### {#pipeline-layout-creation}

{{GPUPipelineLayout}} 是通过 {GPUDevice/createPipelineLayout()|GPUDevice.createPipelineLayout()}} 创建的。

<script type=idl>
dictionary GPUPipelineLayoutDescriptor : GPUObjectDescriptorBase {
    required sequence<GPUBindGroupLayout> bindGroupLayouts;
};
</script>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createPipelineLayout(descriptor)</dfn>
    ::
        创建一个 {{GPUPipelineLayout}}。

        <div algorithm=GPUDevice.createPipelineLayout>
            **调用:** {{GPUDevice}} |this|。

            **参数:**
            <pre class=argumentdef for="GPUDevice/createPipelineLayout(descriptor)">
                |descriptor|: 要创建的 {{GPUPipelineLayout}} 的描述。
            </pre>

            **返回:** {{GPUPipelineLayout}}

            1. 如果以下任一条件为满足：
                <div class=validusage>
                    设定 |limits| 为 |this|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}。

                    设定 |allEntries| 是连接 |descriptor|.{{GPUPipelineLayoutDescriptor/bindGroupLayouts}} 中所有 |bgl| 的 |bgl|.{{GPUBindGroupLayout/[[descriptor]]}}.{{GPUBindGroupLayoutDescriptor/entries}} 的结果。

                    - |descriptor|.{{GPUPipelineLayoutDescriptor/bindGroupLayouts}} 中的每个 {{GPUBindGroupLayout}} 必须与 |this| [$一起有效被使用$]，并且拥有一个为 `null` 的 {{GPUBindGroupLayout/[[exclusivePipeline]]}}。
                    - |descriptor|.{{GPUPipelineLayoutDescriptor/bindGroupLayouts}} 的[=list/大小=]必须 &le; |limits|.{{supported limits/maxBindGroups}}。
                    - |allEntries| 必须不能[=超过绑定槽限制=]，该绑定槽限制为 |limits|。
                </div>

                然后:
                    1. 在当前范围内生成带有适当错误消息的 {{GPUValidationError}}。
                    1. 创建一个新的[=无效=]的 {{GPUPipelineLayout}} 并返回结果。

            1. 设定 |pl| 为一个新的 {{GPUPipelineLayout}} 对象。
            1. 设定 |pl|.{{GPUPipelineLayout/[[bindGroupLayouts]]}} 为 |descriptor|.{{GPUPipelineLayoutDescriptor/bindGroupLayouts}}。
            1. 返回 |pl|。
        </div>
</dl>

Note: 如果两个 {{GPUPipelineLayout}} 对象的内部 {{GPUPipelineLayout/[[bindGroupLayouts]]}} 序列包含的 {{GPUBindGroupLayout}} 对象是[=组等效的=]，那么这两个 {{GPUPipelineLayout}} 对象对于任何用法都被认为是等效的。

## Example ## {#bindgroup-examples}

<div class="example">
    创建一个描述uniform buffer捆绑，纹理，采样器的 {{GPUBindGroupLayout}}，之后使用 {{GPUBindGroupLayout}} 创建 {{GPUBindGroup}} 和 {{GPUPipelineLayout}}。
    <pre highlight="js">
        const bindGroupLayout = gpuDevice.createBindGroupLayout({
            entries: [{
                binding: 0,
                visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
                buffer: {}
            }, {
                binding: 1,
                visibility: GPUShaderStage.FRAGMENT,
                texture: {}
            }, {
                binding: 2,
                visibility: GPUShaderStage.FRAGMENT,
                sampler: {}
            }]
        });

        const bindGroup = gpuDevice.createBindGroup({
            layout: bindGroupLayout,
            entries: [{
                binding: 0,
                resource: { buffer: buffer },
            }, {
                binding: 1,
                resource: texture
            }, {
                binding: 2,
                resource: sampler
            }]
        });

        const pipelineLayout = gpuDevice.createPipelineLayout({
            bindGroupLayouts: [bindGroupLayout]
        });
    </pre>
</div>

# 着色器模块 # {#shader-modules}

## <dfn interface>GPUShaderModule</dfn> ## {#shader-module}

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUShaderModule {
    Promise<GPUCompilationInfo> compilationInfo();
};
GPUShaderModule includes GPUObjectBase;
</script>

{{GPUShaderModule}} 是对内部着色器模块对象的引用。

Issue(gpuweb/gpuweb#354): 完成定义多线程API并将 `[Serializable]` 添加回接口。

### 着色器模块创建 ### {#shader-module-creation}

<script type=idl>
dictionary GPUShaderModuleCompilationHint {
    required GPUPipelineLayout layout;
};
dictionary GPUShaderModuleDescriptor : GPUObjectDescriptorBase {
    required USVString code;
    object sourceMap;
    record<USVString, GPUShaderModuleCompilationHint> hints;
};
</script>

{{GPUShaderModuleDescriptor/sourceMap}}，如果已定义，可以被解析为 source-map-v3 格式。 Source maps 是可选的，但可被当作支持开发工具集成（例如源语言调试）的标准化方法使用。
[[SourceMap]]

{{GPUShaderModuleDescriptor/hints}}，如果已定义，则将着色器的入口点名称映射到 {{GPUShaderModuleCompilationHint}}。不使用任何这些 {{GPUShaderModuleCompilationHint}} 执行验证。实现应使用 {{GPUShaderModuleCompilationHint}} 中存在的任何信息在 {{GPUDevice/createShaderModule()}} 中执行尽可能多的编译。

Note: 在 {{GPUShaderModuleDescriptor/hints}} 中提供信息除了性能之外没有任何可观察到的影响。因为单个着色器模块可以容纳多个入口点，并且可以从单个着色器模块创建多个管线，所以性能更好的实现是在 {{GPUDevice/createShaderModule()}} 中进行一次尽可能多的编译，而不是在对 {{GPUDevice/createComputePipeline()}} / {{GPUDevice/createRenderPipeline()}} 的多次调用中进行多次编译。

Note: 如果可能，开发者应该向 {{GPUDevice/createShaderModule()}} 和 {{GPUDevice/createComputePipeline()}} / {{GPUDevice/createRenderPipeline()}} 提供相同的信息。

Note: 如果开发者在调用 {{GPUDevice/createShaderModule()}} 时无法提供此 {{GPUShaderModuleDescriptor/hints}} 信息，通常不应延迟调用 {{GPUDevice/createShaderModule()}}; 而应该只是省略 {{GPUShaderModuleDescriptor/hints}} 或 {{GPUShaderModuleCompilationHint}} 中的未知信息。省略此信息可能会导致编译推迟到 {{GPUDevice/createComputePipeline()}} / {{GPUDevice/createRenderPipeline()}} 中进行。

Note: 如果开发者不确定传递给 {{GPUDevice/createShaderModule()}} 的信息是否与稍后传递给 {{GPUDevice/createComputePipeline()}} / {{GPUDevice/createRenderPipeline()}} 的信息匹配同一个模块，应该避免将该信息传递给 {{GPUDevice/createShaderModule()}}，因为将不匹配的信息传递给 {{GPUDevice/createShaderModule()}} 可能会导致发生不必要的编译。

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createShaderModule(descriptor)</dfn>
    ::
        创建一个 {{GPUShaderModule}}.

        <div algorithm=GPUDevice.createShaderModule>
            **调用:** {{GPUDevice}} this.

            **参数:**
            <pre class=argumentdef for="GPUDevice/createShaderModule(descriptor)">
                descriptor: 要创建的 {{GPUShaderModule}} 的描述。
            </pre>

            **返回:** {{GPUShaderModule}}

            Issue: 描述 {{GPUDevice/createShaderModule()}} 的算法步骤。
        </div>
</dl>

<div class="example">
    使用 WGSL 代码创建一个 {{GPUShaderModule}}：

    <pre highlight="js">
        // A simple vertex and fragment shader pair that will fill the viewport with red.
        const shaderSource = \`
            var&lt;private&gt; pos : array&lt;vec2&lt;f32&gt;, 3&gt; = array&lt;vec2&lt;f32&gt;, 3&gt;(
                vec2(-1.0, -1.0), vec2(-1.0, 3.0), vec2(3.0, -1.0));

            @stage(vertex)
            fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -&gt; @builtin(position) vec4&lt;f32&gt; {
                return vec4(pos[input.vertexIndex], 1.0, 1.0);
            }

            @stage(fragment)
            fn fragmentMain() -&gt; @location(0) vec4&lt;f32&gt; {
                return vec4(1.0, 0.0, 0.0, 1.0);
            }
        \`;

        const shaderModule = gpuDevice.createShaderModule({
            code: shaderSource,
        });
    </pre>
</div>

### 着色器模块编译信息 ### {#shader-module-compilation-information}

<script type=idl>
enum GPUCompilationMessageType {
    "error",
    "warning",
    "info",
};

[Exposed=(Window, DedicatedWorker), Serializable, SecureContext]
interface GPUCompilationMessage {
    readonly attribute DOMString message;
    readonly attribute GPUCompilationMessageType type;
    readonly attribute unsigned long long lineNum;
    readonly attribute unsigned long long linePos;
    readonly attribute unsigned long long offset;
    readonly attribute unsigned long long length;
};

[Exposed=(Window, DedicatedWorker), Serializable, SecureContext]
interface GPUCompilationInfo {
    readonly attribute FrozenArray<GPUCompilationMessage> messages;
};
</script>

{{GPUCompilationMessage}} 是由 {{GPUShaderModule}} 编译器生成的信息性的、警告或错误消息。 这些消息旨在让人类可读，以帮助开发人员诊断着色器 {{GPUShaderModuleDescriptor/code}} 的问题。每个消息可能对应于着色器代码中的单个点、着色器代码的子串，或者可能根本不对应于代码中的任何特定点。

{{GPUCompilationMessage}} 具有以下属性：

<dl dfn-type=attribute dfn-for=GPUCompilationMessage>
    : <dfn>message</dfn>
    ::
        一个人类可读的，包含着色器编译时产生的消息的字符串。

    : <dfn>type</dfn>
    ::
        消息的重要性级别。
        
        如果 {{GPUCompilationMessage/type}} 为错误，它对应着一个[=着色器创建错误=]。

    : <dfn>lineNum</dfn>
    ::
        {{GPUCompilationMessage/message}} 对应的着色器 {{GPUShaderModuleDescriptor/code}} 中的行号。值是从 1 开始的，这样行号为 1，表示着色器 {{GPUShaderModuleDescriptor/code}} 的第一行。

        如果 {{GPUCompilationMessage/message}} 对应于某子字符串，则指向子字符串开始的行。如果 {{GPUCompilationMessage/message}} 不对应着色器代码中的任何特定点，则必须为 0。

        Issue(gpuweb/gpuweb#2435): 在[定义行是什么]时参考 WGSL 规范(https://gpuweb.github.io/gpuweb/wgsl/#comments)。

    : <dfn>linePos</dfn>
    ::
        从着色器 {{GPUShaderModuleDescriptor/code}} 的 {{GPUCompilationMessage/lineNum}} 行的开头到 {{GPUCompilationMessage/message}} 对应的子字符串的开头的偏移量，以 UTF-16 代码单元为单位。值是从 1 开始的，这样 {{GPUCompilationMessage/linePos}} 为 1 表示该行的第一个字符。

        如果 {{GPUCompilationMessage/message}} 对应于某子字符串，则指向子字符串的第一个 UTF-16 代码单元。如果 {{GPUCompilationMessage/message}} 不对应着色器代码中的任何特定点，则必须为 0。

    : <dfn>offset</dfn>
    ::
        从 UTF-16 代码单元中的着色器 {{GPUShaderModuleDescriptor/code}} 的开头到 {{GPUCompilationMessage/message}} 对应的子字符串的开头的偏移量。必须引用与 {{GPUCompilationMessage/lineNum}} 和 {{GPUCompilationMessage/linePos}} 相同的位置。如果 {{GPUCompilationMessage/message}} 不对应着色器 {{GPUShaderModuleDescriptor/code}} 中的任何特定点，则必须为 0。

    : <dfn>length</dfn>
    ::
        {{GPUCompilationMessage/message}} 对应的子字符串中 UTF-16 代码单元的数量。如果消息与子字符串不对应，则 {{GPUCompilationMessage/length}} 必须为 0。
</dl>

Note: {{GPUCompilationMessage}}.{{GPUCompilationMessage/lineNum}} 和
{{GPUCompilationMessage}}.{{GPUCompilationMessage/linePos}} 是从 1 开始的，因为其最常见的用途是打印人类可读的消息，这些消息可以与许多文本编辑器中显示的行号和列号相关联。

Note: {{GPUCompilationMessage}}.{{GPUCompilationMessage/offset}} 和 {{GPUCompilationMessage}}.{{GPUCompilationMessage/length}} 适合传递给 `substr()` 以检索 {{GPUCompilationMessage/message}} 对应的着色器 {{GPUShaderModuleDescriptor/code}} 的子字符串。

<dl dfn-type=method dfn-for=GPUShaderModule>
    : <dfn>compilationInfo()</dfn>
    ::
        返回 {{GPUShaderModule}} 编译时产生的任何消息。

        消息的位置、顺序和内容是实现定义的。特别的，消息可能不会按 {{GPUCompilationMessage/lineNum}} 排序排列。

        <div algorithm=GPUShaderModule.compilationInfo>
            **调用:** {{GPUShaderModule}} this.

            **返回:** {{Promise}}&lt;{{GPUCompilationInfo}}&gt;

            Issue: 描述 {{GPUShaderModule/compilationInfo()}} 的算法步骤。
        </div>
</dl>


# 管线 # {#pipelines}

一个 <dfn dfn>管线</dfn>，无论是 {{GPUComputePipeline}} 还是 {{GPURenderPipeline}}，
表示由 GPU 硬件、驱动程序、和用户代理完成的某个完整功能，管线以资源绑定和顶点缓冲区作为输入数据，并产生一些输出，如输出渲染目标中的颜色。

在结构上，[=管线=]包含一系列可编程阶段（着色器）和固定功能状态，例如混合模式。

Note: 在内部，取决于不同目标平台，驱动程序可能会将一些固定功能状态转换为着色器代码，并将其与用户提供的着色器链接在一起。这种链接是将对象作为一个整体创建的原因之一。

此组合状态作为单个对象被创建（通过 {{GPUDevice/createComputePipeline(descriptor)|GPUDevice.createComputePipeline()}} 或 {{GPUDevice/createRenderPipeline(descriptor)|GPUDevice.createRenderPipeline()}}），并切换为一个对象（相应地通过 {{GPUComputePassEncoder/setPipeline(pipeline)|GPUComputePassEncoder.setPipeline}} 或 {{GPURenderEncoderBase/setPipeline(pipeline)|GPURenderEncoderBase.setPipeline}}）。

## 基础管线 ## {#pipeline-base}

<script type=idl>
dictionary GPUPipelineDescriptorBase : GPUObjectDescriptorBase {
    GPUPipelineLayout layout;
};

interface mixin GPUPipelineBase {
    GPUBindGroupLayout getBindGroupLayout(unsigned long index);
};
</script>

{{GPUPipelineBase}} 有以下内部插槽:

<dl dfn-type=attribute dfn-for="GPUPipelineBase">
    : <dfn>\[[layout]]</dfn> of type `GPUPipelineLayout`.
    ::
        可以与 `this` 一起使用的资源布局的定义.
</dl>

{{GPUPipelineBase}} 有以下方法:

<dl dfn-type=method dfn-for=GPUPipelineBase>
    : <dfn>getBindGroupLayout(index)</dfn>
    ::
        获取一个 {{GPUBindGroupLayout}}，与 `index` 处的 {{GPUPipelineBase}} 的 {{GPUBindGroupLayout}} 兼容。

        <div algorithm=GPUPipelineBase.getBindGroupLayout>
            **调用:** {{GPUPipelineBase}} |this|.

            **参数:**
            <pre class=argumentdef for="GPUPipelineBase/getBindGroupLayout(index)">
                |index|: 对管线布局的 {{GPUPipelineLayout/[[bindGroupLayouts]]}} 序列的索引。
            </pre>

            **返回:** {{GPUBindGroupLayout}}

            1. 如果 |index| &ge; |this|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxBindGroups}}:
                1. 返回一个 {{RangeError}}.

            1. 如果 |this| 不是[=有效=]的:
                1. 返回一个新的错误的 {{GPUBindGroupLayout}}.

            1. 返回一个新的 {{GPUBindGroupLayout}} 对象引用相同的内部对象 |this|.{{GPUPipelineBase/[[layout]]}}.{{GPUPipelineLayout/[[bindGroupLayouts]]}}[|index|].

            Issue: 一旦我们拥有 {{GPUBindGroupLayout}} 的内部对象，请更正确地指定此项。或者，只有规范作为[=组等效的=]的新内部对象

            Note: 仅返回新的 {{GPUBindGroupLayout}} 对象可确保[=内容时间线=]和[=设备时间线=]之间不需要同步。
        </div>
</dl>

### 默认管线布局 ### {#default-pipeline-layout}

在没有 {{GPUPipelineDescriptorBase/layout}} 的情况下创建的 {{GPUPipelineBase}} 对象，创建和使用的默认布局。

<div algorithm="default pipeline layout creation">

要为 {{GPUPipelineBase}} |pipeline| 创建<dfn abstract-op>默认管线布局</dfn>，需要运行以下步骤：

    1. 让 |groupDescs| 是 |device|.{{device/[[limits]]}}.{{supported limits/maxBindGroups}} 的一系列新的 {{GPUBindGroupLayoutDescriptor}} 对象。
    1. 对于每个在 |groupDescs| 中的 |groupDesc|:

        1. 设置 |groupDesc|.{{GPUBindGroupLayoutDescriptor/entries}} 为一个空序列。

    1. 对于每个在描述符中用于创建 |pipeline| 的 {{GPUProgrammableStage}} |stageDesc|:

        1. 让 |stageInfo| 是 |stageDesc| 的“反射信息”。

            Issue: 定义反射信息概念，以便此规范可以与 WGSL 规范接口，并获取特定入口点的 {{GPUShaderModule}} 接口的信息。

        1. 让 |shaderStage| 成为 |stageDesc|.{{GPUProgrammableStage/module}} 中 |stageDesc|.{{GPUProgrammableStage/entryPoint}} 的 {{GPUShaderStageFlags}}。
        1. 对于每个资源 |resource| 在 |stageInfo| 的资源接口中：

            1. 让 |group| 成为 |resource| 的 “group” 装饰。
            1. 让 |binding| 成为 |resource| 的 "binding" 装饰。
            1. 让 |entry| 成为一个新的 {{GPUBindGroupLayoutEntry}}.
            1. 设定 |entry|.{{GPUBindGroupLayoutEntry/binding}} 为 |binding|.
            1. 设定 |entry|.{{GPUBindGroupLayoutEntry/visibility}} 为 |shaderStage|.
            1. 如果 |resource| 用于采样器绑定:

                1. 让 |samplerLayout| 成为一个新的 {{GPUSamplerBindingLayout}}.
                1. 设置 |entry|.{{GPUBindGroupLayoutEntry/sampler}} 为 |samplerLayout|.

            1. 如果 |resource| 用于比较采样器绑定:

                1. 让 |samplerLayout| 成为一个新的 {{GPUSamplerBindingLayout}}.
                1. 设置 |samplerLayout|.{{GPUSamplerBindingLayout/type}} 为 {{GPUSamplerBindingType/"comparison"}}.
                1. 设置 |entry|.{{GPUBindGroupLayoutEntry/sampler}} 为 |samplerLayout|.

            1. 如果 |resource| 用于缓冲区绑定:

                1. 让 |bufferLayout| 成为一个新的 {{GPUBufferBindingLayout}}.

                1. 设置 |bufferLayout|.{{GPUBufferBindingLayout/minBindingSize}} 为 |resource| 的缓冲区绑定大小的最小值.

                    Issue: 链接到“反射信息”中“最小缓冲区绑定大小”的定义。

                1. 如果 |resource| 用于只读存储缓冲区:

                    1. 设定 |bufferLayout|.{{GPUBufferBindingLayout/type}} 为 {{GPUBufferBindingType/"read-only-storage"}}.

                1. 如果 |resource| 用于存储缓冲区:

                    1. 设置 |bufferLayout|.{{GPUBufferBindingLayout/type}} 为 {{GPUBufferBindingType/"storage"}}.

                1. 设置 |entry|.{{GPUBindGroupLayoutEntry/buffer}} 为 |bufferLayout|.

            1. 如果 |resource| 用于采样纹理绑定:

                1. 设置 |textureLayout| 为一个新的 {{GPUTextureBindingLayout}}.

                1. 如果 |resource| 用于深度采样纹理绑定:
                    - 设置 |textureLayout|.{{GPUTextureBindingLayout/sampleType}} 为 {{GPUTextureSampleType/"depth"}}

                    如果 |resource| 的采样类型是:

                    -
                        <dl class=switch>
                            : `f32` 并且 |resource| 与着色器中内置的 textureSample* 静态使用
                            :: 设置 |textureLayout|.{{GPUTextureBindingLayout/sampleType}} 为 {{GPUTextureSampleType/"float"}}
                            : 其他 `f32` 
                            :: 设置 |textureLayout|.{{GPUTextureBindingLayout/sampleType}} 为 {{GPUTextureSampleType/"unfilterable-float"}}
                            : `i32`
                            :: 设置 |textureLayout|.{{GPUTextureBindingLayout/sampleType}} 为 {{GPUTextureSampleType/"sint"}}
                            : `u32`
                            :: 设置 |textureLayout|.{{GPUTextureBindingLayout/sampleType}} 为 {{GPUTextureSampleType/"uint"}}
                        </dl>

                1. 设置 |textureLayout|.{{GPUTextureBindingLayout/viewDimension}} 为 |resource| 的维度。
                1. 如果 |resource| 用于多重采样纹理:

                    1. 设置 |textureLayout|.{{GPUTextureBindingLayout/multisampled}} 为 `true`.

                1. 设置 |entry|.{{GPUBindGroupLayoutEntry/texture}} 为 |textureLayout|.

            1. 如果 |resource| 用于存储纹理绑定:

                1. 让 |storageTextureLayout| 成为一个新的 {{GPUStorageTextureBindingLayout}}。
                1. 设置 |storageTextureLayout|.{{GPUStorageTextureBindingLayout/format}} 为 |resource| 的格式。
                1. 设置 |storageTextureLayout|.{{GPUStorageTextureBindingLayout/viewDimension}} 为 |resource| 的维度。

                1. 如果 |resource| 用于只写存储纹理:

                    1. 设置 |storageTextureLayout|.{{GPUStorageTextureBindingLayout/access}} 为 {{GPUStorageTextureAccess/"write-only"}}。

                1. 设置 |entry|.{{GPUBindGroupLayoutEntry/storageTexture}} 为 |storageTextureLayout|。

            1. 如果 |groupDescs|[|group|] 有一个条目 |previousEntry| {{GPUBindGroupLayoutEntry/binding}} 等于 |binding|：

                1. 如果 |entry| 具有与 |previousEntry| 不同的 {{GPUBindGroupLayoutEntry/visibility}}:

                    1. 将 |entry|.{{GPUBindGroupLayoutEntry/visibility}} 中设置的位添加到 |previousEntry|.{{GPUBindGroupLayoutEntry/visibility}}

                1. 如果 |resource| 用于缓冲区绑定和 |entry| 有比 |previousEntry| 更大的 {{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/minBindingSize}}:

                    1. 设置 |previousEntry|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/minBindingSize}} 为 |entry|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/minBindingSize}}。

                1. 如果 |resource| 是一个采样的纹理绑定和 |entry| 具有与 |previousEntry| 不同的 {{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/sampleType}}，并且 |entry| 和 |previousEntry| 都有 {{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/sampleType}} 为 {{GPUTextureSampleType/"float"}} 或 {{GPUTextureSampleType/"unfilterable-float"}}：
                    1. 设置 |previousEntry|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/sampleType}} 为 {{GPUTextureSampleType/"float"}}.

                1. 如果任何其他属性在 |entry| 之间不相等 和 |previousEntry|:

                    1. 返回 `null`（这将导致管线的创建失败）。

            1. 其他

                1. 附加 |entry| 到 |groupDescs|[|group|]。

    1. 让 |groupLayouts| 成为一个新的序列。
    1. 对于每一个在 |groupDescs| 中的 |groupDesc|:

        1. 让 |bindGroupLayout| 成为调用 |device|.{{GPUDevice/createBindGroupLayout()}}(|groupDesc|) 的结果。
        1. 设置 |bindGroupLayout|.{{GPUBindGroupLayout/[[exclusivePipeline]]}} 为 |pipeline|。
        1. 附加 |bindGroupLayout| 到 |groupLayouts|。

    1. 让 |desc| 成为一个新的 {{GPUPipelineLayoutDescriptor}}。
    1. 设置 |desc|.{{GPUPipelineLayoutDescriptor/bindGroupLayouts}} 为 |groupLayouts|。
    1. 返回 |device|.{{GPUDevice/createPipelineLayout()}}(|desc|)。

    Issue: 这会用空的绑定组填充管线布局。 一旦指定了空绑定组的行为，请重新访问。

</div>

<dl dfn-for=GPUProgrammableStage dfn-type=dict-member>
    : <dfn>constants</dfn>
    ::
        指定着色器模块 {{GPUProgrammableStage/module}} 中[=管线可重写=]常量的值。

        每个这样的[=管线可重写=]常量都由单个[=管线可重写常量标识符字符串=]唯一标识（如果指定了一个常量，则表示该常量的数字 ID，否则表示常量的标识符名称）。

        每个键值对的键必须等于一个这样的常量的标识符字符串。执行管线时，该常量将具有指定的值。

        被指定为 <dfn typedef for=>GPUPipelineConstantValue</dfn> 的值，是一个 `double` 类型，被转换为相应管线可重写常量的 WGSL 数据类型（`bool`、`i32`、`u32`、 或 `f32`) 通过[=converted to an IDL value|an IDL value=|一个 IDL 值=]（{{boolean}}、{{long}}、{{unsigned long}} 或 {{float}}）。

        <div class=example>
            WGSL 中定义的管线可重写常量:

            <pre highlight=rust>
                @override(0)    let has_point_light: bool = true; // Algorithmic control.
                @override(1200) let specular_param: f32 = 2.3;    // Numeric control.
                @override(1300) let gain: f32;                    // Must be overridden.
                @override       let width: f32 = 0.0;             // Specifed at the API level
                                                                  //   using the name "width".
                @override       let depth: f32;                   // Specifed at the API level
                                                                  //   using the name "depth".
                                                                  //   Must be overridden.
            </pre>

            相应的 JavaScript 代码，仅提供所需的覆盖值（没有默认值）：

            <pre highlight=js>
                {
                    // ...
                    constants: {
                        1300: 2.0,  // "gain"
                        depth: -1,  // "depth"
                    }
                }
            </pre>

            相应的 JavaScript 代码, 重写所有常量:

            <pre highlight=js>
                {
                    // ...
                    constants: {
                        0: false,   // "has_point_light"
                        1200: 3.0,  // "specular_param"
                        1300: 2.0,  // "gain"
                        width: 20,  // "width"
                        depth: -1,  // "depth"
                    }
                }
            </pre>
        </div>
</dl>

<div algorithm>
    <dfn abstract-op>验证 GPUProgrammableStage</dfn>(stage, descriptor, layout)

    **参数:**
    - {{GPUShaderStage}} |stage|
    - {{GPUProgrammableStage}} |descriptor|
    - {{GPUPipelineLayout}} |layout|

    如果满足以下所有条件，则返回 `true`：

    - |descriptor|.{{GPUProgrammableStage/module}} 必须是一个[=有效=]的 {{GPUShaderModule}}.
    - |descriptor|.{{GPUProgrammableStage/module}} 必须包含一个入口点，用于着色器阶段 |stage|，名为 |descriptor|.{{GPUProgrammableStage/entryPoint}}。
    - 对于每个着色器入口点[=静态使用=]的 |binding|：
        - [$验证着色器绑定$](|binding|, |layout|) 必须返回 `true`。
    - 对于入口点[=静态使用=]的每个纹理采样着色器调用:
        1. 让 |texture| 是与调用中的采样纹理对应的 {{GPUBindGroupLayoutEntry}}。
        1. 让 |sampler| 是与调用中使用的采样器对应的 {{GPUBindGroupLayoutEntry}}。
        1. 如果 |sampler|.{{GPUSamplerBindingLayout/type}} 是 {{GPUSamplerBindingType/"filtering"}}, 那么 |texture|.{{GPUTextureBindingLayout/sampleType}} 必须不是 {{GPUTextureSampleType/"unfilterable-float"}}。
    - 对于在 |descriptor|.{{GPUProgrammableStage/constants}} 的 [=map/get the keys|the keys=] 中的每个 |key|：
        - |key| 必须等于在着色器模块 |descriptor|.{{GPUProgrammableStage/module}} 中定义的某些[=管线可重写=]常量的[=管线可重写常量标识符字符串=]。
        
    - 对于每个在着色器入口点[=静态访问=]的[=管线可重写常量标识符字符串=] |key| ：
        - 如果由 |key| 标识的管线可重写常量[=pipeline-overridable constant has a default value|不包含默认值=], |descriptor|.{{GPUProgrammableStage/constants}} 必须 [=map/contain=] |key|。
    
    返回值 `false` 对应于[=管线创建错误=]。
</div>

<div algorithm>
    <dfn abstract-op>验证着色器绑定</dfn>(binding, layout)

    **参数:**
        - 着色器绑定声明的 |variable|，从着色器模块反射的模块范围变量声明
        - {{GPUPipelineLayout}} |layout|

    将 |bindGroup| 是绑定组索引，和 |bindIndex| 作为着色器绑定声明 |variable| 的绑定索引。

    如果满足以下所有条件，则返回 `true`：

        - |layout|.{{GPUPipelineLayout/[[bindGroupLayouts]]}}[|bindGroup|] 包含一个 {{GPUBindGroupLayoutEntry}} |entry|，其中 |entry|.{{GPUBindGroupLayoutEntry/binding}} == |bindIndex|.
        - 如果对于 |entry| 被定义的[=绑定成员=]是:
            <dl class=switch>
                : {{GPUBindGroupLayoutEntry/buffer}}
                ::
                    如果 |entry|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/type}} 是:
                    <dl class=switch>
                        : {{GPUBufferBindingType/"uniform"}}
                        :: |variable| 使用地址空间 `uniform` 声明。
                        : {{GPUBufferBindingType/"storage"}}
                        :: |variable| 使用地址空间 `storage` 和访问模式 `read_write` 声明。
                        : {{GPUBufferBindingType/"read-only-storage"}}
                        :: |variable| 使用地址空间 `storage` 和访问模式 `read` 声明。
                    </dl>
                ::
                    如果 |entry|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/minBindingSize}} 不是 `0`，那么着色器中关联缓冲区变量必须至少是[=最小绑定大小=]。如果变量具有[=存储类型=] |T|，则最小绑定大小为 [=SizeOf=](|T|)。在这个计算中，如果 |T| 是一个[=运行时间大小=]的数组或包含一个运行时间大小的数组，该数组假定有一个元素。强制执行此下限可确保通过缓冲区变量进行的读取和写入仅访问缓冲区绑定区域内的内存位置。

                : {{GPUBindGroupLayoutEntry/sampler}}
                ::
                    如果 |entry|.{{GPUBindGroupLayoutEntry/sampler}}.{{GPUSamplerBindingLayout/type}} 是:
                    <dl class=switch>
                        : {{GPUSamplerBindingType/"filtering"}} 或者 {{GPUSamplerBindingType/"non-filtering"}}
                        :: |variable| 是 `sampler` 类型
                        : {{GPUSamplerBindingType/"comparison"}}
                        :: |variable| 是 `comparison_sampler` 类型。
                    </dl>

                : {{GPUBindGroupLayoutEntry/texture}}
                ::
                    当且仅当，
                    |entry|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/multisampled}} 是 `true`，|variable| 类型为 `texture_multisampled_2d<T>` 或 `texture_depth_multisampled_2d<T>`。
                ::
                    如果 |entry|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/sampleType}} 是:
                    <dl class=switch>
                        : {{GPUTextureSampleType/"float"}}, {{GPUTextureSampleType/"unfilterable-float"}}, {{GPUTextureSampleType/"sint"}} 或 {{GPUTextureSampleType/"uint"}}
                        ::
                            |variable| 是类型 `texture_1d<T>`, `texture_2d<T>`, `texture_2d_array<T>`, `texture_cube<T>`, `texture_cube_array<T>`, `texture_3d<T>`, 或 `texture_multisampled_2d<T>`.
                        ::
                            如果 |entry|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/sampleType}} 是:
                            <dl class=switch>
                                : {{GPUTextureSampleType/"float"}} 或 {{GPUTextureSampleType/"unfilterable-float"}}
                                :: 采样类型 `T` 是 `f32`.
                                : {{GPUTextureSampleType/"sint"}}
                                :: 采样类型 `T` 是 `i32`.
                                : {{GPUTextureSampleType/"uint"}}
                                :: 采样类型 `T` 是 `u32`.
                            </dl>

                        : {{GPUTextureSampleType/"depth"}}
                        ::
                            |variable| 是类型 `texture_depth_2d`, `texture_depth_2d_array`, `texture_depth_cube`, `texture_depth_cube_array`, 或 `texture_depth_multisampled_2d`.
                    </dl>
                ::
                    如果 |entry|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/viewDimension}} 是:
                    <dl class=switch>
                        : {{GPUTextureViewDimension/"1d"}}
                        :: |variable| 是类型 `texture_1d<T>`.
                        : {{GPUTextureViewDimension/"2d"}}
                        :: |variable| 是类型 `texture_2d<T>` 或 `texture_multisampled_2d<T>`.
                        : {{GPUTextureViewDimension/"2d-array"}}
                        :: |variable| 是类型 `texture_2d_array<T>`.
                        : {{GPUTextureViewDimension/"cube"}}
                        :: |variable| 是类型 `texture_cube<T>`.
                        : {{GPUTextureViewDimension/"cube-array"}}
                        :: |variable| 是类型 `texture_cube_array<T>`.
                        : {{GPUTextureViewDimension/"3d"}}
                        :: |variable| 是类型 `texture_3d<T>`.
                    </dl>

                : {{GPUBindGroupLayoutEntry/storageTexture}}
                ::
                    如果 |entry|.{{GPUBindGroupLayoutEntry/storageTexture}}.{{GPUStorageTextureBindingLayout/viewDimension}} 是:
                    <dl class=switch>
                        : {{GPUTextureViewDimension/"1d"}}
                        :: |variable| 是类型 `texture_storage_1d<T, A>`.
                        : {{GPUTextureViewDimension/"2d"}}
                        :: |variable| 是类型 `texture_storage_2d<T, A>`.
                        : {{GPUTextureViewDimension/"2d-array"}}
                        :: |variable| 是类型 `texture_storage_2d_array<T, A>`.
                        : {{GPUTextureViewDimension/"3d"}}
                        :: |variable| 是类型 `texture_storage_3d<T, A>`.
                    </dl>
                ::
                    如果 |entry|.{{GPUBindGroupLayoutEntry/storageTexture}}.{{GPUStorageTextureBindingLayout/access}} 是:
                    <dl class=switch>
                        : {{GPUStorageTextureAccess/"write-only"}}
                        :: 访问模式 “A” 是“写”。
                    </dl>
                ::
                    纹素格式 `T` 等于 |entry|.{{GPUBindGroupLayoutEntry/storageTexture}}.{{GPUStorageTextureBindingLayout/format}}.
            </dl>
</div>

资源绑定被视为着色器入口点的<dfn dfn>静态使用</dfn>，当且仅当可以被着色器模块的控制流图访问，并从入口点开始。

## <dfn interface>GPUComputePipeline</dfn> ## {#compute-pipeline}

{{GPUComputePipeline}} 是一种控制计算着色器阶段的[=管线=]，并且可以在 {{GPUComputePassEncoder}} 中使用。

根据给定的 {{GPUPipelineLayout}}，计算输入和输出都包含在绑定中。输出对应于类型为 {{GPUBufferBindingType/"storage"}} 的 {{GPUBindGroupLayoutEntry/buffer}} 绑定，和类型为 {{GPUStorageTextureAccess/"write-only"}} 的 {{GPUBindGroupLayoutEntry/storageTexture}} 绑定。

计算[=管线=]阶段:
  1. 计算着色器

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUComputePipeline {
};
GPUComputePipeline includes GPUObjectBase;
GPUComputePipeline includes GPUPipelineBase;
</script>

### 创建 ### {#compute-pipeline-creation}

<script type=idl>
dictionary GPUComputePipelineDescriptor : GPUPipelineDescriptorBase {
    required GPUProgrammableStage compute;
};
</script>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createComputePipeline(descriptor)</dfn>
    ::
        创建一个 {{GPUComputePipeline}}。

        <div algorithm=GPUDevice.createComputePipeline>
            **调用:** {{GPUDevice}} |this|.

            **参数:**
            <pre class=argumentdef for="GPUDevice/createComputePipeline(descriptor)">
                |descriptor|: 要创建的 {{GPUComputePipeline}} 的描述.
            </pre>

            **返回:** {{GPUComputePipeline}}

            1. 让 |pipeline| 成一个新的有效的 {{GPUComputePipeline}} 对象.
            1. 在 |this| 的[=设备时间线=]上发出以下步骤:
                <div class=device-timeline>
                    1. 如果不满足以下任一条件：
                        <div class=validusage>
                            - |descriptor|.{{GPUPipelineDescriptorBase/layout}} 与 |this| 可以[$一起有效被使用$]。
                            - [$验证 GPUProgrammableStage$]({{GPUShaderStage/COMPUTE}}, |descriptor|.{{GPUComputePipelineDescriptor/compute}}, |descriptor|.{{GPUPipelineDescriptorBase/layout}}) 成功。
                            - |descriptor|.{{GPUComputePipelineDescriptor/compute}} 使用 &le; |device|.limits.{{supported limits/maxComputeWorkgroupStorageSize}} 工作组存储的字节。

                                Issue: 更好地定义使用静态使用等。
                            - |descriptor|.{{GPUComputePipelineDescriptor/compute}} 使用 &le; |device|.limits.{{supported limits/maxComputeInvocationsPerWorkgroup}} 每一个工作组。

                            - |descriptor|.{{GPUComputePipelineDescriptor/compute}} 的 `workgroup_size` 属性具有每个组件 &le; 对应的组件 [|device|.limits.{{supported limits/maxComputeWorkgroupSizeX}}，|device|.limits.{{supported limits/maxComputeWorkgroupSizeY}}，|device|.limits.{{supported limits/maxComputeWorkgroupSizeZ}}]。
                        </div>

                        然后:
                            1. 在当前范围内生成带有适当错误消息的 {{GPUValidationError}} 。
                            1. 使 |pipeline| [=无效=].

                    1. 如果 |descriptor|.{{GPUPipelineDescriptorBase/layout}} 是 `undefined`:
                        1. 为 |pipeline| 设置 |pipeline|.{{GPUPipelineBase/[[layout]]}} 为一个新的[$默认管线布局$]。

                        否则设置|pipeline|.{{GPUPipelineBase/[[layout]]}} 为 |descriptor|.{{GPUPipelineDescriptorBase/layout}}。
                </div>
            1. 返回 |pipeline|.

        </div>

    : <dfn>createComputePipelineAsync(descriptor)</dfn>
    ::
        创建一个 {{GPUComputePipeline}}。 返回的 {{Promise}} 在创建的管线准备好使用时被决议，并且没有额外的延迟。

        如果管线创建失败，则返回的 {{Promise}} 会以 {{OperationError}} 被拒绝。

        Note: 尽可能使用此方法，因为可以防止阻塞管线编译中的[=队列时间线=]工作。

        <div algorithm=GPUDevice.createComputePipelineAsync>
            **调用:** {{GPUDevice}} |this|.

            **参数:**
            <pre class=argumentdef for="GPUDevice/createComputePipelineAsync(descriptor)">
                |descriptor|: 要创建的 {{GPUComputePipeline}} 的描述。
            </pre>

            **返回:** {{Promise}}&lt;{{GPUComputePipeline}}&gt;

            1. 让 |promise| 为 [=a new promise=].
            1. 在 |this| 的[=设备时间线=]上发出以下步骤:
                <div class=device-timeline>
                    1. 让 |pipeline| 是一个新的 {{GPUComputePipeline}}，就像用 |descriptor| 调用的 |this|.{{GPUDevice/createComputePipeline()}} 一样;

                    1. 当 |pipeline| 已准备好使用，[=决议=] |promise| 与 |pipeline|。
                </div>
            1. 返回 |promise|.
        </div>
</dl>

<div class="example">
    创建一个简单的 {{GPUComputePipeline}}:
    <pre highlight="js">
        const computePipeline = gpuDevice.createComputePipeline({
            layout: pipelineLayout,
            compute: {
                module: computeShaderModule,
                entryPoint: 'computeMain',
            }
        });
    </pre>
</div>

## <dfn interface>GPURenderPipeline</dfn> ## {#render-pipeline}

{{GPURenderPipeline}} 是一种控制顶点和片段着色器阶段的[=管线=]，可以在 {{GPURenderPassEncoder}} 以及 {{GPURenderBundleEncoder}} 中使用。

渲染[=管线=]的输入是：
   - 绑定，根据给定的 {{GPUPipelineLayout}}
   - 顶点和索引缓冲区，由 {{GPUVertexState}} 描述
   - 颜色附件，由 {{GPUColorTargetState}} 描述
   - 可选的，深度模板附件，由 {{GPUDepthStencilState}} 描述

渲染[=管线=]的输出是：
   - {{GPUBufferBindingLayout/type}} 为 {{GPUBufferBindingType/"storage"}} 的 {{GPUBindGroupLayoutEntry/buffer}} 绑定
   - {{GPUStorageTextureBindingLayout/access}} 为 {{GPUStorageTextureAccess/"write-only"}} 的 {{GPUBindGroupLayoutEntry/storageTexture}} 绑定
   - 颜色附件，由 {{GPUColorTargetState}} 描述
   - 可选的，深度模板附件，由 {{GPUDepthStencilState}} 描述

渲染[=管线=]由以下<dfn dfn>渲染阶段</dfn>组成：
   1. 顶点获取，由 {{GPUVertexState/buffers|GPUVertexState.buffers}} 控制
   2. 顶点着色器，由 {{GPUVertexState}} 控制
   3. 原始组装，由 {{GPUPrimitiveState}} 控制
   4. 光栅化，由 {{GPUPrimitiveState}}、{{GPUDepthStencilState}} 和 {{GPUMultisampleState}} 控制
   5. 片段着色器，由{{GPUFragmentState}}控制
   6. 模板测试和操作，由 {{GPUDepthStencilState}} 控制
   7. 深度测试和写入，由 {{GPUDepthStencilState}} 控制
   8. 输出合并，由 {{GPUFragmentState/targets|GPUFragmentState.targets}} 控制

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPURenderPipeline {
};
GPURenderPipeline includes GPUObjectBase;
GPURenderPipeline includes GPUPipelineBase;
</script>

{{GPURenderPipeline}} 有以下内部插槽：

<dl dfn-type=attribute dfn-for=GPURenderPipeline>
    : <dfn>\[[descriptor]]</dfn>, of type {{GPURenderPipelineDescriptor}}
    ::
        {{GPURenderPipelineDescriptor}} 用来描述这个管线。

        {{GPURenderPipelineDescriptor}} 的所有可选字段都已定义。
    : <dfn>\[[writesDepth]]</dfn>, of type boolean
    :: 如果管线写入深度/模板附件的深度组件，则为 True

    : <dfn>\[[writesStencil]]</dfn>, of type boolean
    :: 如果管线写入深度/模板附件的模板组件，则为 True
</dl>

### 创建 ### {#render-pipeline-creation}

<script type=idl>
dictionary GPURenderPipelineDescriptor : GPUPipelineDescriptorBase {
    required GPUVertexState vertex;
    GPUPrimitiveState primitive = {};
    GPUDepthStencilState depthStencil;
    GPUMultisampleState multisample = {};
    GPUFragmentState fragment;
};
</script>

{{GPURenderPipelineDescriptor}} 通过配置每个[=渲染阶段=]来描述渲染[=管线=]的状态。有关详细信息，请参阅 [[#rendering-operations]]。

- {{GPURenderPipelineDescriptor/vertex}} 描述了[=管线=]的顶点着色器入口点及其输入缓冲区布局。
- {{GPURenderPipelineDescriptor/primitive}} 描述了[=管线=]的原始相关属性。
- {{GPURenderPipelineDescriptor/depthStencil}} 描述了可选的深度模板属性，包括测试、操作和偏差。
- {{GPURenderPipelineDescriptor/multisample}} 描述了[=管线=]的多重采样特性。
- {{GPURenderPipelineDescriptor/fragment}} 描述了[=管线=]的片元着色器入口点及其输出颜色。如果是 `null`，则启用 [[#no-color-output]] 模式。

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createRenderPipeline(descriptor)</dfn>
    ::
        创建一个 {{GPURenderPipeline}}.

        <div algorithm=GPUDevice.createRenderPipeline>
            **调用:** {{GPUDevice}} |this|.

            **参数:**
            <pre class=argumentdef for="GPUDevice/createRenderPipeline(descriptor)">
                |descriptor|: 要创建的 {{GPURenderPipeline}} 的描述。
            </pre>

            **返回:** {{GPURenderPipeline}}

            1. 让 |pipeline| 为一个新的可用的 {{GPURenderPipeline}} 对象。
            1. 在 |this| 的[=设备时间线=]上发出以下步骤：
                <div class=device-timeline>
                    1. 如果不满足以下任一条件：
                        <div class=validusage>
                            - |descriptor|.{{GPUPipelineDescriptorBase/layout}} 是与 |this| [$一起有效被使用$]的。
                            - [$validating GPURenderPipelineDescriptor$](|descriptor|, |this|) 成功。
                        </div>

                        然后:
                            1. 在当前范围内生成带有适当错误消息的 {{GPUValidationError}}。
                            1. 使 |pipeline| [=无效=]。

                    1. 设置 |pipeline|.{{GPURenderPipeline/[[descriptor]]}} 为 |descriptor|。
                    1. 设置 |pipeline|.{{GPURenderPipeline/[[writesDepth]]}} 为 false.
                    1. 设置 |pipeline|.{{GPURenderPipeline/[[writesStencil]]}} 为 false.
                    1. 让 |depthStencil| 为 |descriptor|.{{GPURenderPipelineDescriptor/depthStencil}}.
                    1. 如果 |depthStencil| 不是 null:
                        1. 设置 |pipeline|.{{GPURenderPipeline/[[writesDepth]]}} 为 |depthStencil|.{{GPUDepthStencilState/depthWriteEnabled}}.
                        1. 如果 |depthStencil|.{{GPUDepthStencilState/stencilWriteMask}} 不是 0:
                            1. 让 |stencilFront| 为 |depthStencil|.{{GPUDepthStencilState/stencilFront}}.
                            1. 让 |stencilBack| 为 |depthStencil|.{{GPUDepthStencilState/stencilBack}}.
                            1. 让 |cullMode| 为 |descriptor|.{{GPURenderPipelineDescriptor/primitive}}.{{GPUPrimitiveState/cullMode}}.
                            1. 如果 |cullMode| 不是 {{GPUCullMode/"front"}}, 并且 |stencilFront|.{{GPUStencilFaceState/passOp}}, |stencilFront|.{{GPUStencilFaceState/depthFailOp}}, 或 |stencilFront|.{{GPUStencilFaceState/failOp}} 其中任意一个都不是 {{GPUStencilOperation/"keep"}}:
                                1. 设置 |pipeline|.{{GPURenderPipeline/[[writesStencil]]}} 为 true.
                            1. 如果 |cullMode| 不是 {{GPUCullMode/"back"}}, 并且 |stencilBack|.{{GPUStencilFaceState/passOp}}, |stencilBack|.{{GPUStencilFaceState/depthFailOp}}, 或 |stencilBack|.{{GPUStencilFaceState/failOp}} 其中任意一个都不是 {{GPUStencilOperation/"keep"}}:
                                1. 设置 |pipeline|.{{GPURenderPipeline/[[writesStencil]]}} 为 true.
                    1. 如果 |descriptor|.{{GPUPipelineDescriptorBase/layout}} 是 `undefined`:
                        1. 为 |pipeline| 设置 |pipeline|.{{GPUPipelineBase/[[layout]]}} 为一个新的[$默认管线布局$]。

                        否则设置 |pipeline|.{{GPUPipelineBase/[[layout]]}} 为 |descriptor|.{{GPUPipelineDescriptorBase/layout}}.
                </div>
            1. 返回 |pipeline|.

            Issue: 需要渲染状态的描述。
        </div>

    : <dfn>createRenderPipelineAsync(descriptor)</dfn>
    ::
        创建一个 {{GPURenderPipeline}}。 返回的 {{Promise}} 在创建的管线准备好使用时被决议，并且没有额外的延迟。

        如果管线创建失败，则返回的 {{Promise}} 会被拒绝，并且返回一个 {{OperationError}}。

        Note: 最好尽可能使用此方法，因为可以防止阻塞工作在管线编译上的[=队列时间线=]。

        <div algorithm=GPUDevice.createRenderPipelineAsync>
            **调用:** {{GPUDevice}} |this|.

            **参数:**
            <pre class=argumentdef for="GPUDevice/createRenderPipelineAsync(descriptor)">
                |descriptor|: 要创建的 {{GPURenderPipeline}} 的描述。
            </pre>

            **返回:** {{Promise}}&lt;{{GPURenderPipeline}}&gt;

            1. 让 |promise| 为 [=a new promise=].
            1. 在 |this| 的[=设备时间线=]上发出以下步骤:
                <div class=device-timeline>
                    1. 让 |pipeline| 是一个新创建的 {{GPURenderPipeline}}，类似 |this|.{{GPUDevice/createRenderPipeline()}} 用 |descriptor| 调用的一样被创建;

                    1. 当 |pipeline| 已准备好被使用， 用 |pipeline| [=决议=] |promise|。
                </div>
            1. 返回 |promise|.
        </div>
</dl>

<div algorithm>
    <dfn abstract-op>验证 GPURenderPipelineDescriptor</dfn>(descriptor, device)
        **参数:**
            - {{GPURenderPipelineDescriptor}} |descriptor|
            - {{GPUDevice}} |device|

        如果满足以下所有条件，则返回 `true`：

            - [$验证 GPUProgrammableStage$]({{GPUShaderStage/VERTEX}}, |descriptor|.{{GPURenderPipelineDescriptor/vertex}}, |descriptor|.{{GPUPipelineDescriptorBase/layout}}) 成功。
            - [$验证 GPUVertexState$](|device|, |descriptor|.{{GPURenderPipelineDescriptor/vertex}}, |descriptor|.{{GPURenderPipelineDescriptor/vertex}}) 成功。
            - 如果 |descriptor|.{{GPURenderPipelineDescriptor/fragment}} 不是 `null`:
                - [$验证 GPUProgrammableStage$]({{GPUShaderStage/FRAGMENT}}, |descriptor|.{{GPURenderPipelineDescriptor/fragment}}, |descriptor|.{{GPUPipelineDescriptorBase/layout}}) 成功。
                - [$验证 GPUFragmentState$](|descriptor|.{{GPURenderPipelineDescriptor/fragment}}) 成功。
                - 如果 "sample_mask" 的[=内置变量=]是 |descriptor|.{{GPURenderPipelineDescriptor/fragment}} 的[=管线输出=]:
                    - |descriptor|.{{GPURenderPipelineDescriptor/multisample}}.{{GPUMultisampleState/alphaToCoverageEnabled}} 是 `false`。
            - [$验证 GPUPrimitiveState$](|descriptor|.{{GPURenderPipelineDescriptor/primitive}}, |device|.{{device/[[features]]}}) 成功。
            - 如果 |descriptor|.{{GPURenderPipelineDescriptor/depthStencil}} 不是 `null`:
                - [$验证 GPUDepthStencilState$](|descriptor|.{{GPURenderPipelineDescriptor/depthStencil}}) 成功。
            - [$验证 GPUMultisampleState$](|descriptor|.{{GPURenderPipelineDescriptor/multisample}}) 成功。
            - 对于每个用户定义的 |descriptor|.{{GPURenderPipelineDescriptor/vertex}} 输出，必须有一个是用户定义的 |descriptor|.{{GPURenderPipelineDescriptor/fragment}} 输入，并且拥有匹配的[=地址=]，类型，和输出的[=插值=]。
            - 对于每个用户定义的 |descriptor|.{{GPURenderPipelineDescriptor/fragment}} 输入，必须有一个是用户定义的 |descriptor|.{{GPURenderPipelineDescriptor/vertex}} 输出，并且拥有匹配的[=地址=]，类型，和输入的[=插值=]。
            - |descriptor|.{{GPURenderPipelineDescriptor/vertex}} 的用户定义输出组件少于 |device|.limits.{{supported limits/maxInterStageShaderComponents}} 组件。
            - |descriptor|.{{GPURenderPipelineDescriptor/fragment}} 的用户定义输入的组件少于 |device|.limits.{{supported limits/maxInterStageShaderComponents}} 组件。
</div>

Issue: 我们应该验证点和线的 `cullMode` 是 none 吗？

Issue: 定义渲染目标格式的“兼容”意味着什么。

Issue: 需要适当限制颜色目标的最大数量。

<div class="example">
    创建一个简单的 {{GPURenderPipeline}}:
    <pre highlight="js">
        const renderPipeline = gpuDevice.createRenderPipeline({
            layout: pipelineLayout,
            vertex: {
                module: shaderModule,
                entryPoint: 'vertexMain'
            },
            fragment: {
                module: shaderModule,
                entryPoint: 'fragmentMain',
                targets: [{
                    format: 'bgra8unorm',
                }],
            }
        });
    </pre>
</div>

### 原始状态 ### {#primitive-state}

<script type=idl>
enum GPUPrimitiveTopology {
    "point-list",
    "line-list",
    "line-strip",
    "triangle-list",
    "triangle-strip",
};
</script>

<script type=idl>
dictionary GPUPrimitiveState {
    GPUPrimitiveTopology topology = "triangle-list";
    GPUIndexFormat stripIndexFormat;
    GPUFrontFace frontFace = "ccw";
    GPUCullMode cullMode = "none";

    // Requires "depth-clip-control" feature.
    boolean unclippedDepth = false;
};
</script>

<div algorithm>
    <dfn abstract-op>验证 GPUPrimitiveState</dfn>(|descriptor|, |features|)
        **参数:**
            - {{GPUPrimitiveState}} |descriptor|
            - [=list=]&lt;{{GPUFeatureName}}&gt; |features|

        如果满足以下所有条件，则返回 `true`：
            - 如果 |descriptor|.{{GPUPrimitiveState/topology}} 不为 {{GPUPrimitiveTopology/"line-strip"}} 或 {{GPUPrimitiveTopology/"triangle-strip"}}:
                - |descriptor|.{{GPUPrimitiveState/stripIndexFormat}} 为 `undefined`
            - 如果 |descriptor|.{{GPUPrimitiveState/unclippedDepth}} 为 `true`:
                - |features| 必须[=list/包含=] {{GPUFeatureName/"depth-clip-control"}}。
</div>

<script type=idl>
enum GPUFrontFace {
    "ccw",
    "cw",
};
</script>

<script type=idl>
enum GPUCullMode {
    "none",
    "front",
    "back",
};
</script>

### 多重采样状态 ### {#multisample-state}

<script type=idl>
dictionary GPUMultisampleState {
    GPUSize32 count = 1;
    GPUSampleMask mask = 0xFFFFFFFF;
    boolean alphaToCoverageEnabled = false;
};
</script>

<div algorithm>
    <dfn abstract-op>验证 GPUMultisampleState</dfn>(|descriptor|)
        **参数:**
            - {{GPUMultisampleState}} |descriptor|

        如果满足以下所有条件，则返回 `true`:
            - 如果 |descriptor|.{{GPUMultisampleState/alphaToCoverageEnabled}} 是 `true`:
                - |descriptor|.{{GPUMultisampleState/count}} 比 1 大。
</div>

### 片段状态 ### {#fragment-state}

<script type=idl>
dictionary GPUFragmentState : GPUProgrammableStage {
    required sequence<GPUColorTargetState> targets;
};
</script>

<div algorithm>
    <dfn abstract-op>validating GPUFragmentState</dfn>(|descriptor|)
        如果满足以下所有要求，则返回 `true`：

        - |descriptor|.{{GPUFragmentState/targets}}.length 必须 &le; 8.
        - 对于每个|colorState| 列表中的布局描述符 |descriptor|.{{GPUFragmentState/targets}}:
            - |colorState|.{{GPUColorTargetState/format}} 必须在具有
                {{GPUTextureUsage/RENDER_ATTACHMENT}} 功能的 [[#plain-color-formats]] 中列出。
            - 如果 |colorState|.{{GPUColorTargetState/blend}} 不是 `undefined`:
                - |colorState|.{{GPUColorTargetState/format}} 必须是可过滤的
                    根据 [[#plain-color-formats]] 表。
                - |colorState|.{{GPUColorTargetState/blend}}.{{GPUBlendState/color}}
                    必须是 [=valid GPUBlendComponent=].
                - |colorState|.{{GPUColorTargetState/blend}}.{{GPUBlendState/alpha}}
                    必须是 [=valid GPUBlendComponent=].
            - |colorState|.{{GPUColorTargetState/writeMask}} 必须是 &lt; 16.
            - 如果 |descriptor|.{{GPUProgrammableStage/entryPoint}} 有一个 [=pipeline output=] 值，
                [=location=] 属性等于 |colorState| 的索引 在 |descriptor|.{{GPUFragmentState/targets}} 列表中：
                - [=pipeline output=] 类型必须与 |colorState|.{{GPUColorTargetState/format}} 兼容。

                否则:
                - |colorState|.{{GPUColorTargetState/writeMask}} 必须为 0。
</div>

<div algorithm>
    |component| 如果满足以下要求，则是 <dfn>valid GPUBlendComponent</dfn>：
    - 如果 |component|.{{GPUBlendComponent/operation}} 是
        {{GPUBlendOperation/"min"}} 或 {{GPUBlendOperation/"max"}}:
        - |component|.{{GPUBlendComponent/srcFactor}} 和
            |component|.{{GPUBlendComponent/dstFactor}} 必须都是 {{GPUBlendFactor/"one"}}。
</div>

问题：定义 `GPUProgrammableStage` 的“静态使用”事物的范围

### 颜色目标状态 ### {#color-target-state}

<script type=idl>
dictionary GPUColorTargetState {
    required GPUTextureFormat format;

    GPUBlendState blend;
    GPUColorWriteFlags writeMask = 0xF;  // GPUColorWrite.ALL
};
</script>

<script type=idl>
dictionary GPUBlendState {
    required GPUBlendComponent color;
    required GPUBlendComponent alpha;
};
</script>

<script type=idl>
typedef [EnforceRange] unsigned long GPUColorWriteFlags;
[Exposed=(Window, DedicatedWorker)]
namespace GPUColorWrite {
    const GPUFlagsConstant RED   = 0x1;
    const GPUFlagsConstant GREEN = 0x2;
    const GPUFlagsConstant BLUE  = 0x4;
    const GPUFlagsConstant ALPHA = 0x8;
    const GPUFlagsConstant ALL   = 0xF;
};
</script>

#### 混合状态 #### {#blend-state}

<script type=idl>
dictionary GPUBlendComponent {
    GPUBlendOperation operation = "add";
    GPUBlendFactor srcFactor = "one";
    GPUBlendFactor dstFactor = "zero";
};
</script>

<script type=idl>
enum GPUBlendFactor {
    "zero",
    "one",
    "src",
    "one-minus-src",
    "src-alpha",
    "one-minus-src-alpha",
    "dst",
    "one-minus-dst",
    "dst-alpha",
    "one-minus-dst-alpha",
    "src-alpha-saturated",
    "constant",
    "one-minus-constant",
};
</script>

<script type=idl>
enum GPUBlendOperation {
    "add",
    "subtract",
    "reverse-subtract",
    "min",
    "max",
};
</script>

### 深度/模板状态 ### {#depth-stencil-state}

<script type=idl>
dictionary GPUDepthStencilState {
    required GPUTextureFormat format;

    boolean depthWriteEnabled = false;
    GPUCompareFunction depthCompare = "always";

    GPUStencilFaceState stencilFront = {};
    GPUStencilFaceState stencilBack = {};

    GPUStencilValue stencilReadMask = 0xFFFFFFFF;
    GPUStencilValue stencilWriteMask = 0xFFFFFFFF;

    GPUDepthBias depthBias = 0;
    float depthBiasSlopeScale = 0;
    float depthBiasClamp = 0;
};
</script>

<script type=idl>
dictionary GPUStencilFaceState {
    GPUCompareFunction compare = "always";
    GPUStencilOperation failOp = "keep";
    GPUStencilOperation depthFailOp = "keep";
    GPUStencilOperation passOp = "keep";
};
</script>

<script type=idl>
enum GPUStencilOperation {
    "keep",
    "zero",
    "replace",
    "invert",
    "increment-clamp",
    "decrement-clamp",
    "increment-wrap",
    "decrement-wrap",
};
</script>

<div algorithm>
    <dfn abstract-op>validating GPUDepthStencilState</dfn>(descriptor)
    **参数:**
        - {{GPUDepthStencilState}} |descriptor|

    返回 `true`，当且仅当满足以下所有条件：

        - |descriptor|.{{GPUDepthStencilState/format}}为[=depth-or-stencil format=]。
        - 如果 |descriptor|.{{GPUDepthStencilState/depthWriteEnabled}} 是 `true` 或者
            |descriptor|.{{GPUDepthStencilState/depthCompare}} 不是 {{GPUCompareFunction/"always"}}:
            - |descriptor|.{{GPUDepthStencilState/format}} 必须有一个深度组件。
        - 如果 |descriptor|.{{GPUDepthStencilState/stencilFront}} 或者
            |descriptor|.{{GPUDepthStencilState/stencilBack}} 都不是默认值：
            - |descriptor|.{{GPUDepthStencilState/format}} 必须有一个模板组件。

    问题：该算法如何支持在扩展中添加的深度/模板格式？
</div>

### 顶点状态 ### {#vertex-state}

<script type=idl>
enum GPUIndexFormat {
    "uint16",
    "uint32",
};
</script>

索引格式决定了缓冲区中索引值的数据类型，当与带状基元拓扑（{{GPUPrimitiveTopology/"line-strip"}} 或
{{GPUPrimitiveTopology/"triangle-strip"}}) 还指定了图元重启值。
<dfn dfn>primitive restart value</dfn> 指示哪个索引值指示应该启动新的图元，而不是继续使用先前索引的顶点构造三角形条。

{{GPUPrimitiveState}} 指定条带基元拓扑必须指定 {{GPUPrimitiveState/stripIndexFormat}}
以便在管道创建时知道将使用的 [=primitive restart value=]。
指定列表基元拓扑的 {{GPUPrimitiveState}} 必须将 {{GPUPrimitiveState/stripIndexFormat}} 设置为 `undefined`，
并且在渲染时将使用传递给 {{GPURenderEncoderBase/setIndexBuffer()}} 的索引格式。

<table class="data">
  <thead>
    <tr>
      <th>Index format</th>
      <th>Byte size</th>
      <th>Primitive restart value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>{{GPUIndexFormat/"uint16"}}</td>
      <td>2</td>
      <td>0xFFFF</td>
    </tr>
    <tr>
      <td>{{GPUIndexFormat/"uint32"}}</td>
      <td>4</td>
      <td>0xFFFFFFFF</td>
    </tr>
  </tbody>
</table>

#### 顶点格式 #### {#vertex-formats}

格式的名称指定了组件的顺序、每个组件的位数、
和组件的<dfn dfn>vertex data type</dfn>。

  * `unorm` = unsigned normalized
  * `snorm` = signed normalized
  * `uint` = unsigned int
  * `sint` = signed int
  * `float` = floating point

<script type=idl>
enum GPUVertexFormat {
    "uint8x2",
    "uint8x4",
    "sint8x2",
    "sint8x4",
    "unorm8x2",
    "unorm8x4",
    "snorm8x2",
    "snorm8x4",
    "uint16x2",
    "uint16x4",
    "sint16x2",
    "sint16x4",
    "unorm16x2",
    "unorm16x4",
    "snorm16x2",
    "snorm16x4",
    "float16x2",
    "float16x4",
    "float32",
    "float32x2",
    "float32x3",
    "float32x4",
    "uint32",
    "uint32x2",
    "uint32x3",
    "uint32x4",
    "sint32",
    "sint32x2",
    "sint32x3",
    "sint32x4",
};
</script>

多分量格式指定“x”后的分量数。
因此，{{GPUVertexFormat/"sint32x3"}} 表示着色器中 `i32` 值的 3 分量向量。

<script type=idl>
enum GPUVertexStepMode {
    "vertex",
    "instance",
};
</script>

步进模式配置如何根据当前顶点或实例索引计算顶点缓冲区数据的地址：
<dl class="switch">
    : {{GPUVertexStepMode/"vertex"}}
    :: 每个顶点的地址前移 {{GPUVertexBufferLayout/arrayStride}}，
        并在实例之间重置。
    : {{GPUVertexStepMode/"instance"}}
    :: 每个实例的地址都增加了 {{GPUVertexBufferLayout/arrayStride}}。
</dl>

<script type=idl>
dictionary GPUVertexState : GPUProgrammableStage {
    sequence<GPUVertexBufferLayout?> buffers = [];
};
</script>

从概念上讲，<dfn dfn>vertex buffer</dfn> 是将缓冲区内存视为*结构数组* 的视图。
{{GPUVertexBufferLayout/arrayStride}} 是该数组的 *elements* 之间的步幅（以字节为单位）。
顶点缓冲区的每个元素就像一个*结构*，其内存布局由其定义
{{GPUVertexBufferLayout/attributes}}，描述结构的*成员*。

每个 {{GPUVertexAttribute}} 描述了它的
{{GPUVertexAttribute/format}} 及其
{{GPUVertexAttribute/offset}}，以字节为单位，在结构中。

每个属性在顶点着色器中显示为单独的输入，每个属性都由数字 *location* 绑定，
由 {{GPUVertexAttribute/shaderLocation}} 指定。
{{GPUVertexState}} 中的每个位置都必须是唯一的。

<script type=idl>
dictionary GPUVertexBufferLayout {
    required GPUSize64 arrayStride;
    GPUVertexStepMode stepMode = "vertex";
    required sequence<GPUVertexAttribute> attributes;
};
</script>

<script type=idl>
dictionary GPUVertexAttribute {
    required GPUVertexFormat format;
    required GPUSize64 offset;

    required GPUIndex32 shaderLocation;
};
</script>

<div algorithm>
    <dfn abstract-op>validating GPUVertexBufferLayout</dfn>(device, descriptor, vertexStage)
    **参数:**
        - {{GPUDevice}} |device|
        - {{GPUVertexBufferLayout}} |descriptor|
        - {{GPUProgrammableStage}} |vertexStage|

    返回 `true`，当且仅当满足以下所有条件：

        - |descriptor|.{{GPUVertexBufferLayout/arrayStride}} &le;
            |device|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxVertexBufferArrayStride}}.
        - |descriptor|.{{GPUVertexBufferLayout/arrayStride}} 是 4 的倍数/
        - 对于每个属性 |attrib| 在列表中 |descriptor|.{{GPUVertexBufferLayout/attributes}}:
            - 如果 |descriptor|.{{GPUVertexBufferLayout/arrayStride}} 是 0:
                - |attrib|.{{GPUVertexAttribute/offset}} + sizeof(|attrib|.{{GPUVertexAttribute/format}}) &le;
                    |device|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxVertexBufferArrayStride}}.

                否则:
                - |attrib|.{{GPUVertexAttribute/offset}} + sizeof(|attrib|.{{GPUVertexAttribute/format}}) &le;
                    |descriptor|.{{GPUVertexBufferLayout/arrayStride}}.
            - |attrib|.{{GPUVertexAttribute/offset}} 是 4 和 sizeof(|attrib|.{{GPUVertexAttribute/format}}) 中最小值的倍数。
            - |attrib|.{{GPUVertexAttribute/shaderLocation}} 比
                |device|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxVertexAttributes}} 小。
        - 对于 |vertexStage|.{{GPUProgrammableStage/module}} 的着色器反射中的每个顶点属性，
            即 |vertexStage|.{{GPUProgrammableStage/entryPoint}} 的 [=pipeline input=]，
            都有一个对应的 |attrib| |descriptor|.{{GPUVertexBufferLayout/attributes}} 的元素满足以下所有条件：
            - 着色器格式与 |attrib| 兼容。{{GPUVertexAttribute/format}} 的 [=vertex data type=]:
                <dl class="switch">
                    : "unorm", "snorm", 或 "float"
                    :: 着色器格式必须为 `f32` 或 `vecN<f32>`。
                    : "uint"
                    :: 着色器格式必须为 `u32` 或 `vecN<u32>`。
                    : "sint"
                    :: 着色器格式必须为 `i32` or `vecN<i32>`。
                </dl>
            - 着色器的地址为 |attrib|.{{GPUVertexAttribute/shaderLocation}}.
</div>

<div algorithm>
    <dfn abstract-op>validating GPUVertexState</dfn>(device, descriptor)
    **参数:**
        - {{GPUDevice}} |device|
        - {{GPUVertexState}} |descriptor|

    返回 `true`，当且仅当满足以下所有条件：

        - |descriptor|.{{GPUVertexState/buffers}}.length 小于或等于
            |device|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxVertexBuffers}}.
        - 每个 |vertexBuffer| 列表中的布局描述符 |descriptor|.{{GPUVertexState/buffers}}
            通过 [$validating GPUVertexBufferLayout$](|device|, |vertexBuffer|, |descriptor|)
        - |vertexBuffer|.{{GPUVertexBufferLayout/attributes}}.length 在
            |descriptor|.{{GPUVertexState/buffers}} 中的每个 |vertexBuffer| 上的总和，
            小于或等于 |device|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxVertexAttributes}}。
        - 每个|attrib| 在 |descriptor|.{{GPUVertexState/buffers}} 的所有 {{GPUVertexAttribute}} 的联合中，有一个不同的
            |attrib|.{{GPUVertexAttribute/shaderLocation}} 值。
</div>


# 命令缓冲区 # {#command-buffers}

命令缓冲区是预先记录的[=GPU command=]列表，可以提交给{{GPUQueue}}执行。每个<dfn dfn>GPU command</dfn>代表一个要在GPU上执行的任务，例如设置状态、绘图、复制资源等。

## <dfn interface>GPUCommandBuffer</dfn> ## {#command-buffer}

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUCommandBuffer {
};
GPUCommandBuffer includes GPUObjectBase;
</script>

{{GPUCommandBuffer}}有以下内部插槽:

<dl dfn-type=attribute dfn-for="GPUCommandBuffer">
    : <dfn>\[[command_list]]</dfn> of type [=list=]&lt;[=GPU command=]&gt;.
    ::
        当这个命令缓冲被提交时，一个[=GPU command=]的[=list=]会在[=Queue timeline=]上被执行。
</dl>

### 创建 ### {#command-buffer-creation}

<script type=idl>
dictionary GPUCommandBufferDescriptor : GPUObjectDescriptorBase {
};
</script>


# 命令编码 # {#command-encoding}

## <dfn interface>GPUCommandsMixin</dfn> ## {#commands-mixin}

{{GPUCommandsMixin}} 定义了所有编码命令的接口共有的状态。它没有方法。

<script type=idl>
interface mixin GPUCommandsMixin {
};
</script>

{{GPUCommandsMixin}}将以下内部插槽添加到包含它的接口：

<dl dfn-type=attribute dfn-for=GPUCommandsMixin>
    : <dfn>\[[state]]</dfn>, 类型为[=encoder state=]
    ::
        编码器的当前状态，最初设置为“[=encoder state/open=]”。

    : <dfn>\[[commands]]</dfn>, 类型为[=list=]&lt;[=GPU command=]&gt;
    ::
        当包含这些命令的 {{GPUCommandBuffer}} 被提交时，[=GPU commands=] 的 [=list=] 将在 [=Queue Timeline=] 上执行。
</dl>

<dfn dfn>编码器状态</dfn>可能是以下之一：

<dl dfn-type=dfn dfn-for="encoder state">
    : "<dfn>open</dfn>"
    ::
        编码器可用于对新命令进行编码。

    : "<dfn>locked</dfn>"
    ::
        无法使用编码器，因为它被子编码器锁定：它是一个 {{GPUCommandEncoder}}，并且一个 {{GPURenderPassEncoder}} 或 {{GPUComputePassEncoder}} 处于活动状态。当传递结束时，编码器再次变为“[=编码器状态/打开=]”。

        在此状态下发出的任何命令都会使编码器[=invalid=]。

    : "<dfn>ended</dfn>"
    ::
        编码器已结束，无法再对新命令进行编码。

        在此状态下发出的任何命令都会生成 {{GPUValidationError}}。
</dl>

<div algorithm>
    To <dfn abstract-op>Prepare the encoder state</dfn> of {{GPUCommandsMixin}} |encoder|:

    如果 |encoder|.{{GPUCommandsMixin/[[state]]}} 为:
    <dl class=switch>
        : "[=encoder state/open=]"
        :: 返回 `true`.

        : "[=encoder state/locked=]"
        :: 使 |encoder| [=invalid=], 返回 `false`.

        : "[=encoder state/ended=]"
        :: 在当前范围内产生一个{{GPUValidationError}}，并返回 `false`
    </dl>
</div>

## <dfn interface>GPUCommandEncoder</dfn> ## {#command-encoder}

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUCommandEncoder {
    GPURenderPassEncoder beginRenderPass(GPURenderPassDescriptor descriptor);
    GPUComputePassEncoder beginComputePass(optional GPUComputePassDescriptor descriptor = {});

    undefined copyBufferToBuffer(
        GPUBuffer source,
        GPUSize64 sourceOffset,
        GPUBuffer destination,
        GPUSize64 destinationOffset,
        GPUSize64 size);

    undefined copyBufferToTexture(
        GPUImageCopyBuffer source,
        GPUImageCopyTexture destination,
        GPUExtent3D copySize);

    undefined copyTextureToBuffer(
        GPUImageCopyTexture source,
        GPUImageCopyBuffer destination,
        GPUExtent3D copySize);

    undefined copyTextureToTexture(
        GPUImageCopyTexture source,
        GPUImageCopyTexture destination,
        GPUExtent3D copySize);
    
    undefined clearBuffer(
        GPUBuffer buffer,
        optional GPUSize64 offset = 0,
        optional GPUSize64 size);

    undefined writeTimestamp(GPUQuerySet querySet, GPUSize32 queryIndex);

    undefined resolveQuerySet(
        GPUQuerySet querySet,
        GPUSize32 firstQuery,
        GPUSize32 queryCount,
        GPUBuffer destination,
        GPUSize64 destinationOffset);

    GPUCommandBuffer finish(optional GPUCommandBufferDescriptor descriptor = {});
};
GPUCommandEncoder includes GPUObjectBase;
GPUCommandEncoder includes GPUCommandsMixin;
GPUCommandEncoder includes GPUDebugCommandsMixin;
</script>

### 创建 ### {#command-encoder-creation}

<script type=idl>
dictionary GPUCommandEncoderDescriptor : GPUObjectDescriptorBase {
};
</script>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createCommandEncoder(descriptor)</dfn>
    ::
        创建一个{{GPUCommandEncoder}}。

        <div algorithm=GPUDevice.createCommandEncoder>
            **Called on:** {{GPUDevice}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/createCommandEncoder(descriptor)">
                descriptor: 要创建的{{GPUCommandEncoder}}的描述。
            </pre>

            **Returns:** {{GPUCommandEncoder}}

            问题：描述{{GPUDevice/createCommandEncoder()}}算法步骤。
        </div>
</dl>

<div class="example">
    创建一个 {{GPUCommandEncoder}}，编码一条清理缓存的命令，结束编码器以得到 {{GPUCommandBuffer}}，之后提交其至 {{GPUQueue}}。
    <pre highlight="js">
        const commandEncoder = gpuDevice.createCommandEncoder();
        commandEncoder.clearBuffer(buffer);
        const commandBuffer = commandEncoder.finish();
        gpuDevice.queue.submit([commandBuffer]);
    </pre>
</div>

## 通道编码 ## {#command-encoder-pass-encoding}

<dl dfn-type=method dfn-for=GPUCommandEncoder>
    : <dfn>beginRenderPass(descriptor)</dfn>
    ::
        Begins encoding a render pass described by |descriptor|.

        <div algorithm=GPUCommandEncoder.beginRenderPass>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/beginRenderPass(descriptor)">
                |descriptor|: 要创建的{{GPURenderPassEncoder}}的描述。
            </pre>

            **Returns:** {{GPURenderPassEncoder}}

            在|this|的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                1. 使|pass|为一个新的{{GPURenderPassEncoder}}对象。
                2. 如果以下任何条件没有满足，产生一个校验错误并停止。
                    <div class=validusage>
                        - |this|.{{GPUCommandsMixin/[[state]]}}为"[=encoder state/open=]"。
                        - |descriptor|满足[$GPURenderPassDescriptor/Valid Usage$]规则。
                        - |descriptor|.{{GPURenderPassDescriptor/timestampWrites}}为空，或
                            |this|.{{GPUObjectBase/[[device]]}}.{{device/[[features]]}}包括（[=list/contain=]）
                            {{GPUFeatureName/"timestamp-query"}}。
                        - For each |timestampWrite| in |descriptor|.{{GPURenderPassDescriptor/timestampWrites}},
                            - |timestampWrite|.{{GPURenderPassTimestampWrite/querySet}}可以与|this|一起有效使用（[$valid to use with$]）。
                    </div>
                3. 设置|this|.{{GPUCommandsMixin/[[state]]}}为"[=encoder state/locked=]"。
                4. 对每个|descriptor|.{{GPURenderPassDescriptor/colorAttachments}}中的|colorAttachment|:
                    1. |colorAttachment|.{{GPURenderPassColorAttachment/view}}看到的[=texture subresource=]被视为在渲染通道期间用作[=internal usage/attachment=]。
                5. 设置|depthStencilAttachment|为|descriptor|.{{GPURenderPassDescriptor/depthStencilAttachment}}。
                6. 如果|depthStencilAttachment|不是 `null`:
                    1. 设置|depthStencilView|为|depthStencilAttachment|.{{GPURenderPassDepthStencilAttachment/view}}。
                    2. 如果|depthStencilAttachment|.{{GPURenderPassDepthStencilAttachment/depthReadOnly}}和{{GPURenderPassDepthStencilAttachment/stencilReadOnly}}设置了值：
                        1. |depthStencilView|看到的[=texture subresource=]被视为在渲染通道期间用作[=internal usage/attachment-read=]。
                        
                        问题：用“一组子资源”算法来描述此算法。
                    3. 否则, |depthStencilView|看到的[=texture subresource=]被视为在渲染通道期间用作[=internal usage/attachment=]。
                    4. 设置|pass|.{{GPURenderEncoderBase/[[depthReadOnly]]}}为|depthStencilAttachment|.{{GPURenderPassDepthStencilAttachment/depthReadOnly}}。
                    5. 设置|pass|.{{GPURenderEncoderBase/[[stencilReadOnly]]}}为|depthStencilAttachment|.{{GPURenderPassDepthStencilAttachment/stencilReadOnly}}。
                7. 设置|pass|.{{GPURenderEncoderBase/[[layout]]}}为[$derive render targets layout from pass$](|descriptor|)。
                8. 对每个|descriptor|.{{GPURenderPassDescriptor/timestampWrites}}中的|timestampWrite|,
                    1. 如果|timestampWrite|.{{GPURenderPassTimestampWrite/location}}为{{GPURenderPassTimestampLocation/"beginning"}},
                        添加（[=list/Append=]）一个[=GPU command=]至|pass|.{{GPUProgrammablePassEncoder/[[command_encoder]]}}.{{GPUCommandsMixin/[[commands]]}}，将GPU时间戳值写入|timestampWrite|.{{GPURenderPassTimestampWrite/querySet}}的|timestampWrite|.{{GPURenderPassTimestampWrite/queryIndex}}索引处。
                    2. 否则，|timestampWrite|.{{GPURenderPassTimestampWrite/location}}为{{GPURenderPassTimestampLocation/"end"}}，添加|timestampWrite|至|pass|.{{GPURenderPassEncoder/[[endTimestampWrites]]}}。
                9. 问题：入队附件加载/清除。
                10. 返回|pass|。
            </div>

            问题：指定只读深度/模板的行为。
        </div>

    : <dfn>beginComputePass(descriptor)</dfn>
    ::
        开始对|descriptor|描述的compute pass进行编码。

        <div algorithm=GPUCommandEncoder.beginComputePass>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/beginComputePass(descriptor)">
                descriptor:
            </pre>

            **Returns:** {{GPUComputePassEncoder}}

            在|this|的[=Device timeline=]上发起如下步骤：
            <div class=device-timeline>
                1. 如果以下任何条件没有满足，产生一个校验错误并停止。
                    <div class=validusage>
                        - |this|.{{GPUCommandsMixin/[[state]]}}为"[=encoder state/open=]"。
                        - |descriptor|.{{GPUComputePassDescriptor/timestampWrites}}为空，或
                            |this|.{{GPUObjectBase/[[device]]}}.{{device/[[features]]}} [=list/contain=]s
                            {{GPUFeatureName/"timestamp-query"}}.
                        - 对每个|descriptor|.{{GPUComputePassDescriptor/timestampWrites}}中的|timestampWrite|，
                            - |timestampWrite|.{{GPUComputePassTimestampWrite/querySet}} is [$valid to use with$] |this|.
                    </div>
                2. 设置|this|.{{GPUCommandsMixin/[[state]]}}为"[=encoder state/locked=]"。
                3. 设置|pass|为一个新的{{GPUComputePassEncoder}}对象。
                4. 对每个|descriptor|.{{GPUComputePassDescriptor/timestampWrites}}中的|timestampWrite|，
                    1. 如果|timestampWrite|.{{GPUComputePassTimestampWrite/location}}为{{GPUComputePassTimestampLocation/"beginning"}}，
                        添加（[=list/Append=]一个[=GPU command=]至|pass|.{{GPUProgrammablePassEncoder/[[command_encoder]]}}.{{GPUCommandsMixin/[[commands]]}}，将GPU时间戳值写入|timestampWrite|.{{GPUComputePassTimestampWrite/querySet}}中的|timestampWrite|.{{GPUComputePassTimestampWrite/queryIndex}}索引处。
                        index in |timestampWrite|.{{GPUComputePassTimestampWrite/querySet}}.
                    2. 否则，Otherwise, 如果|timestampWrite|.{{GPUComputePassTimestampWrite/location}}为{{GPUComputePassTimestampLocation/"end"}}，则添加（[=list/Append=]）|timestampWrite| 至 |pass|.{{GPUComputePassEncoder/[[endTimestampWrites]]}}。
                5. 返回|pass|。
            </div>
        </div>
</dl>

## 拷贝命令 ## {#copy-commands}

问题：这些字典定义应该在图像副本部分内。

### <dfn dictionary>GPUImageDataLayout</dfn> ### {#gpu-image-data-layout}

<script type=idl>
dictionary GPUImageDataLayout {
    GPUSize64 offset = 0;
    GPUSize32 bytesPerRow;
    GPUSize32 rowsPerImage;
};
</script>

{{GPUImageDataLayout}}是一些线性内存中的图像（<dfn dfn>images</dfn>）布局。它在[=texture=]和[=buffer=]之间复制数据时使用，或者在调度{{GPUQueue}}[=texture=]写入时使用。

  - 对于{{GPUTextureDimension/2d}}纹理，数据在一个或多个毗邻的[=images=]和[=array layers=]之间复制。
  - 对于{{GPUTextureDimension/3d}}纹理，数据在一个或多个毗邻的[=images=]和深度[=slices=]之间复制。

问题：更精确地定义图像，特别地，将它们定义为由[=texel blocks=]组成。

在字节数组和纹理之间复制的操作始终适用于[=texel block=]的行，我们将其称为<dfn dfn>block row</dfn>。不能只更新[=texel block=]的一部分。

[=Texel blocks=]被紧密地封装在图像副本的线性内存布局中的每个[=block row=]中，每个后续的纹素块都紧跟在前一个纹素块之后，没有填充。
这包括copying-depth-stencil到/来自[=depth-or-stencil format=]纹理的特定方面：模板值紧密地打包在字节数组中；深度值紧密地封装在适当类型（“depth16unorm”或“depth32float”）的数组中。

问题：通过参考复制方法共享的通用算法，定义精确的复制语义。

<dl dfn-type=dict-member dfn-for=GPUImageDataLayout>
    : <dfn>bytesPerRow</dfn>
    ::
        每个[=block row=]的开头和后续[=block row=]之间的步幅（以字节为单位）。

        如果有多个[=block row=]则为必须项(即，副本高度或深度大于一块)。

    : <dfn>rowsPerImage</dfn>
    ::
        每个纹理图像的[=block row=]数。{{GPUImageDataLayout/rowsPerImage}} &times;
        {{GPUImageDataLayout/bytesPerRow}}是每个数据[=images=]的开头和后续[=images=]之间的步幅（以字节为单位）。

        如果有多个[=images=]则为必须项(即，副本高度大于一)。
</dl>

### <dfn dictionary>GPUImageCopyBuffer</dfn> ### {#gpu-image-copy-buffer}

在图像复制（[=image copy=]）操作中，{{GPUImageCopyBuffer}}定义了一个{{GPUBuffer}}，并与 `copySize` 一起，定义了图像数据在缓冲区内存中如何布局（请参阅 GPUImageDataLayout）。

<script type=idl>
dictionary GPUImageCopyBuffer : GPUImageDataLayout {
    required GPUBuffer buffer;
};
</script>

<div algorithm class=validusage>
<dfn abstract-op>validating GPUImageCopyBuffer</dfn>

  **Arguments:**
    - {{GPUImageCopyBuffer}} |imageCopyBuffer|

  **Returns:** {{boolean}}

  当且仅当所有以下条件都满足时，返回 `true`。
    - |imageCopyBuffer|.{{GPUImageCopyBuffer/buffer}}必须是一个[=valid=]{{GPUBuffer}}。
    - |imageCopyBuffer|.{{GPUImageDataLayout/bytesPerRow}}必须是256的倍数。

</div>

### <dfn dictionary>GPUImageCopyTexture</dfn> ### {#gpu-image-copy-texture}

在图像复制（[=image copy=]）操作中，{{GPUImageCopyTexture}}定义了一个{{GPUTexture}}，并与 `copySize` 一起定义了纹理的子区域（跨越相同 mip-map 级别的一个或多个连续[=texture subresource=]）。

<script type=idl>
dictionary GPUImageCopyTexture {
    required GPUTexture texture;
    GPUIntegerCoordinate mipLevel = 0;
    GPUOrigin3D origin = {};
    GPUTextureAspect aspect = "all";
};
</script>

<dl dfn-type=dict-member dfn-for=GPUImageCopyTexture>
    : <dfn>texture</dfn>
    ::
        要复制到/从的纹理。

    : <dfn>mipLevel</dfn>
    ::
        要复制到/从的{{GPUImageCopyTexture/texture}}的Mip-map级别。

    : <dfn>origin</dfn>
    ::
        定义复制的原点 - 要复制到/从的纹理子区域的最小角。与 `copySize` 一起定义完整复制子区域。

    : <dfn>aspect</dfn>
    ::
        定义要复制到/从纹理的宽高比。
</dl>

<div algorithm class=validusage>
<dfn abstract-op>validating GPUImageCopyTexture</dfn>

  **Arguments:**
    - {{GPUImageCopyTexture}} |imageCopyTexture|
    - {{GPUExtent3D}} |copySize|

  **Returns:** {{boolean}}

  使:
  - |blockWidth|为|imageCopyTexture|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/format}}的[=texel block width=]。
  - |blockHeight|为|imageCopyTexture|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/format}}的[=texel block height=]。

  当且仅当以下所有条件都满足时，返回 `true`：
  - |imageCopyTexture|.{{GPUImageCopyTexture/texture}}必须为一个[=valid=]{{GPUTexture}}.
  - |imageCopyTexture|.{{GPUImageCopyTexture/mipLevel}}必须小于|imageCopyTexture|.{{GPUImageCopyTexture/texture}}的{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/mipLevelCount}}。
  - |imageCopyTexture|.{{GPUImageCopyTexture/origin}}.[=Origin3D/x=]必须是|blockWidth|的倍数。
  - |imageCopyTexture|.{{GPUImageCopyTexture/origin}}.[=Origin3D/y=]必须是|blockHeight|的倍数。
  - 如果满足以下任一条件，则|imageCopyTexture|的[=imageCopyTexture subresource size=]等于|copySize|：
        - |imageCopyTexture|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/format}}是一个depth-stencil格式。
        - |imageCopyTexture|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/sampleCount}}大于1。

</div>

问题(gpuweb/gpuweb#69)：使用{{GPUTextureDimension/1d}}和{{GPUTextureDimension/3d}}纹理定义副本。

### <dfn dictionary>GPUImageCopyTextureTagged</dfn> ### {#gpu-image-copy-texture-tagged}

WebGPU纹理保存原始数字数据，并且没有用描述颜色的语义元数据标记。 但是，{{GPUQueue/copyExternalImageToTexture()}}从描述颜色的来源进行复制。

一个{{GPUImageCopyTextureTagged}}是一个{{GPUImageCopyTexture}}，它额外标记了颜色空间/编码和alpha预乘元数据，以便可以在复制期间保留语义颜色数据。
此元数据仅影响{{GPUQueue/copyExternalImageToTexture()}}操作的语义，而不是目标纹理的语义。

<script type=idl>
dictionary GPUImageCopyTextureTagged : GPUImageCopyTexture {
    GPUPredefinedColorSpace colorSpace = "srgb";
    boolean premultipliedAlpha = false;
};
</script>

<dl dfn-type=dict-member dfn-for=GPUImageCopyTextureTagged>
    : <dfn>colorSpace</dfn>
    ::
        描述用于将数据编码到目标纹理中的颜色空间和编码。

        此[[#color-space-conversions|may result]]在范围[0, 1]之外的值被写入目标纹理，如果它的格式可以表示它们。否则，结果将被限制在目标纹理格式的范围内。

        Note:
        注意：如果{{GPUImageCopyTextureTagged/colorSpace}}与源图像匹配，则不会发生转换。 {{ImageBitmap}}颜色空间标记和转换可以通过{{ImageBitmapOptions}}进行控制。

    : <dfn>premultipliedAlpha</dfn>
    ::
        描述写入纹理的数据是否应将其RGB通道预乘以Alpha通道。

        如果此选项设置为 `true`并且{{GPUImageCopyExternalImage/source}}也预乘，则即使源RGB值超过其相应的alpha值，也必须保留它们。

        注意：如果{{GPUImageCopyTextureTagged/premultipliedAlpha}}与源图像匹配，则不会发生转换。2d画布总是被预乘，而WebGL画布可以通过<l spec=html>[=WebGLContextAttributes=]</l>控制。{{ImageBitmap}}预乘可以通过{{ImageBitmapOptions}}控制。
</dl>

问题：将颜色值的编码定义（并测试）为{{GPUQueue/copyExternalImageToTexture()}}允许的各种编码。

### <dfn dictionary>GPUImageCopyExternalImage</dfn> ### {#gpu-image-copy-external-image}

<script type=idl>
dictionary GPUImageCopyExternalImage {
    required (ImageBitmap or HTMLCanvasElement or OffscreenCanvas) source;
    GPUOrigin2D origin = {};
    boolean flipY = false;
};
</script>

{{GPUImageCopyExternalImage}}有以下成员：

<dl dfn-type=dict-member dfn-for=GPUImageCopyExternalImage>
    : <dfn>source</dfn>
    ::
        图像副本（[=image copy=]）的来源。源数据副本在发出{{GPUQueue/copyExternalImageToTexture()}}时被捕获。

    : <dfn>origin</dfn>
    ::
        定义副本的原点 - 要从中复制的源子区域的最小（top-left）角。与 `copySize` 一起定义完整子区域副本。
    : <dfn>flipY</dfn>
    ::
        描述源图像是否垂直翻转。
        
        如果此选项设置为 `true`，则垂直翻转副本：源区域的底行被复制到目标区域的第一行，依此类推。{{GPUImageCopyExternalImage/origin}} 选项仍然相对于源图像的左上角，向下增加。
</dl>

### 缓冲区副本 ### {#buffer-copies}

<dl dfn-type=method dfn-for=GPUCommandEncoder>
    : <dfn>copyBufferToBuffer(source, sourceOffset, destination, destinationOffset, size)</dfn>
    ::
        将命令编码到{{GPUCommandEncoder}}中，将数据从{{GPUBuffer}}的子区域复制到另一个{{GPUBuffer}}的子区域。

        <div algorithm=GPUCommandEncoder.copyBufferToBuffer>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/copyBufferToBuffer(source, sourceOffset, destination, destinationOffset, size)">
                |source|: 要复制的{{GPUBuffer}}.
                |sourceOffset|: 到要复制的|source|中的字节偏移量。
                |destination|: 要复制到的{{GPUBuffer}}.
                |destinationOffset|: 到要复制到的的|destination|中的字节偏移量。
                |size|: 要复制的字节大小。
            </pre>

            **Returns:** {{undefined}}

            在 |this|.{{GPUObjectBase/[[device]]}} 的 [=Device Timeline=] 上发出以下步骤：
            <div class=device-timeline>
                1. 准备|this|的编码器状态（[$Prepare the encoder state$]）。如果返回 false，则停止。
                1. 如果不满足以下任何条件，则产生一个校验错误并停止。
                    <div class=validusage>
                        - |this|.{{GPUCommandEncoder/[[state]]}}为[=encoder state/open=]状态。
                        - |source|可以和|this|一起有效使用。
                        - |destination|可以和|this|一起有效使用。
                        - |source|.{{GPUBuffer/[[usage]]}}包含{{GPUBufferUsage/COPY_SRC}}。
                        - |destination|.{{GPUBuffer/[[usage]]}}包含{{GPUBufferUsage/COPY_DST}}。
                        - |size|是4的倍数。
                        - |sourceOffset|是4的倍数。
                        - |destinationOffset|是4的倍数。
                        - (|sourceOffset| + |size|)不会溢出{{GPUSize64}}。
                        - (|destinationOffset| + |size|)不会溢出{{GPUSize64}}。
                        - |source|.{{GPUBuffer/[[size]]}}大于等于(|sourceOffset| + |size|)。
                        - |destination|.{{GPUBuffer/[[size]]}}大于等于(|destinationOffset| + |size|)。
                        - |source|和|destination|不是同一个{{GPUBuffer}}。
                    </div>

                    问题(gpuweb/gpuweb#69)：指出如何处理规范中的溢出。
                1. 问题：描述 GPU 命令并将其排入队列。
            </div>
        </div>
</dl>

### 缓冲区填充 ### {#buffer-fills}

<dl dfn-type=method dfn-for=GPUCommandEncoder>
    : <dfn>clearBuffer(buffer, offset, size)</dfn>
    ::
        将命令编码到{{GPUCommandEncoder}}中，用零填充{{GPUBuffer}}的子区域。

        <div algorithm=GPUCommandEncoder.clearBuffer>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/clearBuffer(buffer, offset, size)">
                |buffer|: 将要清除的{{GPUBuffer}}。
                |offset|: 以字节为单位的偏移量到|buffer|要清除的子区域开始的地方。
                |size|: 要清除的子区域的大小（以字节为单位）。 默认为缓冲区的大小减去 |offset|。
            </pre>

            **Returns:** {{undefined}}

            在|this|.{{GPUObjectBase/[[device]]}}的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                1. 准备|this|的编码器状态（[$Prepare the encoder state$]）。如果返回 false，则停止。
                1. 如果|size|缺失, 设置|size|为 `max(0, |buffer|.{{GPUBuffer/[[size]]}} - |offset|)`。
                1. 如果以下任何条件未满足，生成一个校验错误并停止。
                    <div class=validusage>
                        - |buffer|可以和|this|一起有效使用（[$valid to use with$]）。
                        - |buffer|.{{GPUBuffer/[[usage]]}}包含{{GPUBufferUsage/COPY_DST}}。
                        - |size|为4的倍数。
                        - |offset|为4的倍数。
                        - |buffer|.{{GPUBuffer/[[size]]}}大于或等于(|offset| + |size|)。
                    </div>
            </div>
        </div>
</dl>

### <dfn dfn lt="image copy">Image Copies</dfn> ### {#image-copies}

WebGPU提供{{GPUCommandEncoder/copyBufferToTexture()}}以buffer-to-texture拷贝，{{GPUCommandEncoder/copyTextureToBuffer()}} 以texture-to-buffer拷贝，以及{{GPUQueue/writeTexture()}}以ArrayBuffer-to-texture写入。

以下定义和校验规则对这些方法以及{{GPUCommandEncoder/copyTextureToTexture()}}都应用。

问题：术语“图像拷贝”包括copyTextureToTexture么？

[=imageCopyTexture subresource size=]和[=valid texture copy range=]同样对
{{GPUCommandEncoder/copyTextureToTexture()}}应用。

<div algorithm="imageCopyTexture subresource size">

<dfn dfn>imageCopyTexture subresource size</dfn>

  **Arguments:**
    - {{GPUImageCopyTexture}} |imageCopyTexture|

  **Returns:** {{GPUExtent3D}}

  |imageCopyTexture|的[=imageCopyTexture subresource size=]计算如下:

  它的[=Extent3D/width=], [=Extent3D/height=]和[=Extent3D/depthOrArrayLayers=]分别为=mipmap level=] |imageCopyTexture|.{{GPUImageCopyTexture/mipLevel}}上的|imageCopyTexture|.{{GPUImageCopyTexture/texture}} [=subresource=] [=physical size=]的宽度，高度，和深度。

</div>

问题：将此定义为具有 (texture, mipmapLevel) 参数的算法，并使用调用语法而不是通过标签引用定义。

<div>
    校验线性纹理数据（<dfn abstract-op>validating linear texture data</dfn>(layout, byteSize, format, copyExtent)）

    **Arguments:**
    : {{GPUImageDataLayout}} |layout|
    :: 线性纹理数据的布局。
    : {{GPUSize64}} |byteSize|
    :: 显性数据的总大小，以字节为单位。
    : {{GPUTextureFormat}} |format|
    :: 纹理格式。
    : {{GPUExtent3D}} |copyExtent|
    :: 要复制的纹理的范围。

    1. 使|blockWidth|, |blockHeight|, and |blockSize|为|格式|的[=texel block width=]，[=texel block height|height=]，和[=texel block size|size=]。

    2. 假设|copyExtent|.[=Extent3D/width=]为|blockWidth|的倍数并且|copyExtent|.[=Extent3D/height=]为|blockHeight|的倍数。使:
            - |widthInBlocks|为|copyExtent|.[=Extent3D/width=] &divide; |blockWidth|.
            - |heightInBlocks|为|copyExtent|.[=Extent3D/height=] &divide; |blockHeight|.
            - |bytesInLastRow|为|blockSize| &times; |widthInBlocks|.

    3. 如果以下条件未满足则失败：
        <div class=validusage>
            - 如果|heightInBlocks| &gt; 1，|layout|.{{GPUImageDataLayout/bytesPerRow}}需要被指定。
            - 如果|copyExtent|.[=Extent3D/depthOrArrayLayers=] &gt; 1,
                |layout|.{{GPUImageDataLayout/bytesPerRow}}和|layout|.{{GPUImageDataLayout/rowsPerImage}}需要被指定。
            - 如果被指定，|layout|.{{GPUImageDataLayout/bytesPerRow}}必须大于或等于|bytesInLastRow|。
            - 如果被指定，|layout|.{{GPUImageDataLayout/rowsPerImage}}必须大于或等于|heightInBlocks|。
        </div>

    4. 使|requiredBytesInCopy|为0。

    5. 如果copyExtent|.[=Extent3D/depthOrArrayLayers=] &gt; 1:
        1. 使|bytesPerImage|为
            |layout|.{{GPUImageDataLayout/bytesPerRow}} &times;
            |layout|.{{GPUImageDataLayout/rowsPerImage}}。
        1. 使|bytesBeforeLastImage|为
            |bytesPerImage| &times; (|copyExtent|.[=Extent3D/depthOrArrayLayers=] &minus; 1)。
        1. 将|bytesBeforeLastImage|加至|requiredBytesInCopy|。

    6. 如果|copyExtent|.[=Extent3D/depthOrArrayLayers=] &gt; 0:

        1. 如果|heightInBlocks| &gt; 1, 将
            |layout|.{{GPUImageDataLayout/bytesPerRow}} &times;
            (|heightInBlocks| &minus; 1)
            加至|requiredBytesInCopy|。

        1. 如果|heightInBlocks| &gt; 0, 将
            |bytesInLastRow|加至|requiredBytesInCopy|。

    7. 如果以下条件未满足则失败：
        <div class=validusage>
            - |layout|.{{GPUImageDataLayout/offset}} + |requiredBytesInCopy| &le; |byteSize|。
        </div>
</div>

<div algorithm class=validusage>
    <dfn dfn>Valid Texture Copy Range</dfn>

    给定一个 {{GPUImageCopyTexture}} |imageCopyTexture| 和一个 {{GPUExtent3D}} |copySize|, 使
    - |blockWidth| 为 |imageCopyTexture|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/format}} 的 [=texel block width=].
    - |blockHeight| 为 |imageCopyTexture|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/format}} 的 [=texel block height=].

    应用以下校验:

    - 如果 |imageCopyTexture|.{{GPUImageCopyTexture/texture}} 的 {{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/dimension}} 为
        {{GPUTextureDimension/1d}}:
        - |copySize|.[=Extent3D/height=] 与 [=Extent3D/depthOrArrayLayers=] 都必须为 1.
    - 如果 |imageCopyTexture|.{{GPUImageCopyTexture/texture}} 的 {{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/dimension}} 为
        {{GPUTextureDimension/2d}}:
        -  (|imageCopyTexture|.{{GPUImageCopyTexture/origin}}.[=Origin3D/x=] + |copySize|.[=Extent3D/width=]),
            (|imageCopyTexture|.{{GPUImageCopyTexture/origin}}.[=Origin3D/y=] + |copySize|.[=Extent3D/height=]), 且
            (|imageCopyTexture|.{{GPUImageCopyTexture/origin}}.[=Origin3D/z=] + |copySize|.[=Extent3D/depthOrArrayLayers=])
            必须分别地小于或等于|imageCopyTexture|的[=imageCopyTexture subresource size=]的
            [=Extent3D/width=], [=Extent3D/height=], 和 [=Extent3D/depthOrArrayLayers=]。
        - |copySize|.[=Extent3D/width=]必须为|blockWidth|的倍数。
        - |copySize|.[=Extent3D/height=]必须为|blockHeight|的倍数。
</div>

问题(gpuweb/gpuweb#69): 使用 {{GPUTextureDimension/1d}} 和 {{GPUTextureDimension/3d}} 纹理定义副本

问题(gpuweb/gpuweb#537)：对rowsPerImage附加的限制，如果需要。

问题(gpuweb/gpuweb#652): 定义{{GPUTextureFormat/"depth24plus"}},
{{GPUTextureFormat/"depth24plus-stencil8"}}, 和{{GPUTextureFormat/"stencil8"}}的副本。

问题: 将“有效纹理副本范围”转换为一个带有参数的算法，与“验证线性纹理数据”相似。

<dl dfn-type=method dfn-for=GPUCommandEncoder>
    : <dfn>copyBufferToTexture(source, destination, copySize)</dfn>
    ::
        将命令编码到{{GPUCommandEncoder}}中，将数据从{{GPUBuffer}}的子区域复制到一个或多个连续[=texture subresource=]的子区域。

        <div algorithm=GPUCommandEncoder.copyBufferToTexture>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/copyBufferToTexture(source, destination, copySize)">
                |source|: 结合|copySize|，定义源缓冲区的区域。
                |destination|: 结合复制大小，定义目标[=texture subresource=]的区域。
                |copySize|:
            </pre>

            **Returns:** {{undefined}}

            在 |this|.{{GPUObjectBase/[[device]]}} 的 [=Device Timeline=] 上发出以下步骤：
            <div class=device-timeline>
                1. 准备|this|的编码器状态（[$Prepare the encoder state$]。如果返回 false，则停止。
                1. 如果以下任何条件未满足，则生成一个校验错误并停止。
                    <div class=validusage>
                        - 使|dstTextureDesc|为|destination|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}。
                        - |this|.{{GPUCommandEncoder/[[state]]}}为[=encoder state/open=]。
                        - [$validating GPUImageCopyBuffer$](|source|)返回 `true`。
                        - |source|.{{GPUImageCopyBuffer/buffer}}.{{GPUBuffer/[[usage]]}}包含{{GPUBufferUsage/COPY_SRC}}。
                        - [$validating GPUImageCopyTexture$](|destination|, |copySize|)返回 `true`。
                        - |dstTextureDesc|.{{GPUTextureDescriptor/usage}}包含{{GPUTextureUsage/COPY_DST}}。
                        - |dstTextureDesc|.{{GPUTextureDescriptor/sampleCount}}为1。
                        - 如果|dstTextureDesc|.{{GPUTextureDescriptor/format}}为[=depth-or-stencil format=]：
                            - |destination|.{{GPUImageCopyTexture/aspect}}必须指向一个|dstTextureDesc|.{{GPUTextureDescriptor/format}}的单个宽高比。并且该宽高比必须为一个按照[[#depth-formats]]的有效图片副本目标。
                        - 如果|dstTextureDesc|.{{GPUTextureDescriptor/format}}不是[=depth-or-stencil format=]：
                            - |source|.{{GPUImageDataLayout/offset}}为|dstTextureDesc|.{{GPUTextureDescriptor/format}}的[=texel block size=]的倍数。
                        - 如果|dstTextureDesc|.{{GPUTextureDescriptor/format}}是[=depth-or-stencil format=]：
                            - |source|.{{GPUImageDataLayout/offset}}为4的倍数。
                        - [$validating linear texture data$](|source|,
                            |source|.{{GPUImageCopyBuffer/buffer}}.{{GPUBuffer/[[size]]}},
                            |dstTextureDesc|.{{GPUTextureDescriptor/format}},
                            |copySize|)成功。
                    </div>
            </div>
        </div>

    : <dfn>copyTextureToBuffer(source, destination, copySize)</dfn>
    ::
        将命令编码到{{GPUCommandEncoder}}中，将数据从一个或多个连续[=texture subresource=]的子区域复制到{{GPUBuffer}}的子区域。

        <div algorithm=GPUCommandEncoder.copyTextureToBuffer>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/copyTextureToBuffer(source, destination, copySize)">
                |source|: 结合|copySize|，定义源[=texture subresource=]的区域。
                |destination|: 结合|copySize|，定义目标缓冲区的区域。
                |copySize|:
            </pre>

            **Returns:** {{undefined}}

            在 |this|.{{GPUObjectBase/[[device]]}} 的 [=Device Timeline=] 上发出以下步骤：
            <div class=device-timeline>
                1. 准备|this|的编码器状态。如果返回false，则停止。
                1. 如果以下任何条件未满足，产生一个校验错误并停止。
                    <div class=validusage>
                        - Let |srcTextureDesc|为|source|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}。
                        - [$validating GPUImageCopyTexture$](|source|, |copySize|)返回 `true`。
                        - |srcTextureDesc|.{{GPUTextureDescriptor/usage}}包含{{GPUTextureUsage/COPY_SRC}}。
                        - |srcTextureDesc|.{{GPUTextureDescriptor/sampleCount}}为1。
                        - 如果|srcTextureDesc|.{{GPUTextureDescriptor/format}}为depth-stencil格式:
                            - |destination|.{{GPUImageCopyTexture/aspect}}必须指向一个|srcTextureDesc|.{{GPUTextureDescriptor/format}}的单个宽高比，并且此宽高比必须为一个按照[[#depth-formats]]有效的图像拷贝源。
                        - [$validating GPUImageCopyBuffer$](|destination|)返回 `true`。
                        - |destination|.{{GPUImageCopyBuffer/buffer}}.{{GPUBuffer/[[usage]]}}包含{{GPUBufferUsage/COPY_DST}}。
                        - [=Valid Texture Copy Range=]应用至|destination|和|copySize|。
                        - 如果|srcTextureDesc|.{{GPUTextureDescriptor/format}}不是[=depth-or-stencil format=]：
                            - |destination|.{{GPUImageDataLayout/offset}}|srcTextureDesc|.{{GPUTextureDescriptor/format}}的[=texel block size=]的倍数。
                        - 如果|srcTextureDesc|.{{GPUTextureDescriptor/format}}是[=depth-or-stencil format=]：
                            - |destination|.{{GPUImageDataLayout/offset}}是4的倍数。
                        - [$validating linear texture data$](|destination|,
                            |destination|.{{GPUImageCopyBuffer/buffer}}.{{GPUBuffer/[[size]]}},
                            |srcTextureDesc|.{{GPUTextureDescriptor/format}},
                            |copySize|)成功。
                    </div>
            </div>
        </div>

    : <dfn>copyTextureToTexture(source, destination, copySize)</dfn>
    ::
        将命令编码到{{GPUCommandEncoder}}中，该命令将数据从一个或多个连续[=texture subresource=]的子区域复制到一个或多个连续[=texture subresource=]的另一个子区域。

        <div algorithm=GPUCommandEncoder.copyTextureToTexture>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/copyTextureToTexture(source, destination, copySize)">
                |source|: 结合|copySize|，定义源[=texture subresource=]的区域。
                |destination|: 结合|copySize|，定义目标[=texture subresource=]的区域。
                |copySize|:
            </pre>

            **Returns:** {{undefined}}

            在 |this|.{{GPUObjectBase/[[device]]}} 的 [=Device Timeline=] 上发出以下步骤：
            <div class=device-timeline>
                1. 准备|this|的编码器状态。如果返回 false，则停止。
                1. 如果以下任何条件未满足，生成一个校验错误并停止。
                    <div class=validusage>
                        - 使|srcTextureDesc|为|source|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}。
                        - 使|dstTextureDesc|为|destination|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}。
                        - |this|.{{GPUCommandEncoder/[[state]]}}为[=encoder state/open=]。
                        - [$validating GPUImageCopyTexture$](|source|, |copySize|)返回 `true`。
                        - |srcTextureDesc|.{{GPUTextureDescriptor/usage}}包含{{GPUTextureUsage/COPY_SRC}}。
                        - [$validating GPUImageCopyTexture$](|destination|, |copySize|)返回 `true`。
                        - |dstTextureDesc|.{{GPUTextureDescriptor/usage}}包含{{GPUTextureUsage/COPY_DST}}。
                        - |srcTextureDesc|.{{GPUTextureDescriptor/sampleCount}}等于|dstTextureDesc|.{{GPUTextureDescriptor/sampleCount}}。
                        - |srcTextureDesc|.{{GPUTextureDescriptor/format}}和|dstTextureDesc|.{{GPUTextureDescriptor/format}}必须为[=copy-compatible=]。
                        - 如果|srcTextureDesc|.{{GPUTextureDescriptor/format}}是depth-stencil格式：
                            - |source|.{{GPUImageCopyTexture/aspect}}和|destination|.{{GPUImageCopyTexture/aspect}}必须都分别指向|srcTextureDesc|.{{GPUTextureDescriptor/format}}和|dstTextureDesc|.{{GPUTextureDescriptor/format}}的全部宽高比。
                        - [=Valid Texture Copy Range=](|source|, |copySize|)为真.
                        - [=Valid Texture Copy Range=](|destination|, |copySize|)为真.
                        - [$set of subresources for texture copy$](|source|, |copySize|)和[$set of subresources for texture copy$](|destination|, |copySize|)是不相交的。
                    </div>
            </div>
        </div>
</dl>

<div algorithm>
    Two {{GPUTextureFormat}}s |format1| and |format2| are <dfn dfn>copy-compatible</dfn> if:

    - |format1| equals |format2|, or
    - |format1| and |format2| differ only in whether they are `srgb` formats (have the `-srgb` suffix).

    问题(gpuweb/gpuweb#2322): 一旦 {{GPUTextureDescriptor/viewFormats}} 中允许更多格式，考虑在 viewFormats 中有任何重叠时使两个纹理副本兼容.
</div>
<div>
    The <dfn abstract-op>set of subresources for texture copy</dfn>(|imageCopyTexture|, |copySize|)
    是一个包含如下内容的集合：

      - 如果|imageCopyTexture|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/dimension}}为{{GPUTextureDimension/"2d"}}:
          - 每个|copySize|.[=Extent3D/depthOrArrayLayers=] [=array layers=]的|arrayLayer|从|imageCopyTexture|.{{GPUImageCopyTexture/origin}}.[=Origin3D/z=]开始：
              - |imageCopyTexture|.{{GPUImageCopyTexture/texture}}的The [=subresource=]在[=mipmap level=] |imageCopyTexture|.{{GPUImageCopyTexture/mipLevel}}和[=array layer=] |arrayLayer|处。
      - 否则：
          - |imageCopyTexture|.{{GPUImageCopyTexture/texture}}的[=subresource=]在[=mipmap level=] |imageCopyTexture|.{{GPUImageCopyTexture/mipLevel}}处。
</div>

## 查询 ## {#command-encoder-queries}

<dl dfn-type=method dfn-for=GPUCommandEncoder>
    : <dfn>writeTimestamp(querySet, queryIndex)</dfn>
    ::
        当所有先前命令被全部执行时，向查询集中写入一个时间戳值。

        <div algorithm=GPUCommandEncoder.writeTimestamp>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/writeTimestamp(querySet, queryIndex)">
                |querySet|: 存放时间戳的查询集合。
                |queryIndex|: 查询集合的查询索引。
            </pre>

            **Returns:** {{undefined}}

            1. 如果|this|.{{GPUObjectBase/[[device]]}}.{{device/[[features]]}}不为[=list/contain=]
                {{GPUFeatureName/"timestamp-query"}}，抛出一个{{TypeError}}。
            1. 在 |this|.{{GPUObjectBase/[[device]]}} 的 [=Device Timeline=] 上发出以下步骤：
                <div class=device-timeline>
                    1. 准备|this|的编码器状态。如果返回 false，则停止。
                    2. 如果以下任何条件未满足，生成一个校验错误并停止。
                        <div class=validusage>
                            - |this|.{{GPUCommandEncoder/[[state]]}}为[=encoder state/open=]。
                            - |querySet|可以与|this|一起有效使用。
                            - |querySet|.{{GPUQuerySet/[[descriptor]]}}.{{GPUQuerySetDescriptor/type}}为{{GPUQueryType/"timestamp"}}。
                            - |queryIndex| &lt; |querySet|.{{GPUQuerySet/[[descriptor]]}}.{{GPUQuerySetDescriptor/count}}。
                        </div>

                    问题: 描述{{GPUCommandEncoder/writeTimestamp()}}算法步骤。
                </div>
        </div>

    : <dfn>resolveQuerySet(querySet, firstQuery, queryCount, destination, destinationOffset)</dfn>
    ::
        将来自 {{GPUQuerySet}} 的查询结果解析为 {{GPUBuffer}} 的范围。

        <div algorithm=GPUCommandEncoder.resolveQuerySet>
            **Called on:** {{GPUCommandEncoder}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/resolveQuerySet(querySet, firstQuery, queryCount, destination, destinationOffset)">
                querySet:
                firstQuery:
                queryCount:
                destination:
                destinationOffset:
            </pre>

            **Returns:** {{undefined}}

            在 |this|.{{GPUObjectBase/[[device]]}} 的 [=Device Timeline=] 上发出以下步骤：
            <div class=device-timeline>
                1. 准备|this|的编码器状态。如果返回 false，则停止。
                1. 如果以下任何条件未满足，生成一个{{GPUValidationError}}并停止。
                    <div class=validusage>
                        - |this|.{{GPUCommandEncoder/[[state]]}}为[=encoder state/open=]。
                        - |querySet|为[$valid to use with$] |this|。
                        - |destination|为[$valid to use with$] |this|。
                        - |destination|.{{GPUBuffer/[[usage]]}}包含{{GPUBufferUsage/QUERY_RESOLVE}}。
                        - |firstQuery|小于|querySet|中的查询数量。
                        - (|firstQuery| + |queryCount|)小于等于|querySet|中的查询数量。
                        - |destinationOffset|是256的倍数。
                        - |destinationOffset| + 8 &times; |queryCount| &le; |destination|.{{GPUBuffer/[[size]]}}。
                    </div>

                    问题: 描述{{GPUCommandEncoder/resolveQuerySet()}}算法步骤。
            </div>
        </div>
</dl>

## 结尾 ## {#command-encoder-finalization}

可以通过调用{{GPUCommandEncoder/finish()}}来创建包含{{GPUCommandEncoder}}记录的命令的{{GPUCommandBuffer}}。 一旦{{GPUCommandEncoder/finish()}}被调用，命令编码器就不能再使用了。

<dl dfn-type=method dfn-for=GPUCommandEncoder>
    : <dfn>finish(descriptor)</dfn>
    ::
        停止记录命令序列并返回一个对应的{{GPUCommandBuffer}}。

        <div algorithm=GPUCommandEncoder.finish>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/finish(descriptor)">
                descriptor:
            </pre>

            **Returns:** {{GPUCommandBuffer}}

            1. 使|commandBuffer|为一个新的{{GPUCommandBuffer}}。
            2. 在|this|的[=Device timeline=]上发起如下步骤：
                <div class=device-timeline>
                    1. 如果以下条件都满足则使 |validationFailed| 为 `true`，否则为 `false` 。
                        <div class=validusage>
                            - |this|必须为[=valid=].
                            - |this|.{{GPUCommandsMixin/[[state]]}}'s [=stack/size=]必须为"[=encoder state/open=]"。
                            - |this|.{{GPUDebugCommandsMixin/[[debug_group_stack]]}}必须为[=list/is empty|be empty=]。
                            - 每个包含在|this|中的[=usage scope=]必须满足[=usage scope validation=]。
                        </div>

                    1. 设置 |this|.{{GPUCommandsMixin/[[state]]}} 为 "[=encoder state/ended=]".
                    1. 如果 |validationFailed| 为 `false`, 则:
                        1. 在当前范围内生成一个带有适当错误消息的{{GPUValidationError}}。
                        2. 返回一个新的[=invalid=] {{GPUCommandBuffer}}。

                    1. 设置|this|.{{GPUCommandEncoder/[[state]]}}为[=encoder state/closed=]。
                    1. 设置|commandBuffer|.{{GPUCommandBuffer/[[command_list]]}}为|this|.{{GPUCommandsMixin/[[commands]]}}。
                </div>

            3. 返回|commandBuffer|。
        </div>
</dl>

# Programmable Passes # {#programmable-passes}

<script type=idl>

interface mixin GPUProgrammablePassEncoder {
    undefined setBindGroup(GPUIndex32 index, GPUBindGroup bindGroup,
                      optional sequence<GPUBufferDynamicOffset> dynamicOffsets = []);

    undefined setBindGroup(GPUIndex32 index, GPUBindGroup bindGroup,
                      Uint32Array dynamicOffsetsData,
                      GPUSize64 dynamicOffsetsDataStart,
                      GPUSize32 dynamicOffsetsDataLength);
};
</script>

{{GPUProgrammablePassEncoder}} has the following internal slots:

<dl dfn-type=attribute dfn-for="GPUProgrammablePassEncoder">
    : <dfn>\[[command_encoder]]</dfn> of type {{GPUCommandEncoder}}.
    ::
        The {{GPUCommandEncoder}} that created this programmable pass.

    : <dfn>\[[bind_groups]]</dfn>, of type [=ordered map=]&lt;{{GPUIndex32}}, {{GPUBindGroup}}&gt;
    ::
        The current {{GPUBindGroup}} for each index, initially empty.
</dl>

## 绑定组 ## {#programmable-passes-bind-groups}

<dl dfn-type=method dfn-for=GPUProgrammablePassEncoder>
    : <dfn>setBindGroup(index, bindGroup, dynamicOffsets)</dfn>
    ::
        为给定索引设置当前 {{GPUBindGroup}}。

        <div algorithm=GPUProgrammablePassEncoder.setBindGroup>
            **调用:** {{GPUProgrammablePassEncoder}} this.

            **参数:**
            <pre class=argumentdef for="GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)">
                |index|: 设置绑定组的索引。
                |bindGroup|: 绑定组以用于后续渲染或计算命令。

                <!--|dynamicOffsets|: 包含 |bindGroup| 中每个条目的缓冲区偏移量（以字节为单位）的数组
                标记为 {{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/hasDynamicOffset}}。-->
            </pre>

            **返回:** {{undefined}}

            在  |this|.{{GPUObjectBase/[[device]]}} 的 [=Device timeline=] 发布一下步骤 :
            <div class=device-timeline>
                1. 如果不满足以下任一条件，则使 |this| [=invalid=] 并停止。
                    <div class=validusage>
                        - |bindGroup| 与|this| 一起使用是有效的。
                        - |index| &lt; |this|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxBindGroups}}.
                        - |dynamicOffsets|.length 是
                            |bindGroup|.{{GPUBindGroup/[[layout]]}}.{{GPUBindGroupLayout/[[dynamicOffsetCount]]}}.

                        - 迭代 |bindGroup| 中的每个动态绑定偏移量 并为每个 |bufferBinding|、|bufferLayout| 和 |dynamicOffsetIndex| 运行以下步骤:

                            - 让 |bufferDynamicOffset| 为 |dynamicOffsets|[|dynamicOffsetIndex|].
                            - |bufferBinding|.{{GPUBufferBinding/offset}} + |bufferDynamicOffset| +
                                |bufferLayout|.{{GPUBufferBindingLayout/minBindingSize}} &le;
                                |bufferBinding|.{{GPUBufferBinding/buffer}}.{{GPUBuffer/[[size]]}}.
                            - 如果 |bufferLayout|.{{GPUBufferBindingLayout/type}} 是 {{GPUBufferBindingType/"uniform"}}:

                                - |dynamicOffset| 是 {{supported limits/minUniformBufferOffsetAlignment}} 的倍数。

                            - 如果 |bufferLayout|.{{GPUBufferBindingLayout/type}} 是 {{GPUBufferBindingType/"storage"}}
                                或 {{GPUBufferBindingType/"read-only-storage"}}:

                                - |dynamicOffset| 是 {{supported limits/minStorageBufferOffsetAlignment}} 的倍数。

                    </div>
                1. 设置 |this|.{{GPUProgrammablePassEncoder/[[bind_groups]]}}[|index| 为 |bindGroup|.
            </div>
        </div>

    : <dfn>setBindGroup(index, bindGroup, dynamicOffsetsData, dynamicOffsetsDataStart, dynamicOffsetsDataLength)</dfn>
    ::
        为给定索引设置当前 {{GPUBindGroup}}，将动态偏移指定为 {{Uint32Array}} 的子集。

        <div algorithm=GPUProgrammablePassEncoder.setBindGroup2>
            **调用:** {{GPUProgrammablePassEncoder}} |this|.

            **参数:**
            <pre class=argumentdef for="GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsetsData, dynamicOffsetsDataStart, dynamicOffsetsDataLength)">
                |index|: 设置绑定组的索引。
                |bindGroup|: 绑定组以用于后续渲染或计算命令。
                |dynamicOffsetsData|: 包含 |bindGroup| 中每个条目的缓冲区偏移量（以字节为单位）的数组
                    标记为 {{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/hasDynamicOffset}}。
                |dynamicOffsetsDataStart|: 将元素偏移到 |dynamicOffsetsData| 缓冲区偏移数据开始的地方。
                |dynamicOffsetsDataLength|: 要从 |dynamicOffsetsData| 读取的缓冲区偏移量数。
            </pre>

            **返回:** {{undefined}}

            1. 如果未满足以下任何要求，则抛出 {{RangeError}} 并停止。
                <div class=validusage>
                    - |dynamicOffsetsDataStart| 必须 &ge; 0.
                    - |dynamicOffsetsDataStart| + |dynamicOffsetsDataLength| 必须 &le;
                        |dynamicOffsetsData|.`length`.
                </div>
            1. 让 |dynamicOffsets| 成为一个 [=list=] 包含一个范围， 从获取缓冲区源的副本|dynamicOffsetsData| 的元素
                |dynamicOffsetsDataLength| 的索引 |dynamicOffsetsDataStart| 开始。
            1. 调用 |this|.{{GPUProgrammablePassEncoder/setBindGroup(index,
                bindGroup, dynamicOffsets)|setBindGroup}}(|index|, |bindGroup|, |dynamicOffsets|)。
</dl>

<div algorithm>
    <dfn abstract-op>迭代给定{{GPUBindGroup}}中的每个动态绑定偏移</dfn> |bindGroup| 使用给定的 |steps| 为每个动态偏移执行：

    1. 让 |dynamicOffsetIndex| 为 `0`。
    1. 让 |layout| 为 |bindGroup|.{{GPUBindGroup/[[layout]]}}。
    1. 对于每个 |bindGroup|.{{GPUBindGroup/[[entries]]}} 中的 {{GPUBindGroupEntry}} |entry|:
        1. 让 |bindingDescriptor| 成为 {{GPUBindGroupLayoutEntry}} 在
            |layout|.{{GPUBindGroupLayout/[[entryMap]]}}[|entry|.{{GPUBindGroupEntry/binding}}]:
        1. 如果 |bindingDescriptor|.{{GPUBindGroupLayoutEntry/buffer}} 不是 `undefined` 并且
            |bindingDescriptor|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/hasDynamicOffset}} 是 `true`:
            1. 让 |bufferBinding| 为 |entry|.{{GPUBindGroupEntry/resource}}。
            1. 让 |bufferLayout| 为 |bindingDescriptor|.{{GPUBindGroupLayoutEntry/buffer}}。
            1. 调用 |steps| 使用 |bufferBinding|， |bufferLayout|，和 |dynamicOffsetIndex|。
            1. 让 |dynamicOffsetIndex| 是 |dynamicOffsetIndex| + `1`
</div>

<div algorithm>
    <dfn abstract-op>Validate encoder bind groups</dfn>(encoder, pipeline)

    **参数:**
    <dl>
        : {{GPUProgrammablePassEncoder}} |encoder|
        :: 正在验证绑定组的编码器。
        : {{GPUPipelineBase}} |pipeline|
        :: 用于验证 |encoder|s 绑定组是否兼容的管道。
    </dl>

    1. 如果不满足以下任何一个条件，则返回 `false`:
        <div class=validusage>
            - |pipeline| 不可以是 `null`。
            - 必须设置管线使用的所有绑定组并与管线布局兼容：
                对于在|pipeline|.{{GPUPipelineBase/[[layout]]}}.{{GPUPipelineLayout/[[bindGroupLayouts]]}}({{GPUIndex32}}
                中的每一对 |index|, {{GPUBindGroupLayout}} |bindGroupLayout|) 。
                - 让 |bindGroup| 为 |encoder|.{{GPUProgrammablePassEncoder/[[bind_groups]]}}[|index|].
                - |bindGroup| 不可以是 `null`。
                - |bindGroup|.{{GPUBindGroup/[[layout]]}} 必须是与 |bindGroupLayout| [=group-equivalent=]。

            问题：对未使用 {{GPUBufferBindingLayout/minBindingSize}} 预先验证的缓冲区绑定添加验证，绑定范围足以满足着色器的最小绑定大小要求。
        </div>
    1. [$Encoder bind groups alias a writable resource$](|encoder|, |pipeline|) 必须为 `false`.

        问题(gpuweb/gpuweb#1842): 确定当应用程序违反此规则时会发生什么。
        它是验证错误，多种可能行为之一，还是我们只是完全删除此限制并允许可写绑定以未定义结果为别名？

    否则返回 `true`。
</div>

<div algorithm>
    如果任何可写缓冲区绑定范围与同一缓冲区的任何其他绑定范围重叠，或者任何可写纹理绑定在 [=texture subresources=] 中与任何其他纹理绑定（可能使用相同或不同的 {{GPUTextureView}} 对象）重叠），
    <dfn abstract-op>Encoder bind groups alias a writable resource</dfn>(|encoder|, |pipeline|)。

    **Arguments:**
    <dl>
        : {{GPUProgrammablePassEncoder}} |encoder|
        :: Encoder whose bind groups are being validated.
        : {{GPUPipelineBase}} |pipeline|
        :: Pipeline to validate |encoder|s bind groups are compatible with.
    </dl>

    1. 对每个 [{{GPUShaderStage/VERTEX}}, {{GPUShaderStage/FRAGMENT}}, {{GPUShaderStage/COMPUTE}}] 中的 |stage|:
        1. 使 |bufferBindings| 为 ({{GPUBufferBinding}} 中的 [=list=], `boolean`) 对，其中后者指资源是否可写入。
        1. 对每个 |pipeline|.{{GPUPipelineBase/[[layout]]}}.{{GPUPipelineLayout/[[bindGroupLayouts]]}} 中的 ({{GPUIndex32}} |index|, {{GPUBindGroupLayout}} |bindGroupLayout|) 对：
            1. 使 |bindGroupEntries| 为
                |encoder|.{{GPUProgrammablePassEncoder/[[bind_groups]]}}[|index|].{{GPUBindGroupDescriptor/entries}}.
            1. 使 |bindGroupLayoutEntries| 为
                |bindGroupLayout|.{{GPUBindGroupLayout/[[descriptor]]}}.{{GPUBindGroupLayoutDescriptor/entries}}.
            1. 对每个 |bindGroupLayoutEntries| 中的 {{GPUBindGroupEntry}} |bindGroupLayoutEntry|：
                对包含 |stage| 的 |bindGroupLayoutEntry|.{{GPUBindGroupLayoutEntry/visibility}}：
                1. 使 |bindGroupEntry| 为 |bindGroupEntries| 中的 {{GPUBindGroupEntry}}，其 |bindGroupEntry|.{{GPUBindGroupEntry/binding}} 等于 |bindGroupLayoutEntry|.{{GPUBindGroupLayoutEntry/binding}}。
                1. 如果 |bindGroupEntry|.{{GPUBindGroupEntry/resource}} 为 {{GPUBufferBinding}}:

                    1. 使 {{GPUBufferBinding}} |resource| 为 |bindGroupEntry|.{{GPUBindGroupEntry/resource}}.
                    1. 使 |resourceWritable| 为 (|bindGroupLayoutEntry|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/type}} == {{GPUBufferBindingType/"storage"}}).
                    1. 对每个 |bufferBindings| 中的 ({{GPUBufferBinding}} |pastResource|, `boolean` |pastResourceWritable|) 对:
                        1. 如果 (|resourceWritable| or |pastResourceWritable|) 为真, 及 |pastResource| 和 |resource| 为 [=buffer-binding-aliasing=], 返回 `true`.
                    1. [=list/append|Append=] ([|resource|], |resourceWritable|) 至 |bufferBindings|.

                    否则，如果 |bindGroupEntry|.{{GPUBindGroupEntry/resource}} 为 {{GPUTextureView}}：

                    1. 使 {{GPUTextureView}} |resource| 为 |bindGroupEntry|.{{GPUBindGroupEntry/resource}}.
                    1. 使 |resourceWritable| 为 (|bindGroupLayoutEntry|.{{GPUBindGroupLayoutEntry/storageTexture}}.{{GPUStorageTextureBindingLayout/access}} == {{GPUStorageTextureAccess/"write-only"}}).
                    1. 如果 |bindGroupLayoutEntry|.{{GPUBindGroupLayoutEntry/storageTexture}} 为 `null`, 则继续.
                    1. 对每个 |textureViews| 中的 ({{GPUTextureView}} |pastResource|, `boolean` |pastResourceWritable|) 对,
                        1. 如果 (|resourceWritable| or |pastResourceWritable|) 为真, 及
                            |pastResource| 和 |resource| 为 [=texture-view-aliasing=], 返回 `true`.
                    1. [=list/append|Append=] ([|resource|], |resourceWritable|) 至 |textureViews|.

                    否则，继续。
    1. Return `false`.
</div>

# 调试标记 # {#debug-markers}

<dfn interface>GPUDebugCommandsMixin</dfn> 提供了将调试标签应用于命令组或将单个标签插入命令序列的方法。

调试组可以嵌套以创建标记命令的层次结构，并且必须很好地平衡。

与 {{GPUObjectBase/label|object labels}} 一样，这些标签没有必需的行为，但可能会显示在错误消息和浏览器开发人员工具中，并且可能会传递给原生 API 后端。

<script type=idl>
interface mixin GPUDebugCommandsMixin {
    undefined pushDebugGroup(USVString groupLabel);
    undefined popDebugGroup();
    undefined insertDebugMarker(USVString markerLabel);
};
</script>

{{GPUDebugCommandsMixin}} 仅包含在包含 {{GPUObjectBase}} 和 {{GPUCommandsMixin}} 的接口中。

{{GPUDebugCommandsMixin}} 将以下内部插槽添加到包含它的接口中：

<dl dfn-type=attribute dfn-for=GPUDebugCommandsMixin>
    : <dfn>\[[debug_group_stack]]</dfn> of type [=stack=]&lt;{{USVString}}&gt;.
    ::
        一个活动调试组标签组成的堆。
</dl>

{{GPUDebugCommandsMixin}} adds the following methods to interfaces which include it:

<dl dfn-type=method dfn-for=GPUDebugCommandsMixin>
    : <dfn>pushDebugGroup(groupLabel)</dfn>
    ::
        开始包含后续命令的标记调试组。

        <div algorithm=GPUDebugCommandsMixin.pushDebugGroup>
            **Called on:** {{GPUDebugCommandsMixin}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUDebugCommandsMixin/pushDebugGroup(groupLabel)">
                |groupLabel|: 命令组的标签。
            </pre>

            **Returns:** {{undefined}}

            在 |this|.{{GPUObjectBase/[[device]]}} 的 [=Device Timeline=] 上发出以下步骤：
            <div class=device-timeline>
                1. 准备|this|的编码器状态（[$Prepare the encoder state$]）。如果返回false，则停止。
                1. 在|this|.{{GPUDebugCommandsMixin/[[debug_group_stack]]}}上[=stack/Push=] |groupLabel|。
            </div>
        </div>

    : <dfn>popDebugGroup()</dfn>
    ::
        结束最近由 {{GPUDebugCommandsMixin/pushDebugGroup()}} 启动的标记调试组。

        <div algorithm=GPUDebugCommandsMixin.popDebugGroup>
            **Called on:** {{GPUDebugCommandsMixin}} |this|.

            **Returns:** {{undefined}}

            在 |this|.{{GPUObjectBase/[[device]]}} 的 [=Device Timeline=] 上发出以下步骤：
            <div class=device-timeline>
                1. 准备|this|的编码器状态（[$Prepare the encoder state$]）。如果为false，则停止。
                1. 如果不满足以下任何要求，则使 |this| [=无效=]，然后停止。
                    <div class=validusage>
                        - |this|.{{GPUDebugCommandsMixin/[[debug_group_stack]]}} 必须不为 [=list/is empty|be empty=].
                    </div>
                1. 从 |this|.{{GPUDebugCommandsMixin/[[debug_group_stack]]}} 中 [=stack/Pop=] 出一项。
            </div>
        </div>

    : <dfn>insertDebugMarker(markerLabel)</dfn>
    ::
        用标签标记命令流中的一个点。

        <div algorithm=GPUDebugCommandsMixin.insertDebugMarker>
            **Called on:** {{GPUDebugCommandsMixin}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUDebugCommandsMixin/insertDebugMarker(markerLabel)">
                markerLabel: 要插入的标签。
            </pre>

            **Returns:** {{undefined}}

            在 |this|.{{GPUObjectBase/[[device]]}} 的 [=Device Timeline=] 上发出以下步骤：
            <div class=device-timeline>
                1. 准备|this|的编码器状态（[$Prepare the encoder state$]）。如果为false，则停止。
            </div>
        </div>
</dl>

# 计算通道 # {#compute-passes}

## <dfn interface>GPUComputePassEncoder</dfn> ## {#compute-pass-encoder}

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUComputePassEncoder {
    undefined setPipeline(GPUComputePipeline pipeline);
    undefined dispatch(GPUSize32 workgroupCountX, optional GPUSize32 workgroupCountY = 1, optional GPUSize32 workgroupCountZ = 1);
    undefined dispatchIndirect(GPUBuffer indirectBuffer, GPUSize64 indirectOffset);

    undefined endPass();
};
GPUComputePassEncoder includes GPUObjectBase;
GPUComputePassEncoder includes GPUProgrammablePassEncoder;
</script>

{{GPUComputePassEncoder}}有以下内部插槽：

<dl dfn-type=attribute dfn-for="GPUComputePassEncoder">
    : <dfn>\[[pipeline]]</dfn>, of type {{GPUComputePipeline}}
    ::
        当前{{GPUComputePipeline}}，初始为 `null`。
    : <dfn>\[[endTimestampWrites]]</dfn>, of type {{GPUComputePassTimestampWrites}}
    ::
        通道结束时需要被执行的时间戳附件。
</dl>

### 创建 ### {#compute-pass-encoder-creation}

<script type=idl>
enum GPUComputePassTimestampLocation {
    "beginning",
    "end",
};

dictionary GPUComputePassTimestampWrite {
    required GPUQuerySet querySet;
    required GPUSize32 queryIndex;
    required GPUComputePassTimestampLocation location;
};

typedef sequence<GPUComputePassTimestampWrite> GPUComputePassTimestampWrites;

dictionary GPUComputePassDescriptor : GPUObjectDescriptorBase {
    GPUComputePassTimestampWrites timestampWrites = [];
};
</script>

<dl dfn-type=dict-member dfn-for=GPUComputePassDescriptor>
    : <dfn>timestampWrites</dfn>
    ::
        A sequence of {{GPUComputePassTimestampWrite}} values define where and when timestamp values will be written for this pass.
</dl>

<div class=validusage dfn-for=GPUComputePassDescriptor>
    <dfn abstract-op>Valid Usage</dfn>

    Given a {{GPUComputePassDescriptor}} |this| the following validation rules apply:

    1. For each |timestampWrite| in |this|.{{GPUComputePassDescriptor/timestampWrites}}:

        1. |timestampWrite|.{{GPUComputePassTimestampWrite/querySet}}.{{GPUQuerySet/[[descriptor]]}}.{{GPUQuerySetDescriptor/type}} is {{GPUQueryType/"timestamp"}}.

        1. |timestampWrite|.{{GPUComputePassTimestampWrite/queryIndex}} &lt; |timestampWrite|.{{GPUComputePassTimestampWrite/querySet}}.{{GPUQuerySet/[[descriptor]]}}.{{GPUQuerySetDescriptor/count}}.
</div>

### 调度 ### {#compute-pass-encoder-dispatch}

<dl dfn-type=method dfn-for=GPUComputePassEncoder>
    : <dfn>setPipeline(pipeline)</dfn>
    ::
        设置当前{{GPUComputePipeline}}。

        <div algorithm="GPUComputePassEncoder.setPipeline">
            **Called on:** {{GPUComputePassEncoder}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUComputePassEncoder/setPipeline(pipeline)">
                |pipeline|: 用于后续调度命令的计算管道。
            </pre>

            **Returns:** {{undefined}}

            在|this|.{{GPUObjectBase/[[device]]}}的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                1. 如果以下任何条件未满足，使|this| [=invalid=]并且停止。
                    <div class=validusage>
                        - |pipeline|可以和|this|一起有效使用。
                    </div>
                1. 设置|this|.{{GPUComputePassEncoder/[[pipeline]]}}为|pipeline|。
            </div>
        </div>

    : <dfn>dispatch(workgroupCountX, workgroupCountY, workgroupCountZ)</dfn>
    ::
        使用当前{{GPUComputePipeline}}执行的调度工作。有关详细规范，请参阅[[#computing-operations]]。

        <div algorithm="GPUComputePassEncoder.dispatch">
            **Called on:** {{GPUComputePassEncoder}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUComputePassEncoder/dispatch(workgroupCountX, workgroupCountY, workgroupCountZ)">
                |workgroupCountX|: 要调度的工作组网格的X维度。
                |workgroupCountY|: 要调度的工作组网格的Y维度。
                |workgroupCountZ|: 要调度的工作组网格的Z维度。
            </pre>

            **Returns:** {{undefined}}

            在|this|.{{GPUObjectBase/[[device]]}}的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                1. 如果以下任何条件未满足，使|this| [=invalid=]并停止。
                    <div class=validusage>
                        - [$Validate encoder bind groups$](|this|, |this|.{{GPUComputePassEncoder/[[pipeline]]}})为 `true`。
                        - |workgroupCountX|，|workgroupCountY|，和|workgroupCountZ|都小于或等于|this|.device.limits.{{supported limits/maxComputeWorkgroupsPerDimension}}。
                    </div>

                1. 使|passState|为一个this|的快照当前状态。
                1. [=list/Append=] 一个 [=GPU command=] 至 |this|.{{GPUCommandsMixin/[[commands]]}}，执行以下 [=queue timeline=] 步骤：
                    <div class=queue-timeline>
                        1. 使用 |passState| 调度维度为 [|workgroupCountX|, |workgroupCountY|,
                            |workgroupCountZ|] 的工作组网格。{{GPUComputePassEncoder/[[pipeline]]}} 使用 |passState|.{{GPUProgrammablePassEncoder/[[bind_groups]] }}。
                    </div>
            </div>
        </div>

    : <dfn>dispatchIndirect(indirectBuffer, indirectOffset)</dfn>
    ::
        使用从{{GPUBuffer}}读取的参数调度要与当前{{GPUComputePipeline}一起执行的工作。有关详细规范，请参阅[[#computing-operations]]。

        缓冲区中<dfn dfn for=>indirect dispatch parameters</dfn>必须是三个**32位无符号整数值（共12个字节）**的紧密打包块，以与{{GPUComputePassEncoder/dispatch()}}的参数相同的顺序给出。例如：

        <pre highlight="js">
            let dispatchIndirectParameters = new Uint32Array(3);
            dispatchIndirectParameters[0] = workgroupCountX;
            dispatchIndirectParameters[1] = workgroupCountY;
            dispatchIndirectParameters[2] = workgroupCountZ;
        </pre>

        <div algorithm="GPUComputePassEncoder.dispatchIndirect">
            **Called on:** {{GPUComputePassEncoder}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUComputePassEncoder/dispatchIndirect(indirectBuffer, indirectOffset)">
                |indirectBuffer|: Buffer containing the [=indirect dispatch parameters=].
                |indirectOffset|: Offset in bytes into |indirectBuffer| where the dispatch data begins.
            </pre>

            **Returns:** {{undefined}}

            在|this|.{{GPUObjectBase/[[device]]}}的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                1. 如果以下任何条件未满足, 使|this| [=invalid=]并停止。
                    <div class=validusage>
                        - [$Validate encoder bind groups$](|this|, |this|.{{GPUComputePassEncoder/[[pipeline]]}})为 `true`。
                        - |indirectBuffer|为[$valid to use with$] |this|。
                        - |indirectBuffer|.{{GPUBuffer/[[usage]]}}包含{{GPUBufferUsage/INDIRECT}}。
                        - |indirectOffset| + sizeof([=indirect dispatch parameters=]) &le;
                            |indirectBuffer|.{{GPUBuffer/[[size]]}}。
                        - |indirectOffset|是4的倍数。
                    </div>
                1. 使|indirectBuffer|作为{{GPUBufferUsage/INDIRECT}}加至[=usage scope=]。
            </div>

            如果任何调度参数（x、y 或 z）大于 |this|.device.limits.{{supported limits/maxComputeWorkgroupsPerDimension}}，则不会调度任何工作组。
        </div>
</dl>

<div class=note>
注意：传递给 {{GPUComputePassEncoder/dispatch()}} 和 {{GPUComputePassEncoder/dispatchIndirect()}} 的 `x`、`y` 和 `z` 值是每个维度要调度的 *workgroups* 的数量，*不是 * 在每个维度上执行的着色器调用次数。
这与现代原生 GPU API 的行为相匹配，但与 OpenCL 的行为不同。

这意味着如果一个 {{GPUShaderModule}} 使用 `@workgroup_size(4, 4)` 定义了一个入口点，并且通过调用 `computePass.dispatch(8, 8);`
将工作分派给它，那么入口点将是 总共调用 1024 次：沿 X 轴和 Y 轴分派 4x4 工作组 8 次。 (`4*4*8*8=1024`)
</div>

### 结尾 ### {#compute-pass-encoder-finalization}

用户完成记录命令后，可以通过调用{{GPUComputePassEncoder/endPass()}}来结束计算通道编码器。一旦{{GPUComputePassEncoder/endPass()}}被调用，计算通道编码器就不能再使用了。

<dl dfn-type=method dfn-for=GPUComputePassEncoder>
    : <dfn>endPass()</dfn>
    ::
        完成计算通道命令序列的记录。

        <div algorithm="GPUComputePassEncoder.endPass">
            **Called on:** {{GPUComputePassEncoder}} |this|.

            **Returns:** {{undefined}}

            在|this|的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                1. 如果以下任何条件未满足，生成一个{{GPUValidationError}}并停止。
                    <div class=validusage>
                        - |this|.{{GPUCommandsMixin/[[state]]}} 必须为 "[=encoder state/open=]",
                    </div>
                1. [=Assert=]: |this|.{{GPUProgrammablePassEncoder/[[command_encoder]]}}.{{GPUCommandsMixin/[[state]]}} 为 "[=encoder state/locked=]"。
                1. 设置 |this|.{{GPUCommandsMixin/[[state]]}} 为 "[=encoder state/ended=]"。
                1. 设置 |this|.{{GPUProgrammablePassEncoder/[[command_encoder]]}}.{{GPUCommandsMixin/[[state]]}} 为 "[=encoder state/open=]"。
                1. 如果以下任何条件未满足，使 |this|.{{GPUProgrammablePassEncoder/[[command_encoder]]}} [=invalid=] 并停止。
                    <div class=validusage>
                        - |this| 必须为 [=valid=]
                        - |this|.{{GPUDebugCommandsMixin/[[debug_group_stack]]}} 必须 [=list/is empty|be empty=].
                    </div>
                1. 对每个|this|.{{GPUComputePassEncoder/[[endTimestampWrites]]}}中的|timestampWrite|，
                    1. (|timestampWrite|.{{GPUComputePassTimestampWrite/location}} 必须等于 {{GPUComputePassTimestampLocation/"end"}}.)
                    2. 添加（[=list/Append=]）一个[=GPU command=]至|this|.{{GPUProgrammablePassEncoder/[[command_encoder]]}}.{{GPUCommandEncoder/[[command_list]]}}，将GPU时间戳值写入|timestampWrite|.{{GPUComputePassTimestampWrite/querySet}}中的|timestampWrite|.{{GPUComputePassTimestampWrite/queryIndex}}索引。
            </div>
        </div>
</dl>

# 渲染通道 # {#render-passes}

## <dfn interface>GPURenderPassEncoder</dfn> ## {#render-pass-encoder}

<script type=idl>
interface mixin GPURenderEncoderBase {
    undefined setPipeline(GPURenderPipeline pipeline);

    undefined setIndexBuffer(GPUBuffer buffer, GPUIndexFormat indexFormat, optional GPUSize64 offset = 0, optional GPUSize64 size);
    undefined setVertexBuffer(GPUIndex32 slot, GPUBuffer buffer, optional GPUSize64 offset = 0, optional GPUSize64 size);

    undefined draw(GPUSize32 vertexCount, optional GPUSize32 instanceCount = 1,
              optional GPUSize32 firstVertex = 0, optional GPUSize32 firstInstance = 0);
    undefined drawIndexed(GPUSize32 indexCount, optional GPUSize32 instanceCount = 1,
                     optional GPUSize32 firstIndex = 0,
                     optional GPUSignedOffset32 baseVertex = 0,
                     optional GPUSize32 firstInstance = 0);

    undefined drawIndirect(GPUBuffer indirectBuffer, GPUSize64 indirectOffset);
    undefined drawIndexedIndirect(GPUBuffer indirectBuffer, GPUSize64 indirectOffset);
};

[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPURenderPassEncoder {
    undefined setViewport(float x, float y,
                     float width, float height,
                     float minDepth, float maxDepth);

    undefined setScissorRect(GPUIntegerCoordinate x, GPUIntegerCoordinate y,
                        GPUIntegerCoordinate width, GPUIntegerCoordinate height);

    undefined setBlendConstant(GPUColor color);
    undefined setStencilReference(GPUStencilValue reference);

    undefined beginOcclusionQuery(GPUSize32 queryIndex);
    undefined endOcclusionQuery();

    undefined executeBundles(sequence<GPURenderBundle> bundles);
    undefined end();
};
GPURenderPassEncoder includes GPUObjectBase;
GPURenderPassEncoder includes GPUCommandsMixin;
GPURenderPassEncoder includes GPUDebugCommandsMixin;
GPURenderPassEncoder includes GPUProgrammablePassEncoder;
GPURenderPassEncoder includes GPURenderEncoderBase;
</script>

  * 在间接绘制调用中，基本实例字段（在间接缓冲区数据内）必须设置为零。

{{GPURenderEncoderBase}}有以下内部插槽：

<dl dfn-type=attribute dfn-for="GPURenderEncoderBase">
    : <dfn>\[[layout]]</dfn>, of type {{GPURenderPassLayout}}
    ::
        渲染通道的布局。

    : <dfn>\[[depthReadOnly]]</dfn>, of type boolean?
    ::
        如果存在，表示深度分量未被修改。

    : <dfn>\[[stencilReadOnly]]</dfn>, of type boolean?
    ::
        如果存在，表示模板组件未被修改。

    : <dfn>\[[pipeline]]</dfn>, of type {{GPURenderPipeline}}
    ::
        当前{{GPURenderPipeline}}, 初始为 `null`。

    : <dfn>\[[index_buffer]]</dfn>, of type {{GPUBuffer}}
    ::
        从中读取索引数据的当前缓冲区，初始为 `null`。

    : <dfn>\[[index_format]]</dfn>, of type {{GPUIndexFormat}}
    ::
        {{GPURenderEncoderBase/[[index_buffer]]}}中的索引数据的格式。

    : <dfn>\[[index_buffer_size]]</dfn>, of type {{GPUSize64}}
    ::
        当前设置的{{GPURenderEncoderBase/[[index_buffer]]}}节的字节大小，初始为0。

    : <dfn>\[[vertex_buffers]]</dfn>, of type [=ordered map=]&lt;slot, {{GPUBuffer}}&gt;
    ::
        当前要从每个插槽读取顶点数据的{{GPUBuffer}}s，初始为空。

    : <dfn>\[[vertex_buffer_sizes]]</dfn>, of type [=ordered map=]&lt;slot, {{GPUSize64}}&gt;
    ::
        当前为每个插槽设置的{{GPUBuffer}}部分的大小（以字节为单位），初始为空。
</dl>

{{GPURenderPassEncoder}} has the following internal slots:

<dl dfn-type=attribute dfn-for="GPURenderPassEncoder">
    : <dfn>\[[attachment_size]]</dfn>
    ::
        设置为以下范围：
            - `width, height` = 通道渲染附件的维度。

    : <dfn>\[[occlusion_query_set]]</dfn>, of type {{GPUQuerySet}}.
    ::
        用于存储通道的阻塞查询结果的{{GPUQuerySet}}，在通道创建时使用{{GPURenderPassDescriptor}}.{{GPURenderPassDescriptor/occlusionQuerySet}}进行初始化。

    : <dfn>\[[occlusion_query_active]]</dfn>, of type {{boolean}}.
    ::
        通道的{{GPURenderPassEncoder/[[occlusion_query_set]]}}是否被写入。

    : <dfn>\[[viewport]]</dfn>
    ::  当前视口矩形和深度范围。
    : <dfn>\[[endTimestampWrites]]</dfn>, 类型为{{GPURenderPassTimestampWrites}}
    ::
        通道结束时需要执行的时间戳附件。
</dl>

当{{GPURenderPassEncoder}}被创建，它有以下默认状态：
  * {{GPURenderPassEncoder/[[viewport]]}}:
      * `x, y` = `0.0, 0.0`
      * `width, height` = 通道渲染目标的维度
      * `minDepth, maxDepth` = `0.0, 1.0`
  * 裁剪矩形:
      * `x, y` = `0, 0`
      * `width, height` = 通道渲染目标的维度

### 创建 ### {#render-pass-encoder-creation}

<script type=idl>
dictionary GPURenderPassDescriptor : GPUObjectDescriptorBase {
    required sequence<GPURenderPassColorAttachment> colorAttachments;
    GPURenderPassDepthStencilAttachment depthStencilAttachment;
    GPUQuerySet occlusionQuerySet;
    GPURenderPassTimestampWrites timestampWrites = [];
};
</script>

<dl dfn-type=dict-member dfn-for=GPURenderPassDescriptor>
    : <dfn>colorAttachments</dfn>
    ::
        此序列中的{{GPURenderPassColorAttachment}}值集，定义了在执行此渲染通道时将输出到哪些颜色附件。

        由于 [=compatible usage list|usage compatibility=]，没有颜色附件可以作为另一个附件或渲染通道内使用的任何资源的别名。

    : <dfn>depthStencilAttachment</dfn>
    ::
        {{GPURenderPassDepthStencilAttachment}}值，定义了深度/模板附件，在执行此渲染通道时将输出到该附件并对其进行测试。

        由于 [=compatible usage list|usage compatibility=]，任何可写的深度/模板附件都不能作为另一个附件或渲染通道内使用的任何资源的别名。

    : <dfn>occlusionQuerySet</dfn>
    ::
        {{GPUQuerySet}}值，定义了此通道的的阻塞查询结果将存储在哪里。
</dl>

<div class=validusage dfn-for=GPURenderPassDescriptor>
    <dfn abstract-op>Valid Usage</dfn>

    给定一个{{GPURenderPassDescriptor}} |this|，应用以下校验规则：

    1. |this|.{{GPURenderPassDescriptor/colorAttachments}}.length小于或等于8。
    1. |this|.{{GPURenderPassDescriptor/colorAttachments}}.length 必须大于 `0` 或
        |this|.{{GPURenderPassDescriptor/depthStencilAttachment}} 必须不为 `null`.
    1. 对每个在 |this|.{{GPURenderPassDescriptor/colorAttachments}} 中的 |colorAttachment|:

        1. |colorAttachment|必须满足[$GPURenderPassColorAttachment/GPURenderPassColorAttachment Valid Usage$]规则。

    4. 如果|this|.{{GPURenderPassDescriptor/depthStencilAttachment}}不为 `null`：

        1. |this|.{{GPURenderPassDescriptor/depthStencilAttachment}}必须满足[$GPURenderPassDepthStencilAttachment/GPURenderPassDepthStencilAttachment Valid Usage$]规则。

    5. 所有|this|.{{GPURenderPassDescriptor/colorAttachments}}中的{{GPURenderPassColorAttachment/view}}，以及|this|.{{GPURenderPassDescriptor/depthStencilAttachment}}.{{GPURenderPassDepthStencilAttachment/view}}，
        如果存在，必须有相等的{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/sampleCount}}。

    6. 对每个|this|.{{GPURenderPassDescriptor/colorAttachments}}中的{{GPURenderPassColorAttachment/view}}以及|this|.{{GPURenderPassDescriptor/depthStencilAttachment}}.{{GPURenderPassDepthStencilAttachment/view}}，
        如果存在，{{GPUTextureView/[[renderExtent]]}}必须匹配。

    7. 如果|this|.{{GPURenderPassDescriptor/occlusionQuerySet}}不为 `null`：

        1. |this|.{{GPURenderPassDescriptor/occlusionQuerySet}}.{{GPUQuerySet/[[descriptor]]}}.{{GPUQuerySetDescriptor/type}}必须为{{GPUQueryType/occlusion}}。

        1. |timestampWrite|.{{GPURenderPassTimestampWrite/queryIndex}} &lt; |timestampWrite|.{{GPURenderPassTimestampWrite/querySet}}.{{GPUQuerySet/[[descriptor]]}}.{{GPUQuerySetDescriptor/count}}.

    问题(gpuweb/gpuweb#503)：支持无附件。
</div>

<div algorithm="GPURenderPassDescriptor accessors" dfn-for=RenderPassDescriptor>
    对一个给定{{GPURenderPassDescriptor}}值的|descriptor|，句法：

      - |descriptor|.<dfn dfn>renderExtent</dfn>指任何{{GPUTextureView/[[descriptor]]}}中的{{GPUTextureView/[[renderExtent]]}}在|descriptor|.{{GPURenderPassDescriptor/depthStencilAttachment}}.{{GPURenderPassDepthStencilAttachment/view}}或任何|descriptor|.{{GPURenderPassDescriptor/colorAttachments}}中的{{GPURenderPassColorAttachment/view}}中。

    问题：一旦我们从其他地方引用它，就定义它。

    注意：[$GPURenderPassDescriptor/Valid Usage$]保证附件的所有渲染范围都是相同的，因此我们可以采用其中的任何一个，假设描述符是有效的。
</div>

#### 颜色附件 #### {#color-attachments}

<script type=idl>
dictionary GPURenderPassColorAttachment {
    required GPUTextureView view;
    GPUTextureView resolveTarget;

    GPUColor clearValue;
    required GPULoadOp loadOp;
    required GPUStoreOp storeOp;
};
</script>

<dl dfn-type=dict-member dfn-for=GPURenderPassColorAttachment>
    : <dfn>view</dfn>
    ::
        {{GPUTextureView}}描述将为此颜色附件输出到的纹理[=subresource=]。

    : <dfn>resolveTarget</dfn>
    ::
        一个{{GPUTextureView}}描述纹理[=subresource=]，如果{{GPURenderPassColorAttachment/view}}是多采样的，它将接收此颜色附件的解析输出。

    : <dfn>clearValue</dfn>
    ::
        指在执行渲染通道之前要清除 {{GPURenderPassColorAttachment/view}} 的值。
        如果不是 [=map/exist|provided=] 默认为 `{r: 0, g: 0, b: 0, a: 0}`。
        如果不是 {{GPULoadOp/"clear"}}，则忽略 {{GPURenderPassColorAttachment/loadOp}}。
    
    : <dfn>loadOp</dfn>
    ::
        指在执行渲染通道前在 {{GPURenderPassColorAttachment/view}} 上将执行的加载操作。

        注意：推荐优先清除。详见{{GPULoadOp/"clear"}}。

    : <dfn>storeOp</dfn>
    ::
        执行渲染通道后对{{GPURenderPassColorAttachment/view}}执行的存储操作。
</dl>

<div class=validusage dfn-for=GPURenderPassColorAttachment>
    <dfn abstract-op>GPURenderPassColorAttachment Valid Usage</dfn>
    
    给定一个 {{GPURenderPassColorAttachment}} |this|:

    1. 使 |renderViewDescriptor| 为 |this|.{{GPURenderPassColorAttachment/view}}.{{GPUTextureView/[[descriptor]]}}.
    1. 使 |resolveViewDescriptor| 为 |this|.{{GPURenderPassColorAttachment/resolveTarget}}.{{GPUTextureView/[[descriptor]]}}.
    1. 使 |renderTextureDescriptor| 为 |this|.{{GPURenderPassColorAttachment/view}}.{{GPUTextureView/[[texture]]}}.{{GPUTexture/[[descriptor]]}}.
    1. 使 |resolveTextureDescriptor| 为 |this|.{{GPURenderPassColorAttachment/resolveTarget}}.{{GPUTextureView/[[texture]]}}.{{GPUTexture/[[descriptor]]}}.

    以下验证规则适用：

    - |renderViewDescriptor|.{{GPUTextureViewDescriptor/format}} 必须为 [=color renderable format=].
    - |this|.{{GPURenderPassColorAttachment/view}} 必须为 [$renderable texture view$].
    - 如果 |this|.{{GPURenderPassColorAttachment/resolveTarget}} 不为 `null`:
        - |renderTextureDescriptor|.{{GPUTextureDescriptor/sampleCount}} 必须大于 1.
        - |resolveTextureDescriptor|.{{GPUTextureDescriptor/sampleCount}} 必须为 1.
        - |this|.{{GPURenderPassColorAttachment/resolveTarget}} 必须为 [$renderable texture view$].
        - |this|.{{GPURenderPassColorAttachment/resolveTarget}} 和 |this|.{{GPURenderPassColorAttachment/view}} 看到的 [=subresource=] 大小必须匹配。
        - |resolveViewDescriptor|.{{GPUTextureViewDescriptor/format}} 必须等于
            |renderViewDescriptor|.{{GPUTextureViewDescriptor/format}}.
        - |resolveViewDescriptor|.{{GPUTextureViewDescriptor/format}} 必须支持根据 [[#plain-color-formats]] 解析。
</div>

<div algorithm>
    A {{GPUTextureView}} |view| is a <dfn abstract-op>renderable texture view</dfn>
    if the following requirements are met:

    - |view|.{{GPUTextureView/[[texture]]}}.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/usage}}
        must contain {{GPUTextureUsage/RENDER_ATTACHMENT}}.
    - |descriptor|.{{GPUTextureViewDescriptor/dimension}} must be {{GPUTextureViewDimension/"2d"}}.
    - |descriptor|.{{GPUTextureViewDescriptor/mipLevelCount}} must be 1.
    - |descriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} must be 1.
    - |descriptor|.{{GPUTextureViewDescriptor/aspect}} must refer to all [=aspects=] of
        |view|.{{GPUTextureView/[[texture]]}}.

    where |descriptor| is |view|.{{GPUTextureView/[[descriptor]]}}.
</div>

#### 深度/模板附件 #### {#depth-stencil-attachments}

<script type=idl>
dictionary GPURenderPassDepthStencilAttachment {
    required GPUTextureView view;

    float depthClearValue = 0;
    boolean depthReadOnly = false;

    GPUStencilValue stencilClearValue = 0;
    boolean stencilReadOnly = false;
};
</script>

<dl dfn-type=dict-member dfn-for=GPURenderPassDepthStencilAttachment>
    : <dfn>view</dfn>
    ::
        一个描述纹理[=subresource=]的{{GPUTextureView}}，它将输出至此深度/模板附件，以及从此深度/模板附件中读取。

    : <dfn>depthClearValue</dfn>
    ::
        指示在执行渲染过程之前清除 {{GPURenderPassDepthStencilAttachment/view}} 的深度组件的值。
        如果不是 {{GPULoadOp/"clear"}}，则忽略 {{GPURenderPassDepthStencilAttachment/depthLoadOp}}。
        必须介于 0.0 和 1.0 之间（包括 0.0 和 1.0）。
        <!-- unless unrestricted depth is enabled -->

    : depthLoadOp
    ::
        指示在执行渲染过程之前要在 {{GPURenderPassDepthStencilAttachment/view}} 的深度组件上执行的加载操作。

        注：建议优先清除；详见 {{GPULoadOp/"clear"}}。

    : depthStoreOp
    ::
        执行渲染通道后对{{GPURenderPassDepthStencilAttachment/view}}深度组件执行的存储操作。

        注意：建议选择clear-value；见{{GPULoadOp/"load"}}。

    : <dfn>depthReadOnly</dfn>
    ::
        指{{GPURenderPassDepthStencilAttachment/view}}的深度组件，只读。

    : <dfn>stencilClearValue</dfn>
    ::
        指在执行渲染通道之前清除 {{GPURenderPassDepthStencilAttachment/view}} 的模板组件的值。
        如果不是 {{GPULoadOp/"clear"}}，则忽略 {{GPURenderPassDepthStencilAttachment/stencilLoadOp}}。

    : stencilLoadOp
    ::
        指在执行渲染通道之前要在 {{GPURenderPassDepthStencilAttachment/view}} 的模板组件上执行的加载操作。

        注：建议优先清除；详见 {{GPULoadOp/"clear"}}。

    : stencilStoreOp
    ::
        执行渲染通道后在{{GPURenderPassDepthStencilAttachment/view}}的模板组件上执行的存储操作。

    : <dfn>stencilReadOnly</dfn>
    ::
        指{{GPURenderPassDepthStencilAttachment/view}}的模板组件，只读。
</dl>

<div class=validusage dfn-for=GPURenderPassDepthStencilAttachment>
    <dfn abstract-op>GPURenderPassDepthStencilAttachment Valid Usage</dfn>

    给定一个{{GPURenderPassDepthStencilAttachment}} |this|，应用以下校验规则：

    - |this|.{{GPURenderPassDepthStencilAttachment/view}}必须有一个[=depth-or-stencil format=].
    - |this|.{{GPURenderPassDepthStencilAttachment/view}} 必须为一个 [$renderable texture view$].
    - 如果 |this|.{{GPURenderPassDepthStencilAttachment/depthLoadOp}} 是 {{GPULoadOp/"clear"}}，|this|.{{GPURenderPassDepthStencilAttachment/depthClearValue}} 必须介于 0.0 和 1.0 之间（含）。
      <!-- 除非启用了不受限制的深度 -->
    - If |this|.{{GPURenderPassDepthStencilAttachment/view}}.{{GPUTextureView/[[descriptor]]}}.{{GPUTextureViewDescriptor/format}}
        为一个 [=combined depth-stencil format=]:
        - |this|.{{GPURenderPassDepthStencilAttachment/depthReadOnly}} 必须等于 |this|.{{GPURenderPassDepthStencilAttachment/stencilReadOnly}}
    - 如果 |this|.{{GPURenderPassDepthStencilAttachment/depthReadOnly}} 为 `true`:
        - |this|.{{GPURenderPassDepthStencilAttachment/depthLoadOp}} 必须为 {{GPULoadOp/"load"}}.
        - |this|.{{GPURenderPassDepthStencilAttachment/depthStoreOp}} 必须为 {{GPUStoreOp/"store"}}.
    - If |this|.{{GPURenderPassDepthStencilAttachment/stencilReadOnly}} 为 `true`:
        - |this|.{{GPURenderPassDepthStencilAttachment/stencilLoadOp}} 必须为 {{GPULoadOp/"load"}}.
        - |this|.{{GPURenderPassDepthStencilAttachment/stencilStoreOp}} 必须为 {{GPUStoreOp/"store"}}.

</div>

#### 加载&amp;存储操作 #### {#load-and-store-ops}

<script type=idl>
enum GPULoadOp {
    "load",
    "clear",
};
</script>

<dl dfn-type=enum-value dfn-for=GPULoadOp>
    : <dfn>"load"</dfn>
    ::
        将此附件的现有值加载到渲染通道中。
    
    : <dfn>"clear"</dfn>
    ::
        将此附件的明确值加载到渲染通道中。

        注意：在某些 GPU 硬件（主要是移动设备）上，{{GPULoadOp/"clear"}} 的成本要低得多，因为它避免了将数据从主内存加载到 tile-local 内存中。
        在其他 GPU 硬件上，没有显着差异。
        因此，在初始值无关紧要的情况下（例如，渲染目标将使用天空盒清除），建议使用 {{GPULoadOp/"clear"}} 而不是 {{GPULoadOp/"load"}} 。

</dl>

<script type=idl>
enum GPUStoreOp {
    "store",
    "discard",
};
</script>

<dl dfn-type=enum-value dfn-for=GPUStoreOp>
    : <dfn>"store"</dfn>
    ::
        存储此附件的渲染通道的结果值。

    : <dfn>"discard"</dfn>
    ::
        丢弃此附件的渲染通道的结果值。
</dl>

#### 渲染通道布局 #### {#render-pass-layout}

{{GPURenderPassLayout}}包含当前通道渲染目标的布局，它决定了通道与渲染管线的兼容性。

<script type=idl>
dictionary GPURenderPassLayout: GPUObjectDescriptorBase {
    required sequence<GPUTextureFormat> colorFormats;
    GPUTextureFormat depthStencilFormat;
    GPUSize32 sampleCount = 1;
};
</script>

<div>
    从通道派生渲染目标布局（<dfn abstract-op>derive render targets layout from pass</dfn>）

    **Arguments:**
    - {{GPURenderPassDescriptor}} |descriptor|

    **Returns:** {{GPURenderPassLayout}}

    1. 使|layout|为一个新的{{GPURenderPassLayout}}对象。
    2. 对每个|descriptor|.{{GPURenderPassDescriptor/colorAttachments}}中的|colorAttachment|：
        1. 设置|layout|.{{GPURenderPassLayout/sampleCount}}为|colorAttachment|.{{GPURenderPassColorAttachment/view}}.{{GPUTextureView/[[texture]]}}.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/sampleCount}}。
        2. 将|colorAttachment|.{{GPURenderPassColorAttachment/view}}.{{GPUTextureView/[[descriptor]]}}.{{GPUTextureViewDescriptor/format}}添加至|layout|.{{GPURenderPassLayout/colorFormats}}。
    3. 使|depthStencilAttachment|为|descriptor|.{{GPURenderPassDescriptor/depthStencilAttachment}}.
    4. 如果|depthStencilAttachment|不为 `null`：
        1. 使|view|为|depthStencilAttachment|.{{GPURenderPassDepthStencilAttachment/view}}
        2. 使|layout|.{{GPURenderPassLayout/sampleCount}}为|view|.{{GPUTextureView/[[texture]]}}.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/sampleCount}}。
        3. 使|layout|.{{GPURenderPassLayout/depthStencilFormat}}为|view|.{{GPUTextureView/[[descriptor]]}}.{{GPUTextureViewDescriptor/format}}。
    5. 返回|layout|。

</div>

<div>
    从管线派生渲染目标布局（<dfn abstract-op>derive render targets layout from pipeline</dfn>）

    **Arguments:**
    - {{GPURenderPipelineDescriptor}} |descriptor|

    **Returns:** {{GPURenderPassLayout}}

    1. 使|layout|为一个新的{{GPURenderPassLayout}}对象。
    2. 设置|layout|.{{GPURenderPassLayout/sampleCount}}为|descriptor|.{{GPURenderPipelineDescriptor/multisample}}.{{GPUMultisampleState/count}}。
    3. 如果|descriptor|.{{GPURenderPipelineDescriptor/depthStencil}}不为 `null`：
        1. 设置|layout|.{{GPURenderPassLayout/depthStencilFormat}}为|descriptor|.{{GPURenderPipelineDescriptor/depthStencil}}/{{GPUDepthStencilState/format}}。
    4. 如果|descriptor|.{{GPURenderPipelineDescriptor/fragment}}不为 `null`:
        1. 对每个|descriptor|.{{GPURenderPipelineDescriptor/fragment}}.{{GPUFragmentState/targets}}中的|colorTarget|：
            1. 添加|colorTarget|.{{GPUColorTargetState/format}}至|layout|.{{GPURenderPassLayout/colorFormats}}。
    5. 返回|layout|。

</div>

### 绘制 ### {#render-pass-encoder-drawing}

<dl dfn-type=method dfn-for=GPURenderEncoderBase>
    : <dfn>setPipeline(pipeline)</dfn>
    ::
        设置当前{{GPURenderPipeline}}。

        <div algorithm="GPURenderEncoderBase.setPipeline">
            **Called on:** {{GPURenderEncoderBase}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderEncoderBase/setPipeline(pipeline)">
                |pipeline|: 后续绘制命令使用的渲染管线。
            </pre>

            **Returns:** {{undefined}}

            在|this|.{{GPUObjectBase/[[device]]}}的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                1. 使|pipelineTargetsLayout|为[$derive render targets layout from pipeline$](|pipeline|.{{GPURenderPipeline/[[descriptor]]}})。
                2. 如果以下任何条件未满足, 使|this| [=invalid=]并停止。
                    <div class=validusage>
                        - |pipeline|可以同|this|一起有效使用。
                        - |this|.{{GPURenderEncoderBase/[[layout]]}}等于|pipelineTargetsLayout|。
                        - 如果|pipeline|.{{GPURenderPipeline/[[writesDepth]]}}：
                            |this|.{{GPURenderEncoderBase/[[depthReadOnly]]}}必须为 `false`。
                        - If |pipeline|.{{GPURenderPipeline/[[writesStencil]]}}：
                            |this|.{{GPURenderEncoderBase/[[stencilReadOnly]]}}必须为 `false`。
                    </div>
                3. 设置|this|.{{GPURenderEncoderBase/[[pipeline]]}}为|pipeline|。

                问题：定义对于这里的{{GPURenderPassLayout}}"等于"的含义。
            </div>
        </div>

    : <dfn>setIndexBuffer(buffer, indexFormat, offset, size)</dfn>
    ::
        设置当前索引缓冲区。

        <div algorithm="GPURenderEncoderBase.setIndexBuffer">
            **Called on:** {{GPURenderEncoderBase}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderEncoderBase/setIndexBuffer(buffer, indexFormat, offset, size)">
                |buffer|: 包含后续绘制命令所使用的索引数据的缓冲区。
                |indexFormat|: |buffer|中包含的索引数据的格式。
                |offset|: 以字节为单位在索引数据开始的|缓冲区|中的偏移量。默认为 `0`。
                |size|: |缓冲区|中索引数据的大小（以字节为单位）。默认为缓冲区的大小减去偏移量。
            </pre>

            **Returns:** {{undefined}}

            在|this|.{{GPUObjectBase/[[device]]}}的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                1. 如果|size|缺失，设置|size|为max(0, |buffer|.{{GPUBuffer/[[size]]}} - |offset|)。
                1. 如果以下任何条件未满足，使|this| [=invalid=]并停止。
                    <div class=validusage>
                        - |buffer|可以和|this|一起有效使用。
                        - |buffer|.{{GPUBuffer/[[usage]]}}包含{{GPUBufferUsage/INDEX}}。
                        - |offset|是|indexFormat|字节大小的倍数。
                        - |offset| + |size| &le; |buffer|.{{GPUBuffer/[[size]]}}。
                    </div>
                1. 将|buffer|作为[=internal usage/input=]加至[=usage scope=]。
                1. 设置|this|.{{GPURenderEncoderBase/[[index_buffer]]}}为|buffer|。
                1. 设置|this|.{{GPURenderEncoderBase/[[index_format]]}}为|indexFormat|。
                1. 设置|this|.{{GPURenderEncoderBase/[[index_buffer_size]]}}为|size|。
            </div>
        </div>

    : <dfn>setVertexBuffer(slot, buffer, offset, size)</dfn>
    ::
        设置给定槽的当前顶点缓冲区。

        <div algorithm="GPURenderEncoderBase.setVertexBuffer">
            **Called on:** {{GPURenderEncoderBase}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderEncoderBase/setVertexBuffer(slot, buffer, offset, size)">
                |slot|: 要为其设置顶点缓冲区的顶点缓冲区插槽。
                |buffer|: 包含用于后续绘图命令的顶点数据的缓冲区。
                |offset|: 以字节为单位在顶点数据开始的|缓冲区|中的偏移量。默认为 0。
                |size|: |缓冲区|中顶点数据的大小（以字节为单位）。默认为|缓冲区|的大小减去偏移量。
            </pre>

            **Returns:** {{undefined}}

            在|this|.{{GPUObjectBase/[[device]]}}的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                1. 如果|size|缺失, 设置|size|为max(0, |buffer|.{{GPUBuffer/[[size]]}} - |offset|).
                2. 如果以下任何条件未满足，使|this| [=invalid=]并且停止。
                    <div class=validusage>
                        - |buffer|可以和|this|一起有效使用。
                        - |buffer|.{{GPUBuffer/[[usage]]}}包含{{GPUBufferUsage/VERTEX}}。
                        - |slot| &lt; |this|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxVertexBuffers}}。
                        - |offset|是4的倍数。
                        - |offset| + |size| &le; |buffer|.{{GPUBuffer/[[size]]}}。
                    </div>
                3. 将|缓冲区|作为[=internal usage/input=]加至[=usage scope=]。
                4. 设置|this|.{{GPURenderEncoderBase/[[vertex_buffers]]}}[|slot|]为|buffer|。
                5. 设置|this|.{{GPURenderEncoderBase/[[vertex_buffer_sizes]]}}[|slot|]为|size|。
            </div>
        </div>

    : <dfn>draw(vertexCount, instanceCount, firstVertex, firstInstance)</dfn>
    ::
        绘制图元。见[[#rendering-operations]]。

        <div algorithm="GPURenderEncoderBase.draw">
            **Called on:** {{GPURenderEncoderBase}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderEncoderBase/draw(vertexCount, instanceCount, firstVertex, firstInstance)">
                |vertexCount|: 绘制顶点数。
                |instanceCount|: 绘制实例数。
                |firstVertex|: 开始绘制的位置，以定点为单位的定点缓冲区偏移量。
                |firstInstance|: 第一个绘制实例。
            </pre>

            **Returns:** {{undefined}}

            在|this|.{{GPUObjectBase/[[device]]}}的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                如果以下任何条件未满足，使|this| [=invalid=]并停止。
                <div class=validusage>
                    - 可以和|this|一起有效绘制。
                    - 使|buffers|为|this|.{{GPURenderEncoderBase/[[pipeline]]}}.{{GPURenderPipeline/[[descriptor]]}}.{{GPURenderPipelineDescriptor/vertex}}.{{GPUVertexState/buffers}}.
                    - 对每个 {{GPUIndex32}} |slot| `0` 至 |buffers|.length：
                        - 使|bufferSize|为|this|.{{GPURenderEncoderBase/[[vertex_buffer_sizes]]}}[|slot|]。
                        - 使|stride|为|buffers|[|slot|].{{GPUVertexBufferLayout/arrayStride}}。
                        - 如果 |stride| 为零:
                            - 对每个列表|this|.{{GPURenderEncoderBase/[[pipeline]]}}.{{GPURenderPipeline/[[descriptor]]}}.{{GPURenderPipelineDescriptor/vertex}}.{{GPUVertexState/buffers}}.{{GPUVertexBufferLayout/attributes}}中的|attrib|:
                                - |attrib|.{{GPUVertexAttribute/offset}} + sizeof(|attrib|.{{GPUVertexAttribute/format}}) &le;
                                    |bufferSize|

                            否则:

                            - 如果 |buffers|[|slot|].{{GPUVertexBufferLayout/stepMode}} 为:
                                <dl class="switch">
                                    : {{GPUVertexStepMode/"vertex"}}
                                    :: (|firstVertex| + |vertexCount|) * |stride| &le; |bufferSize|.
                                    : {{GPUVertexStepMode/"instance"}}
                                    :: (|firstInstance| + |instanceCount|) * |stride| &le; |bufferSize|.
                                </dl>
                </div>
            </div>
        </div>

    : <dfn>drawIndexed(indexCount, instanceCount, firstIndex, baseVertex, firstInstance)</dfn>
    ::
        绘制索引图元。见[[#rendering-operations]]。

        <div algorithm="GPURenderEncoderBase.drawIndexed">
            **Called on:** {{GPURenderEncoderBase}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderEncoderBase/drawIndexed(indexCount, instanceCount, firstIndex, baseVertex, firstInstance)">
                |indexCount|: 要绘制的索引数。
                |instanceCount|: 要绘制的实例数。
                |firstIndex|: 开始绘制时，在索引缓冲区中的索引偏移量。
                baseVertex: 在索引到顶点缓冲区之前添加到每个索引值。
                |firstInstance|: 第一个绘制实例。
            </pre>

            **Returns:** {{undefined}}

            在|this|.{{GPUObjectBase/[[device]]}}的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                如果以下任何条件未满足，使this| [=invalid=]并停止。
                <div class=validusage>
                    - 可以和|this|一起有效绘制索引。
                    - |firstIndex| + |indexCount| &le; |this|.{{GPURenderEncoderBase/[[index_buffer_size]]}}
                        &div; |this|.{{GPURenderEncoderBase/[[index_format]]}}'s byte size;
                    - 使|buffers|为|this|.{{GPURenderEncoderBase/[[pipeline]]}}.{{GPURenderPipeline/[[descriptor]]}}.{{GPURenderPipelineDescriptor/vertex}}.{{GPUVertexState/buffers}}。
                    - 对每个{{GPUIndex32}} |slot| 从 `0` 至|buffers|.length（不包含|buffers|.length）：
                        - 使|bufferSize|为|this|.{{GPURenderEncoderBase/[[vertex_buffer_sizes]]}}[|slot|]。
                        - 使|stride|为|buffers|[|slot|].{{GPUVertexBufferLayout/arrayStride}}。
                        - 如果 |stride| 为零:
                            - 对每个在列表|this|.{{GPURenderEncoderBase/[[pipeline]]}}.{{GPURenderPipeline/[[descriptor]]}}.{{GPURenderPipelineDescriptor/vertex}}.{{GPUVertexState/buffers}}.{{GPUVertexBufferLayout/attributes}}中的|attrib|:
                                - |attrib|.{{GPUVertexAttribute/offset}} + sizeof(|attrib|.{{GPUVertexAttribute/format}}) &le;
                                    |bufferSize|

                            否则:

                            - 如果 |buffers|[|slot|].{{GPUVertexBufferLayout/stepMode}} 为 {{GPUVertexStepMode/"instance"}}:
                                - (|firstInstance| + |instanceCount|) * |stride| &le; |bufferSize|.
                </div>
            </div>
        </div>

    : <dfn>drawIndirect(indirectBuffer, indirectOffset)</dfn>
    ::
        使用从{{GPUBuffer}}中读取的参数的绘制图元。见[[#rendering-operations]]。

        缓冲区中编码的<dfn dfn for=>indirect draw parameters</dfn>必须是一个由**四个32位无符号整数值（总共16个字节）**组成的紧密压缩块，以与{{GPURenderEncoderBase/draw()}}的参数相同的顺序给出。比如：

        <pre highlight="js">
            let drawIndirectParameters = new Uint32Array(4);
            drawIndirectParameters[0] = vertexCount;
            drawIndirectParameters[1] = instanceCount;
            drawIndirectParameters[2] = firstVertex;
            drawIndirectParameters[3] = firstInstance;
        </pre>

        对应 `firstInstance` 的值被保留以备日后使用，并且必须为零，除非{{GPUFeatureName/"indirect-first-instance"}}
        [=feature=]被启用，如果{{GPUFeatureName/"indirect-first-instance"}} [=feature=]不被启用且 `firstInstance` 不为零则{{GPURenderEncoderBase/drawIndirect()}}调用被视作一个no-op。

        <div algorithm="GPURenderEncoderBase.drawIndirect">
            **Called on:** {{GPURenderEncoderBase}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderEncoderBase/drawIndirect(indirectBuffer, indirectOffset)">
                |indirectBuffer|: 包含[=indirect draw parameters=]的缓冲区。
                |indirectOffset|: 到绘图数据开始的|indirectBuffer|的以字节为单位的偏移量。
            </pre>

            **Returns:** {{undefined}}

            在|this|.{{GPUObjectBase/[[device]]}}的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                1. 如果以下任何条件未满足，使|this| [=invalid=]并停止。
                    <div class=validusage>
                        - 它可以和|this|一起有效绘制。
                        - |indirectBuffer|可以和|this|一起有效使用。
                        - |indirectBuffer|.{{GPUBuffer/[[usage]]}}包含{{GPUBufferUsage/INDIRECT}}。
                        - |indirectOffset| + sizeof([=indirect draw parameters=]) &le;
                            |indirectBuffer|.{{GPUBuffer/[[size]]}}。
                        - |indirectOffset|是4的倍数。
                    </div>
                2. 将|indirectBuffer|加至[=usage scope=] as [=internal usage/input=]。
            </div>
        </div>

    : <dfn>drawIndexedIndirect(indirectBuffer, indirectOffset)</dfn>
    ::
        使用从{{GPUBuffer}}读取的参数的绘制索引图元。见[[#rendering-operations]]。

        缓冲区中编码的<dfn dfn for=>indirect drawIndexed parameters</dfn>必须是由**五个32位无符号整数值（共 20 个字节）**组成的紧密压缩块，其顺序与{{GPURenderEncoderBase/drawIndexed()}}的参数相同。比如：

        <pre highlight="js">
            let drawIndexedIndirectParameters = new Uint32Array(5);
            drawIndexedIndirectParameters[0] = indexCount;
            drawIndexedIndirectParameters[1] = instanceCount;
            drawIndexedIndirectParameters[2] = firstIndex;
            drawIndexedIndirectParameters[3] = baseVertex;
            drawIndexedIndirectParameters[4] = 0; // firstInstance. Must be 0.
        </pre>

        对应 `firstInstance` 的值被保留以备日后使用并且必须为零。如果它不为零，则{{GPURenderEncoderBase/drawIndexedIndirect()}}调用被视作一个no-op。

        <div algorithm="GPURenderEncoderBase.drawIndexedIndirect">
            **Called on:** {{GPURenderEncoderBase}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderEncoderBase/drawIndexedIndirect(indirectBuffer, indirectOffset)">
                |indirectBuffer|: 包含[=indirect drawIndexed parameters=]的缓冲区。
                |indirectOffset|: 绘制数据开始处|indirectBuffer|中的字节偏移量。
            </pre>

            **Returns:** {{undefined}}

            在|this|.{{GPUObjectBase/[[device]]}}的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                1. 如果以下任何条件未满足，使|this| [=invalid=]并且停止。
                    <div class=validusage>
                        - 可以和|this|一起有效绘制索引。
                        - |indirectBuffer|可以和|this|一起有效使用。
                        - |indirectBuffer|.{{GPUBuffer/[[usage]]}}包含{{GPUBufferUsage/INDIRECT}}.
                        - |indirectOffset| + sizeof([=indirect drawIndexed parameters=]) &le;
                            |indirectBuffer|.{{GPUBuffer/[[size]]}}.
                        - |indirectOffset|是4的倍数。
                    </div>
                2. 将|indirectBuffer|添加至[=usage scope=] as [=internal usage/input=]。
            </div>
        </div>
</dl>

<div>
    要确定使用{{GPURenderEncoderBase}}|编码器|是否<dfn abstract-op>valid to draw</dfn>，运行以下步骤：

    如果以下任何条件未满足，返回 `false`：
        <div class=validusage>
            - [$Validate encoder bind groups$](|encoder|, |encoder|.{{GPURenderEncoderBase/[[pipeline]]}})必须为 `true`。

            - 使|topology|为|encoder|.{{GPURenderEncoderBase/[[pipeline]]}}.{{GPURenderPipeline/[[descriptor]]}}.
            - 如果|topology|为{{GPUPrimitiveTopology/"line-strip"}} or {{GPUPrimitiveTopology/"triangle-strip"}}:
                - |encoder|.{{GPURenderEncoderBase/[[index_format]]}}必须等于|encoder|.{{GPURenderEncoderBase/[[pipeline]]}}.{{GPURenderPipeline/[[descriptor]]}}.{{GPURenderPipelineDescriptor/primitive}}.{{GPUPrimitiveState/stripIndexFormat}}.
        </div>

    否则返回 `true`。
</div>

<div>
    要确定使用{{GPURenderEncoderBase}}|编码器|进行索引绘制（<dfn abstract-op>valid to draw indexed</dfn>）是否有效，请运行以下步骤：

    如果以下任何条件未满足, 返回 `false`：
        <div class=validusage>
            - 使用编码器绘制必须有效。

            - |encoder|.{{GPURenderEncoderBase/[[index_buffer]]}}必须不为 `null`。
            - 使|stripIndexFormat|为|encoder|.{{GPURenderEncoderBase/[[pipeline]]}}.{{GPURenderPipeline/[[strip_index_format]]}}。
            - 如果|stripIndexFormat|不是 `undefined`：
                - |encoder|.{{GPURenderEncoderBase/[[index_format]]}}必须为|stripIndexFormat|。
        </div>

    否则返回 `true`。
</div>

### 光栅化状态 ### {#render-pass-encoder-rasterization-state}

{{GPURenderPassEncoder}}有几种方法会影响绘制命令如何光栅化到此编码器使用的附件。

<dl dfn-type=method dfn-for=GPURenderPassEncoder>
    : <dfn>setViewport(x, y, width, height, minDepth, maxDepth)</dfn>
    ::
        将光栅化阶段使用的视口设置为从标准化设备坐标线性映射到视口坐标。

        <div algorithm="GPURenderPassEncoder.setViewport">
            **Called on:** {{GPURenderPassEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPURenderPassEncoder/setViewport(x, y, width, height, minDepth, maxDepth)">
                |x|: 视口最小X像素值。
                |y|: 视口最小Y像素值。
                |width|: 视口宽度像素值。
                |height|: 视口高度像素值。
                |minDepth|: 视口最小深度。
                |maxDepth|: 视口最大深度。
            </pre>

            **Returns:** {{undefined}}

            在|this|的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                1. 如果以下任何条件未满足，生成一个校验错误并停止。
                    <div class=validusage>
                        - |x|大于等于 `0`。
                        - |y|大于等于 `0`。
                        - |width|大于等于 `0`。
                        - |height|大于等于 `0`。
                        - |x| + |width|小于等于|this|.{{GPURenderPassEncoder/[[attachment_size]]}}.width.
                        - |y| + |height|小于等于|this|.{{GPURenderPassEncoder/[[attachment_size]]}}.height.
                        - |minDepth|大于等于 `0.0`，小于等于 `1.0`。
                        - |maxDepth|大于等于 `0.0`，小于等于 `1.0`。
                        - |maxDepth|大于|minDepth|。
                    </div>
                2. 设置|this|.{{GPURenderPassEncoder/[[viewport]]}}为范围|x|, |y|, |width|, |height|, |minDepth|, 和|maxDepth|。
            </div>

            问题：允许GPU使用固定点或环绕视口坐标。
        </div>

    : <dfn>setScissorRect(x, y, width, height)</dfn>
    ::
        设置在光栅化阶段使用的裁剪矩形。转换为视口坐标后，任何落在裁剪矩形之外的片元都将被丢弃。

        <div algorithm="GPURenderPassEncoder.setScissorRect">
            **Called on:** {{GPURenderPassEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPURenderPassEncoder/setScissorRect(x, y, width, height)">
                |x|: 裁剪矩形的最小X值，以像素为单位。
                |y|: 裁剪矩形的最小Y值，以像素为单位。
                |width|: 裁剪矩形的宽度，以像素为单位。
                |height|: 裁剪矩形的高度，以像素为单位。
            </pre>

            **Returns:** {{undefined}}

            在|this|的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                1. 如果以下任何条件未满足，生成一个错误校验并停止。
                    <div class=validusage>
                        - |x|+|width|小于或等于|this|.{{GPURenderPassEncoder/[[attachment_size]]}}.width。
                        - |y|+|height|小于或等于|this|.{{GPURenderPassEncoder/[[attachment_size]]}}.height。
                    </div>
                2. 设置裁剪矩形范围为|x|, |y|, |width|, 和|height|。
            </div>
        </div>

    : <dfn>setBlendConstant(color)</dfn>
    ::
        设置与{{GPUBlendFactor/"constant"}}和“{{GPUBlendFactor/"one-minus-constant"}}”{{GPUBlendFactor}}一起使用的常量混合颜色和alpha值。

        <div algorithm="GPURenderPassEncoder.setBlendConstant">
            **Called on:** {{GPURenderPassEncoder}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderPassEncoder/setBlendConstant(color)">
                color: 混合时所使用的颜色。
            </pre>
        </div>

    : <dfn>setStencilReference(reference)</dfn>
    ::
        使用{{GPUStencilOperation/"replace"}} {{GPUStencilOperation}}设置模板测试期间使用的模板参考值。

        <div algorithm="GPURenderPassEncoder.setStencilReference">
            **Called on:** {{GPURenderPassEncoder}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderPassEncoder/setStencilReference(reference)">
                reference: 模板参考值。
            </pre>
        </div>
</dl>

### 查询 ### {#render-pass-encoder-queries}

<dl dfn-type=method dfn-for=GPURenderPassEncoder>
    : <dfn>beginOcclusionQuery(queryIndex)</dfn>
    ::

        <div algorithm="GPURenderPassEncoder.beginOcclusionQuery">
            **Called on:** {{GPURenderPassEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPURenderPassEncoder/beginOcclusionQuery(queryIndex)">
                |queryIndex|: 查询集合中的查询索引。
            </pre>

            **Returns:** {{undefined}}

            在|this|.{{GPUObjectBase/[[device]]}}的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                1. 如果以下任何条件未满足，生成一个错误校验并停止。
                    <div class=validusage>
                        - |this|.{{GPURenderPassEncoder/[[occlusion_query_set]]}}不为 `null`。
                        - |queryIndex| &lt; |this|.{{GPURenderPassEncoder/[[occlusion_query_set]]}}.{{GPUQuerySet/[[descriptor]]}}.{{GPUQuerySetDescriptor/count}}。
                        - 同一|queryIndex|的查询必须没有被事先写入此通道。
                        - |this|.{{GPURenderPassEncoder/[[occlusion_query_active]]}}为 `false`。
                    </div>

                2. 设置|this|.{{GPURenderPassEncoder/[[occlusion_query_active]]}}为 `true`。
            </div>
        </div>

    : <dfn>endOcclusionQuery()</dfn>
    ::

        <div algorithm="GPURenderPassEncoder.endOcclusionQuery">
            **Called on:** {{GPURenderPassEncoder}} this.

            **Returns:** {{undefined}}

            在|this|.{{GPUObjectBase/[[device]]}}的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                1. 如果以下任何条件未满足，产生一个校验错误并停止。
                    <div class=validusage>
                        - |this|.{{GPURenderPassEncoder/[[occlusion_query_active]]}}为 `true`。
                    </div>

                2. 设置|this|.{{GPURenderPassEncoder/[[occlusion_query_active]]}}为 `false`。
            </div>
        </div>
</dl>

### 捆绑 ### {#render-pass-encoder-bundles}

<dl dfn-type=method dfn-for=GPURenderPassEncoder>
    : <dfn>executeBundles(bundles)</dfn>
    ::
        执行先前记录到给定{{GPURenderBundle}}中的命令，作为此渲染通道的一部分。

        当执行{{GPURenderBundle}}时，它不会继承渲染通道的管线、绑定组或顶点和索引缓冲区。在{{GPURenderBundle}}执行后，渲染通道的管线、绑定组以及顶点和索引缓冲区被清除。

        注意：状态被清除，哪怕当零{{GPURenderBundle|GPURenderBundles}}被执行。

        Note: state is cleared even if zero {{GPURenderBundle|GPURenderBundles}} are executed.

        <div algorithm="GPURenderPassEncoder.executeBundles">
            **Called on:** {{GPURenderPassEncoder}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderPassEncoder/executeBundles(bundles)">
                |bundles|: 要执行的渲染捆绑列表。
            </pre>

            **Returns:** {{undefined}}

            对|this|的[=Device timeline=]发起以下步骤：
            <div class=device-timeline>
                1. 如果以下任何条件未满足，生成一个{{GPUValidationError}}并停止。
                    <div class=validusage>
                        - 对每个|bundles|中的|bundle|：
                            - |bundle|必须可以和|this|一起有效使用（[$valid to use with$]。
                            - |this|.{{GPURenderEncoderBase/[[layout]]}}必须等于|bundle|.{{GPURenderBundle/[[layout]]}}。
                            - 如果|this|.{{GPURenderEncoderBase/[[depthReadOnly]]}}为真，|bundle|.{{GPURenderBundle/[[depthReadOnly]]}}必须为真。
                            - 如果|this|.{{GPURenderEncoderBase/[[stencilReadOnly]]}}为真，|bundle|.{{GPURenderBundle/[[stencilReadOnly]]}}必须为真。
                    </div>
            </div>
        </div>
</dl>

### 结尾 ### {#render-pass-encoder-finalization}

用户完成记录命令后，可以通过调用{{GPURenderPassEncoder/endPass()}}来结束渲染通道编码器。 一旦{{GPURenderPassEncoder/endPass()}}被调用，渲染通道编码器就不能再使用了。

<dl dfn-type=method dfn-for=GPURenderPassEncoder>
    : <dfn>endPass()</dfn>
    ::
        完全记录渲染通道命令序列。

        <div algorithm="GPURenderPassEncoder.endPass">
            **Called on:** {{GPURenderPassEncoder}} |this|.

            **Returns:** {{undefined}}

            在|this|的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                1. 如果以下任何条件未满足，生成一个校验错误并停止。
                    <div class=validusage>
                        - |this|.{{GPUCommandsMixin/[[state]]}} must be "[=encoder state/open=]",
                    </div>
                1. [=Assert=]: |this|.{{GPUProgrammablePassEncoder/[[command_encoder]]}}.{{GPUCommandsMixin/[[state]]}} 为 "[=encoder state/locked=]".
                1. 设置 |this|.{{GPUCommandsMixin/[[state]]}} 为 "[=encoder state/ended=]".
                1. 设置 |this|.{{GPUProgrammablePassEncoder/[[command_encoder]]}}.{{GPUCommandsMixin/[[state]]}} 为 "[=encoder state/open=]".
                1. 如果以下任何条件未满足，使 |this|.{{GPUProgrammablePassEncoder/[[command_encoder]]}} [=invalid=] 并停止。
                    <div class=validusage>
                        - |this| 必须为 [=valid=].
                        - |this|.{{GPUDebugCommandsMixin/[[debug_group_stack]]}} 必须 [=list/is empty|be empty=].
                        - |this|.{{GPURenderPassEncoder/[[occlusion_query_active]]}} 必须为 `false`.
                    </div>
                1. 使用|this|.{{GPUCommandsMixin/[[commands]]}}，[=list/Extend=] |this|.{{GPUProgrammablePassEncoder/[[command_encoder]]}}.{{GPUCommandsMixin/[[commands]]}}。
                1. 对每个|this|.{{GPURenderPassEncoder/[[endTimestampWrites]]}}中的|timestampWrite|：
                    1. [=Assert=]: |timestampWrite|.{{GPURenderPassTimestampWrite/location}} 为 {{GPURenderPassTimestampLocation/"end"}}.
                    1. [=list/Append=] 一个 [=GPU command=] 至 |this|.{{GPUProgrammablePassEncoder/[[command_encoder]]}}.{{GPUCommandsMixin/[[commands]]}}，将GPU时间戳值写入|timestampWrite|.{{GPURenderPassTimestampWrite/querySet}}中的第|timestampWrite|.{{GPURenderPassTimestampWrite/queryIndex}}索引处。
                1. 问题：入队附件存储/丢弃。
            </div>
        </div>
</dl>

# 捆绑 # {#bundles}

## <dfn interface>GPURenderBundle</dfn> ## {#render-bundle}

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPURenderBundle {
};
GPURenderBundle includes GPUObjectBase;
</script>

<dl dfn-type=attribute dfn-for="GPURenderBundle">
    : <dfn>\[[command_list]]</dfn> of type [=list=]&lt;[=GPU command=]&gt;.
    ::
        A [=list=] of [=GPU commands=] to be submitted to the {{GPURenderPassEncoder}} when the
        {{GPURenderBundle}} is executed.

    : <dfn>\[[layout]]</dfn>, of type {{GPURenderPassLayout}}
    ::
        The layout of the render bundle.

    : <dfn>\[[depthReadOnly]]</dfn>, of type boolean？
    ::
        如果为存在，则表示深度组件没有通过执行此渲染捆绑来修改。

    : <dfn>\[[stencilReadOnly]]</dfn>, of type boolean？
    ::
        如果存在，则表示模板组件没有通过执行此渲染捆绑来修改。
</dl>

### 创建 ### {#render-bundle-creation}

<script type=idl>
dictionary GPURenderBundleDescriptor : GPUObjectDescriptorBase {
};
</script>

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPURenderBundleEncoder {
    GPURenderBundle finish(optional GPURenderBundleDescriptor descriptor = {});
};
GPURenderBundleEncoder includes GPUObjectBase;
GPURenderBundleEncoder includes GPUCommandsMixin;
GPURenderBundleEncoder includes GPUDebugCommandsMixin;
GPURenderBundleEncoder includes GPUProgrammablePassEncoder;
GPURenderBundleEncoder includes GPURenderEncoderBase;
</script>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createRenderBundleEncoder(descriptor)</dfn>
    ::
        创建 {{GPURenderBundleEncoder}}.

        <div algorithm=GPUDevice.createRenderBundleEncoder>
            **调用:** {{GPUDevice}} |this|.

            **参数:**
            <pre class=argumentdef for="GPUDevice/createRenderBundleEncoder(descriptor)">
                |descriptor|: Description of the {{GPURenderBundleEncoder}} to create.
            </pre>

            **返回:** {{GPURenderBundleEncoder}}

            在 |this| 的 [=Device timeline=] 上发出以下步骤:
            <div class=device-timeline>
                1. 如果不满足以下任何条件，生成一个错误消息并停止。
                    <div class=validusage>
                        - |descriptor|.{{GPURenderPassLayout/colorFormats}}.length必须小于或等于8.
                        - |descriptor|.{{GPURenderPassLayout/colorFormats}}.length 必须大于 `0` 或|descriptor|.{{GPURenderPassLayout/depthStencilFormat}}必须不为 `null`:
                            - |descriptor|.{{GPURenderPassLayout/depthStencilFormat}} 必须不为 `null`.
                        - 对每个|descriptor|.{{GPURenderPassLayout/colorFormats}}中的|colorFormat|：
                            - |colorFormat|必须为[=color renderable format=]。
                        - 使|depthStencilFormat|为|descriptor|.{{GPURenderPassLayout/depthStencilFormat}}.
                        - 如果|depthStencilFormat|不为 `null`：
                            - |depthStencilFormat|必须为[=depth-or-stencil format=]。
                            - 如果|depthStencilFormat|为[=combined depth-stencil format=]：
                                - |descriptor|.{{GPURenderBundleEncoderDescriptor/depthReadOnly}}必须等于|descriptor|.{{GPURenderBundleEncoderDescriptor/stencilReadOnly}}
                    </div>
                1. 让 |e| 成为一个新的 {{GPURenderBundleEncoder}} 对象。
                1. 设定 |e|.{{GPURenderEncoderBase/[[layout]]}} 为 |descriptor|.{{GPURenderPassLayout}}.
                1. 设定 |e|.{{GPURenderEncoderBase/[[depthReadOnly]]}} 为 |descriptor|.{{GPURenderBundleEncoderDescriptor/depthReadOnly}}.
                1. 设定 |e|.{{GPURenderEncoderBase/[[stencilReadOnly]]}} 为 |descriptor|.{{GPURenderBundleEncoderDescriptor/stencilReadOnly}}.
                1. 设定 |e|.{{GPUCommandsMixin/[[state]]}} 为 "[=encoder state/open=]"
                1. 返回 |e|.

                问题：描述 {{GPUDevice/createRenderBundleEncoder()}} 的步骤重置。
            </div>
        </div>
</dl>

### 编码 ### {#render-bundle-encoding}

<script type=idl>
dictionary GPURenderBundleEncoderDescriptor : GPURenderPassLayout {
    boolean depthReadOnly = false;
    boolean stencilReadOnly = false;
};
</script>

### 定稿 ### {#render-bundle-finalization}

<dl dfn-type=method dfn-for=GPURenderBundleEncoder>
    : <dfn>finish(descriptor)</dfn>
    ::
        完成渲染包命令序列的记录。

        <div algorithm="GPURenderBundleEncoder.finish">
            **调用:** {{GPURenderBundleEncoder}} this.

            **参数:**
            <pre class=argumentdef for="GPURenderBundleEncoder/finish(descriptor)">
                descriptor:
            </pre>

            **返回:** {{GPURenderBundle}}

            1. 让|renderBundle|成为一个新的{{GPURenderBundle}}。
            1. 在|this|的[=Device timeline=]上发起以下步骤：
                <div class=device-timeline>
                    1. 如果以下条件都满足则使 |validationFailed| 为 `true`，否则为 `false`。
                    1. 如果以下任何条件未满足：
                        <div class=validusage>
                            - |this|必须[=valid=]。
                            - |this|.{{GPUCommandsMixin/[[state]]}} 必须为 "[=encoder state/open=]".
                            - |this|.{{GPUDebugCommandsMixin/[[debug_group_stack]]}} 必须 [=list/is empty|be empty=].
                            - 每个包含在[=usage scope=]中的|this|必须满足[=usage scope validation=]。
                        </div>

                    1. 设置 |this|.{{GPUCommandsMixin/[[state]]}} 为 "[=encoder state/ended=]".
                    1. 如果 |validationFailed|, 则:

                        1. 在当前范围内生成一个带有适当错误消息的{{GPUValidationError}}
                        1. 返回一个新的[=invalid=] {{GPURenderBundle}}。
                    1. 设定|renderBundle|.{{GPURenderBundle/[[command_list]]}}为|this|.{{GPUCommandsMixin/[[commands]]}}。
                </div>

            1. 返回|renderBundle|.
        </div>
</dl>

# 队列 # {#queues}

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUQueue {
    undefined submit(sequence<GPUCommandBuffer> commandBuffers);

    Promise<undefined> onSubmittedWorkDone();

    undefined writeBuffer(
        GPUBuffer buffer,
        GPUSize64 bufferOffset,
        [AllowShared] BufferSource data,
        optional GPUSize64 dataOffset = 0,
        optional GPUSize64 size);

    undefined writeTexture(
      GPUImageCopyTexture destination,
      [AllowShared] BufferSource data,
      GPUImageDataLayout dataLayout,
      GPUExtent3D size);

    undefined copyExternalImageToTexture(
        GPUImageCopyExternalImage source,
        GPUImageCopyTextureTagged destination,
        GPUExtent3D copySize);
};
GPUQueue includes GPUObjectBase;
</script>

{{GPUQueue}} 有以下方法:

<dl dfn-type=method dfn-for=GPUQueue>
    : <dfn>writeBuffer(buffer, bufferOffset, data, dataOffset, size)</dfn>
    ::
        将提供的数据写入 {{GPUBuffer}}。

        <div algorithm=GPUQueue.writeBuffer>
            **调用:** {{GPUQueue}} |this|.

            **参数:**
            <pre class=argumentdef for="GPUQueue/writeBuffer(buffer, bufferOffset, data, dataOffset, size)">
                |buffer|: The buffer to write to.
                |bufferOffset|: Offset in bytes into |buffer| to begin writing at.
                |data|: Data to write into |buffer|.
                |dataOffset|: Offset in into |data| to begin writing from. Given in elements if
                    |data| is a `TypedArray` and bytes otherwise.
                |size|: Size of content to write from |data| to |buffer|. Given in elements if
                    |data| is a `TypedArray` and bytes otherwise.
            </pre>

            **返回:** {{undefined}}

            1.如果 |data| 是一个 {{ArrayBuffer}} 或 {{DataView}}，让元素类型为“byte”。
                否则，|data| 是一个 TypedArray； 让元素类型为 TypedArray 的类型。
            1. 让 |dataSize| 是 |data| 的大小，以元素为单位。
            1. 如果 |size| 不见了，
                让 |contentsSize| 为 |dataSize| &minus; |dataOffset|。
                否则， 让 |contentsSize| 为 |size|。
            1. 如果不满足以下任何一个条件，
                抛出 {{OperationError}} 并停止。
                <!-- 注意：在此处内联编写有效的使用规则是最容易的，因为它们取决于上面的 contentsSize。 -->
                <div class=validusage>
                    - |contentsSize| &ge; 0.
                    - |dataOffset| + |contentsSize| &le; |dataSize|.
                    - |contentsSize|，转换为字节，是 4 字节的倍数。
                </div>
            1. 让 |dataContents| 为 获取缓冲区源的副本|缓冲区源所持有的字节的副本。
            1. 让 |contents| 是 |dataContents| 元素的 |contentsSize| 从 |dataOffset| 的偏移量开始。
            1. 在 |this| 的 [=Queue timeline=] 上发出以下步骤:
                <div class=queue-timeline>
                    1. 如果不满足以下任何条件，生成一个校验错误并停止。
                        <div class=validusage>
                            - |buffer| 是  [$valid to use with$] |this|.
                            - |buffer|.{{GPUBuffer/[[state]]}} 是 [=buffer state/unmapped=]。
                            - |buffer|.{{GPUBuffer/[[usage]]}} 包含 {{GPUBufferUsage/COPY_DST}}。
                            - |bufferOffset|，转换为字节，是 4 字节的倍数。
                            - |bufferOffset| + |contentsSize| ，转换为字节 &le; |buffer|.{{GPUBuffer/[[size]]}} 字节。
                        </div>
                    1. 将 |contents| 写入 |buffer| 从 |bufferOffset| 开始。
                </div>
        </div>

    : <dfn>writeTexture(destination, data, dataLayout, size)</dfn>
    ::
        将提供的数据写入 {{GPUTexture}}。

        <div algorithm=GPUQueue.writeTexture>
            **调用:** {{GPUQueue}} |this|.

            **参数:**
            <pre class=argumentdef for="GPUQueue/writeTexture(destination, data, dataLayout, size)">
                |destination|: [=texture subresource=] 和要写入的来源。
                |data|: 要写入 |destination| 的数据。
                |dataLayout|: |data| 中内容的布局。
                |size|: 要从 |data| 写入的内容的范围 到 |destination|。
            </pre>

            **返回:** {{undefined}}

            1. 让 |dataBytes| 为获取缓冲区源的副本|缓冲区源所持有的字节的副本 |data|.
            1. 让 |dataByteSize| 是 |dataBytes| 中的字节数。
            1. 让 |textureDesc| 为 |destination|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}。
            1. 如果不满足以下任何一个条件，
                抛出 {{OperationError}} 并停止。
                <div class=validusage>
                    - [$validating linear texture data$](|dataLayout|,
                        |dataByteSize|,
                        |textureDesc|.{{GPUTextureDescriptor/format}},
                        |size|) succeeds.
                </div>
            1. 让 |contents| 是通过查看 |dataBytes| 看到的 [=images=] 的内容 与 |dataLayout| 和 |size|。

                问题：更正式地指定。
            1. 在 |this| 的 [=Queue timeline=] 上发出以下步骤:
                <div class=queue-timeline>
                    1. 如果不满足以下任何条件，生成一个校验错误并停止。
                        <div class=validusage>
                            - [$validating GPUImageCopyTexture$](|destination|, |size|) 返回 `true`。
                            - |textureDesc|.{{GPUTextureDescriptor/usage}} 包含 {{GPUTextureUsage/COPY_DST}}。
                            - |textureDesc|.{{GPUTextureDescriptor/sampleCount}} 是 1。
                            - [=Valid Texture Copy Range=](|destination|, |size|)被满足。
                            - |destination|.{{GPUImageCopyTexture/aspect}} 指的是 |textureDesc|.{{GPUTextureDescriptor/format}} 的单个可复制方面。 参见 [[#depth-formats|depth-formats]]。
                            - |destination|.{{GPUImageCopyTexture/aspect}} 必须指代 |textureDesc|.{{GPUTextureDescriptor/format}} 的单个宽高比，并且该宽高比必须是根据 [[#depth-formats]] 的有效图像复制目标。

                            注意：与 {{GPUCommandEncoder}}.{{GPUCommandEncoder/copyBufferToTexture()}} 不同，
                            |dataLayout|.{{GPUImageDataLayout/bytesPerRow}} 或 |dataLayout|.{{GPUImageDataLayout/offset}} 没有对齐要求。
                        </div>
                    1. 将 |contents| 写入 |destination|。

                </div>
        </div>

    : <dfn>copyExternalImageToTexture(source, destination, copySize)</dfn>
    ::
        将平台图像/画布的内容复制到目标纹理中。

        该操作根据{{GPUImageCopyTextureTagged}}的参数将[[#color-space-conversions|color encoding]]转换为目标编码。

        复制到 `-srgb` 纹理会产生相同的纹理字节，而不是相同的解码值，与复制到相应的非 `-srgb` 格式相同。
        因此，在复制操作之后，根据其格式是否为 `-srgb`，对目标纹理进行采样会产生不同的结果，其他一切都保持不变。

        问题：如果添加了 srgb 线性色彩空间，请在此处解释它是如何交互的。

        <div algorithm=GPUQueue.copyExternalImageToTexture>
            **调用:** {{GPUQueue}} |this|.

            **参数:**
            <pre class=argumentdef for="GPUQueue/copyExternalImageToTexture(source, destination, copySize)">
                |source|: 要复制到 |destination| 的源图像和来源。
                |destination|: [=texture subresource=] 和要写入的来源，及其编码元数据。
                |copySize|: 要从 |source| 到 |destination| 写入的内容的范围。
            </pre>

            **返回:** {{undefined}}

            1. 让 |sourceImage| 为 |source|.{{GPUImageCopyExternalImage/source}}。
            1. 运行 [=Check the usability of the image argument=](|sourceImage|).
                如果抛出异常，则停止。
                如果没有返回 `good`，抛出一个 {{InvalidStateError}} 并停止。
            1. 如果 |sourceImage| <l spec=html>[=is not origin-clean=]</l>,
                抛出一个 {{SecurityError}} 并停止。
            1. 如果未满足以下任何要求，则抛出 {{OperationError}} 并停止。
                <div class=validusage>
                    - 如果 |source|.{{GPUImageCopyExternalImage/source}} 是一个 {{HTMLCanvasElement}}:
                        它的 [=canvas context mode=] 必须是 `"2d"`， `"webgl"`，或 `"webgl2"`，或 `"webgpu"`。
                    - 如果 |source|.{{GPUImageCopyExternalImage/source}} 是一个 {{OffscreenCanvas}}:
                        它的 [=OffscreenCanvas context mode=] 必须是 `"2d"`， `"webgl"`，或 `"webgl2"`，或 `"webgpu"`。
                    - |source|.|origin|.[=Origin3D/x=] + |copySize|.[=Extent3D/width=]
                        必须 &le; |sourceImage| 的宽度。
                    - |source|.|origin|.[=Origin3D/y=] + |copySize|.[=Extent3D/height=]
                        必须 &le; |sourceImage| 的高度。
                    - |source|.|origin|.[=Origin3D/z=] + |copySize|.[=Extent3D/depthOrArrayLayers=]
                        必须 &le; 1。
                </div>
            1. 在 |this| 的 [=Device timeline=] 上发出以下步骤:
                <div class=device-timeline>
                    1. 让 |textureDesc| 为 |destination|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}。
                    1. 如果未满足以下任何要求，生成一个校验错误并停止。
                        <div class=validusage>
                            - |destination|.{{GPUImageCopyTexture/texture}} 必须 [$valid to use with$] |this|。
                            - [$validating GPUImageCopyTexture$](destination, copySize) 必须返回真。
                            - [=Valid Texture Copy Range=](destination, copySize) 必须返回 `true`.
                            - |textureDesc|.{{GPUTextureDescriptor/usage}} 必须同时包含
                                {{GPUTextureUsage/RENDER_ATTACHMENT}} 和 {{GPUTextureUsage/COPY_DST}}。
                            - |textureDesc|.{{GPUTextureDescriptor/dimension}} 必须是 {{GPUTextureDimension/"2d"}}。
                            - |textureDesc|.{{GPUTextureDescriptor/sampleCount}} 必须是 1。
                            - |textureDesc|.{{GPUTextureDescriptor/format}} 必须是以下之一格式：
                                - {{GPUTextureFormat/"r8unorm"}}
                                - {{GPUTextureFormat/"r16float"}}
                                - {{GPUTextureFormat/"r32float"}}
                                - {{GPUTextureFormat/"rg8unorm"}}
                                - {{GPUTextureFormat/"rg16float"}}
                                - {{GPUTextureFormat/"rg32float"}}
                                - {{GPUTextureFormat/"rgba8unorm"}}
                                - {{GPUTextureFormat/"rgba8unorm-srgb"}}
                                - {{GPUTextureFormat/"bgra8unorm"}}
                                - {{GPUTextureFormat/"bgra8unorm-srgb"}}
                                - {{GPUTextureFormat/"rgb10a2unorm"}}
                                - {{GPUTextureFormat/"rgba16float"}}
                                - {{GPUTextureFormat/"rgba32float"}}
                        </div>
                    1. 问题：进行实际复制。
                </div>
        </div>

    : <dfn>submit(commandBuffers)</dfn>
    ::
        调度 GPU 在此队列上执行命令缓冲区。

        <div algorithm=GPUQueue.submit>
            **调用:** {{GPUQueue}} this.

            **参数:**
            <pre class=argumentdef for="GPUQueue/submit(commandBuffers)">
                |commandBuffers|:
            </pre>

            **返回:** {{undefined}}

            在 |this| 的 [=Device timeline=] 上发出以下步骤:
            <div class=device-timeline>
                1. 如果不满足以下任何条件，生成一个校验错误并停止。
                    <div class=validusage>
                        - |commandBuffers| 的任何元素中引用的每个 {{GPUBuffer}} 处于 `“unmapped”`[=buffer state=]。
                        - |commandBuffers| 的任何元素中的命令中引用的每个 {{GPUQuerySet}} 处于 [=query set state/available=] 状态。
                            对于遮挡查询，
                            {{GPUCommandEncoder/beginRenderPass()} 中的 {{GPURenderPassDescriptor/occlusionQuerySet}} 不构成参考，
                            而 {{GPURenderPassEncoder/beginOcclusionQuery()}} 则构成参考。
                    </div>

                1. 在 |this| 的 [=Queue timeline=] 上发出以下步骤:
                    <div class=queue-timeline>
                        1. 对于每个 |commandBuffer| 在 |commandBuffers| 中:
                            1. 执行 |commandBuffer|.{{GPUCommandBuffer/[[command_list]]}}中的每个命令。
                    </div>
            </div>
        </div>

    : <dfn>onSubmittedWorkDone()</dfn>
    ::
        返回一个 {{Promise}} ，一旦这个队列完成处理所有提交的工作，这个时刻就会解决。

        <div algorithm="GPUQueue.onSubmittedWorkDone">
            **调用:** {{GPUQueue}} this.

            **参数:**
            <pre class=argumentdef for="GPUQueue/onSubmittedWorkDone()">
            </pre>

            **返回:** {{Promise}}&lt;{{undefined}}&gt;

            问题：描述 {{GPUQueue/onSubmittedWorkDone()}} 算法步骤。
        </div>
</dl>

查询 {#queries}
================

## <dfn interface>GPUQuerySet</dfn> ## {#queryset}

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUQuerySet {
    undefined destroy();
};
GPUQuerySet includes GPUObjectBase;
</script>

{{GPUQuerySet}} 有以下内部插槽:

<dl dfn-type=attribute dfn-for="GPUQuerySet">
    : <dfn>\[[descriptor]]</dfn>， {{GPUQuerySetDescriptor}} 类型
    ::
        描述此查询集的 {{GPUQuerySetDescriptor}}。

        {{GPUTextureViewDescriptor}} 的所有可选字段都已定义。

    : <dfn>\[[state]]</dfn> 【=query set state=] 类型。
    ::
        {{GPUQuerySet}} 的当前状态。
</dl>

每个 {{GPUQuerySet}} 在 [=Device Timeline=] 上都有一个当前的 <dfn dfn>query set state</dfn>，它是以下之一：

 - "<dfn dfn for="query set state">available</dfn>" 其中 {{GPUQuerySet}} 可用于对其内容进行 GPU 操作。
 - "<dfn dfn for="query set state">destroyed</dfn>" 其中 {{GPUQuerySet}} 不再可用于除 {{GPUQuerySet/destroy}} 之外的任何操作。

### 查询集创建 ### {#queryset-creation}

{{GPUQuerySetDescriptor}} 指定用于创建 {{GPUQuerySet}} 的选项。

<script type=idl>
dictionary GPUQuerySetDescriptor : GPUObjectDescriptorBase {
    required GPUQueryType type;
    required GPUSize32 count;
};
</script>

<dl dfn-type=dict-member dfn-for=GPUQuerySetDescriptor>
    : <dfn>type</dfn>
    ::
        {{GPUQuerySet}} 管理的查询类型。

    : <dfn>count</dfn>
    ::
        {{GPUQuerySet}} 管理的查询数量。
</dl>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createQuerySet(descriptor)</dfn>
    ::
        创建一个 {{GPUQuerySet}}.

        <div algorithm=GPUDevice.createQuerySet>
            **调用:** {{GPUDevice}} this.

            **参数:**
            <pre class=argumentdef for="GPUDevice/createQuerySet(descriptor)">
                descriptor: 要创建的 {{GPUQuerySet}} 的描述。
            </pre>

            **返回:** {{GPUQuerySet}}

            1. 如果 |descriptor|.{{GPUQuerySetDescriptor/type}} 是 {{GPUQueryType/"timestamp"}}，
                但是 |this|.{{GPUObjectBase/[[device]]}}.{{device/[[features]]}} 不包含 [=list/contain=]
                {{GPUFeatureName/"timestamp-query"}}， 抛出一个 {{TypeError}}。
            1. 如果未满足以下任何要求，则返回错误查询集并停止。
                <div class=validusage>
                    - |this| 必须是一个 [=valid=] {{GPUDevice}}.
                    - |descriptor|.{{GPUQuerySetDescriptor/count}} 必须 &le; 8192.
                </div>
            1. 让 |q| 成为一个新的 {{GPUQuerySet}} 对象。
            1. 设置 |q|.{{GPUQuerySet/[[descriptor]]}} 为 |descriptor|。
            1. 设置 |q|.{{GPUQuerySet/[[state]]}} 为 [=query set state/available=]。
            1. 返回 |q|。
        </div>
</dl>

<div class="example">
    创建一个包含 32 个遮挡查询结果的 {{GPUQuerySet}}。
    <pre highlight="js">
        const querySet = gpuDevice.createQuerySet({
            type: 'occlusion',
            count: 32
        });
    </pre>
</div>

### 查询集销毁 ### {#queryset-destruction}

不再需要 {{GPUQuerySet}} 的应用程序可以通过调用 {{GPUQuerySet/destroy()}} 选择在垃圾收集之前失去对它的访问权限。

<dl dfn-type=method dfn-for=GPUQuerySet>
    : <dfn>destroy()</dfn>
    ::
        销毁 {{GPUQuerySet}}。

        <div algorithm="GPUQuerySet.destroy">
            **调用:** {{GPUQuerySet}} |this|.

            **返回:** {{undefined}}

            1. 设置 |this|.{{GPUQuerySet/[[state]]}} 为 [=query set state/destroyed=]。
        </div>
</dl>

## 查询类型 ## {#querytype}

<script type=idl>
enum GPUQueryType {
    "occlusion",
    "timestamp",
};
</script>

## 遮挡查询 ## {#occlusion}

遮挡查询仅在渲染过程中可用，用于查询通过一组绘图命令的所有每个片段测试的片段样本数量，包括剪刀、样本蒙版、覆盖率、模板和深度测试。
查询的任何非零结果值表示至少有一个样本通过了测试并到达了渲染管道的输出合并阶段，0 表示没有样本通过测试。

开始渲染过程时，{{GPURenderPassDescriptor}}.{{GPURenderPassDescriptor/occlusionQuerySet}} 必须设置为能够在过程中使用遮挡查询。
遮挡查询开始和结束是通过成对调用 {{GPURenderPassEncoder/beginOcclusionQuery()}} 和 {{GPURenderPassEncoder/endOcclusionQuery()}}，不能嵌套。

## 时间戳查询 ## {#timestamp}

时间戳查询允许应用程序通过在 {{GPUComputePassEncoder}} 或 {{GPURenderPassEncoder}} 或 {{GPUCommandEncoder}} 上调用
{{GPUCommandEncoder/writeTimestamp()}} 将时间戳值写入 {{GPUQuerySet}}，
然后解析时间戳值 在 **nanoseconds**（{{GPUSize64}} 的类型）到 {{GPUBuffer}}（使用 {{GPUCommandEncoder/resolveQuerySet()}}）。

时间戳查询需要 {{GPUFeatureName/"timestamp-query"}} 在设备上可用。

注意：如果物理设备重置时间戳计数器，时间戳值可能为零，请忽略它和以下值。

问题：编写有关时间戳值重置的规范文本。

问题：由于时间戳查询提供高分辨率的 GPU 时间戳，我们需要确定其可用性受到哪些限制（如果有的话）。

# 画布渲染 # {#canvas-rendering}

## {{HTMLCanvasElement/getContext()|HTMLCanvasElement.getContext()}} ## {#canvas-getcontext}

{{GPUCanvasContext}} 对象可以通过 {{HTMLCanvasElement/getContext()}} 获得
{{HTMLCanvasElement}} 实例的方法，通过将字符串文字 `'webgpu'` 作为其 `contextType` 参数传递。

<div class="example">
    Get a {{GPUCanvasContext}} from an offscreen {{HTMLCanvasElement}}:
    <pre highlight="js">
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('webgpu');
    </pre>
</div>

## GPUCanvasContext ## {#canvas-context}

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUCanvasContext {
    readonly attribute (HTMLCanvasElement or OffscreenCanvas) canvas;

    undefined configure(GPUCanvasConfiguration configuration);
    undefined unconfigure();

    GPUTextureFormat getPreferredFormat(GPUAdapter adapter);
    GPUTexture getCurrentTexture();
};
</script>

{{GPUCanvasContext}} 具有以下属性:

<dl dfn-type=attribute dfn-for=GPUCanvasContext>
    : <dfn>canvas</dfn>
    ::
        创建此上下文的画布。
</dl>

{{GPUCanvasContext}} 有以下内部插槽:

<dl dfn-type=attribute dfn-for="GPUCanvasContext">
    : <dfn>\[[validConfiguration]]</dfn> boolean 类型， 初始化为 `false`。
    ::
        指示上下文当前是否具有有效配置。

    : <dfn>\[[configuration]]</dfn> {{GPUCanvasConfiguration}} 类型， 初始化为 `null`。
    ::
        配置此上下文的选项。 设置为 `null` 如果上下文尚未配置或配置已被删除。

    : <dfn>\[[size]]</dfn> {{GPUExtent3D}} 类型
    ::
        从该上下文返回的 {{GPUTexture}} 的大小。[=Extent3D/depthOrArrayLayers=] 始终为 `1`。

    : <dfn>\[[currentTexture]]</dfn> {{GPUTexture}} 类型， 初始化为 `null`
    ::
        调用 {{GPUCanvasContext/getCurrentTexture()}} 时上下文将返回的当前纹理，以及下一个要合成到文档中的纹理。
        最初设置为此上下文 [$allocating a new context texture$] 的结果。
</dl>

{{GPUCanvasContext}} 有以下方法:

<dl dfn-type=method dfn-for=GPUCanvasContext>
    : <dfn>configure(configuration)</dfn>
    ::
        配置此画布的上下文。 销毁使用先前配置生成的任何纹理。

        <div algorithm="GPUCanvasContext.configure">
            **调用:** {{GPUCanvasContext}} |this|.

            **参数:**
            <pre class=argumentdef for="GPUCanvasContext/configure(configuration)">
                |configuration|: 所需的上下文配置。
            </pre>

            **返回:** undefined

            1. 设定 |this|.{{GPUCanvasContext/[[validConfiguration]]}} 为 `false`.
            1. 设定 |this|.{{GPUCanvasContext/[[configuration]]}} 为 |configuration|.
            1. 如果 |this|.{{GPUCanvasContext/[[currentTexture]]}} 不是 `null` 在
                |this|.{{GPUCanvasContext/[[currentTexture]]}} 上调用 {{GPUTexture/destroy()}}。
            1. 设定 |this|.{{GPUCanvasContext/[[currentTexture]]}} 为 `null`.
            1. 让 |device| 为 |configuration|.{{GPUCanvasConfiguration/device}}。
            1. 让 |canvas| 为 |this|.{{GPUCanvasContext/canvas}}。
            1. 如果 |configuration|.{{GPUCanvasConfiguration/size}} 是 `undefined`， 设定
                |this|.{{GPUCanvasContext/[[size]]}} 为 [|canvas|.width, |canvas|.height, 1],
                否则设定 |this|.{{GPUCanvasContext/[[size]]}} 为
                |configuration|.{{GPUCanvasConfiguration/size}}。

            1. 在 |device| 的 [=Device Timeline=] 上执行以下步骤:
                <div class=device-timeline>
                    1. 如果不满足以下任一条件：
                        <div class=validusage>
                            - |device| 是一个 [=valid=] {{GPUDevice}}。
                            - [=Supported context formats=] [=set/contains=]
                                |configuration|.{{GPUCanvasConfiguration/format}}.
                            - |this|.{{GPUCanvasContext/[[size]]}}.[=Extent3D/width=] &gt; 0.
                            - |this|.{{GPUCanvasContext/[[size]]}}.[=Extent3D/width=] &le;
                                |device|.{{GPUDevice/limits}}.{{GPUSupportedLimits/maxTextureDimension2D}}.
                            - |this|.{{GPUCanvasContext/[[size]]}}.[=Extent3D/height=] &gt; 0.
                            - |this|.{{GPUCanvasContext/[[size]]}}.[=Extent3D/height=] &le;
                                |device|.{{GPUDevice/limits}}.{{GPUSupportedLimits/maxTextureDimension2D}}.
                            - |this|.{{GPUCanvasContext/[[size]]}}.[=Extent3D/depthOrArrayLayers=]
                                是 1;
                        </div>

                        Then:
                            1. 生成一个校验错误。
                            1. 返回。
                </div>
            1. 设定 |this|.{{GPUCanvasContext/[[validConfiguration]]}} 为 `true`。
        </div>

    : <dfn>unconfigure()</dfn>
    ::
        删除上下文配置。 销毁配置时产生的任何纹理。

        <div algorithm="GPUCanvasContext.unconfigure">
            **调用:** {{GPUCanvasContext}} |this|。

            **返回:** undefined

            1. 设定 |this|.{{GPUCanvasContext/[[validConfiguration]]}} 为 `false`。
            1. 设定 |this|.{{GPUCanvasContext/[[configuration]]}} 为 `null`。
            1. 如果 |this|.{{GPUCanvasContext/[[currentTexture]]}} 不是 `null` 调用
                 |this|.{{GPUCanvasContext/[[currentTexture]]}} 上的 {{GPUTexture/destroy()}}。
            1. 设定 |this|.{{GPUCanvasContext/[[currentTexture]]}} 为 `null`。
        </div>

    : <dfn>getPreferredFormat(adapter)</dfn>
    ::
        返回最佳 {{GPUTextureFormat}} 以用于此上下文和从给定适配器创建的设备。

        <div algorithm="GPUCanvasContext.getPreferredFormat">
            **调用:** {{GPUCanvasContext}} this.

            **参数:**
            <pre class=argumentdef for="GPUCanvasContext/getPreferredFormat(adapter)">
                |adapter|: 应查询格式的适配器。
            </pre>

            **返回:** {{GPUTextureFormat}}

            <div class=content-timeline>
                1. 返回最佳 {{GPUTextureFormat}} 以在使用给定的 |adapter| 调用 {{GPUCanvasContext/configure()}} 时使用。 必须是 [=supported context formats=] 之一。
            </div>
        </div>

    : <dfn>getCurrentTexture()</dfn>
    ::
        获取将通过 {{GPUCanvasContext}} 合成到文档中的 {{GPUTexture}}。

        <div algorithm="GPUCanvasContext.getCurrentTexture">
            **调用:** {{GPUCanvasContext}} |this|。

            **返回:** {{GPUTexture}}

            1. 如果 |this|.{{GPUCanvasContext/[[configuration]]}} 是 `null`:
                1. 抛出一个 {{OperationError}} 并且停止。
            1. 如果 |this|.{{GPUCanvasContext/[[currentTexture]]}} 是 `null` 或者
                |this|.{{GPUCanvasContext/[[currentTexture]]}}.{{GPUTexture/[[destroyed]]}} 是 true:
                1. 设定 |this|.{{GPUCanvasContext/[[currentTexture]]}} 为 |this| 的 [$allocating
                    a new context texture$] 的结果。
            1. 返回 |this|.{{GPUCanvasContext/[[currentTexture]]}}。
        </div>

        注意：开发人员可以期望在同一帧内（即在 [=Update the rendering=] 的调用之间）每次调用 {{GPUCanvasContext/getCurrentTexture()}}
        都会返回相同的 {{GPUTexture}} 对象，除非 { {GPUCanvasContext/configure()}} 被调用。
</dl>

<div algorithm>
    在“[=Update the rendering=]”HTML 处理模型的“更新的 `Document` 渲染”步骤期间，
    每个{{GPUCanvasContext}} |context| 必须通过运行以下步骤将上下文内容呈现给画布<dfn abstract-op>present the context content to the </dfn>：

    1. 如果 |context|.{{GPUCanvasContext/[[currentTexture]]}} 不是 `null` 并且
        |context|.{{GPUCanvasContext/[[currentTexture]]}}.{{GPUTexture/[[destroyed]]}} 是 `false`:
        1. 让 |imageContents| 为 |context| 的
            [$get a copy of the image contents of a context|a copy of the image contents$]。
        1. 更新 |context|.{{GPUCanvasContext/canvas}} 使用 |imageContents|。
        1. 调用 |context|.{{GPUCanvasContext/[[currentTexture]]}}.{{GPUTexture/destroy()}}。
    1. 设定 |context|.{{GPUCanvasContext/[[currentTexture]]}} 为 `null`。
</div>

<div algorithm="transferToImageBitmap from WebGPU">
    当在带有 {{GPUCanvasContext}} |context| 的画布上调用 {{OffscreenCanvas/transferToImageBitmap()}} 时:

    1. 让 |imageContents| 为 |context| 的
        [$get a copy of the image contents of a context|a copy of the image contents$]。
    1. 如果 |context|.{{GPUCanvasContext/[[currentTexture]]}} 不是 `null`:
        1. 调用 |context|.{{GPUCanvasContext/[[currentTexture]]}}.{{GPUTexture/destroy()}}。
    1. 设定 |context|.{{GPUCanvasContext/[[currentTexture]]}} 为 `null`。
    1. 返回一个新的包含 |imageContents| 的 {{ImageBitmap}}。
</div>

<div algorithm>
当使用其他 Web API 读取 WebGPU 画布内容时，例如 {{CanvasDrawImage/drawImage()}}、
`texImage2D()`、`texSubImage2D()`、{{HTMLCanvasElement/toDataURL()}}、{{HTMLCanvasElement/toBlob()}}，
依此类推，他们得到一个上下文图像内容的副本<dfn abstract-op>get a copy of the image contents of a context</dfn>:

    **参数:**
    |context|: {{GPUCanvasContext}}

    **返回:** 图像内容

    1. 让 |texture| 为 |context|.{{GPUCanvasContext/[[currentTexture]]}}。
    1. 如果不满足以下任何要求，则返回大小为 |context|.{{GPUCanvasContext/[[size]]}} 的透明黑色图像并停止。
        <div class=validusage>
            - |texture| 不可以是 `null`。
            - |texture|.{{GPUTexture/[[destroyed]]}} 必须是 false。
            - 如果 |context|.{{GPUCanvasContext/canvas}} 是一个 {{OffscreenCanvas}},
                它不可以被连接到 [=placeholder canvas element=]。

                问题：如果添加，画布也不得“不同步”.
        </div>
    1. 确保所有提交的工作项（例如队列提交）都已完成写入 |texture|。
    1. 返回 |texture| 的内容，标记为具有 alpha 预乘，
        并返回有颜色空间 |context|.{{GPUCanvasContext/[[configuration]]}}.{{GPUCanvasConfiguration/colorSpace}}。

        问题(gpuweb/gpuweb#1847): compositingAlphaMode=opaque 是否会返回不透明的内容？
</div>

<div algorithm>
    为 {{GPUCanvasContext}} |context| 分配新的上下文纹理 <dfn abstract-op lt='allocating a new context texture'>allocate a new context texture</dfn> 运行以下步骤：

        1. 让 |device| 为 |context|.{{GPUCanvasContext/[[configuration]]}}.{{GPUCanvasConfiguration/device}}.
        1. 如果 |context|.{{GPUCanvasContext/[[validConfiguration]]}} 是 `false`:
            1. 在当前范围内生成一个带有适当错误消息的{{GPUValidationError}}。
            1. 返回一个新的 [=invalid=] {{GPUTexture}}。
        1. 让 |textureDescriptor| 为一个新的 {{GPUTextureDescriptor}}。
        1. 设定 |textureDescriptor|.{{GPUTextureDescriptor/size}} 为 |context|.{{GPUCanvasContext/[[size]]}}。
        1. 设定 |textureDescriptor|.{{GPUTextureDescriptor/format}} 为
            |context|.{{GPUCanvasContext/[[configuration]]}}.{{GPUCanvasConfiguration/format}}。
        1. 设定 |textureDescriptor|.{{GPUTextureDescriptor/usage}} 为
            |context|.{{GPUCanvasContext/[[configuration]]}}.{{GPUCanvasConfiguration/usage}}。
        1. 让 |texture| 为一个新的 {{GPUTexture}} 就像 |device|.{{GPUDevice/createTexture()}} 一样被创建，
            是用 |textureDescriptor| 调用的。
            <div class='note'>如果先前呈现的纹理来自 |context| 符合要求的标准，其 GPU 内存可能会被重复使用。</div>
        1. 确保 |texture| 被清空为  `(0, 0, 0, 0)`。
        1. 返回 |texture|。
</div>

## GPUCanvasConfiguration ## {#canvas-configuration}

<dfn dfn>supported context formats</dfn> 是 {{GPUTextureFormat}} 的一个 [=set=]，
不管给定的 {{GPUCanvasConfiguration}}.{{GPUCanvasConfiguration/device}} 的是什么，
当指定一个 {{GPUCanvasConfiguration}}.{{GPUCanvasConfiguration/format}} 它都必须支持，
初始设定为: &laquo;{{GPUTextureFormat/"bgra8unorm"}}, {{GPUTextureFormat/"rgba8unorm"}},
{{GPUTextureFormat/"rgba16float"}}&raquo;。

注意：画布配置不能使用像 {{GPUTextureFormat/"bgra8unorm-srgb"}} 这样的 `srgb` 格式。
相反，使用非 `srgb` 等效项 ({{GPUTextureFormat/"bgra8unorm"}})，指定 `srgb` {{GPUCanvasConfiguration/viewFormats}} 中的格式，并使用 {{GPUTexture/createView()}} 创建一个 `srgb` 格式的视图。

<script type=idl>

enum GPUCanvasCompositingAlphaMode {
    "opaque",
    "premultiplied",
};

dictionary GPUCanvasConfiguration {
    required GPUDevice device;
    required GPUTextureFormat format;
    GPUTextureUsageFlags usage = 0x10;  // GPUTextureUsage.RENDER_ATTACHMENT
    sequence<GPUTextureFormat> viewFormats = [];
    GPUPredefinedColorSpace colorSpace = "srgb";
    GPUCanvasCompositingAlphaMode compositingAlphaMode = "opaque";
    GPUExtent3D size;
};
</script>

<div class="example">
    使用此上下文的首选格式配置 {{GPUCanvasContext}} 以与特定 {{GPUDevice}} 一起使用：
    <pre highlight="js">
        const canvas = document.createElement('canvas');
        const context =  canvas.getContext('webgpu');

        context.configure({
            device: gpuDevice,
            format: context.getPreferredFormat(gpuAdapter),
        });
    </pre>
</div>

问题：对于 SDR，“srgb”的默认颜色空间是表示extended-srgb 还是clamped-srgb 并不重要。 但是，当我们添加 HDR 画布输出（表示像素值 > 1）时，
我们需要选择这两个中的哪一个是默认值。 目前上游规范还没有解决这个问题。

### 画布色彩空间 ### {#canvas-color-space}

During presentation, the chrominance of color values outside of the [0, 1] range is not to be
clamped to that range; extended values may be used to display colors outside of the gamut defined
by the canvas' color space's primaries, when permitted by the configured
{{GPUCanvasConfiguration/format}} and the user's display capabilities.
This is in contrast with luminance, which is to be clamped to the maximum standard dynamic range
luminance.

呈现时，不在[0, 1]范围外的色值色度不钳制在该范围内；当配置的 {{GPUCanvasConfiguration/format}} 和用户的显示能力允许时，扩展值可用于显示由画布颜色空间的原色定义的色域之外的颜色。这与亮度形成对比，亮度将被钳位到最大标准动态范围亮度。

问题：
[除非](https://github.com/WICG/canvas-color-space/blob/6bc492d2564abec316e2c5663aec9f9fa523a6a2/CanvasColorSpaceProposal.md#compositing-of-the-htmlcanvaselement)
为画布元素显式启用了高动态范围。

### 画布上下文大小 ### {#context-sizing}

{{GPUCanvasContext}} 的 {{GPUCanvasContext/[[size]]}} 由传递给 {{GPUCanvasContext/configure()}} 的 {{GPUCanvasConfiguration}} 设置，
并保持不变直到 {{GPUCanvasContext/configure()}} 以新的大小再次调用。
如果未指定 {{GPUCanvasConfiguration/size}}，则将使用 {{GPUCanvasContext}}.{{GPUCanvasContext/canvas}}
在调用 {{GPUCanvasContext/configure()}} 时的宽度和高度属性 .
如果 {{GPUCanvasContext}}.{{GPUCanvasContext/[[size]]}} 与画布的尺寸不匹配，{{GPUCanvasContext}} 生成的纹理将被缩放以适合画布元素。

<div class="note">
    注意：与 `'webgl'` 或 `'2d'` 上下文不同，具有 `'webgpu'` 上下文的画布的 `width` 和 `height` 属性仅影响:
    - 默认布局大小，如果没有被 CSS 覆盖。
    - 调用 {{GPUCanvasContext/configure()}} 时， 默认 {{GPUCanvasConfiguration}}.{{GPUCanvasConfiguration/size}}，如果没有被覆盖。
</div>

如果需要在调整大小后匹配画布的尺寸，则必须通过使用新尺寸再次调用 {{GPUCanvasContext/configure()}} 来重新配置 {{GPUCanvasContext}}。

<div class="example">
    重新配置 {{GPUCanvasContext}} 以响应画布调整大小，使用 [ResizeObserver](https://www.w3.org/TR/resize-observer/) 进行监控以获取画布的确切像素尺寸:

    <pre highlight="js">
        const canvas = document.createElement('canvas');
        const context =  canvas.getContext('webgpu');

        const resizeObserver = new ResizeObserver(entries => {
            for (const entry of entries) {
                if (entry != canvas) { continue; }
                context.configure({
                    device: gpuDevice,
                    format: context.getPreferredFormat(gpuAdapter),
                    size: {
                        // 这以像素为单位报告画布元素的大小
                        width: entry.devicePixelContentBoxSize[0].inlineSize,
                        height: entry.devicePixelContentBoxSize[0].blockSize,
                    }
                });
            }
        });
        resizeObserver.observe(canvas);
    </pre>
</div>

## <dfn dfn-type=enum-value dfn-for=GPUCanvasCompositingAlphaMode>GPUCanvasCompositingAlphaMode</dfn> ## {#GPUCanvasCompositingAlphaMode}

这个 enum 选择画布上下文的内容将如何绘制到页面上。

<table class='data'>
    <thead>
        <tr>
            <th>GPUCanvasCompositingAlphaMode
            <th>Description
            <th>dst.rgb
            <th>dst.a
    </thead>
    <tr>
        <td>{{GPUCanvasCompositingAlphaMode/opaque}}
        <td>将 RGB 绘制为不透明并忽略 alpha 值。
            如果内容尚未不透明，则实现可能需要在演示期间将 alpha 清除为不透明。
        <td>|dst.rgb = src.rgb|
        <td>|dst.a = 1|
    <tr>
        <td>{{GPUCanvasCompositingAlphaMode/premultiplied}}
        <td>复合假设颜色值预先乘以它们的 alpha 值。
            100% 红色 50% 不透明是 [0.5, 0, 0, 0.5]。
            颜色值必须小于或等于它们的 alpha 值。
            [1.0, 0, 0, 0.5] 是“超亮”，无法可靠显示。
        <td>|dst.rgb = src.rgb + dst.rgb*(1-src.a)|
        <td>|dst.a = src.a + dst.a*(1-src.a)|
</table>

# 错误 &amp; 调试 # {#errors-and-debugging}

## 致命错误 ## {#fatal-errors}

<script type=idl>
enum GPUDeviceLostReason {
    "destroyed",
};

[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUDeviceLostInfo {
    readonly attribute (GPUDeviceLostReason or undefined) reason;
    readonly attribute DOMString message;
};

partial interface GPUDevice {
    readonly attribute Promise<GPUDeviceLostInfo> lost;
};
</script>

{{GPUDevice}}具有以下附加属性：

<dl dfn-type=attribute dfn-for=GPUDevice>
    : <dfn>lost</dfn>
    ::
        与设备一起创建的promise在设备的生命周期内保持挂起状态，然后在设备丢失时resolves。

        此属性由同名的不可变内部插槽支持，最初设置为 [=a new promise=]，并始终返回其值。
</dl>


## 错误范围 ## {#error-scopes}

<script type=idl>
enum GPUErrorFilter {
    "out-of-memory",
    "validation",
};
</script>

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUOutOfMemoryError {
    constructor();
};

[Exposed=(Window, DedicatedWorker)]
interface GPUValidationError {
    constructor(DOMString message);
    readonly attribute DOMString message;
};

typedef (GPUOutOfMemoryError or GPUValidationError) GPUError;
</script>

<script type=idl>
partial interface GPUDevice {
    undefined pushErrorScope(GPUErrorFilter filter);
    Promise<GPUError?> popErrorScope();
};
</script>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>pushErrorScope(filter)</dfn>
    ::
        问题: 定义 pushErrorScope.

    : <dfn>popErrorScope()</dfn>
    ::
        问题: 定义 popErrorScope.

        以 {{OperationError}} 拒绝，如果:

        - 设备缺失。
        - 栈里没有错误范围。
</dl>

<div class="example">
    使用错误范围从可能失败的 {{GPUDevice}} 操作中捕获验证错误：
    <pre highlight="js">
        gpuDevice.pushErrorScope('validation');

        let sampler = gpuDevice.createSampler({
            maxAnisotropy: 0, // Invalid, maxAnisotropy must be at least 1.
        });

        gpuDevice.popErrorScope().then((error) => {
            if (error) {
                // There was an error creating the sampler, so discard it.
                sampler = null;
                console.error(\`An error occured while creating sampler: ${error.message}\`);
            }
        });
    </pre>
</div>

## 遥测 ## {#telemetry}

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUUncapturedErrorEvent : Event {
    constructor(
        DOMString type,
        GPUUncapturedErrorEventInit gpuUncapturedErrorEventInitDict
    );
    readonly attribute GPUError error;
};

dictionary GPUUncapturedErrorEventInit : EventInit {
    required GPUError error;
};
</script>

<dl dfn-type=attribute dfn-for=GPUUncapturedErrorEvent>
    : <dfn>error</dfn>
    ::
        Object representing the error that was uncaptured.
        This has the same type as errors returned by {{GPUDevice/popErrorScope()}}.

        This attribute is backed by an immutable internal slot of the same name, and
        always returns its value.

        Issue(whatwg/webidl#1077): This attribute should be `[SameObject]`.
        (If GPUError [becomes an interface](https://github.com/gpuweb/gpuweb/issues/1884) then
        we can do this without resolving the WebIDL issue.)
</dl>

<script type=idl>
partial interface GPUDevice {
    [Exposed=(Window, DedicatedWorker)]
    attribute EventHandler onuncapturederror;
};
</script>

<div class="example">
    监听来自 {{GPUDevice}} 的未捕获错误：
    <pre highlight="js">
        gpuDevice.addEventListener('uncapturederror', (event) => {
            if (event.error instanceof GPUValidationError) {
                console.error(\`An uncaught WebGPU validation error was raised: ${event.error.message}\`);
            }
        });
    </pre>
</div>

# 详细操作 # {#detailed-operations}

本节介绍各种GPU操作的详细信息。

## 转移 ## {#transfer-operations}

问题：描述高级别的转移。

## 计算 ## {#computing-operations}

计算提供对GPU可编程硬件的直接访问的操作。计算没有管线输入或输出的着色器，它们的结果是将数据写入绑定为{{GPUBufferBindingType/"storage"|GPUBufferBindingType."storage"}}和{{GPUStorageTextureBindingLayout}}的存储绑定的副作用。这些操作在{{GPUComputePassEncoder}}中编码为：
  - {{GPUComputePassEncoder/dispatch()}}
  - {{GPUComputePassEncoder/dispatchIndirect()}}

问题：描述计算算法。

## 渲染 ## {#rendering-operations}

渲染由一组GPU操作完成，这些操作在{{GPURenderPassEncoder}}中执行，并导致纹理数据的修改，由渲染通道附件查看。这些操作编码为：
  - {{GPURenderEncoderBase/draw()}}
  - {{GPURenderEncoderBase/drawIndexed()}},
  - {{GPURenderEncoderBase/drawIndirect()}}
  - {{GPURenderEncoderBase/drawIndexedIndirect()}}.

注意：渲染是GPU的传统用途，由硬件中的多个固定功能块支持。

<dfn dfn>RenderState</dfn>是一个在命令编码时表示当前{{GPURenderPassEncoder}}状态的内部对象。[=RenderState=]是以下定义的规范命名空间：
<div algorithm="RenderState accessors" dfn-for=RenderState>
    对一个给定的{{GPURenderPassEncoder}} |pass|，句法：

      - |pass|.<dfn dfn>indexBuffer</dfn>指通过{{GPURenderEncoderBase/setIndexBuffer()}}绑定的索引缓冲区，如果有的话。
      - |pass|.<dfn dfn>vertexBuffers</dfn>指通过{{GPURenderEncoderBase/setVertexBuffer()}}绑定的[=list=]&lt;vertex buffer&gt;。
      - |pass|.<dfn dfn>bindGroups</dfn>指通过{{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)}}绑定的[=list=]&lt;{{GPUBindGroup}}&gt;。
      - |pass|.<dfn dfn>viewport</dfn> 指的是一个包含 {{GPURenderPassEncoder/setViewport()}} 参数的对象。在渲染通道开始时，状态相当于调用 setViewport(0, 0, |pass|.{{GPURenderPassEncoder/[[attachment_size]]}}.width, |pass|.{{GPURenderPassEncoder/[[ attachment_size]]}}.height, 0.0, 1.0)。
      - |pass|.<dfn dfn>scissorRect</dfn> 指的是一个包含 {{GPURenderPassEncoder/setScissorRect()}} 参数的对象。在渲染过程开始时，状态相当于调用 setScissorRect(0, 0, |pass|.{{GPURenderPassEncoder/[[attachment_size]]}}.width, |pass|.{{GPURenderPassEncoder/[[ attachment_size]]}}.height）。
</div>

主渲染算法：

<div>
    <dfn abstract-op>render</dfn>(descriptor, drawCall, state)

        **Arguments:**
            - |descriptor|: 当前{{GPURenderPipeline}}的描述。
            - |drawCall|: 绘制调用参数。
            - |state|: 发出绘制调用的{{GPURenderEncoderBase}}的[=RenderState=]。

        1. **Resolve indices**. 见[[#index-resolution]]。

            使|vertexList|为[$resolve indices$](|drawCall|, |state|)的结果。

        2. **Process vertices**. See [[#vertex-processing]].

            执行[$process vertices$](|vertexList|, |drawCall|, |descriptor|.{{GPURenderPipelineDescriptor/vertex}}, |state|)。

        3. **Assemble primitives**.

            执行assemble primitives(|vertexList|, |drawCall|, |descriptor|.{{GPURenderPipelineDescriptor/primitive}})。

        4. **Clip primitives**.
            使 |primitiveList| 为当前阶段的结果。
        
        5. **光栅化**. See [[#rasterization]].

            使|rasterizationList|为[$rasterize$](|primitiveList|, |state|)的结果。

        6. **Process fragments**. 见 [[#fragment-processing]].

            收集 |fragments| 的列表，通过为每个 |rasterizationList| 中的 |rasterPoint| 执行 [$process fragment$](|rasterPoint|, |descriptor|.{{GPURenderPipelineDescriptor/fragment}}, |state|)得到。

        7. **Process depth/stencil**.

            Issue: 完成此节，使用 |fragments|

        8. **Write pixels**.
            问题：完成此节。
</div>

### 索引分辨率 ### {#index-resolution}

在渲染的第一阶段，管道会为每个实例构建一个要处理的顶点列表。
<div>
    <dfn abstract-op>resolve indices</dfn>(drawCall, state)

    **Arguments:**
    - |drawCall|: 绘制调用参数。
    - |state|: 激活的[=RenderState=]。

    **Returns:** 整数索引列表。

    1. 使|vertexIndexList|为一个空的索引列表。
    2. 如果|drawCall|是一个索引绘制调用：
        1. 使用|drawCall|.indexCount整数初始化|vertexIndexList|。
        2. 对0 .. |drawCall|.indexCount (non-inclusive)范围内的|i|：
            1. 使|relativeVertexIndex| be [$fetch index$](|i| + |drawCall|.`firstIndex`,
                |state|.[=RenderState/indexBuffer=])。
            2. 如果|relativeVertexIndex|有 `"out of bounds"` 的具体值，停止并返回空列表。

                注意：当发生这种情况时，实现可能会选择显示警告，特别是当它很容易检测时（如在非间接索引绘制调用中）。
            3. 将|drawCall|.`baseVertex` + |relativeVertexIndex|添加至|vertexIndexList|。
    3. Otherwise:
        1. 使用|drawCall|.vertexCount整数初始化|vertexIndexList|。
        2. 设置每个|vertexIndexList| item |i|为值|drawCall|.firstVertex + |i|。
    4. 返回|vertexIndexList|。

    注意：在间接绘制调用的情况下，从间接缓冲区而不是绘制命令本身读取indexCount、vertexCount 和|drawCall|的其他属性。

    问题：更好地细化间接命令。
</div>

<div>
    <dfn abstract-op>fetch index</dfn>(i, buffer, offset, format)

    **Arguments:**
    - |i|: 要获取的顶点索引的索引。
    - |indexBufferState|: [=RenderState/indexBuffer=] (buffer, format, offset, and size)的值。

    **Returns:** 无符号整数或 `"out of bounds"`

    1. 使|indexSize|被indexBufferState|.`format`定义：
        <dl class="switch">
            : {{GPUIndexFormat/"uint16"}}
            :: 2
            : {{GPUIndexFormat/"uint32"}}
            :: 4
        </dl>
    2. 如果|indexBufferState|.`offset` + |i + 1| &times; |indexSize| &gt; |indexBufferState|.`size`，返回特殊值 `"out of bounds"`。
    3. 将|indexBufferState|.`buffer`中的数据从偏移量|indexBufferState|.`offset` + |i| &times; |indexSize|开始，大小为|indexSize|字节，解释为一个无符号整数并返回它。
</div>

### 顶点处理 ### {#vertex-processing}

顶点处理阶段是渲染[=pipeline=]的一个可编程阶段，它处理顶点属性数据，并为#primitive-clipping生成剪辑空间位置，以及为[[#fragment-processing]]片元处理生成其他数据。

<div>
    <dfn abstract-op>process vertices</dfn>(vertexIndexList, drawCall, desc, state)

    **Arguments:**
    - |vertexIndexList|: 要处理的定点索引列表（可变，通过引用传递）。
    - |desc|: 类型{{GPUVertexState}}的描述符。
    - |state|: 激活的[=RenderState=]。

    每个|vertexIndexList|中的顶点|vertexIndex|，在索引|rawInstanceIndex|的每个实例中，都是独立处理的。|rawInstanceIndex|的范围是从0到|drawCall|.instanceCount - 1，包括这两个值。此处理并行发生，任何副作用，例如写入{{GPUBufferBindingType/"storage"|GPUBufferBindingType."storage"}}绑定，都可能以任何顺序发生。

    1. 使|instanceIndex|为|rawInstanceIndex| + |drawCall|.firstInstance.
    2. 对每个列表|desc|.{{GPUVertexState/buffers}}中的non-`null` |vertexBufferLayout|：
        1. 使|i|为此列表中缓冲区布局的索引值。
        2. 使|vertexBuffer|，|vertexBufferOffset|，和|vertexBufferBindingSize|为buffer，offset，和|state|.[=RenderState/vertexBuffers=]的|i|处大小。
        3. 使|vertexElementIndex|依赖于|vertexBufferLayout|.{{GPUVertexBufferLayout/stepMode}}:
            <dl class="switch">
                : {{GPUVertexStepMode/"vertex"}}
                :: |vertexIndex|
                : {{GPUVertexStepMode/"instance"}}
                :: |instanceIndex|
            </dl>
        4. 对每个|vertexBufferLayout|.{{GPUVertexBufferLayout/attributes}}中的|attributeDesc|：
            1. 使|attributeOffset|为|vertexBufferOffset| +
                |vertexElementIndex| * |vertexBufferLayout|.{{GPUVertexBufferLayout/arrayStride}} +
                |attributeDesc|.{{GPUVertexAttribute/offset}}。
            2. 从|vertexBuffer|偏移量|attributeOffset|开始，加载格式|attributeDesc|.{{GPUVertexAttribute/format}}的属性数据。 组件按 x、y、z、w 的顺序从缓冲区内存中加载。

                如果这导致越界访问，则结果值根据WGSL的[=invalid memory reference=]行为确定。
            3. **Optionally (implementation-defined):**
                如果|attributeOffset| + sizeof(|attributeDesc|.{{GPUVertexAttribute/format}}) &gt;
                |vertexBufferOffset| + |vertexBufferBindingSize|,
                [=list/empty=] |vertexIndexList|并且停止，取消绘制调用。

                注意：这允许实现在发出绘制调用之前检测索引缓冲区中的越界值，而不是使用[=invalid memory reference=]行为。
            4. 根据[=channel formats=]规则，将|数据|转换为着色器可见的格式。
                <div class="example">
                    在WGSL中，{{GPUVertexFormat/"snorm8x2"}}类型的属性和字节值 `[0x70, 0xD0]` 将转换为 `vec2<f32>(0.88, -0.24)`。
                </div>
            5. 调整|数据|大小至着色器类型：
                - 如果都是标量，或者都是相同维度的向量，则不需要调整。
                - 如果|数据|是向量但是着色器类型为标量，则只提取第一个分量。
                - 如果两者都是向量，并且|数据|具有更高的维度，则删除额外的组件。
                    <div class="example">
                        如果需要2-component vector，则类型为{{GPUVertexFormat/"float32x3"}}且值为 `vec3<f32>(1.0, 2.0, 3.0)` 的属性将作为 `vec2<f32>(1.0, 2.0)`暴露给着色器。
                    </div>
                - 如果着色器类型是更高维度的向量，或者|数据|是标量，则以 `vec4<*>(0, 0, 0, 1)` 值填充缺失的组件。
                    <div class="example">
                        如果需要4-component vector，则类型为{{GPUVertexFormat/"sint32"}}且值为5的属性将作为 `vec4<i32>(5, 0, 0, 1)`暴露给着色器。
                    </div>
            6. 将|数据|绑定到顶点着色器输入位置|attributeDesc|.{{GPUVertexAttribute/shaderLocation}}。
    3. 对每个|state|.[=RenderState/bindGroups=]中的{{GPUBindGroup}}组：
        1. 对每个绑定组中的资源{{GPUBindingResource}}：
            1. 使|entry|为此资源对应的{{GPUBindGroupLayoutEntry}}。
            2. 如果|entry|.{{GPUBindGroupLayoutEntry}}.visibility包含{{GPUShaderStage/VERTEX}}:
                - 绑定资源至|索引|组下的着色器并绑定{{GPUBindGroupLayoutEntry/binding|GPUBindGroupLayoutEntry.binding}}.
    4. 设置着色器[=builtins=]:
        - 将vertex_index内置，如果有的话，设置为|vertexIndex|。
        - 将instance_index内置，如果有的话，设置为|instanceIndex|。
    5. 调用由|desc|描述的顶点着色器入口点。

        注意：目标平台缓存顶点着色器调用的结果。不能保证任何重复多次的|vertexIndex|会导致多次调用。同样，不能保证单个|vertexIndex|只会被处理一次。
</div>

### 图元装配 ### {#primitive-assembly}

图元由GPU的固定功能阶段组装。

<div>
    <dfn abstract-op>assemble primitives</dfn>(vertexIndexList, drawCall, desc)

        **Arguments:**
            - |vertexIndexList|: 要处理的顶点索引列表。
            - |drawCall|: 绘制调用参数。
            - |desc|: 类型{{GPUPrimitiveState}}的描述符。

        对于每个实例，图元都是根据|vertexIndexList|从着色器处理过的顶点组装而成的。

        1. 首先，如果原始拓扑是条带，（这意味着 |desc|.{{GPUPrimitiveState/stripIndexFormat}} 不是未定义的）并且|drawCall|已被索引，|vertexIndexList| 使用 |desc|.{{GPUPrimitiveState/stripIndexFormat}} 的最大值作为分隔符拆分为子列表。

            示例：一个类型为{{GPUIndexFormat/"uint16"}}，值为 `[1, 2, 65535, 4, 5, 6]`的|vertexIndexList|将被拆分为子列表：`[1, 2]`和 `[4, 5, 6]`。

        2. 对于每个子列表|vl|，根据|desc|.{{GPUPrimitiveState/topology}}进行图元生成：
            <dl class="switch">
                : {{GPUPrimitiveTopology/"line-list"}}
                ::
                    线图元由(|vl|.0, |vl|.1)，然后(|vl|.2, |vl|.3)，然后(|vl|.4, |vl|.5)等组成。每个后续图元采用2个顶点。

                : {{GPUPrimitiveTopology/"line-strip"}}
                ::
                    线图元由(|vl|.0, |vl|.1)，然后(|vl|.1, |vl|.2)，然后(|vl|.2, |vl|.3)等组成。每个后续图元采用1个顶点。

                : {{GPUPrimitiveTopology/"triangle-list"}}
                ::
                    三角形图元由(|vl|.0, |vl|.1, |vl|.2)，然后(|vl|.3, |vl|.4, |vl|.5)，然后(|vl|.6, |vl|.7, |vl|.8)等组成。每个后续图元采用3个顶点。

                : {{GPUPrimitiveTopology/"triangle-strip"}}
                ::
                    三角形图元由(|vl|.0, |vl|.1, |vl|.2)，然后(|vl|.2, |vl|.1, |vl|.3)，然后(|vl|.2, |vl|.3, |vl|.4)，然后(|vl|.4, |vl|.3, |vl|.5)等组成。每个后续图元采用1个顶点。
            </dl>

            问题：这应该更正式地定义吗？

            未完成的图元被删除。

</div>

### 图元剪裁 ### {#primitive-clipping}

顶点着色器必须创建一个内置的“position”（类型为 vec4<f32>），表示顶点的<dfn dfn>clip position</dfn>。

问题：连接至WGSL内置项。

图元被剪裁到<dfn dfn>clip volume</dfn>，对于图元内的任何剪裁位置p，它由以下不等式定义：
  - &minus;|p|.w &le; |p|.x &le; |p|.w
  - &minus;|p|.w &le; |p|.y &le; |p|.w
  - 0 &le; |p|.z &le; |p|.w (<dfn dfn>depth clipping</dfn>)

如果|descriptor|.{{GPURenderPipelineDescriptor/primitive}}.{{GPUPrimitiveState/unclippedDepth}} 为 `true`,
[=depth clipping=]未被应用: [=clip volume=]未被绑定至z维度。

如果图元的每条边都完全位于[=clip volume=]内，则图元不变地通过此阶段。如果图元的边与剪辑体积的边界相交，则相交的边将通过位于[=clip volume=]边界的新边重新连接。对于三角形图元（|descriptor|.{{GPURenderPipelineDescriptor/primitive}}.{{GPUPrimitiveState/topology}}是{{GPUPrimitiveTopology/"triangle-list"}}或{{GPUPrimitiveTopology/"triangle-strip"}}），这种重新连接可能会导致在多边形内部引入新的顶点。

如果图元与[=clip volume=]边界的一条边相交，则裁剪的多边形必须包含一个在该边界边上的点。

如果顶点着色器输出其他浮点值（标量和向量），用“透视”插值限定，它们也会被裁剪。与位于裁剪体积内的顶点关联的输出值不受裁剪的影响。然而，如果一个图元被裁剪，分配给裁剪产生的顶点的输出值也会被裁剪。

考虑顶点|a|和|b|之间的边被剪裁，导致顶点|c|，让我们定义|t|为边顶点之间的比率：|c|.p = |t| &times; |a|.p &plus; (1 &minus; |t|) &times; |b|.p，其中|x|.p是顶点|x|的输出[=clip position=]。

对于具有相应片元输入的每个顶点输出值“v”，|a|.v和|b|.v将分别是|a|和|b|顶点的输出。裁剪着色器输出|c|.v是基于插值限定符生成的：
<dl class="switch">
    : "flat"
    ::
        flat插值不受影响，并且基于<dfn dfn>provoking vertex</dfn>，即图元中的第一个顶点。 整个图元的输出值相同，并且与[=provoking vertex=]的顶点输出匹配：|c|.v = [=provoking vertex=].v。

    : "linear"
    ::
        插值率根据[=clip position=]的透视坐标调整，所以的差值结果在屏幕空间中为线性的。

        问题：在这里提供更多细节，如果可能。

    : "perspective"
    ::
        该值在裁剪空间中线性插值，产生透视正确的值：

        |c|.v = |t| &times; |a|.v &plus; (1 &minus; |t|) &times; |b|.v
</dl>

问题：链接到WGSL中的插值限定符。

图元裁剪的结果是一组新的图元，它们包含在[=clip volume=]中。

### 光栅化 ### {#rasterization}

光栅化是硬件处理阶段，将生成的图元映射到<dfn dfn>framebuffer</dfn>的二维渲染区域——当前{{GPURenderPassEncoder}}中的渲染附件集。 该渲染区域被分成均匀的像素网格。

光栅化确定受图元影响的像素集。在多重采样的情况下，每个像素被进一步拆分为|descriptor|.{{GPURenderPipelineDescriptor/multisample}}.{{GPUMultisampleState/count}}个样本。每个像素的样本位置都相同，但在本规范中未定义。

问题：我们需要强制启用Vulkan中的"Standard sample locations"吗？

[=framebuffer=]坐标从渲染目标的左上角开始。 每个单元正好对应一个像素。有关更多信息，请参阅[[#coordinate-systems]]坐标系。


让我们定义一个<dfn dfn>FragmentDestination</dfn>包含：
<dl dfn-for=FragmentDestination>
    : <dfn dfn>position</dfn>
    :: [=framebuffer=]空间中的2D像素位置。
    : <dfn dfn>sampleIndex</dfn>
    :: 如果[[#sample-frequency-shading]]处于激活状态，则为整数，否则为“null”
</dl>

我们还将使用<dfn dfn>NDC</dfn>的概念 - 标准化设备坐标。在这个坐标系中，视口范围在 X 和 Y 中从 -1 到 1，在 Z 中从 0 到 1。

光栅化会生成一个 <dfn dfn>RasterizationPoint</dfn> 列表，每个列表包含以下数据：
<dl dfn-for=RasterizationPoint>
    : <dfn dfn>destination</dfn>
    :: 指[=FragmentDestination=]
    : <dfn dfn>coverageMask</dfn>
    :: 指多样本覆盖掩码（见[[#sample-masking]]）
    : <dfn dfn>frontFacing</dfn>
    :: 如果它是图元正面的一个点，则为真
    : <dfn dfn>perspectiveDivisor</dfn>
    :: 指内插的 1.0 &divide; W跨越图元
    : <dfn dfn>depth</dfn>
    :: 指[=NDC=]中的深度
    : <dfn dfn>primitiveVertices</dfn>
    :: 指形成图元的顶点输出列表
    : <dfn dfn>barycentricCoordinates</dfn>
    :: 指#barycentric-coordinates
</dl>

问题：定义深度计算算法。

<div algorithm>
    <dfn abstract-op>rasterize</dfn>(primitiveList, state)

    **Arguments:**
    - |primitiveList|: 要栅格化的图元列表。
    - |state|: 激活的[=RenderState=]。

    **Returns:** [=RasterizationPoint=]列表。

    |primitiveList| 中的每个基元 是独立处理的。 但是，图元的顺序会影响后面的阶段，例如深度/模板操作和像素写入。

    1. 首先，裁剪的顶点被转换为[=NDC=] - 标准化设备坐标。给定输出位置|p|，[=NDC=]坐标计算如下：

        divisor(|p|) = 1.0 &divide; |p|.w

        ndc(|p|) = vector(|p|.x &divide; |p|.w, |p|.y &divide; |p|.w, |p|.z &divide; |p|.w)

    1. 让 |vp| 为 |state|.[=RenderState/viewport=]。然后 [=NDC=] 坐标 |n| 根据渲染目标的大小转换为[=framebuffer=]坐标：

       framebufferCoords(|n|) = vector(|vp|.`x` &plus; 0.5 &times; (|n|.x &plus; 1) &times; |vp|.`width`, |vp|.`y` &plus; .5 &times; (|n|.y &plus; 1) &times; |vp|.`height`)

       问题：也指定到视口的深度转换

    1. 让|光栅化点|是一个空列表。

      问题：指定为每个光栅化点分配一个内插的 `divisor(p)` 和 `framebufferCoords(n)`，以及其他属性。

    1. 继续使用特定的光栅化算法，具体取决于 {{GPURenderPipelineDescriptor/primitive}}.{{GPUPrimitiveState/topology}}：
        <dl class="switch">
            : {{GPUPrimitiveTopology/"point-list"}}
            :: 该点如果没有被 [[#primitive-clipping]] 过滤，则会进入 [[#point-rasterization]]。
            : {{GPUPrimitiveTopology/"line-list"}} 或 {{GPUPrimitiveTopology/"line-strip"}}
            :: 由[[#primitive-clipping]]切割的线进入[[#line-rasterization]]。
            : {{GPUPrimitiveTopology/"triangle-list"}} 或 {{GPUPrimitiveTopology/"triangle-strip"}}
            :: 在[[#primitive-clipping]]中生成的多边形进入 [[#polygon-rasterization]]。
        </dl>

        问题：改写“进入”部分

    1. 删除所有点 |rp| 来自 |光栅化点| 在 |state|.[=RenderState/scissorRect=] 之外具有 |rp|.[=RasterizationPoint/destination=].[=FragmentDestination/position=]。

    1. 返回 |rasterizationPoints|。

</div>

#### 点光栅化 #### {#point-rasterization}

单个[=FragmentDestination=]在包含点的framebuffer坐标的像素内被选择。

coverage mask依赖于多重采样模式:
<dl class="switch">
    : sample-frequency
    :: coverageMask = 1 &Lt; `sampleIndex`
    : pixel-frequency multi-sampling
    :: coverageMask = 1 &Lt; |descriptor|.{{GPURenderPipelineDescriptor/multisample}}.{{GPUMultisampleState/count}} &minus; 1
    : no multi-sampling
    :: coverageMask = 1
</dl>

#### 线光栅化 #### {#line-rasterization}

问题：补充本章节。

#### 重心坐标 #### {#barycentric-coordinates}

重心坐标是|n|的列表数字|b|<sub>|i|</sub>，为点|p|定义在带有|n|的凸多边形内[=framebuffer=]空间中的顶点|v|<sub>|i|</sub>。
每个|b|<sub>|i|</sub>都在0到1的范围内，包括端点，并且表示与顶点|v|<sub>|i|</sub>的接近度。
它们的总和始终不变：

&sum; (|b|<sub>|i|</sub>) = 1

这些坐标唯一地指定了任何点|p|在多边形内（或其边界）为：

|p| = &sum; (|b|<sub>|i|</sub> &times; |p|<sub>|i|</sub>)

对于具有 3 个顶点的多边形 - 一个三角形，任何点的重心坐标 |p| 可以计算如下：

|A|<sub>polygon</sub> = A(|v|<sub>|1|</sub>, |v|<sub>|2|</sub>, |v|<sub>|3|</sub>)
|b|<sub>|1|</sub> = A(|p|, |b|<sub>|2|</sub>, |b|<sub>|3|</sub>) &divide; |A|<sub>polygon</sub>
|b|<sub>|2|</sub> = A(|b|<sub>|1|</sub>, |p|, |b|<sub>|3|</sub>) &divide; |A|<sub>polygon</sub>
|b|<sub>|3|</sub> = A(|b|<sub>|1|</sub>, |b|<sub>|2|</sub>, |p|) &divide; |A|<sub>polygon</sub>

其中 A（点列表）是具有给定顶点集的多边形面积。

对于具有3个以上顶点的多边形，确切的算法取决于实现。一种可能的实现方式是对多边形进行三角测量并基于它落入的三角形的点计算重心。

#### 多边形光栅化 #### {#polygon-rasterization}

如果多边形面向投影，则它是<dfn dfn>正面</dfn>。否则，多边形是<dfn dfn>背面</dfn>。

<div algorithm>
    <dfn abstract-op>rasterize polygon</dfn>()

    **Arguments:**

    **Returns:** [=RasterizationPoint=]列表。

    1. 使|rasterizationPoints|为空列表。
    1. 令|v|(|i|)是n个顶点的光栅化多边形中剪切顶点编号|i|（从 1 开始）的帧缓冲区（[=framebuffer=]）坐标。

       注意：本节以术语“多边形”替代“三角形”，由于#primitive-clipping阶段可能介绍了其他顶点。这不会被应用程序发现。
    1. 确定多边形是否为正面，这取决于多边形在帧缓冲区（[=framebuffer=]）坐标中所占|区域|的符号：

        |area| = 0.5 &times; ((|v|<sub>1</sub>.x &times; |v|<sub>|n|</sub>.y &minus; |v|<sub>|n|</sub>.x &times; |v|<sub>1</sub>.y) &plus; &sum; (|v|<sub>|i|&plus;1</sub>.x &times; |v|<sub>|i|</sub>.y &minus; |v|<sub>|i|</sub>.x &times; |v|<sub>|i|&plus;1</sub>.y))

        |区域|的符号是根据{{GPURenderPipelineDescriptor/primitive}}.{{GPUPrimitiveState/frontFace}}解释的：
        <dl class="switch">
            : {{GPUFrontFace/"ccw"}}
            :: |area| &gt; 0被当作[=front-facing=], 否则为[=back-facing=]
            : {{GPUFrontFace/"cw"}}
            :: |area| &lt; 0被当作[=front-facing=], 否则为[=back-facing=]
        </dl>
    1. 基于 {{GPURenderPipelineDescriptor/primitive}}.{{GPUPrimitiveState/cullMode}} 的剔除：
        <dl class="switch">
            : {{GPUCullMode/"none"}}
            :: 所有通过此测试的多边形。
            : {{GPUCullMode/"front"}}
            :: [=front-facing=]多边形将被丢弃，并且不会在渲染管线的后期阶段进行处理。
            : {{GPUCullMode/"back"}}
            :: [=back-facing=]多边形将被丢弃。
        </dl>
    1. 确定帧缓冲区（[=framebuffer=]）空间中多边形内的一组片元（[=fragments=]） - 这些是为每个片元操作安排的位置。此操作称为“点采样”。逻辑基于|descriptor|.{{GPURenderPipelineDescriptor/multisample}}：

        <dl class="switch">
            : disabled
            :: [=Fragment=]与像素中心相关联。也就是说，包含在多边形中的framebuffer空间中坐标为C的所有点（其中fract(|C|) = vector2(0.5, 0.5)）都包括在内。如果像素中心位于多边形的边缘，则是否包含它未定义。

                注意：这成为光栅化器的精度问题。

            : enabled
            :: 每个像素都与|descriptor|.{{GPURenderPipelineDescriptor/multisample}}.{{GPUMultisampleState/count}}位置相关联，这些位置是实现定义的。位置是有序的，并且列表对于framebuffer的每个像素都是相同的。每个位置对应于多采样framebuffer中的一个片元。

            光栅化器构建每个像素内被击中的位置的掩码，并提供作为片元着色器内置的“样本掩码”。

        </dl>

    1. 对于每个生成的 [=FragmentDestination=] 类型的片元：
        
        1. 使|rp|为一个新的[=RasterizationPoint=]对象
        1. 计算列表|b|作为该片元的 [[#barycentric-coordinates]]。
        1. 设|d|<sub>|i|</sub> 为|v|<sub>|i|</sub> 的深度值。
            问题：定义此值的构造方式。
        1. 将 |rp|.[=RasterizationPoint/depth=] 设置为 &sum; (|b|<sub>|i|</sub> &times; |d|<sub>|i|</sub>)
        1. 添加|rp|至|rasterizationPoints|.

    1. 返回|rasterizationPoints|.

</div>

### 片元处理 ### {#fragment-processing}

片元处理阶段是渲染管线（[=pipeline=]）的可编程阶段，它计算要写入渲染目标的片段数据（通常是一种颜色）。
此阶段为每个 [=RasterizationPoint=] 生成一个 <dfn dfn>Fragment</dfn>：
<div algorithm="Fragment accessors" dfn-for=Fragment>
    - <dfn dfn>destination</dfn>指[=FragmentDestination=].
    - <dfn dfn>coverageMask</dfn>指多样本覆盖掩码（见[[#sample-masking]]）。
    - <dfn dfn>depth</dfn>指[=NDC=]坐标系中的深度。
    - <dfn dfn>colors</dfn>指颜色值列表，{{GPURenderPassDescriptor/colorAttachments}}中的每个目标对应一个颜色值。
</div>

<div algorithm>
    <dfn abstract-op>process fragment</dfn>(rp, desc, state)

    **Arguments:**
    - |rp|: [=RasterizationPoint=], 通过[[#rasterization]]产生。
    - |desc|: 类型为{{GPUFragmentState}}的描述符。
    - |state|: 激活的[=RenderState=]。

    **Returns:** [=Fragment=]或 `null`.

    1. 使|fragment|为一个新的[=Fragment=]对象。
    1. 设置|fragment|.[=Fragment/destination=]为|rp|.[=RasterizationPoint/destination=]。
    1. 设置|fragment|.[=Fragment/coverageMask=]为|rp|.[=RasterizationPoint/coverageMask=]。
    1. 设置|fragment|.[=Fragment/depth=]为|rp|.[=RasterizationPoint/depth=]。
    1. 如果|desc|不为 `null`：
        1. 设置着色器输入 [=builtins=]。对于入口点的每个非复合参数，注释为 [=builtin=]，根据注释设置其值：
            <dl class="switch">
                : `position`
                :: `vec4<f32>`(|rp|.[=RasterizationPoint/destination=].[=FragmentDestination/position=], |rp|.[=RasterizationPoint/depth=], |rp|.[=RasterizationPoint/perspectiveDivisor=])

                : `front_facing`
                :: |rp|.[=RasterizationPoint/frontFacing=]

                : `sample_index`
                :: |rp|.[=RasterizationPoint/destination=].[=FragmentDestination/sampleIndex=]

                : `sample_mask`
                :: |rp|.[=RasterizationPoint/coverageMask=]
            </dl>
        1. 对于片元阶段的每个用户指定的 [=pipeline input=]：
            1. 令|value|为插值片段输入，基于|rp|.[=RasterizationPoint/barycentricCoordinates=]，|rp|.[=RasterizationPoint/primitiveVertices=]，和输入的[=interpolation=]限定符。

               问题：描述准确的方程。
            1. 将相应的片元着色器 [=location=] 输入设置为 |value|。
        1. 调用 |desc| 描述的片元着色器入口点。
        1. 如果片元发出 `discard`，则返回 `null`。
        1. 将 |fragment|.[=Fragment/colors=] 设置为来自着色器的用户指定的 [=pipeline output=] 值。
        1. 取着色器输出 [=builtins=]：
            1. 如果 `frag_depth` [=builtin=] 由着色器生成为|value|：
                1. 使|vp|为|state|.[=RenderState/viewport=]。
                1. 设定|fragment|.[=Fragment/depth=]为clamp(|value|, |vp|.`minDepth`, |vp|.`maxDepth`)。
        1. 如果 `sample_mask` [=builtin=]由着色器生成为|value|：
            1. 设置|fragment|.[=Fragment/coverageMask=]为|fragment|.[=Fragment/coverageMask=] &and; |value|。
        
        否则我们在[[#no-color-output]]模式, 并且|fragment|.[=Fragment/colors=]为空。
    1. 返回|fragment|。
</div>

片元的处理是并行发生的，而任何副作用，例如写入 {{GPUBufferBindingType/"storage"|GPUBufferBindingType."storage"}} 绑定，可能以任何顺序发生。

### Output Merging ### {#output-merging}

问题：完成此节。

此阶段的深度输入（如果有）被钳制到当前{{GPURenderPassEncoder/[[viewport]]}}深度范围（无论片元着色器阶段是否写入了内置的 `frag_depth`）。

### 无颜色输出 ### {#no-color-output}

在no-color-output模式下，[=pipeline=]不产生任何颜色附件输出。

[=pipeline=]仍然执行光栅化并根据顶点位置输出生成深度值。深度测试和模板操作仍然可以使用。

### Alpha覆盖 ### {#alpha-to-coverage}

在alpha-to-coverage模式下, 根据{GPURenderPipelineDescriptor/fragment}}.{{GPUFragmentState/targets}}[0]的片元着色器输出|alpha|组件，产生一个另外的MSAA样本的<dfn dfn>alpha-to-coverage mask</dfn>。

生成额外掩码的算法取决于平台，并且可能因不同像素而异。它保证：
  - 如果|alpha|为0.0或更小，结果为0x0。
  - 如果|alpha|为1.0或更大，结果为0xFFFFFFFF。
  - 如果|alpha|比一些其他的|alpha1|更大，则生成的样本掩码设置为1的位数至少和|alpha1|的掩码一样多。
    then the produced sample mask has at least as many bits set to 1 as the mask for |alpha1|

### 采样频率着色 ### {#sample-frequency-shading}

问题：补充此章节。

### 采样遮掩 ### {#sample-masking}

一个像素的<dfn dfn>final sample mask</dfn>计算为：
[=rasterization mask=] & {{GPUMultisampleState/mask}} & [=shader-output mask=]

仅考虑掩码的较低{{GPUMultisampleState/count}}位。

如果[=final sample mask=]的位置|N|处的最低有效位的值为“0”，则丢弃到片段着色器的所有附件的样本颜色输出（对应于样本|N|）。 此外，不会对深度模板附件的相关样本执行深度测试或模板操作。

注意：样本|N|的颜色输出是由片段着色器执行产生的，当前像素的 SV_SampleIndex == |N|。如果片元着色器不使用此语义，则每个像素仅执行一次。

<dfn dfn>rasterization mask</dfn>由光栅化阶段根据光栅化多边形的形状生成。包含在形状中的样本在掩码中获得相关位1。

<dfn dfn>shader-output mask</dfn>采用片元着色器中内置的“sample_mask”的输出值。如果内置函数不是从片元着色器输出的，并且启用了{{GPUMultisampleState/alphaToCoverageEnabled}}，则[=shader-output mask=]将成为[=alpha-to-coverage mask=]。否则，它默认为0xFFFFFFFF。

# 类型定义 # {#type-definitions}

<script type=idl>
typedef [EnforceRange] unsigned long GPUBufferDynamicOffset;
typedef [EnforceRange] unsigned long GPUStencilValue;
typedef [EnforceRange] unsigned long GPUSampleMask;
typedef [EnforceRange] long GPUDepthBias;

typedef [EnforceRange] unsigned long long GPUSize64;
typedef [EnforceRange] unsigned long GPUIntegerCoordinate;
typedef [EnforceRange] unsigned long GPUIndex32;
typedef [EnforceRange] unsigned long GPUSize32;
typedef [EnforceRange] long GPUSignedOffset32;

typedef unsigned long GPUFlagsConstant;
</script>

## 颜色 &amp; 向量 ## {#colors-and-vectors}

<script type=idl>
dictionary GPUColorDict {
    required double r;
    required double g;
    required double b;
    required double a;
};
typedef (sequence<double> or GPUColorDict) GPUColor;
</script>

注意：`double`足够大以精确保存32位有符号/无符号整数和单精度浮点数。

<script type=idl>
dictionary GPUOrigin2DDict {
    GPUIntegerCoordinate x = 0;
    GPUIntegerCoordinate y = 0;
};
typedef (sequence<GPUIntegerCoordinate> or GPUOrigin2DDict) GPUOrigin2D;
</script>

<dfn dfn>Origin2D</dfn>是一个{{GPUOrigin2D}}。
[=Origin2D=]是以下定义的规范命名空间：
<!-- This is silly, but provides convenient syntax for the spec. -->

<div algorithm="GPUOrigin2D accessors" dfn-for=Origin2D>
    对一个给定{{GPUOrigin2D}}值的|origin|，根据其类型，句法：

      - |origin|.<dfn dfn>x</dfn>指{{GPUOrigin2DDict}}.{{GPUOrigin2DDict/x}}或序列的第一项，如果不存在则为0。
      - |origin|.<dfn dfn>y</dfn>指{{GPUOrigin2DDict}}.{{GPUOrigin2DDict/y}}或序列的第二项，如果不存在则为0。
</div>

<script type=idl>
dictionary GPUOrigin3DDict {
    GPUIntegerCoordinate x = 0;
    GPUIntegerCoordinate y = 0;
    GPUIntegerCoordinate z = 0;
};
typedef (sequence<GPUIntegerCoordinate> or GPUOrigin3DDict) GPUOrigin3D;
</script>

<dfn dfn>Origin3D</dfn>是一个{{GPUOrigin3D}}。
[=Origin3D=]是以下定义的规范命名空间：
<!-- This is silly, but provides convenient syntax for the spec. -->

<div algorithm="GPUOrigin3D accessors" dfn-for=Origin3D>
    对于给定{{GPUOrigin3D}}值的|origin|，根据它的类型，句法：

      - |origin|.<dfn dfn>x</dfn>指{{GPUOrigin3DDict}}.{{GPUOrigin3DDict/x}}或序列的第一项，如果不存在则为0。
      - |origin|.<dfn dfn>y</dfn>指{{GPUOrigin3DDict}}.{{GPUOrigin3DDict/y}}或序列的第二项，如果不存在则为0。
      - |origin|.<dfn dfn>z</dfn>指{{GPUOrigin3DDict}}.{{GPUOrigin3DDict/z}}或序列的第三项，如果不存在则为0。
</div>

<script type=idl>
dictionary GPUExtent3DDict {
    required GPUIntegerCoordinate width;
    GPUIntegerCoordinate height = 1;
    GPUIntegerCoordinate depthOrArrayLayers = 1;
};
typedef (sequence<GPUIntegerCoordinate> or GPUExtent3DDict) GPUExtent3D;
</script>

<dfn dfn>Extent3D</dfn>是一个{{GPUExtent3D}}.
[=Extent3D=]为以下定义的规范命名空间：
<!-- This is silly, but provides convenient syntax for the spec. -->

<div algorithm="GPUExtent3D accessors" dfn-for=Extent3D>
    For a given {{GPUExtent3D}} value |extent|, depending on its type, the syntax:

      - |extent|.<dfn dfn>width</dfn>指{{GPUExtent3DDict}}.{{GPUExtent3DDict/width}}或序列的第一项，如果不存在则为1。
      - |extent|.<dfn dfn>height</dfn>指{{GPUExtent3DDict}}.{{GPUExtent3DDict/height}}或序列的第二项，如果不存在则为1。
      - |extent|.<dfn dfn>depthOrArrayLayers</dfn>指{{GPUExtent3DDict}}.{{GPUExtent3DDict/depthOrArrayLayers}}或序列的第三项，如果不存在则为1。
</div>

# 特性索引 # {#feature-index}

## <dfn dfn-type=enum-value dfn-for=GPUFeatureName>"depth-clip-control"</dfn> ## {#depth-clip-control}

问题：当{{GPUFeatureName/"depth-clip-control"}} [=feature=]被启用时定义功能。

**特性字典值**

以下字典值当且仅当{{GPUFeatureName/"depth-clip-control"}} [=feature=]启用时被支持，否则必须设置为它们的默认值：

<dl>
    : {{GPUPrimitiveState}}
    ::
        * {{GPUPrimitiveState/unclippedDepth}}
</dl>

## <dfn dfn-type=enum-value dfn-for=GPUFeatureName>"depth24unorm-stencil8"</dfn> ## {#depth24unorm-stencil8}

允许明确创建{{GPUTextureFormat/"depth24unorm-stencil8"}}格式的纹理。

**特性枚举**

以下枚举当且仅当{{GPUFeatureName/"depth24unorm-stencil8"}}
[=feature=]启用时被支持：

<dl>
    : {{GPUTextureFormat}}
    ::
        * {{GPUTextureFormat/"depth24unorm-stencil8"}}
</dl>

## <dfn dfn-type=enum-value dfn-for=GPUFeatureName>"depth32float-stencil8"</dfn> ## {#depth32float-stencil8}

允许明确创建{{GPUTextureFormat/"depth32float-stencil8"}}格式的纹理。

**特性枚举**

以下枚举当且仅当{{GPUFeatureName/"depth32float-stencil8"}} [=feature=]启用时被支持。

<dl>
    : {{GPUTextureFormat}}
    ::
        * {{GPUTextureFormat/"depth32float-stencil8"}}
</dl>

## <dfn dfn-type=enum-value dfn-for=GPUFeatureName>"texture-compression-bc"</dfn> ## {#texture-compression-bc}

允许明确创建BC压缩格式的纹理。

**特性枚举**

以下枚举当且仅当{{GPUFeatureName/"texture-compression-bc"}}
[=feature=]启用时被支持：

<dl>
    : {{GPUTextureFormat}}
    ::
        * {{GPUTextureFormat/"bc1-rgba-unorm"}}
        * {{GPUTextureFormat/"bc1-rgba-unorm-srgb"}}
        * {{GPUTextureFormat/"bc2-rgba-unorm"}}
        * {{GPUTextureFormat/"bc2-rgba-unorm-srgb"}}
        * {{GPUTextureFormat/"bc3-rgba-unorm"}}
        * {{GPUTextureFormat/"bc3-rgba-unorm-srgb"}}
        * {{GPUTextureFormat/"bc4-r-unorm"}}
        * {{GPUTextureFormat/"bc4-r-snorm"}}
        * {{GPUTextureFormat/"bc5-rg-unorm"}}
        * {{GPUTextureFormat/"bc5-rg-snorm"}}
        * {{GPUTextureFormat/"bc6h-rgb-ufloat"}}
        * {{GPUTextureFormat/"bc6h-rgb-float"}}
        * {{GPUTextureFormat/"bc7-rgba-unorm"}}
        * {{GPUTextureFormat/"bc7-rgba-unorm-srgb"}}
</dl>

## <dfn dfn-type=enum-value dfn-for=GPUFeatureName>"texture-compression-etc2"</dfn> ## {#texture-compression-etc}

允许明确创建ETC2压缩格式的纹理。

**特性枚举**

以下枚举当且仅当{{GPUFeatureName/"texture-compression-etc2"}}
[=feature=]启用时被支持：

<dl>
    : {{GPUTextureFormat}}
    ::
        * {{GPUTextureFormat/"etc2-rgb8unorm"}}
        * {{GPUTextureFormat/"etc2-rgb8unorm-srgb"}}
        * {{GPUTextureFormat/"etc2-rgb8a1unorm"}}
        * {{GPUTextureFormat/"etc2-rgb8a1unorm-srgb"}}
        * {{GPUTextureFormat/"etc2-rgba8unorm"}}
        * {{GPUTextureFormat/"etc2-rgba8unorm-srgb"}}
        * {{GPUTextureFormat/"eac-r11unorm"}}
        * {{GPUTextureFormat/"eac-r11snorm"}}
        * {{GPUTextureFormat/"eac-rg11unorm"}}
        * {{GPUTextureFormat/"eac-rg11snorm"}}
</dl>

## <dfn dfn-type=enum-value dfn-for=GPUFeatureName>"texture-compression-astc"</dfn> ## {#texture-compression-astc}

允许明确创建ASTC压缩格式的纹理。

**特性枚举**

以下枚举当且仅当{{GPUFeatureName/"texture-compression-astc"}}
[=feature=]启用时被支持：

<dl>
    : {{GPUTextureFormat}}
    ::
        * {{GPUTextureFormat/"astc-4x4-unorm"}}
        * {{GPUTextureFormat/"astc-4x4-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-5x4-unorm"}}
        * {{GPUTextureFormat/"astc-5x4-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-5x5-unorm"}}
        * {{GPUTextureFormat/"astc-5x5-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-6x5-unorm"}}
        * {{GPUTextureFormat/"astc-6x5-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-6x6-unorm"}}
        * {{GPUTextureFormat/"astc-6x6-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-8x5-unorm"}}
        * {{GPUTextureFormat/"astc-8x5-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-8x6-unorm"}}
        * {{GPUTextureFormat/"astc-8x6-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-8x8-unorm"}}
        * {{GPUTextureFormat/"astc-8x8-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-10x5-unorm"}}
        * {{GPUTextureFormat/"astc-10x5-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-10x6-unorm"}}
        * {{GPUTextureFormat/"astc-10x6-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-10x8-unorm"}}
        * {{GPUTextureFormat/"astc-10x8-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-10x10-unorm"}}
        * {{GPUTextureFormat/"astc-10x10-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-12x10-unorm"}}
        * {{GPUTextureFormat/"astc-12x10-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-12x12-unorm"}}
        * {{GPUTextureFormat/"astc-12x12-unorm-srgb"}}
</dl>

## <dfn dfn-type=enum-value dfn-for=GPUFeatureName>"timestamp-query"</dfn> ## {#timestamp-query}

问题：当{{GPUFeatureName/"timestamp-query"}} [=feature=]启用时定义功能。

**特性枚举**

以下枚举当且仅当{{GPUFeatureName/"timestamp-query"}}
[=feature=]启用时被支持。

<dl>
    : {{GPUQueryType}}
    ::
        * {{GPUQueryType/"timestamp"}}
</dl>

## <dfn dfn-type=enum-value dfn-for=GPUFeatureName>"indirect-first-instance"</dfn> ## {#indirect-first-instance}

删除间[=indirect draw parameters=]和[=indirect drawIndexed parameters=]中的 `firstInstance` 的零值限制。当且仅当启用{{GPUFeatureName/"indirect-first-instance"}} [=feature=]时，`firstInstance` 才允许为非零值。

# 附录 # {#appendices}

## 纹理格式功能 ## {#texture-format-caps}

### 纯色格式 ### {#plain-color-formats}

所有纯色格式支持{{GPUTextureUsage/COPY_SRC}}, {{GPUTextureUsage/COPY_DST}}, 和{{GPUTextureUsage/TEXTURE_BINDING}}用法。

只有具有{{GPUTextureSampleType}} {{GPUTextureSampleType/"float"}}才能被混合。

列{{GPUTextureUsage/RENDER_ATTACHMENT}}和{{GPUTextureUsage/STORAGE_BINDING}}分别指定对{{GPUTextureUsage/RENDER_ATTACHMENT|GPUTextureUsage.RENDER_ATTACHMENT}}和{{GPUTextureUsage/STORAGE_BINDING|GPUTextureUsage.STORAGE_BINDING}}用法的支持。

<table class='data'>
    <thead class=stickyheader>
        <tr>
            <th>Format
            <th>{{GPUTextureSampleType}}
            <th>{{GPUTextureUsage/RENDER_ATTACHMENT}}
            <th>multisampling
            <th>resolve
            <th>{{GPUTextureUsage/STORAGE_BINDING}}
    </thead>
    <tr><th class=stickyheader>8-bit per component<th><th><th><th><th>
    <tr>
        <td>{{GPUTextureFormat/r8unorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&checkmark;
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/r8snorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td><!-- Vulkan -->
        <td>&checkmark;
        <td>
        <td><!-- Vulkan -->
    <tr>
        <td>{{GPUTextureFormat/r8uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>&checkmark;
        <td><!-- Metal -->
        <td>
    <tr>
        <td>{{GPUTextureFormat/r8sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>&checkmark;
        <td><!-- Metal -->
        <td>
    <tr>
        <td>{{GPUTextureFormat/rg8unorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&checkmark;
        <td>&checkmark;
        <td><!-- Vulkan -->
    <tr>
        <td>{{GPUTextureFormat/rg8snorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td><!-- Vulkan -->
        <td>&checkmark;
        <td>
        <td><!-- Vulkan -->
    <tr>
        <td>{{GPUTextureFormat/rg8uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>&checkmark;
        <td><!-- Metal -->
        <td>
    <tr>
        <td>{{GPUTextureFormat/rg8sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>&checkmark;
        <td><!-- Metal -->
        <td>
    <tr>
        <td>{{GPUTextureFormat/rgba8unorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&checkmark;
        <td>&checkmark;
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rgba8unorm-srgb}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&checkmark;
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/rgba8snorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td><!-- Vulkan -->
        <td>&checkmark;
        <td>
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rgba8uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>&checkmark;
        <td><!-- Metal -->
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rgba8sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>&checkmark;
        <td><!-- Metal -->
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/bgra8unorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&checkmark;
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/bgra8unorm-srgb}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&checkmark;
        <td>&checkmark;
        <td>
    <tr><th class=stickyheader>16-bit per component<th><th><th><th><th>
    <tr>
        <td>{{GPUTextureFormat/r16uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>&checkmark;
        <td><!-- Metal -->
        <td>
    <tr>
        <td>{{GPUTextureFormat/r16sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>&checkmark;
        <td><!-- Metal -->
        <td>
    <tr>
        <td>{{GPUTextureFormat/r16float}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&checkmark;
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/rg16uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>&checkmark;
        <td><!-- Metal -->
        <td>
    <tr>
        <td>{{GPUTextureFormat/rg16sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>&checkmark;
        <td><!-- Metal -->
        <td>
    <tr>
        <td>{{GPUTextureFormat/rg16float}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&checkmark;
        <td>&checkmark;
        <td><!-- Vulkan -->
    <tr>
        <td>{{GPUTextureFormat/rgba16uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>&checkmark;
        <td><!-- Metal -->
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rgba16sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>&checkmark;
        <td><!-- Metal -->
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rgba16float}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&checkmark;
        <td>&checkmark;
        <td>&checkmark;
    <tr><th class=stickyheader>32-bit per component<th><th><th><th><th>
    <tr>
        <td>{{GPUTextureFormat/r32uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td><!-- Metal -->
        <td>
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/r32sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td><!-- Metal -->
        <td>
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/r32float}}
        <td>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&checkmark;
        <td><!-- Metal -->
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rg32uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td><!-- Metal -->
        <td>
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rg32sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td><!-- Metal -->
        <td>
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rg32float}}
        <td>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td><!-- Metal -->
        <td>
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rgba32uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td><!-- Metal -->
        <td>
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rgba32sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td><!-- Metal -->
        <td>
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rgba32float}}
        <td>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td><!-- Metal -->
        <td>
        <td>&checkmark;
    <tr><th class=stickyheader>mixed component width<th><th><th><th><th>
    <tr>
        <td>{{GPUTextureFormat/rgb10a2unorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&checkmark;
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/rg11b10ufloat}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td><!-- Vulkan -->
        <td>&checkmark;
        <td>
        <td><!-- Vulkan -->

</table>

### 深度-模板格式 ### {#depth-formats}

<dfn dfn>depth-or-stencil format</dfn>是具有深度和/或模板宽高比的任何格式。<dfn dfn>combined depth-stencil format</dfn>是具有深度和模板宽高比的深度或模板格式。

所有[=depth-or-stencil formats=]都支持{{GPUTextureUsage/COPY_SRC}}, {{GPUTextureUsage/COPY_DST}},
{{GPUTextureUsage/TEXTURE_BINDING}}, 和{{GPUTextureUsage/RENDER_ATTACHMENT}}用法。

所有这些格式都支持多重采样。

但是，某些复制操作也会限制源格式和目标格式。

没有深度格式可以被过滤。

<table class='data'>
    <thead>
        <tr>
            <th>Format
            <th>Bytes per texel
            <th>Aspect
            <th>{{GPUTextureSampleType}}
            <th>Valid [=image copy=] source
            <th>Valid [=image copy=] destination
    </thead>
    <tr>
        <td>{{GPUTextureFormat/stencil8}}
        <td>1 &minus; 4
        <td>stencil
        <td>{{GPUTextureSampleType/"uint"}}
        <td colspan=2>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/depth16unorm}}
        <td>2
        <td>depth
        <td>{{GPUTextureSampleType/"depth"}}
        <td colspan=2>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/depth24plus}}
        <td>4
        <td>depth
        <td>{{GPUTextureSampleType/"depth"}}
        <td colspan=2>&cross;
    <tr>
        <td rowspan=2 style='white-space:nowrap'>{{GPUTextureFormat/depth24plus-stencil8}}
        <td rowspan=2>4 &minus; 8
        <td>depth
        <td>{{GPUTextureSampleType/"depth"}}
        <td colspan=2>&cross;
    <tr>
        <td>stencil
        <td>{{GPUTextureSampleType/"uint"}}
        <td colspan=2>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/depth32float}}
        <td>4
        <td>depth
        <td>{{GPUTextureSampleType/"depth"}}
        <td colspan=1>&checkmark;
        <td colspan=1>&cross;
    <tr>
        <td rowspan=2 style='white-space:nowrap'>{{GPUTextureFormat/depth24unorm-stencil8}}
        <td rowspan=2>4
        <td>depth
        <td>{{GPUTextureSampleType/"depth"}}
        <td colspan=2>&cross;
    <tr>
        <td>stencil
        <td>{{GPUTextureSampleType/"uint"}}
        <td colspan=2>&checkmark;
    <tr>
        <td rowspan=2 style='white-space:nowrap'>{{GPUTextureFormat/depth32float-stencil8}}
        <td rowspan=2>5 &minus; 8
        <td>depth
        <td>{{GPUTextureSampleType/"depth"}}
        <td colspan=1>&checkmark;
        <td colspan=1>&cross;
    <tr>
        <td>stencil
        <td>{{GPUTextureSampleType/"uint"}}
        <td colspan=2>&checkmark;
</table>


#### 读取和采样深度/模板纹理 #### {#reading-depth-stencil}

当通过 `texture_depth_*`-类型的绑定读取或采样深度分量时，该值作为 `f32` 值返回。

问题(gpuweb/gpuweb#2094)：根据此问题的解决方案，允许通过上表中的 `texture_2d` 等读取/采样并指定行为。(`vec4<f32>(D, X, X, X)`?) 更新下面的注释，它会稍微过时。[问题#gpuweb/gpuweb#2094]

必须通过普通纹理绑定(`texture_2d`, `texture_2d_array`, `texture_cube`, 或 `texture_cube_array`)读取或采样模板组件。这样做时，该值作为 `vec4<u32>(S, X, X, X)` 返回，其中 S 是模板值，每个 X 是实现定义的未指定值。

作者不能依赖这些.y、.z和.w组件，因为它们的行为是不可移植的。

注意：如果没有添加新的更受约束的模板采样器类型（如深度），实现有效地掩盖模板读取的驱动程序差异是不可行的。由于这不是WebGL的可移植性痛点，因此预计在WebGPU中不会有问题。实际上，根据硬件，需要 `vec4<u32>(S, S, S, S)` 或 `vec4<u32>(S, 0, 0, 1)`。

#### 复制深度/模板纹理 #### {#copying-depth-stencil}

depth32float格式的纹素值（({{GPUTextureFormat/"depth32float"}}和{{GPUTextureFormat/"depth32float-stencil8"}}的范围有限。因此，复制到此类纹理中仅对来自相同格式的其他纹理有效。
<!-- Update this if an unrestricted-depth feature is added. -->

depth24plus格式（{{GPUTextureFormat/"depth24plus"}}和{{GPUTextureFormat/"depth24plus-stencil8"}}）的深度方面具有不透明的表示（实现为“depth24unorm”或“depth32float”）。{{GPUTextureFormat/"depth24unorm-stencil8"}}的深度方面没有对齐的紧密包装表示（因为它的大小是 3 个字节）。因此，这些格式不允许使用深度方面的图像副本（[=image copies=]）。

<div class=note>
    It is possible to imitate these disallowed copies:

    - All of these formats can be written in a render pass using a fragment shader that outputs
        depth values via the `frag_depth` output.
    - Textures with "depth24plus"/"depth24unorm" formats can be read as shader textures, and
        written to a texture (as a render pass attachment) or
        buffer (via a storage buffer binding in a compute shader).
</div>

### 打包格式 ### {#packed-formats}

所有打包纹理格式支持{{GPUTextureUsage/COPY_SRC}}, {{GPUTextureUsage/COPY_DST}}, 和{{GPUTextureUsage/TEXTURE_BINDING}}用法。所有这些有{{GPUTextureSampleType/"float"}}类型的格式可以在采样时被过滤。这些格式都不支持多重采样。

A <dfn dfn>compressed format</dfn> is any format with a block size greater than 1 &times; 1.

<table class='data'>
    <thead class=stickyheader>
        <tr>
            <th>Format
            <th>Bytes per block
            <th>{{GPUTextureSampleType}}
            <th>Block Size
            <th>[=Feature=]
    </thead>
    <tr>
        <td>{{GPUTextureFormat/rgb9e5ufloat}}
        <td>4
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>1 &times; 1
        <td>
    <tr>
        <td>{{GPUTextureFormat/bc1-rgba-unorm}}
        <td rowspan=2>8
        <td rowspan=14>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td rowspan=14>4 &times; 4
        <td rowspan=14>{{GPUFeatureName/texture-compression-bc}}
    <tr>
        <td>{{GPUTextureFormat/bc1-rgba-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/bc2-rgba-unorm}}
        <td rowspan=2>16
    <tr>
        <td>{{GPUTextureFormat/bc2-rgba-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/bc3-rgba-unorm}}
        <td rowspan=2>16
    <tr>
        <td>{{GPUTextureFormat/bc3-rgba-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/bc4-r-unorm}}
        <td rowspan=2>8
    <tr>
        <td>{{GPUTextureFormat/bc4-r-snorm}}
    <tr>
        <td>{{GPUTextureFormat/bc5-rg-unorm}}
        <td rowspan=2>16
    <tr>
        <td>{{GPUTextureFormat/bc5-rg-snorm}}
    <tr>
        <td>{{GPUTextureFormat/bc6h-rgb-ufloat}}
        <td rowspan=2>16
    <tr>
        <td>{{GPUTextureFormat/bc6h-rgb-float}}
    <tr>
        <td>{{GPUTextureFormat/bc7-rgba-unorm}}
        <td rowspan=2>16
    <tr>
        <td>{{GPUTextureFormat/bc7-rgba-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/etc2-rgb8unorm}}
        <td rowspan=2>8
        <td rowspan=10>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td rowspan=10>4 &times; 4
        <td rowspan=10>{{GPUFeatureName/texture-compression-etc2}}
    <tr>
        <td>{{GPUTextureFormat/etc2-rgb8unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/etc2-rgb8a1unorm}}
        <td rowspan=2>8
    <tr>
        <td>{{GPUTextureFormat/etc2-rgb8a1unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/etc2-rgba8unorm}}
        <td rowspan=2>16
    <tr>
        <td>{{GPUTextureFormat/etc2-rgba8unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/eac-r11unorm}}
        <td rowspan=2>8
    <tr>
        <td>{{GPUTextureFormat/eac-r11snorm}}
    <tr>
        <td>{{GPUTextureFormat/eac-rg11unorm}}
        <td rowspan=2>16
    <tr>
        <td>{{GPUTextureFormat/eac-rg11snorm}}
    <tr>
        <td>{{GPUTextureFormat/astc-4x4-unorm}}
        <td rowspan=2>16
        <td rowspan=28>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td rowspan=2>4 &times; 4
        <td rowspan=28>{{GPUFeatureName/texture-compression-astc}}
    <tr>
        <td>{{GPUTextureFormat/astc-4x4-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-5x4-unorm}}
        <td rowspan=2>16
        <td rowspan=2>5 &times; 4
    <tr>
        <td>{{GPUTextureFormat/astc-5x4-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-5x5-unorm}}
        <td rowspan=2>16
        <td rowspan=2>5 &times; 5
    <tr>
        <td>{{GPUTextureFormat/astc-5x5-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-6x5-unorm}}
        <td rowspan=2>16
        <td rowspan=2>6 &times; 5
    <tr>
        <td>{{GPUTextureFormat/astc-6x5-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-6x6-unorm}}
        <td rowspan=2>16
        <td rowspan=2>6 &times; 6
    <tr>
        <td>{{GPUTextureFormat/astc-6x6-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-8x5-unorm}}
        <td rowspan=2>16
        <td rowspan=2>8 &times; 5
    <tr>
        <td>{{GPUTextureFormat/astc-8x5-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-8x6-unorm}}
        <td rowspan=2>16
        <td rowspan=2>8 &times; 6
    <tr>
        <td>{{GPUTextureFormat/astc-8x6-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-8x8-unorm}}
        <td rowspan=2>16
        <td rowspan=2>8 &times; 8
    <tr>
        <td>{{GPUTextureFormat/astc-8x8-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-10x5-unorm}}
        <td rowspan=2>16
        <td rowspan=2>10 &times; 5
    <tr>
        <td>{{GPUTextureFormat/astc-10x5-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-10x6-unorm}}
        <td rowspan=2>16
        <td rowspan=2>10 &times; 6
    <tr>
        <td>{{GPUTextureFormat/astc-10x6-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-10x8-unorm}}
        <td rowspan=2>16
        <td rowspan=2>10 &times; 8
    <tr>
        <td>{{GPUTextureFormat/astc-10x8-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-10x10-unorm}}
        <td rowspan=2>16
        <td rowspan=2>10 &times; 10
    <tr>
        <td>{{GPUTextureFormat/astc-10x10-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-12x10-unorm}}
        <td rowspan=2>16
        <td rowspan=2>12 &times; 10
    <tr>
        <td>{{GPUTextureFormat/astc-12x10-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-12x12-unorm}}
        <td rowspan=2>16
        <td rowspan=2>12 &times; 12
    <tr>
        <td>{{GPUTextureFormat/astc-12x12-unorm-srgb}}
</table>

## 非导出dfns的临时使用 ## {#temp-dfn-usages}

[=Origin2D/x=] [=Origin2D/y=]
[=RenderPassDescriptor/renderExtent=]

最终这些将被删除，但目前它们对避免构建此规范文档时的编译警告仍然有用。

[=vertex buffer=]