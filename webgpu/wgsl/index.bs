<pre class='metadata'>
Title: WebGPU Shading Language
Shortname: WGSL
Level: None
Status: w3c/ED
Group: webgpu
ED: https://gpuweb.github.io/gpuweb/wgsl/
TR: https://www.w3.org/TR/WGSL/
Repository: gpuweb/gpuweb
Text Macro: INT i32 or u32
Text Macro: UNSIGNEDINTEGRAL u32 or vec|N|&lt;u32&gt;
Text Macro: SIGNEDINTEGRAL i32 or vec|N|&lt;i32&gt;
Text Macro: INTEGRAL i32, u32, vec|N|&lt;i32&gt;, or vec|N|&lt;u32&gt;
Text Macro: FLOATING f32, f16, vec|N|&lt;f32&gt;, or vec|N|&lt;f16&gt;
Text Macro: NUMERIC i32, u32, f32, f16, vec|N|&lt;i32&gt;, vec|N|&lt;u32&gt;, vec|N|&lt;f32&gt;, or vec|N|&lt;f16&gt;
Text Macro: ALLINTEGRALDECL |S| is AbstractInt, i32, u32<br>|T| is |S| or vec|N|&lt;|S|&gt;
Text Macro: ALLFLOATING AbstractFloat, f32, f16, vec|N|&lt;AbstractFloat&gt;, vec|N|&lt;f32&gt;, or vec|N|&lt;f16&gt;
Text Macro: ALLNUMERICDECL |S| is AbstractInt, AbstractFloat, i32, u32, f32, or f16<br>|T| is |S|, or vec|N|&lt;|S|&gt;
Text Macro: ALLINTEGRALDECL |S| is AbstractInt, i32, or u32<br>|T| is |S| or vec|N|&lt;|S|&gt;
Ignored Vars: i, c0, e, e1, e2, e3, eN, p, s1, s2, sn, N, M, C, R, v, Stride, Offset, Align, Extent, S, T, T1

!Participate: <a href="https://github.com/gpuweb/gpuweb/issues/new?labels=wgsl">File an issue</a> (<a href="https://github.com/gpuweb/gpuweb/issues?q=is%3Aissue+is%3Aopen+label%3Awgsl">open issues</a>)
!Tests: <a href=https://github.com/gpuweb/cts/tree/main/src/webgpu/shader/>WebGPU CTS shader/</a>
!Translator: 赵凌云，lingyun.zhao@orillusion.com
!Translator: 薛沛，pei.xue@orillusion.com
Editor: David Neto, Google https://www.google.com, dneto@google.com, w3cid 99785
Editor: Myles C. Maxfield, Apple Inc., mmaxfield@apple.com, w3cid 77180
Former Editor: dan sinclair, Google https://www.google.com, dsinclair@google.com
Abstract: Shading language for WebGPU. WGSL 翻译文档。本翻译非官方翻译。
Markup Shorthands: markdown yes
Markup Shorthands: biblio yes
Markup Shorthands: idl no
Assume Explicit For: yes
</pre>

<style>
tr:nth-child(2n) {
  background-color: #b0b0b050;
}
thead {
  background-color: #b0b0b050;
  font-weight: bold;
}
.nowrap {
  white-space:nowrap;
}
.small {
  font-size: smaller;
}
div.syntax {
  display: block;
  page-break-before: avoid;
  padding: .5em 1em;
  background: var(--def-bg);
  border-left: 0.5em solid var(--def-border);
  color: black;
  color: var(--def-text);
  margin-block-start: 1em;
  margin-block-end: 1em;
}
div.syntax > p {
  margin-block-start: 0em;
  margin-block-end: 0em;
  margin-inline-start: 1em;
  margin-inline-end: 0em;
}
div.syntax > p::first-letter {
  letter-spacing: 0.5em;
}
div.syntax > p > a {
  margin-inline-start: 0.1em;
  margin-inline-end: 0.1em;
}
div.syntax > p > code {
  margin-inline-start: 0.1em;
  margin-inline-end: 0.1em;
}
</style>

<pre class=biblio>
{
  "WebGPU": {
    "authors": [
      "Dzmitry Malyshau",
      "Justin Fan",
      "Kai Ninomiya",
      "Brandon Jones"
    ],
    "href": "https://gpuweb.github.io/gpuweb/",
    "title": "WebGPU",
    "status": "Editor's Draft",
    "publisher": "W3C",
    "deliveredBy": [
      "https://github.com/gpuweb/gpuweb"
    ]
  },
  "IEEE-754":{
    "href":"http://ieeexplore.ieee.org/servlet/opac?punumber=4610933",
    "title":"IEEE Standard for Floating-Point Arithmetic",
    "publisher":"Institute of Electrical and Electronics Engineers",
    "isbn":"978-0-7381-5752-8",
    "versions":["IEEE-754-2008","IEEE-754-1985"],
    "id":"IEEE-754",
    "date":"29 August 2008"
  },
  "VulkanMemoryModel": {
    "authors": [
      "Jeff Bolz",
      "Alan Baker",
      "Tobias Hector",
      "David Neto",
      "Robert Simpson",
      "Brian Sumner"
    ],
    "href": "https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#memory-model",
    "title": "Vulkan Memory Model",
    "publisher": "Khronos Group"
  },
   "UnicodeVersion14": {
      "href":"http://www.unicode.org/versions/Unicode14.0.0/",
      "author":"The Unicode Consortium",
      "title":"The Unicode Standard, Version 14.0.0",
      "isbn":"978-1-936213-29-0",
      "id":"UnicodeVersion14"
    }

}
</pre>

<pre class='anchors'>
spec: Vulkan ; urlPrefix: https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#
    type: dfn
        text: memory model memory operation; url: memory-model-memory-operation
        text: memory model reference; url: memory-model-references
        text: memory model atomic operation; url: memory-model-atomic-operation
        text: memory model scope; url:memory-model-scope
        text: memory model memory semantics; url:memory-model-memory-semantics
        text: memory model non-private; url: memory-model-non-private
spec: UAX14; urlPrefix: https://www.unicode.org/reports/tr14
    type: dfn
        text: UAX14 Section 6.1 Non-tailorable Line Breaking Rules; url: BreakingRules
        text: UAX14 LB4; url: LB4
        text: UAX14 LB5; url: LB5
spec: UAX15; urlPrefix: https://www.unicode.org/reports/tr15/tr15-51.html
    type: dfn
        text: Unicode Standard Annex #15 for Unicode Version 14.0.0
        text: UAX15 Normalization Forms; url: Normalization_Forms_Table
spec: UAX31; urlPrefix: https://www.unicode.org/reports/tr31/tr31-35.html
    type: dfn
        text: Unicode Standard Annex #31 for Unicode Version 14.0.0
        text: UAX31 Lexical Classes; url: Table_Lexical_Classes_for_Identifiers
        text: UAX31 Grammar; url: D1
spec: UTS46; urlPrefix: https://www.unicode.org/reports/tr46/tr46-27.html
    type: dfn
        text: UTS46 Mapping; url: IDNA_Mapping_Table
spec: charmod-norm; urlPrefix: https://www.w3.org/TR/charmod-norm/
    type: dfn
        text: charmod-norm Matching; url: identityMatching
spec: Unicode Character Database for Unicode Version 14.0.0; urlPrefix: https://www.unicode.org/Public/14.0.0/ucd/DerivedCoreProperties.txt
    type: dfn
        text: Unicode Character Database for Unicode Version 14.0.0
spec: UnicodeVersion14; urlPrefix: https://www.unicode.org/versions/Unicode14.0.0/UnicodeStandard-14.0.pdf
    type: dfn
        text: code point; url:
</pre>

# 介绍 # {#intro}

WebGPU Shading Language (WGSL)是为 [[!WebGPU]] 设计的着色器语言。也就是说，使用 WebGPU API 的应用程序使用 WGSL 来表达在 GPU 上运行的程序（称为着色器）。

<div class='example wgsl global-scope'>
  <xmp highlight='rust'>
    @fragment
    fn main() -> @location(0) vec4<f32> {
        return vec4<f32>(0.4, 0.4, 0.8, 1.0);
    }
  </xmp>
</div>

## 技术概览 ## {#technical-overview}


WebGPU 以[[WebGPU#gpu-command|GPU command]]的形式向 GPU 发出一个工作单元。WGSL关注两种 GPU 命令：
* <dfn noexport>draw command</dfn>在[=pipeline input|inputs=]、[=pipeline output|outputs=]和附加[=resources=]的上下文中执行[=GPURenderPipeline|render pipeline=]。
* <dfn noexport>dispatch command</dfn>在[=GPUComputePipeline|compute pipeline=]和附加[=resources=]的上下文中执行[=GPUComputePipeline|compute pipeline=]。

这两种管线都使用以WGSL编写的着色器。

<dfn noexport>shader</dfn>是WGSL程序的一部分，用于在管线中执行[=shader stage=]。着色器包括：
* 一个入口点 [=entry point=] [=function/function=]。
* 所有被调用函数的传递闭包，从入口点开始。该集合包括[=user-defined function|user-defined=]和[=built-in function|built-in=]函数。（有关更严格的定义，请参阅“[=functions in a shader stage=]”。）
* 所有这些函数静态访问（[=statically accessed=]）的一组变量和常量。
* 用于定义或分析所有这些函数、变量和常量的类型集。

执行着色器阶段时，实现：
* 计算在 [=module scope|module-scope=] 中声明的常量的值。
* 将资源（[=resources=]）绑定到着色器资源接口([=resource interface of a shader|resource interface=])中的变量，使这些资源的内容在执行期间可供着色器使用。
* 为其他模块范围([=module scope|module-scope=])的变量分配内存，并使用指定的初始值填充该内存。
* 使用阶段的管线输入填充入口点的形式参数（如果存在）。
* 将入口点返回值([=return value=])（如果存在）连接到阶段的管线输出。
* 然后它调用入口点。

一个 WGSL 程序被组织成：
* 函数，指定执行行为。
* 文字，是纯数学值的文本表示。
* 常量，每个常量都为在特定时间计算的值提供一个名称。
* 表达式，每个表达式组合一组值以生成结果值。
* 类型，每个类型描述：
    * 对受支持表达式的限制。
    * 这些表达式的语义。

WGSL 是一种命令式语言：行为被指定为要执行的语句序列。声明：
* 声明常量或变量
* 修改变量内容
* 使用结构化编程结构修改执行顺序：
    * 选择：if/else, switch
    * 循环: loop, while, for.
    * 跳出嵌套命令结构：break, continue
    * 重构：函数调用和返回
    * 丢弃（仅限片元着色器）：终止调用并丢弃输出

* 评估表达式以计算值作为上述行为的一部分。

WGSL 是静态类型的：由特定表达式计算的每个值都属于特定类型，仅通过检查程序源来确定。

WGSL 具有以数组和结构的形式描述布尔值、数字、向量、矩阵和由它们组成的数组和结构。其他类型描述内存。

WGSL 没有数字或布尔类型之间的隐式转换或提升。 将值从一种数字或布尔类型转换为另一种需要显式转换([[#conversion-expr|conversion]])、构造([[#type-constructor-expr|construction]])或重新解释位([[#bitcast-expr|reinterpretation of bits]])。这也适用于向量类型。

WGSL 有纹理和采样器类型。连同相关的内置函数，这些支持通常用于图形渲染的功能，并且通常由GPU提供。

着色器阶段的工作被划分为一个或多个调用（<dfn noexport>invocations</dfn>），每个调用都执行入口点，但条件略有不同。着色器阶段中的调用共享对某些变量的访问：
* 阶段中的所有调用共享着色器接口中的资源。
* 在计算着色器（[=compute shader stage|compute shader=]）中，同一工作组（[=compute shader stage/workgroup=]）中的调用共享工作组（[=address spaces/workgroup=]）存储类（[=address class=]）中的变量。不同工作组中的调用不共享这些变量。

但是，调用作用于不同的管线输入集，包括提供识别值以将调用与其对等调用区分开的内置输入。
此外，每个调用在 [=address spaces/private=] 和 [=address spaces/function=] 地址空间中以变量的形式拥有自己的独立内存空间。

着色器阶段中的调用并发执行，并且通常可能并行执行。
着色器作者负责确保着色器阶段调用的动态行为：

* 满足某些图元操作的一致性[[#uniformity|uniformity]] 要求，包括纹理采样和控制屏障。
* 协调对共享变量的潜在冲突访问，以避免竞争条件。

WGSL 有时允许给定特征的几种可能行为。这是一种可移植性危害，因为不同的实现可能会表现出不同的行为。WGSL的设计旨在最大限度地减少此类情况，但受到可行性和在各种设备上实现高性能的目标的限制。

## 符号 ## {#notation}

<dfn noexport>floor expression</dfn>在实数|x|上定义：

* &lfloor;|x|&rfloor; = |k|, 其中|k|是一个唯一整数，使得|k| &le; |x| &lt; |k|+1

<dfn noexport>ceiling expression</dfn>在实数|x|上定义：

* &lceil;|x|&rceil; = |k|, 其中|k|是一个唯一整数，使得|k|-1 &lt; |x| &le; |k|

<dfn noexport>roundUp</dfn>函数在正整数|k|和|n|上定义：

* roundUp(|k|, |n|) = &lceil;|n| &div; |k|&rceil; &times; |k|

|c|列|r|行矩阵|A|的转置（<dfn noexport>transpose</dfn>）是将|A|的行复制为|A|<sup>T</sup>的列形成的|r|列|c|行矩阵|A|<sup>T</sup>：

* transpose(|A|) = |A|<sup>T</sup>
* transpose(|A|)<sub>|i|,|j|</sub> = |A|<sub>|j|,|i|</sub>

列向量的转置是通过将列向量解释为1行矩阵来定义的。类似地，行向量的转置是通过将行向量解释为1列矩阵来定义的。

# 着色器生命周期 # {#shader-lifecycle}

WGSL程序及其可能包含的着色器生命周期中有四个关键事件。前两个对应于用于准备WGSL程序以供执行的WebGPU API方法。最后两个是着色器执行的开始和结束。

事件为：

1. <dfn noexport>Shader module creation</dfn>
    * 当[[WebGPU#dom-gpudevice-createshadermodule|WebGPU createShaderModule]]方法被调用后发生。此时WGSL程序的源文件被提供。
2. <dfn noexport>Pipeline creation</dfn>
    * 当[[WebGPU#dom-gpudevice-createcomputepipeline|WebGPU createComputePipeline]]或[[WebGPU#dom-gpudevice-createrenderpipeline|WebGPU createRenderPipeline]]方法被调用时发生。这些方法使用一个或更多先前被创建的着色器模块，以及其他配置信息。
3. <dfn noexport>Shader execution start</dfn>
    * 当向GPU发出[=draw command|draw=]或[=dispatch command=]命令、开始执行管线并调用[=shader stage=] [=entry point=]函数时发生。
4. <dfn noexport>Shader execution end</dfn>
    * 当所有着色器中的工作被完成时发生：
        * 所有调用（[=invocations=]）完结。
        * 所有对资源（[=resources=]）的访问完结。
        * 输出（如果有）已经传递给下游管线阶段。

事件按照以下方式排序：
*  数据依赖：着色器执行需要一个管线，一个管线同样需要一个着色器模块。
*  因果关系：着色器必须开始执行才能完成执行。

## 处理错误 ## {#processing-errors}

一个WebGPU实现可能由于两个原因对着色器处理失败：

* 程序错误（<dfn export>program error</dfn>）当着色器不满足WGSL或WebGPU规范要求时发生。
* 未分类错误（<dfn noexport>uncategorized error</dfn>）当所有WGSL和WebGPU需求都被满足时可能发生，可能的原因包括：
    * 着色器太复杂，超出了实现的能力，但在某种程度上不容易被规定的限制（[[#limits|limits]]）捕获。 简化着色器可能会解决此问题。
    * WebGPU实现中的缺陷。

处理错误可能会发生在着色器生命周期的三个阶段：

* <dfn export>shader-creation error</dfn>是在着色器模块创建时可行检测到的错误。检测必须仅依赖于WGSL程序源文本和其他可用于 `createShaderModule` API 方法的信息。

* <dfn export>pipeline-creation error</dfn>是在管线创建时可检测到的错误。检测必须仅依赖于特定管线创建API方法可用的WGSL程序源文本和其他信息。

* <dfn export>dynamic error</dfn>是在着色器执行期间发生的错误。这些错误可能会也可能不会被检测到。

注意：比如，一个竞争条件可能不会被检测到。

每个要求将被尽早检查。也就是：
* 当未能满足着色器创建时可检测到的要求，会导致shader-creation错误。
* 当未能满足管线创建时可检测到的要求，但更早无法检测到，会导致pipeline-creation错误。

当上下文不清楚时，本规范会指出未能满足特定要求是否会导致着色器创建、管线创建或动态错误。

WebGPU规范描述了每种错误的后果。

TODO：更新WebGPU规范，参考这里定义的三种错误。

# 文本结构 # {#textual-structure}

WGSL程序为文本。本规范并未规定该文本的特定编码。但是，UTF-8始终是WGSL程序的有效编码。

注意：像这样推广 UTF-8 的目的是为了简化WGSL程序的交换并鼓励工具之间的互操作性。

WGSL程序文本由一系列双字节对字符 [=code points=]组成，分组为连续的非空集形成：

* [=comments=]
* [=tokens=]
* [=blankspaces=]

程序文本不得包含空字符。

## 解析 ## {#parsing}
要解析一个WGSL程序：
1. 去掉注释[=comments=]：
    * 用一个space字符编码(`U+0020`)替换第一个注释。
    * 重复直到没有注释。
2. 从头到尾扫描，将剩余的字符编码分组为标记[=tokens=]和空格[=blankspaces=]：
    * 下一组由剩余未分组字符编码的最长非空前缀组成
3. 删除空格，只保留标记。
4. 解析token序列，尝试匹配 [=syntax/translation_unit=] 语法规则。

在以下情况下会导致[=shader-creation error=]：
* 整个源文本无法转换为有限的有效tokens序列，或
* [=syntax/translation_unit=] 语法规则与整个token序列不匹配。

## 空格和换行符## {#blankspace-and-line-breaks}

<dfn>Blankspace</dfn> 是 Unicode 中的一个或多个代码点的任意组合。
以下是 [=Unicode Standard Annex #31 for Unicode Version 14.0.0|Pattern_White_Space=] 中的代码点集：
* 空格 (`U+0020`)
* 水平制表符 (`U+0009`)
* 换行 (`U+000A`)
* 垂直制表符 (`U+000B`)
* 换页 (`U+000C`)
* 回车 (`U+000D`)
* 下一行 (`U+0085`)
* 从左到右的标记 (`U+200E`)
* 从右到左的标记 (`U+200F`)
* 行分隔符 (`U+2028`)
* 段落分隔符 (`U+2029`)

<div class='syntax' noexport='true'>
  <dfn for=syntax>_blankspace</dfn> ：

    | `/[\u0020\u0009\u000a\u000b\u000c\u000d\u0085\u200e\u200f\u2028\u2029]/uy`
</div>

<dfn>line break</dfn> 是一个连续的 [=blankspace=] 代码点序列，指示行尾。
它被定义为表示“强制中断”的空格，定义为
[=UAX14 第 6.1 节不可定制的换行规则=] [=UAX14 LB4|LB4=] 和 [=UAX14 LB5|LB5=]。
也就是说，换行符是以下任何一种：
* 换行 (`U+000A`)
* 垂直制表符 (`U+000B`)
* 换页 (`U+000C`)
* 回车符 (`U+000D`) 后不跟换行符 (`U+000A`)
* 回车 (`U+000D`) 后跟换行符 (`U+000A`)
* 下一行 (`U+0085`)
* 行分隔符 (`U+2028`)
* 段落分隔符 (`U+2029`)

注意：根据行号报告源文本位置的诊断应使用 [=line breaks=]数行。

## 注释 ## {#comments}

注释（<dfn>comment</dfn>）是一块不影响WGSL程序有效性和含义的文本，只是注释可以分隔[=tokens=]。着色器作者可以使用注释去给程序添加文档信息。

行尾注释（<dfn noexport>line-ending comment</dfn>）是一种由两个字符编码 //  (`U+002F` followed by `U+002F`) 和后面的字符编码组成的注释，直到但不包括：
* 下一个[=line break=]，或
* 程序结尾

<dfn noexport>block comment</dfn>是一种[=comment=]，由以下内容组成：
* 两个字符编码 `/*` (`U+002F` 跟着 `U+002A`)
* 然后是任何序列：
     * A [=block comment=]，或
     * 不包含 `*/` (`U+002A` 跟着 `U+002F`) 或 `/*` (`U+002F` followed by `U+002A`) 的文本
* 然后两个字符编码 `*/` (`U+002A` 跟着 `U+002F`)

注意：块注释可以嵌套。
由于块注释需要匹配的开始和结束文本序列，并允许任意嵌套，因此不能用正则表达式识别块注释。
这是常规语言的抽水引理的结果。

<div class='example wgsl' heading='Comments'>
  <xmp>
  const f = 1.5;   // 这是行尾注释。
  const g = 2.5;   /* 这是一个块注释
                    跨越几行。
                    /* 块注释可以嵌套
                     */
                    但是所有的块注释必须完结。
                  */
  </xmp>
</div>

## 标记 ## {#tokens}

一个标记（<dfn>token</dfn>）是一系列连续字符编码构成以下内容：
* 一个[=literal=].
* 一个[=keyword=].
* 一个[=reserved word=].
* 一个[=syntactic token=].
* 一个[=identifier=].

## 文字 ## {#literals}

文字（<dfn>literal</dfn>）为一下之一：
* 布尔文字<dfn noexport>boolean literal</dfn>：`true`或 `false`。
* 数字文字<dfn>numeric literal</dfn>：[=integer literal=] 或 [=floating point literal=]，用于表示一个数字。

<div class='example wgsl bool-literals' heading='boolean literals'>
  <xmp highlight='rust'>
    const a = true;
    const b = false;
  </xmp>
</div>

<div class='syntax' noexport='true'>
  <dfn for=syntax>bool_literal</dfn> :

    | [=syntax/true=]

    | [=syntax/false=]
</div>

[=numeric literal=]的形式是通过模式匹配定义
<dfn>integer literal</dfn> 是：
* 指定为以下任意项的整数：
     *`0`
     * 十进制数字序列，其中第一个数字不是“0”。
     * `0x` 或 `0X` 后跟一系列十六进制数字。
* 然后是可选的 `i` 或 `u` 后缀。

<div class='example wgsl int-literals' heading='integer literals'>
  <xmp highlight='rust'>
    const a = 0x123;
    const b = 0X123u;
    const c = 1u;
    const d = 123;
    const e = 0;
    const f = 0i;
    const g = 0x3f;
  </xmp>
</div>

<div class='syntax' noexport='true'>
  <dfn for=syntax>int_literal</dfn> :

    | `/(0[xX][0-9a-fA-F]+|0|[1-9][0-9]*)[iu]?/`
</div>

<dfn>floating point literal</dfn> 是 [=十进制浮点文字l=]
或 [=十六进制浮点文字=]。
* <dfn noexport>十进制浮点文字</dfn>是：
     * 尾数，指定为数字序列，其中包含可选的小数点 (`.`)。
     * 然后是一个可选的指数后缀，包括：
         * `e` 或 `E`。
         * 然后是指定为带有可选前导符号（`+` 或 `-`）的十进制数的指数。
         * 然后是可选的 `f` 或 `h` 后缀。
     * 小数点、指数、`f` 或 `h` 后缀中至少有一个必须存在。
          如果没有，则标记是 [=integer literal=]。
     * 字面量的值是尾数乘以 10 的指数幂。
          如果未指定指数，则假定指数为 0。

* <dfn noexport>十六进制浮点字面量</dfn> 是：
     * 一个 `0x` 或 `0X` 前缀
     * 然后是尾数，指定为十六进制数字序列，其中有一个可选的十六进制点 (`.`)。
     * 然后是一个可选的指数后缀，包括：
         * `p` 或 `P`
         * 然后是指定为带有可选前导符号（`+` 或 `-`）的十进制数的指数。
         * 然后是可选的 `f` 或 `h` 后缀。
     * 至少一个十六进制点或指数必须存在。
          如果两者都不是，则标记是 [=integer literal=]。
     * 文字的值是尾数乘以 2 的指数次方的值。
          如果未指定指数，则假定指数为 0。

<div class='example wgsl float-literals' heading='floating point literals'>
  <xmp highlight='rust'>
    const a = 0.e+4f;
    const b = 01.;
    const c = .01;
    const d = 12.34;
    const f = .0f;
    const g = 0h;
    const h = 1e-3;
    const i = 0xa.fp+2;
    const j = 0x1P+4f;
    const k = 0X.3;
    const l = 0x3p+2h;
    const m = 0X1.fp-4;
    const n = 0x3.2p+2h;
  </xmp>
</div>

<div class='syntax' noexport='true'>
  <dfn for=syntax>float_literal</dfn> :

    | [=syntax/decimal_float_literal=]

    | [=syntax/hex_float_literal=]
</div>

<div class='syntax' noexport='true'>
  <dfn for=syntax>decimal_float_literal</dfn> :

    | `/((([0-9]*\.[0-9]+|[0-9]+\.[0-9]*)([eE](\+|-)?[0-9]+)?)|([0-9]+[eE](\+|-)?[0-9]+))[fh]?|0[fh]|[1-9][0-9]*[fh]/`
</div>

<div class='syntax' noexport='true'>
  <dfn for=syntax>hex_float_literal</dfn> :

    | `/0[xX]((([0-9a-fA-F]*\.[0-9a-fA-F]+|[0-9a-fA-F]+\.[0-9a-fA-F]*)([pP](\+|-)?[0-9]+[fh]?)?)|([0-9a-fA-F]+[pP](\+|-)?[0-9]+[fh]?))/`
</div>

<div class='syntax' noexport='true'>
  <dfn for=syntax>const_literal</dfn> :

    | [=syntax/int_literal=]

    | [=syntax/float_literal=]

    | [=syntax/bool_literal=]
</div>

当 [=numeric literal=] 具有后缀时，该文字表示特定 [=scalar=] 类型中的值。
否则，文字表示下面定义的 [=abstract numeric types=] 之一的值。

<table class=data>
  <caption>将文字映射到类型</caption>
  <thead>
    <tr><th>文字<th>后缀<th>类型<th>例子
  </thead>

  <tr><td>[=integer literal=]<td>`i`<td>[=i32=]<td>42i
  <tr><td>[=integer literal=]<td>`u`<td>[=u32=]<td>42u
  <tr><td>[=integer literal=]<td><td>[=AbstractInt=]<td>124
  <tr><td>[=floating point literal=]<td>`f`<td>[=f32=]<td>42f 1e5f 1.2f 0x1.0p10f
  <tr><td>[=floating point literal=]<td>`h`<td>[=f16=]<td>42h 1e5h 1.2h 0x1.0p10h
  <tr><td>[=floating point literal=]<td><td>[=AbstractFloat=]<td>1e5 1.2 0x1.0p10
</table>

如果出现以下情况，则会导致 [=shader-creation error=]：
* 带有 `i` 或 `u` 后缀的 [=integer literal=] 不能由目标类型表示。
* 带有 `f` 或 `h` 后缀的 [=hexadecimal floating point literal=] 溢出或无法由目标类型精确表示。
* 带有 `f` 或 `h` 后缀的 [=decimal floating point literal=] 会溢出目标类型。
* 使用带有 `h` 后缀的 [=floating point literal=] 而 [=extension/f16|f16 extension=] 未启用。

Note: The hexadecimal float value 0x1.00000001p0 requires 33 mantissa bits to be represented exactly,
but [=f32=] only has 23 explicit mantissa bits.

注意：如果要使用 `f` 后缀来强制十六进制浮点字面量为类型，则字面量还必须使用二进制指数。 例如，写“0x1p0f”。 相比之下，`0x1f` 是一个十六进制整数文字。

## 关键字 ## {#keywords}

一个关键字(<dfn>keyword</dfn>)是一个[=token=]，总是指代被预定义的语言概念。有关WGSL关键字列表，请参阅[[#keyword-summary]]。

## 标识符 ## {#identifiers}

标识符（<dfn>identifier</dfn>）是一种用作名称的[=token=]，请参阅[[#declaration-and-scope]]和[[#directives]]。

标识符的形式基于
[=Unicode 标准附件 #31 用于 Unicode 版本 14.0.0|Unicode 标准附件 #31=] 用于
[[!UnicodeVersion14|Unicode 版本 14.0.0]],
以下详细说明。

标识符使用根据 [=UAX31 Grammar=] 描述的以下配置文件：

```
<Identifier> := <Start> <Continue>* (<Medial> <Continue>+)*

<Start> := XID_Start + U+005F
<Continue> := <Start> + XID_Continue
<Medial> :=
```

这意味着具有此类非 ASCII 代码点的标识符是
有效：`Δέλτα`, `réflexion`, `Кызыл`, `𐰓𐰏𐰇`, `朝焼け`, `سلام`, `검정`, `שָׁלוֹם`, `गुलाबी`, `փրոզ`

除以下例外：
* 标识符的拼写不得与 [=keyword=] 或 [=reserved word=] 相同。
* 标识符不能是 `_` （单下划线， `U+005F` ）。
* 标识符不能以 `__` 开头（两个下划线，`U+005F` 后跟 `U+005F`）。

<div class='syntax' noexport='true'>
  <dfn for=syntax>ident</dfn> :

    | `/([_\p{XID_Start}][\p{XID_Continue}]+)|([\p{XID_Start}])/uy`
</div>

[=Unicode 版本 14.0.0 的 Unicode 字符数据库=] 包括非规范列表，其中包含 [=UAX31 词法类|XID_Start=] 和
[=UAX31 词法类|XID_Continue=]。


注意：某些 [=built-in functions=] 的 [=return type=] 是其名称不能用于WGSL源的结构类型。
这些结构类型被描述为 [=predeclared=]，名称以两个下划线开头。
结果值可以使用类型推断保存到新声明的 `let` 或 `var` 中，或者立即通过名称立即提取其成员之一。 参见 `frexp` 和 `modf` 描述中的示例用法。

### 标识符比较 ### {#identifier-comparison}

当且仅当它们由相同的代码点序列组成时，两个 WGSL 标识符才是相同的。

特别是，两个标识符在 WGSL 中可能是不同的，但在常规规范化下被认为是相同的，
映射和匹配算法，例如：
- [=UAX15 标准化表格|标准化表格 C (NFC)=],
- [=UAX15 规范化形式|规范化形式 D (NFD)=],
- [=UAX15 规范化形式|规范化形式 KC (NFKC)=],
- [=UAX15 规范化形式|规范化形式 KD (NFKD)=],
- [=UTS46 映射=]，和
- [=charmod-norm 匹配=]。

注意：当 WGSL 程序的含义发生改变时，用户代理应该发出开发人员可见的警告，如果
标识符的所有实例都替换为该标识符的同形异义词之一。
（同形文字是一个代码点序列，在读者看来可能与另一个代码点序列相同。
用于检测同形文字的映射示例是中提到的转换、映射和匹配算法
上一段。如果标识符可以通过以下方式将一个代码点转换为另一个，则两个代码点序列是同形异义词
反复用同形文字替换一个子序列。）

## 属性 ## {#attributes}

属性（<dfn noexport>attribute</dfn>）修改对象或类型。WGSL为应用属性提供了统一的语法。属性用于多种目的，例如指定带有API的接口。一般来说，从语言的角度来看，出于类型和语义检查的目的，可以忽略属性。

对每个对象或类型，属性不能被多次指定。

<div class='syntax' noexport='true'>
  <dfn for=syntax>attribute</dfn> :

    | [=syntax/attr=] [=syntax/ident=] [=syntax/paren_left=] ( [=syntax/literal_or_ident=] [=syntax/comma=] ) * [=syntax/literal_or_ident=] [=syntax/comma=] ? [=syntax/paren_right=]

    | [=syntax/attr=] [=syntax/ident=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>literal_or_ident</dfn> :

    | [=syntax/float_literal=]

    | [=syntax/int_literal=]

    | [=syntax/ident=]
</div>

<table class='data'>
  <caption>Attributes defined in WGSL/caption>
  <thead>
    <tr><th>Attribute<th>Valid Values<th>Description
  </thead>

  <tr><td><dfn noexport dfn-for="attribute">`align`</dfn>
    <td>正i32文字
    <td>必须仅应用于结构（[=structure=]）类型的成员。

    必须是2的幂，并且必须满足成员类型的对齐要求：

    <p algorithm="align constraint">
     如果 `align(`|n|`)` 应用于 |S| 的成员
     类型为 |T| 和 |S| 是 [=store type=]
     或包含在地址空间 |C| 中变量的存储类型中，
     那么|n| 必须满足：
     |n|&nbsp;=&nbsp;|k|&nbsp;&times;&nbsp;[=RequiredAlignOf=](|T|,|C|)
     其中|k|是某个正整数。
    </p>

    见内存布局[[#memory-layouts]]。

  <tr><td><dfn noexport dfn-for="attribute">`binding`
    <td>非负i32文字
    <td>必须仅应用于资源（[=resource=]）变量。

    指定绑定组（[=attribute/group=]）中资源的绑定号。见[[#resource-interface]]。

  <tr><td><dfn noexport dfn-for="attribute">`builtin`
    <td>内置值的标识符名称
    <td>只能应用于入口点函数参数、入口点返回类型或结构（[=structure=]）成员。

    声明一个内置变量。见[[#builtin-values]]。
  <tr><td><dfn noexport dfn-for="attribute">`const`
     <td>*无*
     <td>只能应用于函数声明。

     指定该函数可用作 [=creation-time function=]。
     如果此属性应用于
     用户自定义函数。

     注意：此属性用作符号约定来描述可以在 [=creation-time expressions=] 中使用哪些内置函数。

  <tr><td><dfn noexport dfn-for="attribute">`group`
    <td>非负i32文字
    <td>必须仅应用于资源（[=resource=]）变量。

    指定资源的绑定组。见[[#resource-interface]]。

 <tr><td><dfn noexport dfn-for="attribute">`id`
     <td>非负 i32 字面量
     <td>只能应用于 [=scalar=] 类型的 [=override declaration=]。

     指定一个数字标识符作为 [=pipeline-overridable=] 常量的备用名称。

  <tr><td><dfn noexport dfn-for="attribute">`interpolate`
    <td>一个或两个参数。

    第一个参数必须是插值类型（[=interpolation type=]）。 第二个参数（如果存在）必须指定插值采样（[=interpolation sampling=]）。

    <td>只能应用于用 [=attribute/location=] 属性修饰的声明。

    指定用户定义的IO如何必须插入。该属性仅对用户定义的顶点（[=vertex=]）输出和片元（[=fragment=]）输入有意义。见[[#interpolation]]。

  <tr><td><dfn noexport dfn-for="attribute"> `invariant`
    <td>*None*
    <td>

    仅应用于 `position` 内置值。

    当应用于顶点着色器的位置内置输出变量（`position` [=built-in output value=]）时，结果的计算在不同程序和同一入口点的不同调用之间是不变的。 也就是说，如果数据和控制流在不同入口点的两个位置输出匹配，则结果值保证相同。对位置内置输入变量（`position` [=built-in input value=]）没有影响。

    注意：此属性映射到 HLSL 中的 `precise` 限定符和 GLSL 中的 `invariant` 限定符

  <tr><td><dfn noexport dfn-for="attribute">`location`
    <td>非负i32文字
    <td>仅应用于入口点函数参数、入口点返回类型或结构（[=structure=]）类型的成员。只能应用于数值标量（[=numeric scalar=]）或数值向量（[=numeric
    vector=]）类型的声明。不得与计算（[=compute=]）着色器阶段一起使用。

    指定入口点的用户定义IO的一部分。见[[#input-output-locations]]。

  <tr><td><dfn noexport dfn-for="attribute">`size`</dfn>
    <td>正i32文字
    <td>仅应用于结构（[=structure=]）类型的成员。

    在结构中为此成员保留的字节数。
    此数字必须至少是成员类型的 [=byte-size=]：
     <p algorithm="byte-size constraint">
     如果 `size(`|n|`)` 应用于类型为 |T| 的成员，则 [=SizeOf=](|T|)&nbsp;&leq;&nbsp;|n|。
     </p>

     见 [[#memory-layouts]]

  <tr><td><dfn noexport dfn-for="attribute">`workgroup_size`</dfn>
    <td>

    一个，两个，或三个参数。

    每个参数是文字常量或模块范围常量（[[#module-constants|module-scope constant]]）。所有参数的类型必须相同，或者是 [INT]。

    <td>

    必须应用于计算着色器（[=compute shader stage|compute shader=]）入口点函数。不得应用于任何其他对象。

    指定计算着色器的工作组网格（[=workgroup grid=]）的x、y和z维度。

    第一个参数指定x维度。第二个参数（如果提供）指定y维度，否则假设为1。第三个参数（如果提供）指定z维度，否则假设为1。每个维度必须至少为 1，最多为一个上限由WebGPU API指定的边界。

</table>

下面的<dfn noexport>管道阶段属性</dfn>
将函数指定为特定 [=shader stage=] 的 [=entry point=]。
这些属性只能应用于 [=function declarations=]，
并且在给定的函数上最多可以存在一个。
它们不带参数。

<表类='数据'>
  <caption>流水线阶段属性</caption>
  <头>
    <tr><th>属性<th>描述
  </thead>

  <tr><td><dfn noexport dfn-for="attribute">`vertex`</dfn><br>
    <td>将函数声明为 [=vertex shader stage=] 的 [=entry point=]
    [=GPURenderPipeline|render pipeline=]。

  <tr><td><dfn noexport dfn-for="attribute">`fragment`</dfn><br>
    <td>将函数声明为 [=fragment shader stage=] 的 [=entry point=]
    [=GPURenderPipeline|render pipeline=]。

  <tr><td><dfn noexport dfn-for="attribute">`compute`</dfn><br>
    <td>将函数声明为 [=compute shader stage=] 的 [=entry point=]
    [=GPUComputePipeline|compute pipeline=]。

</table>

## 指令 ## {#directives}

指令（<dfn noexport>directive</dfn>）是一个[=token=]序列，它修改了WebGPU实现对WGSL程序的处理方式。见[[#enable-directive-section]]。

<div class='syntax' noexport='true'>
  <dfn for=syntax>global_directive</dfn> :

    | [=syntax/enable_directive=]
</div>

## 声明和范围 ## {#declaration-and-scope}

声明（<dfn noexport>declaration</dfn>）将标识符（[=identifier=]）与以下类型的对象之一相关联：
* [=type=]
* [=value declaration|value=]
* [=variable=]
* [=function/function=]
* [=formal parameter=]

换句话说，声明引入了对象的名称（<dfn noexport>name</dfn>）。

声明的范围（<dfn noexport>scope</dfn>）是一组程序位置，其中使用声明的标识符可能表示其关联对象。我们说标识符在那些源位置的（声明的）范围内（<dfn noexport>in scope</dfn>）。

使用标识符时，对于某些声明，它必须是 [=in scope=] 或作为指令的一部分。
当标识符用于该名称的一个或多个声明的范围内时，该标识符将表示最接近该用途的非 [=module scope|module-scope=] 声明的对象，或者如果是模块范围声明 范围内没有其他声明。
我们说标识符使用 <dfn noexport>resolves</dfn> 到那个声明。

声明出现的位置决定了它的范围。
通常，范围是在声明结束后立即开始的一段文本。
[=module scope=] 处的声明是例外，如下所述。

当该标识符已经在范围内且与该名称的另一个实例具有相同的范围结束时，声明不得引入该名称。

某些对象由 WebGPU 实现提供，并被视为已被每个 WGSL 程序声明。
我们说这样的对象是预先声明的（<dfn noexport>predeclared</dfn>）。他们的范围是整个WGSL程序。预先声明的对象的示例为：
* [=built-in functions=], and
* built-in types.

如果声明出现在任何其他声明的文本之外，则声明在<dfn noexport>模块范围</dfn>。
整个程序的模块范围声明是 [=in scope=]。
也就是说，模块范围内的声明可以被该声明之后*或之前*的源文本引用。

如果任何模块范围声明是递归的，则为 [=shader-creation error=]。
也就是说，声明之间不能有循环：

> 考虑有向图，其中：
> * 每个节点对应一个声明 |D|。
> * 声明 |D| 有一条边 到声明 |T| 当定义
>      对于 |D| 提到 [=resolves=] 到 |T| 的标识符。
>
> 此图不得有环。

注意：[=function body=] 是 [=function declaration=] 的一部分，因此
函数不得直接或间接递归。

注意：非[=module scope=] 标识符的使用必须遵循文本中该标识符的声明。
然而，对于 [=module scope=] 声明来说，情况并非如此，它们可能在文本中被乱序引用。

注意：只有 [=function declaration=] 可以包含其他声明。

<div class='example wgsl' heading='Valid and invalid declarations'>
  <xmp  highlight='rust'>
    // 无效，无法重用内置函数名称。
    var<private> modf: f32 = 0.0;

    // 有效，foo_1 在整个程序的范围内。
    var<private> foo: f32 = 0.0; // foo_1

    // 有效，my_func_1 在整个程序的范围内。
    var<private> bar: u32 = 0u; // bar_1

    // 有效，my_func_1 在程序结束前一直在作用域内。
    // 有效，foo_2 一直在作用域内直到函数结束。
    fn my_func(foo: f32) { // my_func_1, foo_2
      // 对 'foo' 的任何引用都解析为函数参数。

      // 无效，foo_2 的作用域结束于函数的 。
      var foo: f32; // foo_3

      // 有效，bar_2 一直在作用域内直到函数结束。
      var bar: u32; // bar_2
      // 对 'bar' 的引用解析为 bar_2
      {
        // 有效，bar_3 一直在范围内，直到复合语句结束。
        var bar: u32; // bar_3
        // 对 'bar' 的引用解析为 bar_3

        // 无效，bar_4 与 bar_3 具有相同的结束范围。
        var bar: i32; // bar_4

        // 有效，i_1 在范围内直到 for 循环结束
        for ( var i: i32 = 0; i < 10; i = i++ ) { // i_1
          // 无效，i_2 与 i_1 具有相同的结束范围。
          var i: i32 = 1; // i_2.
        }
      }

      // 无效，bar_5 与 bar_2 具有相同的结束范围。
      var bar: u32; // bar_5

      // 有效的模块范围声明在整个程序的范围内。
      var early_use : i32 = later_def;
    }

    // 无效，bar_6 与 bar_1 具有相同的结束范围。
    var<private> bar: u32 = 1u; // bar_6

    // 无效，my_func_2 与 my_func_1 具有相同的结束范围。
    fn my_func() { } // my_func_2

    // 有效，my_foo_1 在整个程序的范围内。
    fn my_foo( //my_foo_1
      // 有效，my_foo_2 一直在作用域内直到函数结束。
      my_foo: i32 // my_foo_2
    ) { }

    var<private> later_def : i32 = 1;
  </xmp>
</div>

# 类型 # {#types}

程序计算值。

在WGSL中，类型（<dfn noexport>type</dfn>）是一组值，每个值都属于一种类型。值的类型决定了可以对该值执行的操作的语法和语义。

例如，数学数字 1 对应于 [SHORTNAME] 中的这些不同值：
* 32 位有符号整数值 `1i`,
* 32 位无符号整数值 `1u`,
* 32 位浮点值 `1.0f`,
* 如果启用了 [=extension/f16|f16 extension=]，则为 16 位浮点值 `1.0h`，
* [=AbstractInt=] 值 1，和
* [=AbstractFloat=] 值 1.0

WGSL将它们视为不同的值，因为它们的机器表示和操作不同。

类型要么是预声明（[=predeclared=]）的，要么是通过声明（[=declaration=]）在WGSL源代码中创建的。

我们区分类型的*概念*和WGSL中表示该类型的*语法*。在许多情况下，本规范中类型的拼写与其WGSL语法相同。例如：
* 32-位无符号整数值的集合在本规范中拼写为 `u32`，在WGSL程序中也一样。
* 结构类型或包含结构的类型的拼写不同。

一些WGSL类型仅用于分析源程序和确定程序的运行时行为。本规范将描述此类类型，但它们不会出现在WGSL源文本中。

注意：WGSL [=reference types=] 未写在WGSL程序中。见[[#memory-view-types]]。

## 类型检查 ## {#type-checking-section}

WGSL值是通过计算表达式来计算的。表达式（<dfn noexport>expression</dfn>）
是解析为名称以“`_expression`”结尾的 [SHORTNAME] 语法规则之一。
表达式 |E| 可以包含 <dfn noexport>subexpressions</dfn>，它们是正确包含在外部表达式 |E| 中的表达式。
<dfn noexport>顶级表达式</dfn> 是一个本身不是子表达式的表达式。
参见 [[#expression-grammar]]。

表达式求值产生的特定值取决于：
* <dfn noexport>static context</dfn>:
    表达式周围的源文本，以及
* <dfn noexport>dynamic context</dfn>:
    计算表达式的调用状态，以及调用在运行时的执行上下文。

计算特定表达式可能产生的值将始终属于特定的WGSL类型，称为表达式的静态类型（<dfn noexport>static type</dfn>）。WGSL的规则被设计为表达式的静态类型仅取决于表达式的静态上下文。


类型断言（<dfn noexport>type assertion</dfn>）是从一些WGSL源表达式到WGSL类型的映射。符号

> *e* : *T*

是一个意思为*T*为WGSL表达式*e*的静态类型的断言。

注意：类型断言是关于程序文本的事实陈述。它不是运行时的检查。


语句经常使用表达式，并且可能对这些表达式的静态类型提出要求。
例如：
* `if` 语句的条件表达式必须是 [=bool=] 类型。
* 在指定显式类型的 `let` 声明中，初始化表达式必须计算为该类型。

<dfn noexport>类型检查</dfn> 一个成功解析的WGSL程序是映射过程
每个表达式为其静态类型，
并验证是否满足每个语句的类型要求。
如果类型检查失败，则会产生一个 [=shader-creation error=] 的特殊情况，称为 <dfn noexport>type error</dfn>。

可以通过递归应用 [=type rules=] 来执行类型检查
到句法短语，其中 <dfn noexport>句法短语</dfn> 是 [=expression=] 或 [[#statements|statement]]。
<dfn noexport>类型规则</dfn> 描述 [=syntactic phrase=] 的 [=static context=] 如何
确定该短语中包含的表达式的静态类型。
[=type rule=] 有两个部分：
* 一个<dfn noexport lt="类型规则结论">结论</dfn>。
    * 如果短语是表达式，则结论是表达式的 [=type assertion=]。
    * 如果短语是陈述，则结论是一组 [=type assertions=]，
        每个语句的 [=顶级表达式=] 一个。
    * 在这两种情况下，[=syntactic phrases=] 都是示意性指定的，
        使用 *italicized* 名称来表示子表达式
        或其他语法确定的参数。
* <dfn noexport lt="type rule preconditions">先决条件</dfn>，包括：
    * 对于表达式：
        * 为子表达式键入断言，当它有子表达式时。
             每个都可以直接满足，或者通过 [=feasible automatic conversion=]（如 [[#conversion-rank]] 中定义）。
        * 如何在语句中使用表达式。
    * 对于语句：
        * 语句的句法形式，以及
        * 在语句中为 [=顶级表达式=] 键入断言。
    * 其他原理图参数的条件（如果有）。
    * 可选地，其他静态上下文。

类型规则的每个不同类型参数化称为 <dfn noexport>overload</dfn>。
例如，[[#arithmetic-expr|unary negation]]（`-`|e| 形式的表达式）有十二个重载，因为它的类型规则由类型 |T| 参数化。 可以是以下任何一种：
* [=i32=]
* [=vector|vec2&lt;i32&gt;=]
* vec3&lt;i32&gt;
* vec4&lt;i32&gt;
* [=f32=]
* [=vec2&lt;f32&gt;=]
* vec3&lt;f32&gt;
* vec4&lt;f32&gt;
* [=f16=]
* [=vector|vec2&lt;f16&gt;=]
* vec3&lt;f16&gt;
* vec4&lt;f16&gt;

在以下情况下，<dfn noexport>类型规则适用于句法短语</dfn>：
* 规则的结论匹配 [=syntactic phrase=] 的有效解析，并且
* 规则的先决条件被满足。

考虑表达式，`1u+2u`。
它有两个 [[#literal-expressions|literal 子表达式]]：`1u` 和 `2u`，都是 u32 类型。
[=顶级表达式=] 是一个附加项。
参考 [[#arithmetic-expr]] 规则，标量 u32 加法的类型规则适用于表达式，因为：
* `1u+2u` 匹配 |e1|+|e2| 形式的解析，带有 |e1|代表 `1u` 和|e2|代表“2u”，和
* |e1|是 u32 类型，并且
* |e2|是u32类型。

在分析[=句法短语=]时，可能会出现三种情况：
* 没有类型规则适用于表达式。这会导致 [=type error=]。
* 只有一种类型规则适用于表达式。
    在这种情况下，规则的 [=type rule 结论|conclusion=] 被断言，确定表达式的静态类型。
* 不止一种类型规则适用。即满足多个[=overload=]的前提条件。
    在这种情况下，使用 [[#overload-resolution-section]] 中描述的平局过程。
    * 如果重载解析成功，则确定将单个类型规则应用于表达式。
        该重载的 [=type 规则结论|结论=] 中的 [=type assertions=] 被断言，
        并因此确定 [=syntactic phrase=] 中一个或多个表达式的类型。
    * 如果重载解析失败，则结果为 [=type error=]。

继续上面的例子，只有一个类型规则适用于表达式 `1u+2u`，所以类型检查
接受该类型规则的结论，即 `1u+2u` 是 u32 类型。

一个WGSL源程序为<dfn noexport>well-typed</dfn>当：
* 可以通过应用类型规则为程序中的每个表达式确定静态类型，并且
* 满足每个语句的类型要求

否则会出现类型错误（[=type error=]）并且源程序不是有效的WGSL程序。

WGSL是一种静态类型语言（<dfn noexport>statically typed language</dfn>），因为 WGSL 程序的类型检查要么成功要么发现类型错误，而只需要检查程序源文本。

### 类型规则表 ### {#typing-tables-section}

对于表达式WGSL类型规则（[=type rules=]）被组织成类型规则表（<dfn noexport>type rule tables</dfn>），每个类型规则占一行。

表达式的语义（<dfn noexport>semantics of an expression</dfn>）是对表达式求值的结果，主要是结果值的产生。 适用于表达式的类型规则的*描述*列将指定表达式的语义。语义通常取决于类型规则参数的值，包括任何子表达式的假定值。 有时，表达式的语义包括产生结果值以外的效果，例如其子表达式的非结果值效果。

TODO：示例：非结果值效应是函数调用子表达式的任何副作用。

### 转化排名### {#conversion-rank}

当一个类型断言 |e|:|T|用作 [=type rule precondition=]，满足以下条件：
* |e|已经是 |T| 类型，或者
* |e| 的值可以自动转换为 |T| 类型的值。

该规则由 <dfn>ConversionRank</dfn> 函数对类型对进行编码，在下表中定义。
[=ConversionRank=] 函数表示自动将一种类型 (*Src*) 的值转换为另一种类型 (*Dest*) 的偏好和可行性。
较低的等级更可取。

<dfn>可行的自动转换</dfn> 将值从 *Src* 类型转换为 *Dest* 类型，并且当 [=ConversionRank=](*Src*,*Dest*) 是有限的时允许。
这种转换是保值的，受 [[#floating-point-evaluation]] 中描述的限制。

注意：自动转换仅在两种情况下发生。
首先，将 [=creation-time constant=] 转换为可在 GPU 上使用的相应类型数值时。
其次，当发生来自内存引用的加载时，会产生存储在该内存中的值。

注意：无限等级的转换是不可行的，即不允许。

注意：当不进行转换时，转换等级为零。

<table class='data'>
  <caption>
    ConversionRank from one type to another
  </caption>
  <thead>
    <tr><th>Src
        <th>Dest
        <th>ConversionRank(Src,Dest)
        <th>Notes
  </thead>
  <tr algorithm="conversion rank identity">
      <td>|T|
      <td>|T|
      <td>0
      <td>Identity. No conversion performed.
  <tr algorithm="conversion rank from reference via load rule">
      <td>ref&lt;|S|,|T|,|A|&gt;<br>where |A| is [=access/read=] or [=access/read_write=]
      <td>|T|
      <td>0
      <td>Apply the [=Load Rule=] to load a value from a memory reference.
  <tr algorithm="conversion rank abstract float to f32">
      <td>[=AbstractFloat=]
      <td>f32
      <td>1
      <td>
  <tr algorithm="conversion rank abstract float to f16">
      <td>[=AbstractFloat=]
      <td>f16
      <td>2
      <td>
  <tr algorithm="conversion rank abstract int to i32">
      <td>[=AbstractInt=]
      <td>i32
      <td>3
      <td>
  <tr algorithm="conversion rank abstract int to u32">
      <td>[=AbstractInt=]
      <td>u32
      <td>4
      <td>
  <tr algorithm="conversion rank abstract int to abstract float">
      <td>[=AbstractInt=]
      <td>[=AbstractFloat=]
      <td>5
      <td>
  <tr algorithm="conversion rank abstract int to f32">
      <td>[=AbstractInt=]
      <td>f32
      <td>6
      <td>Behaves as [=AbstractInt=] to [=AbstractFloat=], and then [=AbstractFloat=] to f32
  <tr algorithm="conversion rank abstract int to f16">
      <td>[=AbstractInt=]
      <td>f16
      <td>7
      <td>Behaves as [=AbstractInt=] to [=AbstractFloat=], and then [=AbstractFloat=] to f16
  <tr algorithm="conversion rank for non-convertible cases">
      <td>|S|
      <td>|T|<br>where above cases don't apply
      <td>infinity
      <td>There are no automatic conversions between other types.
</table>

### 过载分辨率 ### {#overload-resolution-section}

当多个 [=type 规则适用于句法短语=] 时，使用平局程序
来决定哪一个应该生效。
此过程称为<dfn noexport>重载解析</dfn>，
并假设类型检查已经成功找到 [=subexpressions=] 的静态类型。

考虑一个 [=syntactic phrase=] |P|，并且所有 [=type 规则都适用于一个句法短语|type 规则，这些规则将 =] 应用于 |P|。
重载解析算法将这些类型规则称为<dfn noexport>重载候选</dfn>。
对于每个候选人：
* 其先决条件已直接或通过[=可行的自动转换|自动转换=]得到满足。
* 它的 [=type rule 结论|conclusion=] 有：
    * 匹配 |P| 的有效解析的句法形式，以及
    * 一个 [=type assertion=] 对应于 |P| 中的每个 [=top-level expression=]。

|P| 的重载分辨率如下进行，目标是找到一个最 [=preferable Candidate|preferable=] [=overload Candidate=]：
1. 对于每个候选|C|，枚举句法短语中子表达式的转换等级。
    候选者的先决条件已经满足，因此对于 |P| 中的第 |i| 个子表达式：
    * 其静态类型已计算。
    * 从表达式的静态类型到前置条件中对应类型断言所需要的类型有一个[=feasible automatic conversion=]。
        令 |C|.|R|(i) 为该转换的 [=ConversionRank=]。

1. 给候选者排序：给定两个重载候选者|C1|和 |C2|、|C1| <dfn lt="preferable Candidate">首选</dfn>优于|C2|如果：
    * 对于每个表达式位置 |i|在 |P|, |C1|.|R|(i) &le; |C2|.|R|(i)。
         * 即每次表达式转换都需要应用|C1|到 |P|至少与应用 |C2| 所需的相应表达式转换一样可取到 |P|。
    * 至少有一个表达式位置 |i|其中|C1|.|R|(i) &lt; |C2|.|R|(i)。
         * 即应用 |C1| 至少需要进行一次表达式转换这比应用 |C2| 所需的相应转换更可取。

1. 如果只有一个候选人 |C|这是 [=preferable Candidate|preferred=] 高于所有其他，然后重载解析成功，产生候选类型规则 |C|。
      否则，重载解析失败。

      TODO: Examples


 ## 创建时间常量的类型 ## {#types-for-creation-time-constants}

 某些表达式在 [=shader module creation|shader-creation time=] 时计算，
 并且具有可能比 GPU 直接实现的数值范围和精度更大的数值范围和精度。

 [SHORTNAME] 为这些评估定义了两个 <dfn>抽象数字类型</dfn>：
 * <dfn noexport>AbstractInt</dfn> 类型是整数集|i|，具有-2<sup>63</sup> &leq; |我| &lt; 2<sup>63</sup>。
 * <dfn noexport>AbstractFloat</dfn> 类型是一组可表示的有限浮点数
     [[!IEEE-754|IEEE-754]] binary64（双精度）格式。

 对其中一种类型的表达式的求值不得溢出或产生未定义的结果。
 否则，结果是 [=shader-creation error=]。

 这些类型不能在 WGSL 源代码中拼写。它们仅由 [=type checks=] 使用。

 不是抽象数字类型也不包含抽象数字的类型
 类型称为 <dfn noexport>concrete</dfn>。

 没有后缀的 [=numeric literal=] 表示 [=abstract numeric type=] 中的值：
 * 没有 `i` 或 `u` 后缀的 [=integer literal=] 表示 [=AbstractInt=] 值。
 * 没有 `f` 后缀的 [=floating point literal=] 表示 [=AbstractFloat=] 值。

示例：表达式 `log2(32)` 分析如下：
* `log2(32)` 被解析为对 `log2` 内置函数的函数调用，操作数 [=AbstractInt=] 值为 32。
* 没有带有整数标量形式参数的 `log2` 重载。
* 考虑到两个可能的重载和 [=可行的自动转换=]，而是应用 [=overload resolution=]：
    * [=AbstractInt=] 到 [=AbstractFloat=]。 （转换等级 4）
    * [=AbstractInt=] 到 [=f32=]。 （转换等级 5）
* 结果计算以 [=AbstractFloat=] 的形式出现（例如 `log2(32.0)`）。

示例：表达式 `1 + 2.5` 分析如下：
* `1 + 2.5` 被解析为子表达式 [=AbstractInt=] 值为 1 和 [=AbstractFloat=] 值为 2.5 的加法运算。
* |e|+|f| 没有重载在哪里 |e|是整数且 |f|是浮点数。
* 然而，使用可行的自动转换，有两个潜在的重载：
    * `1` 转换为 [=AbstractFloat=] 值 `1.0`（排名 4），而 `2.5` 仍然是 [=AbstractFloat=]（排名 0）。
    * `1` 转换为 [=f32=] 值 `1.0f`（排名 5），而 `2.5` 转换为 [=f32=] 值 `2.5f`（排名 1）。
* 第一个重载是 [=preferable Candidate=] 并且类型检查成功。
* 结果计算以 [=AbstractFloat=] `1.0 + 2.5` 的形式出现。

示例：`让 x = 1 + 2.5;`
* 这个例子和上面的例子类似，只是 `x` 不能解析为 [=abstract numeric type=]。
* 因此，只有一个可行的重载候选：使用 [=f32=] 加法。
* 声明的效果就像是写成 `let x : f32 = 1.0f + 2.5f;`。

示例：`1u + 2.5` 导致 [=shader-creation error=]：
* `1u` 项是 [=u32=] 类型的表达式。
* `2.5` 项是 [=AbstractFloat=] 类型的表达式。
* 没有有效的重载候选：
     * 从 GPU 物化的整数类型到浮点类型的自动转换是不可行的。
     * 没有类型规则匹配 *e*`+`*f* 与 *e* 为整数类型和 *f* 为浮点类型。

     <div class='example literals' heading="文字类型推断">
       <xmp highlight='rust'>
         // 显式类型的无符号整数文字。
         var u32_1 = 1u； // 变量持有一个 u32

         // 显式类型的有符号整数文字。
         var i32_1 = 1i; // 变量保存一个 i32

         // 显式类型的浮点字面量。
         var f32_1 = 1f; // 变量包含一个 f32

         // 显式类型的无符号整数文字不能被否定。
         var u32_neg = -1u; // 无效：一元减法不支持 u32

         // 没有后缀的整型字面量往往会被推断为 i32：
         // let-declaration 的初始化程序必须是可构造的（或指针）。
         // 最优选的从 AbstractInt 到可构造类型的自动转换
         // 是 AbstractInt 到 i32，转换等级为 2。所以“1”被推断为 i32。
         let some_i32 = 1; // 比如 let some_i32: i32 = 1i;

         // 从声明类型推断。
         var i32_from_type : i32 = 1; // 变量保存 i32。 AbstractInt 到 i32，转换等级 2
         var u32_from_type : u32 = 1; // 变量保存 u32。 AbstractInt 到 u32，转换等级 3

         // 无后缀的整数字面量可以在需要时转换为浮点数：
         // 自动将 AbstractInt 转换为 f32，转换等级为 5。
         var f32_promotion : f32 = 1; // 变量保存 f32

         // 无效：从浮点到整数的转换不可行
         var i32_demotion : i32 = 1.0; // 无效的

         // 从表达式推断。
         var u32_from_expr = 1 + u32_1; // 变量保存 u32
         var i32_from_expr = 1 + i32_1; // 变量保存 i32

         // 值必须是可表示的。
         let u32_too_large : u32 = 1234567890123456890; // 无效，溢出
         let i32_too_large : i32 = 1234567890123456890; // 无效，溢出
         let u32_large : u32 = 2147483649; // 有效的
         let i32_large : i32 = 2147483649; // 无效，溢出
         let f32_out_of_range1 = 0x1p500; // 无效，超出范围
         let f32_hex_lost_bits = 0x1.0000000001p0; // 无效，在 f32 中不能完全表示

         // 最小整数：对 AbstractInt 进行一元否定，然后推断 i32。
         // 从 AbstractInt 到可构造类型的最优选转换（最低
         // 转换等级) 是 AbstractInt 到 i32。
         let i32_min = -2147483648; // 类型为 i32

         // 无效的。同上选择AbstractInt to i32，但是值out of
         // 范围，产生着色器创建错误。
         let i32_too_large_2 = 2147483648; // 无效的。

         // 子表达式可以解析为 AbstractInt 和 AbstractFloat。
         // 下面的例子都是有效的，变量的值为6u。
         // var u32_expr1 = (1 + (1 + (1 + (1 + 1)))) + 1u;
         // var u32_expr2 = 1u + (1 + (1 + (1 + (1 + 1))));
         // var u32_expr3 = (1 + (1 + (1 + (1u + 1)))) + 1;
         // var u32_expr4 = 1 + (1 + (1 + (1 + (1u + 1))));

         // 基于内置函数参数的推理。

         // 最喜欢的候选是clamp(i32,i32,i32)->i32
    let i32_clamp = clamp(1, -5, 5);
         // 最喜欢的候选是clamp(u32,u32,u32)。
         // 文字使用 AbstractInt 到 u32 的自动转换。
    let u32_clamp = clamp(5, 0, u32_from_expr);
         // 最喜欢的候选是clamp(f32,f32,f32)->f32
         // 文字使用 AbstractInt 到 f32 的自动转换。
    let f32_clamp = clamp(0, f32_1, 1);

         // TODO: 当 AbstractFloat 获得加法支持时，这些将变为有效，
         // 通过提升。
        // let f32_promotion1 = 1.0 + 2 + 3 + 4; // TODO: like let f32_promotion1:f32 = 10f;
        // let f32_promotion2 = 2 + 1.0 + 3 + 4; // TODO: like let f32_promotion1:f32 = 10f;
        // let f32_promotion3 = 1f + ((2 + 3) + 4); // TODO: like let f32_promotion1:f32 = 10f;
        // let f32_promotion4 = ((2 + (3 + 1f)) + 4); // TODO: like let f32_promotion1:f32 = 10f;

         // 类型规则违规。

         // 无效，初始化器只能解析为 f32：
         // 从 AbstractFloat 到 u32 的自动转换不可行。
            let mismatch : u32 = 1.0;

         // 无效的。没有允许混合符号参数的钳位过载。
         let ambiguous_clamp = clamp(1u, 0, 1i);

         // 推理在语句级别完成。

         // let-declaration 的初始化程序必须是可构造的（或指针）。
         // 最优选的从 AbstractInt 到可构造类型的自动转换
         // 是 AbstractInt 到 i32，转换等级为 2。所以“1”被推断为 i32。
         let some_i32 = 1; // 比如 let some_i32: i32 = 1i;

         let some_f32 : f32 = some_i32; // 类型错误：i32 不能分配给 f32

         // 另一个溢出情况
         let overflow_u32 = (1 -2) + 1u; // 无效，-1 超出 u32 的范围

         // 理想值超出 32 位范围，但又回到了范围内
         let out_and_in_again = (0x1ffffffff / 8);

         // 类似，但无效
         let out_of_range = (0x1ffffffff / 8u); // 要求以 32 位进行计算，
     // 使 0x1ffffffff 超出范围。

       </xmp>
     </div>

## 普通类型 ## {#plain-types-section}

普通类型（[=Plain types=]） 是布尔值、数字、向量、矩阵或这些值的机器表示类型，。

普通类型（<dfn>plain type</dfn>）是一个标量（[=scalar=]）类型，一个原子（[=atomic type|atomic=]）类型，或一个复合（[=composite=]）类型。

注意：WGSL中的普通类型类似于C++中的Plain-Old-Data类型，但也包括原子类型。

### 布尔类型 ### {#bool-type}

布尔（<dfn noexport>bool</dfn>）类型包括值 `true` 和 `false`。
<table class='data'>
  <caption>Boolean literal type rules</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr><td><td>`true`: bool<td>The true value.<br>OpConstantTrue %bool
  <tr><td><td>`false`: bool<td>The false value.<br>OpConstantFalse %bool
</table>

### 整数类型 ### {#integer-types}

<dfn noexport>u32</dfn>类型为一组32-位无符号整数的集合。

<dfn noexport>i32</dfn>类型为一组32-位有符号整数的集合。它使用二进制补码表示，符号位位于最高有效位的位置。

### 浮点类型 ### {#floating-point-types}

<dfn noexport>f32</dfn>类型是一组[[!IEEE-754|IEEE-754]] binary32 （单精度）格式的32-位浮点型数值。详见[[#floating-point-evaluation]]。
<dfn noexport>f16</dfn> 类型是 [[!IEEE-754|IEEE-754]] binary16（半精度）格式的 16 位浮点值集。 如果使用 [=f16=] 类型，则为 [=shader-creation error=]，除非程序包含“enable f16;” 启用 [=extension/f16|f16 extension=] 的指令。 有关详细信息，请参阅 [[#floating-point-evaluation]]。

### 标量类型 ### {#scalar-types}

标量（<dfn noexport>scalar</dfn>）类型有[=bool=], [=i32=], [=u32=], [=f32=], 和 [=f16=]。

数字标量（<dfn noexport>numeric scalar</dfn>）类型有[=i32=], [=u32=],  [=f32=], 和 [=f16=]。

整数标量（<dfn noexport>integer scalar</dfn>）有[=i32=]和[=u32=]。

### 向量类型 ### {#vector-types}

向量（<dfn noexport>vector</dfn>）是一组由2，3，或4个标量（[=scalar=]）或者[=abstract numeric type=]组件构成的序列。

<table class='data'>
  <thead>
    <tr><th>Type<th>Description
  </thead>
  <tr><td>vec*N*<*T*><td>
  *N*个类型*T*元素构成的向量。*N*必须为{2, 3, 4}中的值，*T*必须为一种标量（[=scalar=]）或者[=abstract numeric type=]类型。我们称*T*为向量的组件类型（<dfn noexport>component type</dfn>）。
</table>

如果向量的组件类型是 [=numeric scalar=]，则向量是 <dfn noexport>numeric vector</dfn>。

一个向量是一个<dfn noexport>抽象向量</dfn>，如果它的组件类型是一个[=abstract numeric type=]。

向量的关健用例包括：

* 同时表示方向和大小。
* 表示空间中的位置。
* 在某个颜色空间中表达一种颜色。例如，分量可以是红色、绿色和蓝色的强度，而第四个分量可以是alpha（不透明度）值。

向量上的许多操作都是按组件（<dfn noexport>component-wise</dfn>）进行的，即结果向量是通过对每个组件独立操作而形成的。

<div class='example wgsl type-scope' heading='Vector'>
  <xmp highlight='rust'>
    vec2<f32>  // 两个f32组成的向量。
  </xmp>
</div>

<div class='example wgsl component-wise addition' heading='Component-wise addition'>
  <xmp highlight='rust'>
    let x : vec3<f32> = a + b; // a 和 b 为 vec3<f32>
    // x[0] = a[0] + b[0]
    // x[1] = a[1] + b[1]
    // x[2] = a[2] + b[2]
  </xmp>
</div>

### 矩阵类型 ### {#matrix-types}

矩阵（<dfn noexport>matrix</dfn>）是一组由2，3，或4个浮点型向量组成的序列，

<table class='data'>
  <thead>
    <tr><th>Type<th>Description
  </thead>
  <tr algorithm="matrix type">
    <td>mat|C|x|R|&lt;|T|&gt;
    <td>|C|列|R|行矩阵，|N|和|M|都为{2, 3, 4}中的值。并且 |T|必须是[=f32=], [=f16=], or [=AbstractFloat=]。也就是说，它同样可以被看作|C|列vec|R|&lt;f32&gt;类型的向量。
</table>

矩阵的关键用例是体现线性变换。在这种解释中，矩阵的向量被视为列向量。

乘积操作符(`*`)可用于：

* 按标量大小缩放变换。
* 对一个向量应用变换。
* 与另一个矩阵组合变换。

见[[#arithmetic-expr]]。

<div class='example wgsl type-scope' heading='Matrix'>
  <xmp highlight='rust'>
    mat2x3<f32>  // 此为 2 列 3 行的 32-位浮点数矩阵。
                 // 等价地，此为 2 列类型 vec3<f32> 构成的向量。
  </xmp>
</div>

### 原子类型 ### {#atomic-types}

原子类型（<dfn noexport>atomic type</dfn>）封装了一个整数标量[=integer scalar=]类型，使得：
* 原子对象为并发观察者提供了一定的保证，并且
* 对原子对象唯一有效的操作是原子内置函数（[[#atomic-builtin-functions|atomic builtin functions]]）。

<table class='data'>
  <thead>
    <tr><th>Type<th>Description
  </thead>
  <tr algorithm="atomic type"><td>atomic&lt;|T|&gt;
    <td>类型|T|的原子。|T|必须为[=u32=]或[=i32=]。
</table>

表达式不得计算为原子类型。

原子类型只能由 [=address spaces/workgroup=] 地址空间中的变量或具有 [=access/read_write=] 访问模式的 [=storage buffer=] 变量实例化。
对类型的操作的 [=memory scope=] 由实例化的 [=address space=] 确定。
[=address spaces/workgroup=] 地址空间中的原子类型的内存范围为 `Workgroup`，而 [=address spaces/storage=] 地址空间中的原子类型的内存范围为 `QueueFamily`。

<dfn noexport>atomic modification</dfn>是原子对象上的任何[[#memory-operation|operation]]，它设置对象的内容。
即使新值与对象的现有值相同，该操作也算作修改。

在WGSL中，对于每个对象，原子修改是相互排序的。也就是说，在着色器阶段的执行期间，对于每个原子对象*A*，所有代理都观察应用于*A* 的相同修改操作顺序。不同原子对象的顺序可能没有任何关系；没有任何因果关系。
注意，工作组（[=address spaces/workgroup=]）空间中的变量在一个工作组（[=compute shader stage/workgroup=]）内共享，但在不同工作组之间不共享。

### 数组类型 ### {#array-types}

数组（<dfn noexport>array</dfn>）是一组可索引的元素值。

<table class='data'>
  <thead>
    <tr><th>Type<th>Description
  </thead>
  <tr><td algorithm="fixed-size array type">array&lt;|E|,|N|&gt;
      <td>
          |N|个类型为|E|的元素组成的固定大小数组（<dfn>fixed-size array</dfn>。
          <br>
          |N|被称为数组的元素计数（<dfn noexport>element count</dfn>）。
  <tr><td algorithm="runtime-sized array type">array&lt;|E|&gt;
      <td>
          由类型|E|元素构成的<dfn noexport>runtime-sized</dfn>数组。它们仅出现在特定上下文中。
          <br>
</table>

数组中的第一个元素位于索引 0 处，每个后续元素位于下一个整数索引处。
参见 [[#array-access-expr]]。

表达式不得计算为运行时大小的数组类型。

元素计数表达式 |N| 固定大小的数组必须：
* [=override expression=]，以及
* 计算为一个大于零的整数标量（[=integer scalar=]）。

注意：元素计数在[=pipeline creation=]时已被完全确定。

数组元素类型必须是以下之一:
* [=scalar=] 类型
* [=vector=] 类型，带有 [=concrete=] 组件
* [=matrix=] 类型，带有 [=concrete=] 组件
* [=atomic type|atomic=] 类型
* 一个数组类型具有 [=creation-fixed footprint=]
* 有 [=creation-fixed footprint=] 的 [=structure=] 类型 。

注意：元素类型必须是 [=plain type=]。

当且仅当以下所有条件都为真时，两种数组类型是相同的：
* 它们拥有相同的元素类型。
* 它们的元素计数规范匹配，即以下任一情况为真：
    * 它们都是runtime-sized。
    * 它们都是固定大小的 [=creation-fixedfootprint=]，并且
            等值元素计数，即使一个是有符号的，另一个是无符号的。（在这种情况下，有符号和无符号值是可比较的，因为元素计数必须大于零。）
    * 它们都是固定大小的，元素计数指定为相同的 [=pipeline-overridable=] 常量。

<div class='example wgsl fixed-size array types' heading='Example fixed-size array types, non-overridable element count'>
  <xmp highlight='rust'>
    // array<f32,8> and array<i32,8> are different types:
    // different element types
    var<private> a: array<f32,8>;
    var<private> b: array<i32,8>;
    var<private> c: array<i32,8u>;  // array<i32,8> and array<i32,8u> are the same type

    const width = 8;
    const height = 8;

    // array<i32,8>, array<i32,8u>, and array<i32,width> are the same type.
    // Their element counts evaluate to 8.
    var<private> d: array<i32,width>;

    // array<i32,height> and array<i32,width> are the same type.
    var<private> e: array<i32,width>;
    var<private> f: array<i32,height>;
  </xmp>
</div>

注意：由可覆盖常量确定大小的数组的唯一有效使用是作为 [=address spaces/workgroup=] 空间中变量的存储类型。

<div class='example wgsl global-scope' heading="Workgroup variables sized by overridable constants">
  <xmp highlight='rust'>
    override blockSize = 16;

    var<workgroup> odds: array<i32,blockSize>;
    var<workgroup> evens: array<i32,blockSize>;

     // 一个无效的例子，因为可覆盖的元素计数可能只发生
     // 在外层。
     // var<workgroup> both: array<array<i32,blockSize>,2>;
     // 一个无效的例子，因为可覆盖的元素数量只有
     // 对工作组变量有效。
     // var<private> bad_storage_space: array<i32,blockSize>;
  </xmp>
</div>

<div class='syntax' noexport='true'>
  <dfn for=syntax>array_type_decl</dfn> :

    | [=syntax/array=] [=syntax/less_than=] [=syntax/type_decl=] ( [=syntax/comma=] [=syntax/element_count_expression=] ) ? [=syntax/greater_than=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>element_count_expression</dfn> :

    | [=syntax/int_literal=]

    | [=syntax/uint_literal=]

    | [=syntax/bitwise_expression=]
</div>

### 结构类型 ### {#struct-types}

<dfn noexport>structure</dfn>是一组已命名的成员值。

<table class='data'>
  <thead>
    <tr><th>Type<th>Description
  </thead>
  <tr algorithm="structure type">
      <td>struct&lt;|T|<sub>1</sub>,...,|T|<sub>N</sub>&gt;
      <td>
          类型为|T|<sub>1</sub>到|T|<sub>N</sub>的*N*个成员的有序元组，其中*N*是大于0的整数。结构类型声明为每个成员指定标识符（[=identifier=]）名称。相同结构类型的两个成员不得具有相同的名称。
</table>

一个结构成员类型必须为以下之一：
* 标量（[=scalar=]）类型
* 向量[=vector=]类型
* 矩阵[=matrix=]类型
* 原子（[=atomic type|atomic=]）类型
* 一个 [=fixed-size array=] 类型带有 [=creation-fixedfootprint=]
* 一个 [=runtime-sized=] 数组类型，但前提是它是结构的最后一个成员
* 一个 [=structure=] 类型，具有 [=creation-fixed footprint=]

注意：任何成员类型必须为普通类型（[=plain type=]）。

限制结构成员和数组元素类型的一些后果是：
* 指针、纹理或采样器不得出现在数组或结构内的任何嵌套级别中。
* 当 [=runtime-sized=] 数组是较大类型的一部分时，它只能作为结构的最后一个元素出现，它本身不能是封闭数组或结构的一部分。

<div class='example wgsl global-scope' heading="Structure">
  <xmp highlight='rust'>
    // 拥有四个成员的结构
    struct Data {
      a: i32,
      b: vec2<f32>,
      c: array<i32,10>,
      d: array<f32>, // 最后这个逗号可以不写
    };
  </xmp>
</div>

<div class='syntax' noexport='true'>
  <dfn for=syntax>struct_decl</dfn> :

    | [=syntax/attribute=] * [=syntax/struct=] [=syntax/ident=] [=syntax/struct_body_decl=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>struct_body_decl</dfn> :

| [=syntax/brace_left=] ( [=syntax/struct_member=] [=syntax/comma=] ) * [=syntax/struct_member=] [=syntax/comma=] ? [=syntax/brace_right=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>struct_member</dfn> :

    | [=syntax/attribute_list=] * [=syntax/variable_ident_decl=]
</div>

WGSL定义了以下可应用于结构成员的属性：
 * [=attribute/builtin=]
 * [=attribute/location=]
 * [=attribute/align=]
 * [=attribute/size=]

注意：如果结构类型用于定义统一缓冲区（[=uniform buffer=]）或存储缓冲区（[=storage buffer=]），则可能需要布局属性。见[[#memory-layouts]]。

<div class='example wgsl global-scope' heading='Structure declaration'>
  <xmp highlight='rust'>
    struct my_struct {
      a: f32,
      b: vec4<f32>
    }
  </xmp>
</div>

<div class='example wgsl global-scope' heading='Structure WGSL'>
  <xmp highlight='rust'>
    // TODO: runtime-sized array syntax may have changed
    // Runtime Array
    type RTArr = array<vec4<f32>>;
    struct S {
      a: f32,
      b: f32,
      data: RTArr
    }
    @group(0) @binding(0) var<storage> buffer: S;
  </xmp>
</div>

### 复合类型 ### {#composite-types}

如果一个类型内部结构表达为其他类型的复合，则其为复合的（<dfn noexport>composite</dfn>）。内部部分不重叠，并称为组件（<dfn noexport>components</dfn>）。

复合类型为：

* [=vector=]类型
* [=matrix=]类型
* [=array=]类型
* [=structure=]类型

对于一个复合类型|T|，|T|的<dfn>nesting depth</dfn>，写作*NestDepth*(|T|)为：
* 对向量类型，为1
* 对矩阵类型，为2
* 对类型为|E|的数组类型，1 + *NestDepth*(|E|)
* 成员类型为*M*<sub>1</sub>,...,*M*<sub>1</sub>的结构类型|T|，1 + max(*NestDepth*(*M*<sub>1</sub>),..., *NestDepth*(*M*<sub>N</sub>))


### 可构造类型 ### {#constructible-types}

多种类型的数值可以被创建，加载，存储，传递至函数，以及作为函数返回值。
我们称之为可构造的（[=constructible=]）。

一个类型为可构造的（<dfn>constructible</dfn>）如果其为以下之一：
* [=scalar=]类型
* [=vector=]类型，带有 [=concrete=] 组件
* [=matrix=]类型，带有 [=concrete=] 组件
* 一个 [=fixed-size array=] 类型，如果它有 [=creation-fixedfootprint=] 并且它的元素类型是可构造的。
* [=structure=]类型, 如果它的全部成员都为可构造的。

注意：所有可构造类型为普通类型（[=plain types|plain=]）并有 [=creation-fixed footprint=]。

注意：原子类型和runtime-sized数组类型是不可构造的。包含原子和runtime-sized数组的复合类型是不可构造的。

### 固定占用类型 ### {#fixed-footprint-types}

变量的内存占用<dfn noexport>memory footprint</dfn>是用于存储变量内容的[=memory locations=]的数量。
变量的内存占用取决于它的 [=store type=]，并在 [[#shader-lifecycle|shader 生命周期]] 中的某个时刻最终确定。
大多数变量在 [=Shader 模块创建|着色器创建=] 时间很早就确定了大小。
一些变量可能会在 [=pipeline creation=] 时间稍后调整大小，
而其他变量可能会在 [=shader execution start|start of shader execution=] 时调整大小。

如果 [=plain type=] 的大小在 [=shader module creation|shader creation=] 时完全确定，
则 [=plain type=] 具有创建固定的占用空间<dfn>creation-fixed footprint</dfn>。

如果 [=plain type=] 的大小在 [=pipeline creation=] 时完全确定，则其具有固定占用空间 <dfn>fixed footprint</dfn>。

注意：管道的创建依赖于着色器的创建，因此具有 [=creation-fixedfootprint=] 的类型也具有 [=fixedfootprint=]。

带有 [=creation-fixedfootprint=] 的普通类型是：
* [=scalar=] 类型
* [=vector=] 类型，带有 [=concrete=] 组件
* [=matrix=] 类型，带有 [=concrete=] 组件
* [=atomic type|atomic=] 类型
* [=fixed-size array=] 类型, 当:
      * 它的 [=element count=] 是文字，或者是 [[#module-constants|module-scope]] 的名称
         [=let declaration=]
* [=structure=] 类型，如果它的所有成员都有 [=creation-fixed footprint=]。

注意：[=constructible=] 类型具有 [=creation-fixed footprint=]。

带有 [=fixed footprint=] 的普通类型是以下任何一种：
* 具有 [=creation-fixed footprint=] 的类型
* 一个 [=fixed-size array=] 类型

注意：固定大小数组的唯一有效用途是元素计数是 [=override expression=] 而不是 [=creation-time expression=] 是 [=store type=] for a [=address spaces/workgroup=] 变量。

注意：固定足迹类型可以直接或间接包含 [=atomic type|atomic=] 类型，而 [=constructible=] 类型不能。

注意：固定足迹类型不包括 [=runtime-sized=] 数组，以及任何包含 [=runtime-sized=] 数组的结构或数组，递归。

## 内存 ## {#memory}

WGSL中，可存储类型的值可以存储在内存中，以供以后检索。本节介绍内存的结构，以及如何使用WGSL类型来描述内存的内容。

### 内存位置 ### {#memory-locations-section}

内存由一组不同的内存位置（<dfn noexport>memory locations</dfn>）组成。每个内存位置的大小为8位。影响内存的操作与一组由一个或多个组成的内存位置交互。

如果两组存储器位置的交集非空，则两组存储器位置重叠（<dfn noexport>overlap</dfn>）。每个变量声明都有一组内存位置，不会与任何其他变量声明的内存位置集重叠。对结构和数组的内存操作可以访问元素之间的填充，但不得访问结构或数组末尾的填充。

### 内存访问模式 ### {#memory-access-mode}

内存访问（<dfn noexport>memory access</dfn>）是一种作用于内存位置的操作。

* 读操作（<dfn noexport>read access</dfn>）观察内存位置的内容。
* 写操作（<dfn noexport>write access</dfn>）设置内存位置的内容。

单个操作可以为读，写，或读与写。

特定的内存位置可能只支持某些类型的访问，表示为内存的访问模式（<dfn noexport>access mode</dfn>）：

: <dfn noexport dfn-for="access">read</dfn>
:: 支持读访问，但不是写。
: <dfn noexport dfn-for="access">write</dfn>
:: 支持写访问，但不是读。
: <dfn noexport dfn-for="access">read_write</dfn>
:: 读写访问都支持。

<div class='syntax' noexport='true'>
  <dfn for=syntax>access_mode</dfn> :

    | `'read'`

    | `'write'`

    | `'read_write'`
</div>

### 可存储类型 ### {#storable-types}

变量（[=variable=]）中包含的值必须是可存储（[=storable=]）类型。可存储类型可能具有WGSL定义的显式表示，如[[#internal-value-layout]]中所述，或者它可能是不透明的，例如纹理和采样器。

如果一个类型为以下之一，其为可存储的（<dfn noexport>storable</dfn>）

* 标量（[=scalar=]）类型
* 向量（[=vector=]）类型，带有 [=concrete=] 组件
* 矩阵（[=matrix=]）类型，带有 [=concrete=] 组件
* 原子（[=atomic type|atomic=]）类型
* 数组（[=array=]）类型
* 结构（[=structure=]）类型
* 纹理（[=texture=]）类型
* 采样器（[=sampler=]）类型

注意：也就是说，可存储类型是普通类型（[=plain types=]）、纹理类型和采样器类型。

### IO可共享类型 ### {#io-shareable-types}

管线输入和输出值必须为IO可共享类型。

一个类型是IO可共享的（<dfn noexport>IO-shareable</dfn>）当其为以下之一：

* 标量（[=scalar=]）类型
* 数值向量（[=numeric vector=]）类型
* 结构（[=structure=]）类型，如果其成员全部为标量（[=scalars=]）或数值向量（[=numeric vectors=]）。

以下类型的值必须是IO可共享类型：

* 从内置变量读取或写入的值。
* 接受作为来自上游管线阶段的输入的值。
* 作为管线中下游处理的输出或输出附件写入的值。

注意：只有内置管线输入可能具有布尔类型。用户输入或输出数据属性不得为[=bool=]类型或包含[=bool=]类型。见[[#builtin-inputs-outputs]]。

### 主机可共享类型 ### {#host-shareable-types}

主机可共享类型用于描述在主机和GPU之间共享的缓冲区内容，或者在主机和GPU之间复制而无需格式转换的内容。 用于此目的时，该类型必须额外使用布局属性进行修饰，如[[#memory-layouts]]中所述。 我们将在[[#module-scope-variables]]中看到统一缓冲区（[=uniform buffer=]）和存储缓冲区（[=storage buffer=]）变量的存储类型（[=store type=]）必须是主机可共享的。

类型为主机可共享的（<dfn noexport>host-shareable</dfn>）当其为以下之一：

* 数值标量（[=numeric scalar=]）类型
* 数值向量（[=numeric vector=]）类型
* 矩阵（[=matrix=]）类型
* 原子（[=atomic type|atomic=]）类型
* [=fixed-size array=]类型，如果其元素类型为主机可共享的，并且有[=creation-fixed footprint=]
* [=runtime-sized=]数组类型，如果其元素类型为主机可共享的
* 结构（[=structure=]）类型，如果其所有元素为主机可共享的。

WGSL定义了以下影响内存布局的属性：
 * [=attribute/stride=]
 * [=attribute/align=]
 * [=attribute/size=]

注意：当[=IO-shareable=]类型*T*不是[=bool=]并且不包含[=bool=]时，其为主机可共享的。许多类型为主机可共享的，但不是IO可共享的，包括原子类型（[=atomic types=]），[=runtime-sized=]数组，以及任何包含它们的复合类型。


注意：IO可共享类型和主机可共享类型都具有具体大小，但是各自计数。IO可共享类型的大小由位置计数指标决定，见[[#input-output-locations]]。主机可共享类型的大小由字节计数指标决定，见[[#memory-layouts]]。

### 地址空间 ### {#address-space}

内存位置被划分为存储类（<dfn noexport>address spaces</dfn>）。每个地址空间都具有确定可变性、可见性、它可能包含的值以及如何使用变量的单独属性。

<table class='data' id="address-space-table">
  <caption>Address Space</caption>
  <thead>
    <tr><th>Storage class
        <th>Sharing among invocations
        <th>Supported access modes
        <th>Variable scope
        <th>Restrictions on stored values
        <th>Notes
  </thead>
  <tr><td><dfn noexport dfn-for="address spaces">function</dfn>
      <td>仅相同调用
      <td>[=access/read_write=]
      <td>[=Function scope=]
      <td>[=Constructible=]类型
      <td>
  <tr><td><dfn noexport dfn-for="address spaces">private</dfn>
      <td>仅相同调用
      <td>[=access/read_write=]
      <td>[=Module scope=]
      <td>[=Constructible=]类型
      <td>
  <tr><td><dfn noexport dfn-for="address spaces">workgroup</dfn>
      <td>相同[=compute shader stage|compute shader=] [=compute shader stage/workgroup=]中的调用
      <td>[=access/read_write=]
      <td>[=Module scope=]
      <td>带有[=fixed footprint=]的[=Plain type=]
      <td>最外层数组的 [=element count=] 可能是 [=pipeline-overridable=] 常量。
      <td>
  <tr><td><dfn noexport dfn-for="address spaces">uniform</dfn>
      <td>相同[=shader stage=]中的调用
      <td>[=access/read=]
      <td>[=Module scope=]
      <td>[=Constructible=] [=host-shareable=]类型
      <td>对[=uniform buffer=]变量
  <tr><td><dfn noexport dfn-for="address spaces">storage</dfn>
      <td>相同[=shader stage=]中的调用
      <td> [=access/read_write=], [=access/read=] (default)
      <td>[=Module scope=]
      <td>[=Host-shareable=]
      <td>对[=storage buffer=]变量
  <tr><td><dfn noexport dfn-for="address spaces">handle</dfn>
      <td>相同着色器阶段中的调用
      <td>[=access/read=]
      <td>[=Module scope=]
      <td>[=Sampler=]类型或[=texture=]类型
      <td>对[=sampler=]和纹理变量<br>
</table>

注意：标记 `handle` 被保留：它在WGSL程序中从不被使用。

注意：纹理变量包含一个不透明的句柄，用于访问底层的纹素网格。句柄本身始终是只读的。在大多数情况下，底层纹素是只读的。对于只写存储纹理，底层纹素是只写的。

<div class='syntax' noexport='true'>
  <dfn for=syntax>address_space</dfn> :

    | [=syntax/function=]

    | [=syntax/private=]

    | [=syntax/workgroup=]

    | [=syntax/uniform=]

    | [=syntax/storage=]
</div>

### 内存布局 ### {#memory-layouts}

统一缓冲区（[=Uniform buffer=]）和存储缓冲区（[=storage buffer=]）变量用于共享在内存中组织为字节序列的批量数据。缓冲区在 CPU 和 GPU 之间共享，或在管线中的不同着色器阶段之间，或在不同管线之间共享。

由于缓冲区数据无需重新格式化或转换即可共享，缓冲区生产者和消费者必须就<dfn noexport>memory layout</dfn>达成一致，
这是如何将缓冲区中的字节组织成类型化的WGSL值的描述。

缓冲区变量的存储类型（[=store type=]）必须是主机可共享的（[=host-shareable=]），具有完全详细的内存布局，如下所述。

每个缓冲区变量必须在[=address spaces/uniform=]或[=address spaces/storage=]地址空间中声明。

类型的内存布局仅在评估具有以下内容的表达式时才有意义：
* [=address spaces/uniform=]或[=address spaces/storage=]存储类中的变量，或
* 指向[=address spaces/uniform=]或[=address spaces/storage=]存储类的指针。

一个8位字节是[=host-shareable=]内存的最基本单位。本节中定义的术语表示 8 位字节的计数。

我们将使用以下符号：
* <dfn noexport>AlignOf</dfn>(|T|) 是主机可共享类型 |T| 的 [=alignment=]。
* <dfn noexport>AlignOfMember</dfn>(|S|, |i|) 是主机可共享结构 |S| 的第 |i| 个成员的对齐方式。
* <dfn noexport>SizeOf</dfn>(|T|) 是主机可共享类型 |T| 的 [=byte-size=]。
* <dfn noexport>SizeOfMember</dfn>(|S|, |i|) 是主机可共享结构 |S| 的第 |i| 个成员的大小。
* <dfn noexport>OffsetOfMember</dfn>(|S|, |i|) 是第 |i| 个成员从主机可共享结构 |S| 开始的偏移量。
* <dfn noexport>StrideOf</dfn>(|A|) 是主机可共享数组类型|A|的<dfn>元素跨度</dfn>，定义
     作为从一个数组元素的开头到下一个元素的开头的字节数。
     它等于数组元素类型的大小，向上舍入到元素类型的对齐：
         <p algorithm="array element stride">
           [=StrideOf=](数组<|E|, |N|>) = [=roundUp=]([=AlignOf=](E), [=SizeOf=](E))<br>
           [=StrideOf=](array<|E|>) = [=roundUp=]([=AlignOf=](E), [=SizeOf=](E))
         </p>

#### 对齐和大小 ####  {#alignment-and-size}

每个[=host-shareable=]数据类型|T|都有对齐和大小。

类型的 <dfn>alignment</dfn> 是对该类型的值可以放置在内存中何处的约束，以整数表示：
一个类型的对齐方式必须平均划分该类型值的起始 [=memory location=] 的字节地址。
对齐允许使用更有效的硬件指令来访问这些值，或者满足对某些地址空间的更严格的硬件要求。
（参见 [address space layout constraints](#address-space-layout-constraints)）。

注意：根据构造，每个对齐值始终是2的幂。

类型或结构成员的 <dfn>byte-size</dfn> 是为存储类型或结构成员的值而保留在主机可共享内存中的连续字节数。

主机可共享类型的对齐方式和大小在下表中递归定义：

<table class='data'>
  <caption>
    Alignment and size for host-shareable types<br>
  </caption>
  <thead>
    <tr><th>Host-shareable type |T|
        <th>[=AlignOf=](|T|)
        <th>[=SizeOf=](|T|)
  </thead>
  <tr><td>[=i32=], [=u32=], or [=f32=]
      <td>4
      <td>4
  <tr><td>[=f16=]
      <td>2
      <td>2
  <tr><td>[=atomic type|atomic&lt;|T|&gt;=]
      <td>4
      <td>4
  <tr><td>[=vector|vec=]2&lt;|T|&gt;, |T| is [=i32=], [=u32=], or [=f32=]
      <td>8
      <td>8
  <tr><td>vec2&lt;f16&gt;
      <td>4
      <td>4
  <tr><td>vec3&lt;|T|&gt;, |T| is [=i32=], [=u32=], or [=f32=]
      <td>16
      <td>12
  <tr><td>vec3&lt;f16&gt;
      <td>8
      <td>6
  <tr><td>vec4&lt;|T|&gt;, |T| is [=i32=], [=u32=], or [=f32=]
      <td>16
      <td>16
  <tr><td>vec4&lt;f16&gt;
      <td>8
      <td>8
  <tr><td>[=matrix|mat=]|C|x|R| (col-major)<br>
      <p class="small">(General form)</p>
      <td>[=AlignOf=](vec|R|)
      <td>[=SizeOf=](array&lt;vec|R|, |C|&gt;)
  <tr><td>mat2x2&lt;f32&gt;
      <td>8
      <td>16
  <tr><td>mat2x2&lt;f16&gt;
      <td>4
      <td>8
  <tr><td>mat3x2&lt;f32&gt;
      <td>8
      <td>24
  <tr><td>mat3x2&lt;f16&gt;
      <td>4
      <td>12
  <tr><td>mat4x2&lt;f32&gt;
      <td>8
      <td>32
  <tr><td>mat4x2&lt;f16&gt;
      <td>4
      <td>16
  <tr><td>mat2x3&lt;f32&gt;
      <td>16
      <td>32
  <tr><td>mat2x3&lt;f16&gt;
      <td>8
      <td>16
  <tr><td>mat3x3&lt;f32&gt;
      <td>16
      <td>48
  <tr><td>mat3x3&lt;f16&gt;
      <td>8
      <td>24
  <tr><td>mat4x3&lt;f32&gt;
      <td>16
      <td>64
  <tr><td>mat4x3&lt;f16&gt;
      <td>8
      <td>32
  <tr><td>mat2x4&lt;f32&gt;
      <td>16
      <td>32
  <tr><td>mat2x4&lt;f16&gt;
      <td>8
      <td>16
  <tr><td>mat3x4&lt;f32&gt;
      <td>16
      <td>48
  <tr><td>mat3x4&lt;f16&gt;
      <td>8
      <td>24
  <tr><td>mat4x4&lt;f32&gt;
      <td>16
      <td>64
  <tr><td>mat4x4&lt;f16&gt;
      <td>8
      <td>32
  <tr><td>[=structure|struct=] |S| with members M<sub>1</sub>...M<sub>N</sub>
      <td>max([=AlignOfMember=](S,1), ... , [=AlignOfMember=](S,N))<br>
      <td>[=roundUp=]([=AlignOf=](|S|), justPastLastMember)<br><br>
          where justPastLastMember = [=OffsetOfMember=](|S|,N) + [=SizeOfMember=](|S|,N)
  <tr><td>[=array=]<|E|, |N|><br>
      <td>[=AlignOf=](|E|)
      <td>|N| &times; [=roundUp=]([=AlignOf=](|E|), [=SizeOf=](|E|))
  <tr><td>array<|E|><br>
      <td>[=AlignOf=](|E|)
      <td>N<sub>runtime</sub> &times; [=roundUp=]([=AlignOf=](|E|),[=SizeOf=](|E|))<br><br>
          where N<sub>runtime</sub> is the runtime-determined number of elements of |T|
</table>


#### 结构成员布局 ####  {#structure-member-layout}

结构 |S| 的第 |i| 个成员 具有大小和对齐方式，分别用 [=SizeOfMember=](|S|, |i|) 和 [=AlignOfMember=](|S|, |i|) 表示。
成员大小和对齐方式用于计算每个成员从结构开始的字节偏移量，如 [[#internal-value-layout]] 中所述。

<p algorithm="structure member size">
  [=SizeOfMember=](|S|, |i|) 是 |k| 如果 |S| 的第 |i| 个成员 具有属性 [=attribute/size=](|k|)。
  否则，它是 [=SizeOf=](|T|) 其中 |T| 是成员的类型。
</p>

<p algorithm="structure member alignment">
  [=AlignOfMember=](|S|, |i|) 是 |k| 如果第 |i| 个成员具有属性 [=attribute/align=](|k|)。
  否则，它是 [=AlignOf=](|T|) 其中 |T| 是成员的类型。
</p>

如果结构成员使用 [=attribute/size=] 属性修饰，则该值必须至少与成员类型的大小一样大：

<p algorithm="member size constraint">
   [=SizeOfMember=](|S|, |i|) &ge; [=SizeOf=](T)<br>
   哪里|T| 是 |S| 的第 |i| 个成员的类型。
</p>

第一个结构成员总是从结构的开头有一个零字节偏移：
<p algorithm="offset of first structure member">
  [=OffsetOfMember=](|S|, 1) = 0
</p>

每个后续成员都放置在满足成员类型对齐的最低偏移量处，并且避免与前一个成员重叠。
对于每个成员索引 |i| > 1:
<p algorithm="structure member offset">
  [=OffsetOfMember=](|S|, |i|) = [=roundUp=]([=AlignOfMember=](|S|, |i| ), [=OffsetOfMember=](|S|, |i|-1) + [=SizeOfMember=](|S|, |i|-1))<br>
</p>

<div class='example wgsl' heading='Layout of structures using implicit member sizes and alignments'>
  <xmp highlight='rust'>
    struct A {                                     //             align(8)  size(24)
        u: f32,                                    // offset(0)   align(4)  size(4)
        v: f32,                                    // offset(4)   align(4)  size(4)
        w: vec2<f32>,                              // offset(8)   align(8)  size(8)
        x: f32                                    // offset(16)  align(4)  size(4)
        // -- implicit struct size padding --      // offset(20)            size(4)
    }

    struct B {                           //             align(16) size(160)
        a: vec2<f32>,                              // offset(0)   align(8)  size(8)
        // -- implicit member alignment padding -- // offset(8)             size(8)
        b: vec3<f32>,                              // offset(16)  align(16) size(12)
        c: f32,                                    // offset(28)  align(4)  size(4)
        d: f32,                                    // offset(32)  align(4)  size(4)
        // -- implicit member alignment padding -- // offset(36)            size(4)
        e: A,                                      // offset(40)  align(8)  size(24)
        f: vec3<f32>,                              // offset(64)  align(16) size(12)
        // -- implicit member alignment padding -- // offset(76)            size(4)
        g: array<A, 3>,    //element stride 24     // offset(80)  align(8)  size(72)
        h: i32                                    // offset(152) align(4)  size(4)
        // -- implicit struct size padding --      // offset(156)           size(4)
    }

    @group(0) @binding(0)
    var<storage,read_write> storage_buffer: B;
  </xmp>
</div>

<div class='example wgsl' heading='Layout of structures with explicit member sizes and alignments'>
  <xmp highlight='rust'>
    struct A {                                     //             align(8)  size(32)
        u: f32,                                    // offset(0)   align(4)  size(4)
        v: f32,                                    // offset(4)   align(4)  size(4)
        w: vec2<f32>,                              // offset(8)   align(8)  size(8)
        @size(16) x: f32                       // offset(16)  align(4)  size(16)
    };

    struct B {                           //             align(16) size(208)
        a: vec2<f32>,                              // offset(0)   align(8)  size(8)
        // -- implicit member alignment padding -- // offset(8)             size(8)
        b: vec3<f32>,                              // offset(16)  align(16) size(12)
        c: f32,                                    // offset(28)  align(4)  size(4)
        d: f32,                                    // offset(32)  align(4)  size(4)
        // -- implicit member alignment padding -- // offset(36)            size(12)
        @align(16) e: A,                        // offset(48)  align(16) size(32)
        f: vec3<f32>,                              // offset(80)  align(16) size(12)
        // -- implicit member alignment padding -- // offset(92)            size(4)
        g: array<A, 3>,    //element stride 32       // offset(96)  align(8)  size(96)
        h: i32                                    // offset(192) align(4)  size(4)
        // -- implicit struct size padding --      // offset(196)           size(12)
    }

    @group(0) @binding(0)
    var<uniform> uniform_buffer: B;
  </xmp>
</div>

#### 数组布局示例 ####  {#array-layout-examples}

<div class='example wgsl function-scope' heading='Fixed-size array layout examples'>
  <xmp highlight='rust'>
    // Array where:
    //   - alignment is 4 = AlignOf(f32)
    //   - element stride is 4 = roundUp(AlignOf(f32),SizeOf(f32)) = roundUp(4,4)
    //   - size is 32 = stride * number_of_elements = 4 * 8
    var small_stride: array<f32, 8>;

    // Array where:
    //   - alignment is 16 = AlignOf(vec3<f32>) = 16
    //   - element stride is 16 = roundUp(AlignOf(vec3<f32>), SizeOf(vec3<f32>))
    //                          = roundUp(16,12)
    //   - size is 128 = stride * number_of_elements = 16 * 8
    var bigger_stride: array<vec3<f32>, 8>;
  </xmp>
</div>

<div class='example wgsl global-scope' heading='Runtime-sized array layout examples'>
  <xmp highlight='rust'>
    // Array where:
    //   - alignment is 4 = AlignOf(f32)
    //   - element stride is 4 = roundUp(AlignOf(f32),SizeOf(f32)) = 4
    // 如果 B 是绑定的有效缓冲区绑定大小
    // 绘制或调度命令，元素个数为:
    //   N_runtime = floor(B / element stride) = floor(B / 4)
    @group(0) @binding(0)
    var<storage> weights: array<f32>;

    // Array where:
    //   - alignment is 16 = AlignOf(vec3<f32>) = 16
    //   - element stride is 16 = roundUp(AlignOf(vec3<f32>), SizeOf(vec3<f32>))
    //                          = roundUp(16,12)
    // 如果 B 是绑定的有效缓冲区绑定大小
    // 绘制或调度命令，元素个数为:
    //   N_runtime = floor(B / element stride) = floor(B / 16)
    var<uniform> directions: array<vec3<f32>>;
  </xmp>
</div>

#### 值的内部布局 ####  {#internal-value-layout}

本节描述了如何将值的内部结构放置在缓冲区的字节位置中，给定一个假设的整个值的位置。
这些布局取决于值的类型，以及结构成员的 [=attribute/align=] 和 [=attribute/size=] 属性。

放置值的缓冲区字节偏移量必须满足类型对齐要求：
如果 |T| 类型的值 被放置在缓冲区偏移 |k|，然后 |k| = |c| &times; [=AlignOf=](|T|)，对于一些非负整数|c|。

无论地址空间如何，数据都会以相同的方式出现。

当[=u32=]或[=i32=]类型的值|V|放置在主机共享缓冲区的字节偏移量|k|处时，则：
   * 字节|k|包含|V|的0-7位
   * 字节|k|+1包含|V|的8-15位
   * 字节|k|+2包含|V|的16-23位
   * 字节|k|+3包含|V|的24-31位

注意：回想一下，[=i32=]使用二进制补码表示，因此符号位位于第31位。

[=f32=]类型的值|V|以[[!IEEE-754|IEEE-754]] binary32格式表示。它有1个符号位、8个指数位和23个分数位。当|V|被放置在主机共享缓冲区的字节偏移 k处时，则：
   * 字节|k|包含分数位的0-7位。
   * 字节|k|+1包含分数位的8-15位。
   * 字节|k|+2的0-6位包含分数位的16-22位。
   * 字节|k|+2的第7位包含指数位的第0位。
   * 字节|k|+3的第0-6位包含指数位的1-7位。
   * 字节|k|+3的第7位包含符号位。

一个值 |V| [=f16=] 类型的以 [[!IEEE-754|IEEE-754]] binary16 格式表示。
它有 1 个符号位、5 个指数位和 10 个小数位。
当 |V| 被放置在字节偏移 |k| 主机共享缓冲区，然后：
    * 字节 |k| 包含分数的 0 到 7 位。
    * 字节 |k|+1 的位 0 到 1 包含小数的位 8 到 9。
    * 字节 |k|+1 的位 2 到 6 包含指数的位 0 到 4。
    * 字节|k|+1 的第7 位包含符号位。

注意：上述规则隐含表明主机共享缓冲区中的数值以little-endian格式存储。

当原子类型（[=atomic type=]） `atomic`&lt;|T|&gt; 的值|V|放置在主机共享缓冲区中时，它具有与基础类型|T|的值相同的内部布局。

当向量类型 [=vector|vector type=] vec|N|&lt;|T|&gt;  的值 |V| 放置在主机共享缓冲区的字节偏移量 |k| 处时，则：

   * |V|.x 被放置在字节偏移量 |k| 处
   * |V|.y 被放置在字节偏移量 |k| + [=SizeOf=](|T|) 处
   * 如果 |N| &ge; 3，则|V|.z被放置在字节偏移量 |k| + 2 &times; [=SizeOf=](|T|) 处
   * 如果 |N| &ge; 4，则|V|.w被放置在字节偏移量 |k| + 3 &times; [=SizeOf=](|T|) 处

当一个值 |V| [=vector|vector type=] mat|C|x|R|&lt;|T|&gt; 被放置在字节偏移 |k| 主机共享缓冲区，然后：
   * 列向量 |i| 的 |V| 被放置在字节偏移 |k| + |i| &times; [=AlignOf=](vec|R|<|T|>)

当数组类型 [=array|array type=] |A| 的值放置在主机共享内存缓冲区的字节偏移量 |k| 处时，则：
   * 数组的元素 |i| 被放置在字节偏移量 k| + |i| &times; [=StrideOf=](|A|) 处

当结构类型 [=structure|structure type=] |S| 的值被放置在主机共享内存缓冲区的字节偏移量 |k| 处时，则：
    * 结构值的|i|'<sup>th</sup> 成员被放置在字节偏移|k| 处 + [=OffsetOfMember=](|S|,|i|)。
        请参阅 [[#structure-member-layout]]。

#### 地址空间布局约束 ####  {#address-space-layout-constraints}

地址空间（[=address spaces/storage=]）和（[=address spaces/uniform=]）具有不同的缓冲区布局约束，本节将对此进行介绍。

变量直接或间接引用的所有结构和数组类型都必须遵守变量地址空间的约束。
违反地址空间约束会导致 [=shader-creation error=]。

在本节中，我们将 <dfn noexport>RequiredAlignOf</dfn>(|S|, |C|) 定义为主机可共享类型 |S| 的值的字节偏移 [=alignment=] 要求 在地址空间 |C| 中使用时。
<table class='data'>
  <caption>
    对[=address spaces/storage=]和[=address spaces/uniform=]存储类的主机可共享类型的对齐要求。
  </caption>
  <thead>
    <tr><th>Host-shareable type |S|
        <th>[=RequiredAlignOf=](|S|, [=address spaces/storage=])
        <th>[=RequiredAlignOf=](|S|, [=address spaces/uniform=])
  </thead>
  <tr><td>[=i32=], [=u32=], [=f32=], or [=f16=]
      <td>[=AlignOf=](|S|)
      <td>[=AlignOf=](|S|)
  <tr><td>[=atomic types|atomic=]&lt;T&gt;
      <td>[=AlignOf=](|S|)
      <td>[=AlignOf=](|S|)
  <tr><td>[=vector|vec=]N&lt;T&gt;
      <td>[=AlignOf=](|S|)
      <td>[=AlignOf=](|S|)
  <tr algorithm="alignment of a matrix with C columns and R rows">
      <td>[=matrix|mat=]CxR&lt;T&gt;
      <td>[=AlignOf=](|S|)
      <td>[=AlignOf=](|S|)
  <tr algorithm="alignment of an array">
      <td>[=array=]&lt;T, N&gt;
      <td>[=AlignOf=](|S|)
      <td>[=roundUp=](16, [=AlignOf=](|S|))
  <tr algorithm="alignment of an runtime-sized array">
      <td>array&lt;T&gt;
      <td>[=AlignOf=](|S|)
      <td>[=roundUp=](16, [=AlignOf=](|S|))
  <tr algorithm="alignment of a structure">
      <td>[=structure|struct=] |S|
      <td>[=AlignOf=](|S|)
      <td>[=roundUp=](16, [=AlignOf=](|S|))<br>
</table>

|T| 类型的结构成员 必须有一个字节偏移量从结构的开头开始，该结构是地址空间 |C| 的 [=RequiredAlignOf=](|T|, |C|) 的倍数：

<p algorithm="structure member minimum alignment">
    [=OffsetOfMember=](|S|, |M|) = |k| &times; [=RequiredAlignOf=](|T|, C)<br>
    其中 |k| 为一个正整数，且 |M| 为具有类型 |T| 的结构 |S| 的成员。
</p>

元素类型 |T| 的数组的元素步幅（[=element stride=]）必须是对地址空间|C| 的 [=RequiredAlignOf=](|T|, |C|) 的倍数：

<p algorithm="array element minimum alignment">
    [=StrideOf=](array<|T|, |N|>) = |k| &times; [=RequiredAlignOf=](|T|, C)<br>
    [=StrideOf=](array<|T|>) = |k| &times; [=RequiredAlignOf=](|T|, C)<br>
    其中|k| 是一个正整数
</p>

注意：[=RequiredAlignOf=](|T|, |C|) 不会对对齐（[=attribute/align=]）修饰允许的值施加任何额外限制，也不会影响 [=AlignOf=](|T|) 的规则。数据按照前面部分中定义的规则进行布局，然后根据 [=RequiredAlignOf=](|T|, |C|) 规则验证生成的布局。

统一（[=address spaces/uniform=]）存储类还要求：
* 数组元素对齐到 16 字节边界。也就是说，对于某个正整数 k'，[=StrideOf=](array&lt;|T|,|N|&gt;) = 16 &times; |k|'。
* 如果结构成员本身具有结构类型 `S`，则该成员的开头和任何后续成员的开头之间的字节数必须至少为 [=roundUp=](16, [=SizeOf=](S))。

注意：以下示例展示了如何在结构成员上使用 [=attribute/align=] 和 [=attribute/size=] 属性来满足统一缓冲区的布局要求。
特别是，可以使用这些技术将具有 std140 布局的 GLSL 缓冲区机械地转换为 WGSL。

<div class='example wgsl global-scope' heading='Satisfying offset requirements for uniform address space'>
  <xmp highlight='rust'>
    struct S {
      x: f32,
    }
    struct Invalid {
      a: S,
      b: f32 // 无效：a 和 b 之间的偏移量为 4 字节，但必须至少为 16
    }
    struct Valid {
      a: S,
      [[align(16)]] b: f32 // 有效：a 和 b 之间的偏移量为 16 字节
    }
    @group(0) @binding(0) var<uniform> invalid: Invalid;
    @group(0) @binding(1) var<uniform> valid: Valid;
  </xmp>
</div>

<div class='example wgsl global-scope' heading='Satisfying stride requirements for uniform address space'>
  <xmp highlight='rust'>
    struct small_stride {
      a: array<f32,8> // stride 4
    }
    @group(0) @binding(0) var<uniform> invalid: small_stride; // Invalid

    struct wrapped_f32 {
      @size(16) elem: f32
    }
    struct big_stride {
      a: array<wrapped_f32,8> // stride 16
    }
    @group(0) @binding(1) var<uniform> valid: big_stride;     // Valid
  </xmp>
</div>

## 内存视图类型 ## {#memory-view-types}

除了使用普通（[=plain types|plain=]）值进行计算之外，WGSL程序还经常通过内存访问（[=memory access=]）操作从内存中读取值或将值写入内存。 每个内存访问都是通过内存视图（[=memory view=]）执行的。

内存视图（<dfn noexport>memory view</dfn>）由以下内容组成：
* 特定存储类（[=address space=]）中的一组内存位置（[=memory locations=]），
* 将这些位置的内容解释为 WGSL 类型（[=type=]），以及
* 一个访问模式（[=access mode=]）。

内存视图的访问方式必须被存储类支持。见[[#address-space]]。

WGSL 有两种表示内存视图的类型：引用类型（[=reference types=]）和指针类型（[=pointer types=]）。

<table class='data'>
  <thead>
    <tr><th>Constraint<th>Type<th>Description
  </thead>
  <tr algorithm="memory reference type">
    <td style="width:25%">|S| 是一个存储类（[=address space=]）,<br>|T|是一个可存储（[=storable=]）类型,<br>|A| 是访问模式（[=access mode=]）
    <td>ref&lt;|S|,|T|,|A|&gt;
    <td>
        引用类型（<dfn noexport>reference type</dfn>）由一组对 |SC| 中的内存位置持有类型 |T| 的值的内存视图（[=memory views=]）标识，支持模式 |A| 中描述的内存访问。<br>在这种情况下，|T| 被称为存储类型（<dfn noexport>store type</dfn>）。<br>参考类型没有写在 WGSL 源程序中；相反它们用于分析 WGSL 程序。
  <tr algorithm="pointer type">
    <td>|S|是一个存储类（[=address space=]）,<br>|T|是一个可存储（[=storable=]）类型,<br>|A| 是一个访问模式（[=access mode=]）
    <td>ptr&lt;|S|,|T|,|A|&gt;
    <td>
        指针类型（<dfn noexport>pointer type</dfn>）由一组对 |S| 中内存位置持有类型 |T| 的值的内存视图（[=memory views=]）标识，支持模式 |A| 中描述的内存访问。<br>在这种情况下，|T| 被称为指针类型（<dfn noexport>pointee type</dfn>）。<br>指针类型可能出现在 WGSL 程序源中。
</table>

在*分析* WGSL 程序时，引用和指针类型完全由地址空间、可存储类型和访问模式参数化。在本规范的代码示例中，注释显示了这种完全参数化的形式。

但是，在 WGSL *源*文本中：
* 引用类型必须不能出现。
* 指针类型可能出现。一个参数化的指针类型通过以下内容拼写：
    * 地址空间[=address space=]，
    * 存储类型[=store type=]，以及
    * 有时通过访问模式[=access mode=]，如[[#access-mode-defaults]]中所述。

<div class='example wgsl' heading='Pointer type'>
  <xmp highlight='rust'>
    fn my_function(
      // 'ptr<function,i32,read_write>' 是指针值的类型，它使用'function' 地址空间中的内存位置来引用内存以保持'i32' 值。
      // 这里 'i32' 是指针类型。
      // 隐含的访问模式为 'read_write' ，访问模式的默认值见下文。
      ptr_int: ptr<function,i32>,

      // 'ptr<private,array<f32,50>,read_write>' 是指针值的类型，
      // 它指的是使用 'private' 存储类中的内存位置保存 50 个类型为 'f32' 元素的数组的存储。
      // 这里的指针类型是'array<f32,50>'。 隐含的访问模式是“read_write”。见下面的访问模式默认值。
      ptr_array: ptr<private, array<f32, 50>>
    ) { }
  </xmp>
</div>

引用类型和指针类型都是内存视图的集合：特定的内存视图与唯一的引用值和唯一的指针值相关联：

<blockquote algorithm="pointer reference correspondence">
每个类型ptr&lt;|S|,|T|,|A|&gt;的指针值 |p| 对应于一个类型ref&lt;|S|,|T|,|A|&gt;的单独参考值|r|，反之亦然，其中 |p| 和 |r| 描述相同的内存视图。
</blockquote>

### 访问模式默认值 ### {#access-mode-defaults}

内存视图的访问模式通常由上下文决定：

* [=address spaces/storage=] 存储类支持 [=access/read=] 和 [=access/read_write=] 两种访问模式。
* 每个其他地址空间仅支持一种访问模式，如<a href="#address-space-table">地址空间</a>表中所述。

当在 WGSL 源码中写入变量声明（[=variable declaration=]）或指针类型（[=pointer type=]）时：
* 对 [=address spaces/storage=] 地址空间，访问模式是可选的，默认为 [=access/read=]。
* 对其他地址空间，访问模式必须不填写。

### 原始变量 ### {#originating-variable-section}

在 WGSL 中，参考值始终对应于某些变量的部分或全部内存位置的内存视图。这定义了参考值的原始变量（<dfn noexport>originating variable</dfn>）。

一个指针值总是对应一个引用值，因此指针的原始变量与相应引用的原始变量相同。

注意：原始变量是一个动态概念。函数形式参数的原始变量取决于函数的调用位置（[=call site|call sites=]）。 不同的调用位置可以提供指向不同起始变量的指针。

如果一个引用或指针访问出界，则产生一个无效内存引用（<dfn noexport>invalid
memory reference</dfn>）。

从无效引用中加载（[=Load Rule|Loads=]）返回以下内容之一：
    * 来自绑定到原始变量（[=originating variable=]）的 WebGPU 缓冲区（[[WebGPU#buffers|WebGPU buffer]]）的任何内存位置（[=memory locations|memory location(s)=]）的值
    * 引用的存储类型的零值（[=zero value=]）。
    * 如果加载的值是向量，则值 (0, 0, 0, x)，其中 x 是：
        * 0、1 或最大正值对整数分量
        * 0.0 或 1.0 对浮点分量
对无效引用的存储（[=statement/assignment|Stores=]）可能：
    * 将值存储到绑定到原始变量的 WebGPU 缓冲区（[[WebGPU#buffers|WebGPU buffer]]）的任何内存位置（[=memory locations|memory location(s)=]）
    * 没有被执行

对无效内存引用进行操作的读-修改-写原子（[[#atomic-rmw|Read-modify-write atomics]]）必须从相同的内存位置（[=memory locations|memory
locations=]）加载和存储，如果它们访问内存。

### 引用和指针用例 ### {#ref-ptr-use-cases}

引用和指针通过使用方法来区分：

* 一个变量（[=variable=]）的类型为一个引用类型。
* 寻址（[=address-of=]）操作（unary `&`）将一个引用值转换为其对应的指针值。
* 间接寻址（[=indirection=]）操作（unary *）将指针值转换为其对应的引用值。
* let声明（[=let declaration=]）可以为指针类型，但是不能为引用类型。
* 形式参数（[=formal parameter=]）可以是指针类型，但是不能为引用类型。
* 赋值语句（[=simple assignment=]）执行写访问（[=write access=]）以通过引用更新内存内容，其中：
    * 赋值语句的左侧[=left-hand side=]必须是引用类型，访问模式为 [=access/write=] 或 [=access/read_write=]。
    * 赋值语句的右侧[=right-hand side=]必须计算为左侧的存储类型。
* 加载规则（<dfn noexport>Load Rule</dfn>）：在函数内部，引用会自动解除引用（读取）以满足类型规则：
    * 在函数中，当在语句或表达式中使用存储类型为 |T| 的引用表达式 |r| 时，其中
    * |r| 具有访问模式 [=access/read=] 或 [=access/read_write=]，且
    * 唯一可能匹配的类型规则要求 |r| 具有类型 |T| 的值，然后
    * 此类型规则的要求视作被满足，且
    * 在该上下文中，表达式 |r| 的计算结果为存储在计算时被 |r| 引用的内存位置的值（类型为|T|）。也就是说，执行读取访问（[=read access=]）以产生结果值。

以这种方式定义引用可以简单地惯用变量：

<div class='example wgsl' heading='Reference types enable simple use of variables'>
  <xmp highlight='rust'>
    @compute
    fn main() {
      // 'i' 具有引用类型 ref<function,i32,read_write>。
      // 'i' 的内存位置存储 i32 值 0。
      var i: i32 = 0;

      // 'i + 1'只能匹配'i'子表达式为 i32 类型的类型规则。
      // 因此，表达式'i + 1'的类型为 i32，并且在计算时，'i'子表达式的计算结果为计算时存储在'i'的内存位置中的 i32 值。
      let one: i32 = i + 1;

      // 更新 'i' 引用的位置中的值，使它们保持值 2。
      i = one + 1;

      // 更新 'i' 引用的位置中的值，使它们保持值 5。
      // 右侧的计算发生在分配生效之前。
      i = i + 3;
    }
  </xmp>
</div>

<div class='example wgsl' heading='Returning a reference returns the value loaded via the reference'>
  <xmp highlight='rust'>
    var<private> age: i32;
    fn get_age() -> i32 {
      // return 语句中的表达式类型必须是“i32”，因为它必须与函数声明的返回类型匹配。
      // 'age' 表达式的类型为 ref<private,i32,read_write>。
      // 应用加载规则，因为引用的存储类型与所需的表达式类型匹配，并且不应用其他类型规则。
      // 在此上下文中对'age'的计算是在执行 return 语句时从'age'引用的内存位置加载的 i32 值。
      return age;
    }

    fn caller() {
      age = 21;
      // copy_age 常量将获得 i32 值 21。
      let copy_age: i32 = get_age();
    }
  </xmp>
</div>

以这种方式定义指针可以实现两个关键用例：

* 使用带指针类型的 let 声明，为变量的部分内容形成一个短名称。
* 使用函数的形式参数来引用调用函数（[=calling function=]）可访问变量的内存。
    * 对此类函数的调用必须为该操作数提供一个指针值。这通常需要使用寻址（[=address-of=]）操作（unary `&`）来获取指向变量内容的指针。

注意：以下示例使用了本规范稍后解释的 WGSL 功能。

<div class='example wgsl' heading='Using a pointer as a short name for part of a variable'>
  <xmp highlight='rust'>
    struct Particle {
      position: vec3<f32>,
      velocity: vec3<f32>
    }
    struct System {
      active_index: i32,
      timestep: f32,
      particles: array<Particle,100>
    }
    @group(0) @binding(0) var<storage,read_write> system: System;

    @compute
    fn main() {
      // 在存储内存中形成一个指向特定粒子的指针。
      let active_particle: ptr<storage,Particle> =
          &system.particles[system.active_index];

      let delta_position: vec3<f32> = (*active_particle).velocity * system.timestep;
      let current_position: vec3<f32>  = (*active_particle).position;
      (*active_particle).position = delta_position + current_position;
    }
  </xmp>
</div>

<div class='example wgsl' heading='Using a pointer as a formal parameter'>
  <xmp highlight='rust'>
    fn add_one(x: ptr<function,i32>) {
      // 更新 'x' 的位置以包含下一个更高的整数值，（或环绕到最大的负 i32 值）。
      // 在左侧，一元“*”将指针转换为随后可以分配给的引用。
      // 默认情况下，它具有 read_write 访问模式。
      // 在右侧：
      // - 一元'*'将指针转换为引用，具有 read_write 访问模式。
      // - 唯一匹配的类型规则是加法 (+) 并且要求 '*x' 具有类型 i32，这是 '*x' 的存储类型。
      //   所以负载规则应用并且 '*x' 计算为在计算时为 '*x' 存储在内存中的值，即 0 的 i32 值。
      // - 将 1 添加到 0，以生成右侧的最终值 1 - 手边。 将 1 存储到 '*x' 的内存中。
      *x = *x + 1;
    }

    @compute
    fn main() {
      var i: i32 = 0;

      // 修改'i' 的内容，使其包含1。使用一元'&' 获取'i' 的指针值。
      // 这是一个明确的信号，表明被调用的函数可以访问 'i' 的内存，并且可以修改它。
      add_one(&i);
      let one: i32 = i;  // 'one' has value 1.
    }
  </xmp>
</div>

### 形成引用和指针值 ### {#forming-references-and-pointers}

引用值通过以下方式之一形成：

* 解析为范围内（[=in scope|in-scope=]）变量 *v* 的标识符（[=identifier=]）表示 *v* 内存的引用值。
    * 解析成的变量是对引用的原始变量（[=originating variable=]）。
* 对一个指针使用间接寻址（[=indirection=] (unary `*`)）操作。
    * 结果的原始变量被定义为指针的原始变量。
* 使用一个复合参考元件表达式（<dfn noexport>composite reference component expression</dfn>）。
    在每种情况下，结果的原始变量都被定义为原始引用的原始变量。
    * 给定具有向量[=vector=]存储类型的引用，附加单字母向量访问短语会产生对向量的命名组件的引用。见[[#component-reference-from-vector-reference]]。
    * 给定具有向量[=vector=]存储类型的引用，附加数组索引访问短语会产生对向量的索引组件的引用。见[[#component-reference-from-vector-reference]]。
    * 给定具有矩阵[=matrix=]存储类型的引用，附加数组索引访问短语会产生对矩阵的索引列向量的引用。见[[#matrix-access-expr]]。
    * 给定具有数组[=array=]存储类型的引用，附加数组索引访问短语会产生对数组索引元素的引用。见[[#array-access-expr]]。
    * 给定具有结构[=structure=] 存储类型的引用，附加成员访问短语会产生对结构的命名成员的引用。见[[#struct-access-expr]]。

在所有情况下，结果的访问模式[=access mode=]与原始引用的访问模式相同。
<div class='example wgsl' heading='Component reference from a composite reference'>
  <xmp highlight='rust'>
    struct S {
        age: i32,
        weight: f32
    }
    var<private> person: S;
    // 'person' 的使用表示对变量底层内存的引用，并且类型为 ref<private,S,read_write>。

    fn f() {
        var uv: vec2<f32>;
        // 'uv' 的使用表示对变量底层内存的引用，并且类型为 ref<function,vec2<f32>,read_write>。
        // 计算赋值的左侧： 计算 'uv.x' 以产生引用：
        // 1. 首先计算 'uv'，产生对 'uv' 变量内存的引用。结果的类型为 ref<function,vec2<f32>,read_write>。
        // 2. 然后应用'.x'向量访问短语，产生对由上一步中的引用值指向的向量的第一个分量的内存的引用。
        //    结果的类型为 ref<function,f32,read_write>。
        //    计算赋值的右侧会产生 f32 值 1.0。 将 f32 值 1.0 存储到 uv.x 引用的存储内存位置。
        uv.x = 1.0;

        // 计算赋值的左侧： 计算 'uv[1]' 以产生引用：
        // 1. 首先计算 'uv'，产生对 'uv' 变量内存的引用。 结果的类型为 ref<function,vec2<f32>,read_write>。
        // 2. 然后应用'[1]'数组索引短语，产生对上一步引用的向量的第二个组件的存储的引用。
        //    结果的类型为 ref<function,f32,read_write>。
        //    计算赋值的右侧会产生 f32 值 2.0。
        //    将 f32 值 2.0 存储到 uv[1] 引用的存储内存位置。
        uv[1] = 2.0;

        var m: mat3x2<f32>;
        // 计算'm[2]'时：
        // 1. 首先计算'm'，产生对“m”变量内存的引用。结果的类型为 ref<function,mat3x2<f32>,read_write>。
        // 2. 然后应用 '[2]' 数组索引短语，产生对存储由上一步中的参考值指向的第三列向量。
        //    因此，'m[2]' 表达式的类型为 ref<function,vec2<f32>,read_write>。
        //    'let' 声明是针对 vec2<f32> 类型的，因此声明语句要求初始化程序的类型为 vec2<f32>。
        //    加载规则适用（因为没有其他类型规则可以适用），以及初始化器的计算产生 vec2<f32> 值，
        //    该值是在执行声明时从 'm[2]' 引用的内存位置加载的。
        let p_m_col2: vec2<f32> = m[2];

        var A: array<i32,5>;
        // 计算'A[4]'时
        // 1. 首先计算“A”，产生对“A”变量内存的引用。
        //    结果的类型为 ref<function,array<i32,5>,read_write>。
        // 2. 然后应用'[4]'数组索引短语，产生对由上一步中的引用值引用的数组的第五个元素的存储的引用。
        //    结果值的类型为 ref<function,i32,read_write>。 他让声明要求右手边是 i32 类型。
        //    加载规则适用（因为没有其他类型规则可以应用），并且初始化器的计算产生从执行声明时由 'A[4]' 引用的内存位置加载的 i32 值。
        let A_4_value: i32 = A[4];

        // 计算'person.weight'时：
        // 1. 首先计算'person'，产生对在模块范围内声明的“person”变量的内存的引用。
        //    结果的类型为 ref<private,S,read_write>。
        // 2. 然后应用'.weight'成员访问短语，产生对存储器的第二个成员的内存的引用，该存储器由上一步中的引用值引用。
        //    结果的类型为 ref<private,f32,read_write>。
        //    let 声明要求右侧的类型为 f32。
        //    加载规则适用（因为没有其他类型规则可以应用），并且初始化器的计算产生从执行声明时'person.weight'引用的内存位置加载的 f32 值。

        let person_weight: f32 = person.weight;
    }
  </xmp>
</div>

指针值以下列方式之一形成：

* 对引用使用寻址（[=address-of=] (unary `&`)）操作。
    * 结果的原始变量被定义为引用的原始变量。
* 如果函数形式参数（[=formal parameter=]）具有指针类型，则在运行时调用该函数时，形参的使用表示在调用函数（[=calling function=]）的调用位置（[=call site=]）处提供给相应操作数的指针值。
    * 形式参数（在运行时）的原始变量被定义为在调用位置处指针操作数的原始变量。

在所有情况下，结果的访问模式与原始指针的访问模式相同。

<div class='example wgsl' heading='Pointer from a variable'>
  <xmp highlight='rust'>
    // 在私有地址空间中声明一个变量，用于存储 f32 值。
    var<private> x: f32;

    fn f() {
        // 在函数地址空间中声明一个变量，用于存储 i32 值。
        var y: i32;

        // 名称'x'解析为模块范围变量'x'，并且具有引用类型 ref<private,f32,read_write>。
        // 应用一元“&”运算符将引用转换为指针。
        // 访问方式与原变量的访问方式相同，所以完全指定的类型为ptr<private,f32,read_write>。
        // 但是read_write是函数地址空间的默认访问方式，所以这种情况下不需要拼写read_write
        let x_ptr: ptr<private,f32> = &x;

        // 名称'y'解析为函数范围变量'y'，并且具有引用类型 ref<private,i32,read_write>。
        // 应用一元“&”运算符将引用转换为指针。 访问模式默认为“read_write”。
        let y_ptr: ptr<function,i32> = &y;

        // 一个新变量，不同于在模块范围内声明的变量。
        var x: u32;

        // 此处，名称'x'解析为前一条语句中声明的函数作用域变量'x'，其类型为 ref<function,u32,read_write>。
        // 应用一元'&'运算符将引用转换为指针。 访问模式默认为'read_write'。
        let inner_x_ptr: ptr<function,u32> = &x;
    }
  </xmp>
</div>

### 与其他语言中引用和指针的比较 ### {#pointers-other-languages}

本节是信息性的，是不规范的。

WGSL中的引用和指针相较于其他语言受更多的限制。具体为：

* 在 WGSL 中，不能将引用直接声明为另一个引用或变量的别名，无论是变量还是形式参数。
* 在 WGSL中，指针和引用不可存储（[=storable=]）。也就是说，WGSL 变量的内容可能不包含指针或引用。
* 在 WGSL中，函数必须不返回指针或引用。
* 在 WGSL 中，无法在整数值和指针值之间进行转换。
* 在 WGSL中，无法将指针值的类型强制更改为另一种指针类型。
    * 复合组件引用表达式是不同的：它获取对复合值的引用，并产生对复合值内的组件或元素之一的引用。这些在 WGSL 中被认为是不同的引用，即使它们在实现抽象级别的较低级别可能具有相同的机器地址。
* 在 WGSL中，无法将引用值的类型强制更改为另一种引用类型
* 在 WGSL中，无法更改指针或引用的访问模式。
    * 相比之下，C++ 会自动将非常量指针转换为 const 指针，并有一个 const_cast 将一个 const 值转换为一个非常量值。
* 在 WGSL中，无法从“堆”分配新的存储空间。
* 在 WGSL 中，无法显式销毁变量。 只有当变量超出范围时，WGSL 变量的内存才会变得不可访问。

注意：根据上述规则，不可能形成“悬空”指针，即不引用有效的（或“活动的”）原始变量的内存的指针。

## 纹理和采样器类型 ## {#texture-types}

纹素（<dfn noexport>texel</dfn>）是用作纹理的最小可独立访问元素的标量或向量。*texel*这个词是*纹理元素*的缩写。

纹理（<dfn noexport>texture</dfn>）是支持对渲染有用的特殊操作的纹素集合。 在 WGSL 中，这些操作是通过纹理内置函数调用的。 有关完整列表，见[[#texture-builtin-functions]]。

WGSL 纹理对应于 [[WebGPU#gputexture|WebGPU GPUTexture]]。

纹理可以是数组形式的，也可以是非数组的：

* 非数组纹理（<dfn noexport>non-arrayed texture</dfn>）是一个纹素网格，每个纹素有单独的网格坐标。
* 数组纹理（<dfn noexport>arrayed texture</dfn>）是纹素网格的齐次数组。在数组纹理中，每个纹素通过其唯一的数组索引和网格坐标组合来标识。

纹理具有以下特性：
: 纹素格式
:: 每个纹素中的数据，见[[#texel-formats]]。
: 维度
:: 网格坐标中的维数，以及坐标的解释方式。维度数为 1、2 或 3。大多数纹理使用笛卡尔坐标。立方体纹理有六个方形面，并使用三维坐标进行采样，该坐标解释为从原点到以原点为中心的立方体的方向向量。
: 大小
:: 沿每个维度的网格坐标的范围
: mip 级别计数
:: 采样纹理的 mip 级别计数至少为 1，存储纹理的 mip 级别计数至少为 1。<dfn>Mip level</dfn> 0 包含纹理的全尺寸版本。每个连续的 mip 级别都包含前一个 mip 级别的过滤版本，大小为前一个 mip 级别的一半（在舍入范围内）。在对纹理进行采样时，使用显式或隐式计算的细节级别来选择从中读取纹素数据的 mip 级别。 然后通过过滤将它们组合起来以产生采样值。
: 数组化
:: 纹理是否为数组化
: 数组大小（<dfn noexport>array size</dfn>）
:: 齐次网格的数量，如果纹理为数组化的

纹理的表示通常针对渲染操作进行优化。为了实现这一点，许多细节对程序员是隐藏的，包括无法直接用着色器语言表达的数据布局、数据类型和内部操作。

因此，着色器无法直接访问纹理变量中的纹素内存。相反，访问是通过一个不透明的句柄来调解的：

* 在着色器内：
    * 声明一个模块范围变量，其中存储类型（[=store type=]）是后面部分中描述的纹理类型之一。 该变量存储底层纹理内存的不透明句柄，并自动放置在句柄（[=address spaces/handle=]）地址空间中。
    * 在函数内部，调用其中一个纹理内置函数，并提供纹理变量作为第一个参数。
* 在构建 WebGPU 管道时，纹理变量的存储类型和绑定必须与相应的绑定组布局条目兼容。

这样，纹理类型支持的操作集由接受该纹理类型作为第一个参数的纹理内置函数的可用性决定。

注意：着色器无法更改纹理变量存储的句柄。也就是说，该变量是只读的，即使它提供访问的底层纹理可能是可变的（例如，只写存储纹理）。

采样器是一个不透明的句柄，它控制如何从采样纹理访问 [=texel|texels=]。

WGSL 采样器映射到 [[WebGPU#gpusampler|WebGPU GPUSampler]]。

Texel 访问是通过采样器的几个属性控制的：

: 寻址方式
:: 控制如何解决纹理边界和越界坐标。
     每个纹理维度的寻址模式可以独立设置。
     参见 [[WebGPU#enumdef-gpuaddressmode|WebGPU GPUAddressMode]]。
: 过滤模式
:: 控制访问哪些纹素以产生最终结果。
     过滤可以使用最近的纹素或在多个纹素之间进行插值。
     多种过滤模式可独立设置。
     参见 [[WebGPU#enumdef-gpufiltermode|WebGPU GPUFilterMode]]。
: LOD 钳位
:: 控制访问的详细信息的最小和最大级别。
: 比较
:: 控制为 [=syntax/sampler_comparison|comparison sampler=] 所做的比较类型。
     参见 [[WebGPU#enumdef-gpucomparefunction|WebGPU GPUCompareFunction]]。
: 最大各向异性
:: 控制采样器使用的最大各向异性值。

采样器不能在 WGSL 程序中创建，它们的状态（例如上面列出的属性）在着色器中是不可变的，只能由 WebGPU API 设置。

如果过滤采样器（即任何采样器
使用插值过滤）与具有不可过滤格式的纹理一起使用。

注意：着色器无法更改采样器变量存储的句柄。

### 纹素格式 ### {#texel-formats}

在 WGSL 中，某些纹理类型由纹素格式参数化。

纹素格式（<dfn noexport>texel format</dfn>）被归类为：

: 频道（<dfn noexport>channels</dfn>）
:: 每个频道包含一个标量。纹素格式最多有四个通道：r、g、b 和 a，通常对应于红色、绿色、蓝色和 alpha 通道的概念。
: 频道格式（<dfn noexport>channel format</dfn>）
:: 通道中的位数，以及如何解释这些位。

WGSL 中的每个纹素格式都对应一个同名的 [[WebGPU#enumdef-gputextureformat|WebGPU GPUTextureFormat]]。

WGSL 源代码中仅使用某些纹素格式。用于定义这些纹素格式的频道格式在频道格式（<dfn dfn>Channel Formats</dfn>）表中列出。 最后一列指定从存储的频道位到着色器中使用的值的转换。这也称为频道传递函数（<dfn noexport>channel transfer function</dfn>）或 CTF。

<table class='data'>
  <caption>Channel Formats</caption>
  <thead>
    <tr><th>Channel format
        <th>Number of stored bits
        <th>Interpetation of stored bits
        <th>Shader type<td style="width:25%">Shader value
(Channel Transfer Function)
  </thead>
  <tr><td>8unorm<td>8<td>无符号整数 |v| &isinv; {0,...,255}<td>f32<td> |v| &div; 255
  <tr><td>8snorm<td>8<td>有符号整数 |v| &isinv; {-128,...,127}<td>f32<td> max(-1, |v| &div; 127)
  <tr><td>8uint<td>8<td>无符号整数 |v| &isinv; {0,...,255}<td>u32<td> |v|
  <tr><td>8sint<td>8<td>有符号整数 |v| &isinv; {-128,...,127}<td>i32<td> |v|
  <tr><td>16uint<td>16<td>无符号整数 |v| &isinv; {0,...,65535}<td>u32<td> |v|
  <tr><td>16sint<td>16<td>有符号整数 |v| &isinv; {-32768,...,32767}<td>i32<td> |v|
  <tr><td>16float<td>16<td>[[!IEEE-754|IEEE-754]] binary16 16-位浮点值 |v|, 1 符号位，5指数位，10尾数位<td>f32<td>|v|
  <tr><td>32uint<td>32<td>32-位无符号整数值 |v|<td>u32<td>|v|
  <tr><td>32sint<td>32<td>32-位有符号整数值 |v|<td>i32<td>|v|
  <tr><td>32float<td>32<td>[[!IEEE-754|IEEE-754]] binary32 32-位浮点值 |v|<td>f32<td>|v|
</table>

存储纹理的纹素格式（<dfn lt="storage-texel-formats">Texel Formats for Storage Textures</dfn>）表中列出的纹素格式对应于支持 [[WebGPU#dom-gputextureusage-storage|WebGPU STORAGE]] 使用的 WebGPU 纯色格式（[[WebGPU#plain-color-formats|WebGPU plain color formats]]）。这些纹素格式用于参数化在[[#texture-storage]]中定义的存储纹理类型。

当纹素格式没有所有四个频道时，则：

* 当读取纹素时：
    * 如果纹素格式没有绿色频道，则着色器值的第二个分量为 0。
    * 如果纹素格式没有蓝色频道，则着色器值的第三个分量为 0。
    * 如果纹素格式没有 Alpha 频道，则着色器值的第四个分量为 1。
* 写入纹素时，缺失频道的着色器值组件将被忽略。

下表中的最后一列使用了频道格式（[=channel formats=]）表中特定于格式的频道传输函数（[=channel transfer function=]）。

<table class='data'>
  <caption>存储纹理的纹素格式</caption>
  <thead>
    <tr><th>Texel format
        <th>Channel format
        <th>Channels in memory order
        <th style="width:50%">Corresponding shader value
  </thead>
  <tr><td>rgba8unorm<td>8unorm<td>r, g, b, a<td>vec4&lt;f32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td>rgba8snorm<td>8snorm<td>r, g, b, a<td>vec4&lt;f32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td>rgba8uint<td>8uint<td>r, g, b, a<td>vec4&lt;u32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td>rgba8sint<td>8sint<td>r, g, b, a<td>vec4&lt;i32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td>rgba16uint<td>16uint<td>r, g, b, a<td>vec4&lt;u32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td>rgba16sint<td>16sint<td>r, g, b, a<td>vec4&lt;i32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td>rgba16float<td>16float<td>r, g, b, a<td>vec4&lt;f32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td>r32uint<td>32uint<td>r<td>vec4&lt;u32&gt;(CTF(r), 0u, 0u, 1u)
  <tr><td>r32sint<td>32sint<td>r<td>vec4&lt;i32&gt;(CTF(r), 0, 0, 1)
  <tr><td>r32float<td>32float<td>r<td>vec4&lt;f32&gt;(CTF(r), 0.0, 0.0, 1.0)
  <tr><td>rg32uint<td>32uint<td>r, g<td>vec4&lt;u32&gt;(CTF(r), CTF(g), 0.0, 1.0)
  <tr><td>rg32sint<td>32sint<td>r, g<td>vec4&lt;i32&gt;(CTF(r), CTF(g), 0.0, 1.0)
  <tr><td>rg32float<td>32float<td>r, g<td>vec4&lt;f32&gt;(CTF(r), CTF(g), 0.0, 1.0)
  <tr><td>rgba32uint<td>32uint<td>r, g, b, a<td>vec4&lt;u32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td>rgba32sint<td>32sint<td>r, g, b, a<td>vec4&lt;i32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td>rgba32float<td>32float<td>r, g, b, a<td>vec4&lt;f32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
</table>


### 采样纹理类型 ### {#sampled-texture-type}

<pre class='def'>
`texture_1d<type>`

`texture_2d<type>`

`texture_2d_array<type>`

`texture_3d<type>`

`texture_cube<type>`

`texture_cube_array<type>`
</pre>
* 类型必须为 `f32`, `i32` 或 `u32`
* 图像的参数化类型是采样转换后的类型。例如：你可以使用带有 8 位 unorm 组件的纹素图像，但是当您对它们进行采样时，您会得到 32 位浮点结果（或 vec-of-f32）。

### 多重采样纹理类型 ### {#multisampled-texture-type}

<pre class='def'>
`texture_multisampled_2d<type>`
</pre>
* 类型必须为 `f32`, `i32` 或 `u32`

### 外部采样纹理类型 ### {#external-texture-type}

<pre class='def'>
`texture_external`
</pre>

`texture_external` 是一种类似于 `texture_2d<f32>` 的不透明 2d 浮点采样纹理类型，但可能具有不同的表示。可以使用  [[#textureload|textureLoad]]  或 [[#texturesamplelevel|textureSampleLevel]]  读取它，它们不透明地处理这些不同的表示。

详见[[WebGPU#GPUExternalTexture]]。

### 存储纹理类型 ### {#texture-storage}

存储纹理（<dfn noexport>storage texture</dfn）支持在不使用采样器的情况下访问单个纹素。

* 只写存储纹理（A <dfn noexport>write-only storage texture</dfn>）支持写入单个纹素，并自动将着色器值转换为存储的纹素值。

存储纹理类型必须由一种存储纹理的纹素格式（[=storage-texel-format|texel formats for storage textures=]）进行参数化。纹素格式决定了 [[#texel-formats]] 中指定的转换函数。

对于只写存储纹理，转换函数的*逆*函数用于将着色器值转换为存储的纹素。

见[[#texture-builtin-functions]]。

TODO(dentro)：将转换的描述移动到实际进行读取的内置函数中。

<pre class='def'>
`texture_storage_1d<texel_format,access>`

`texture_storage_2d<texel_format,access>`

`texture_storage_2d_array<texel_format,access>`

`texture_storage_3d<texel_format,access>`
</pre>

* `texel format` 必须为存储纹素格式（[=storage-texel-formats=]）中指定的纹素类型之一
* `access` 必须为 [=access/write=]

### 深度纹理类型 ### {#texture-depth}
<pre class='def'>
`texture_depth_2d`

`texture_depth_2d_array`

`texture_depth_cube`

`texture_depth_cube_array`

`texture_depth_multisampled_2d`
</pre>

### 采样器类型 ### {#sampler-type}

采样器（<dfn>sampler</dfn>）通过执行以下组合来调节对采样纹理或深度纹理的访问：
* 坐标转换。
* 可选地修改 mip-level 选择。
* 对于采样纹理，可选择过滤检索到的纹素值。
* 对于深度纹理，确定应用于检索到的纹素的比较函数。

<table class='data'>
  <thead>
    <tr><th>Type<th>Description
  </thead>
  <tr algorithm="sampler type">
    <td>sampler
    <td>采样器。调节对采样纹理的访问。</td>
  <tr algorithm="comparison sampler type">
    <td>sampler_comparison
    <td>比较采样器。调节对深度纹理的访问。</td>
</table>

采样器在被 WebGPU API 创建时参数化。它们在 WGSL 程序中不能被修改。

采样器仅能通过[[#texture-builtin-functions|texture builtin functions]]被使用。

<pre class='def'>
sampler

sampler_comparison
</pre>

### 纹理类型语法 ### {#texture-types-grammar}

<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_sampler_types</dfn> :

    | [=syntax/sampler_type=]

    | [=syntax/depth_texture_type=]

    | [=syntax/sampled_texture_type=] [=syntax/less_than=] [=syntax/type_decl=] [=syntax/greater_than=]

    | [=syntax/multisampled_texture_type=] [=syntax/less_than=] [=syntax/type_decl=] [=syntax/greater_than=]

    | [=syntax/storage_texture_type=] [=syntax/less_than=] [=syntax/texel_format=] [=syntax/comma=] [=syntax/access_mode=] [=syntax/greater_than=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>sampler_type</dfn> :

    | [=syntax/sampler=]

    | [=syntax/sampler_comparison=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>sampled_texture_type</dfn> :

    | [=syntax/texture_1d=]

    | [=syntax/texture_2d=]

    | [=syntax/texture_2d_array=]

    | [=syntax/texture_3d=]

    | [=syntax/texture_cube=]

    | [=syntax/texture_cube_array=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>multisampled_texture_type</dfn> :

    | [=syntax/texture_multisampled_2d=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>storage_texture_type</dfn> :

    | [=syntax/texture_storage_1d=]

    | [=syntax/texture_storage_2d=]

    | [=syntax/texture_storage_2d_array=]

    | [=syntax/texture_storage_3d=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>depth_texture_type</dfn> :

    | [=syntax/texture_depth_2d=]

    | [=syntax/texture_depth_2d_array=]

    | [=syntax/texture_depth_cube=]

    | [=syntax/texture_depth_cube_array=]

    | [=syntax/texture_depth_multisampled_2d=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texel_format</dfn> :

    | `'rgba8unorm'`

    | `'rgba8snorm'`

    | `'rgba8uint'`

    | `'rgba8sint'`

    | `'rgba16uint'`

    | `'rgba16sint'`

    | `'rgba16float'`

    | `'r32uint'`

    | `'r32sint'`

    | `'r32float'`

    | `'rg32uint'`

    | `'rg32sint'`

    | `'rg32float'`

    | `'rgba32uint'`

    | `'rgba32sint'`

    | `'rgba32float'`
</div>

## 类型别名 ## {#type-aliases}
<dfn noexport> 类型别名</dfn> 为现有类型声明一个新名称。
声明必须出现在[=module scope=]，它的[=scope=] 就是整个程序。

<div class='syntax' noexport='true'>
  <dfn for=syntax>type_alias</dfn> :

    | [=syntax/type=] [=syntax/ident=] [=syntax/equal=] [=syntax/type_decl=]
</div>

<div class='example wgsl global-scope' heading='Type Alias'>
  <xmp highlight='rust'>
    type Arr = array<i32, 5>;

    type RTArr = array<vec4<f32>>;
    const pi_approx: single = 3.1415;
        fn two_pi() -> single {
          return single(2) * pi_approx;
        }
  </xmp>
</div>

## 类型声明语法 ## {#type-declarations}

<div class='syntax' noexport='true'>
  <dfn for=syntax>type_decl</dfn> :

    | [=syntax/ident=]
    | [=syntax/type_decl_without_ident=]
</div>

<div class='syntax' noexport='true'>
    <dfn for=syntax>type_decl_without_ident</dfn> :

    | [=syntax/bool=]

    | [=syntax/float32=]

    | [=syntax/float16=]

    | [=syntax/int32=]

    | [=syntax/uint32=]

    | [=syntax/vec_prefix=] [=syntax/less_than=] [=syntax/type_decl=] [=syntax/greater_than=]

    | [=syntax/mat_prefix=] [=syntax/less_than=] [=syntax/type_decl=] [=syntax/greater_than=]

    | [=syntax/pointer=] [=syntax/less_than=] [=syntax/address_space=] [=syntax/comma=] [=syntax/type_decl=] ( [=syntax/comma=] [=syntax/access_mode=] ) ? [=syntax/greater_than=]

    | [=syntax/array_type_decl=]

    | [=syntax/atomic=] [=syntax/less_than=] [=syntax/type_decl=] [=syntax/greater_than=]

    | [=syntax/texture_sampler_types=]
</div>
<div class='syntax' noexport='true'>
    <dfn for=syntax>vec_prefix</dfn> :

    | [=syntax/vec2=]

    | [=syntax/vec3=]

    | [=syntax/vec4=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>mat_prefix</dfn> :

    | [=syntax/mat2x2=]

    | [=syntax/mat2x3=]

    | [=syntax/mat2x4=]

    | [=syntax/mat3x2=]

    | [=syntax/mat3x3=]

    | [=syntax/mat3x4=]

    | [=syntax/mat4x2=]

    | [=syntax/mat4x3=]

    | [=syntax/mat4x4=]
</div>

当类型声明是标识符（[=identifier=]）时，表达式必须在标识符声明（[=declaration=]）的范围内，作为类型别名或结构类型。

<div class='example' heading="Type Declarations">
  <xmp>
    identifier
      Allows to specify types created by the type command

    bool

    f32

    i32

    u32

    vec2<f32>

    array<f32, 4>

    array<f32>

    mat2x3<f32>
  </xmp>
</div>

<div class='example wgsl global-scope' heading='Access modes for buffers'>
  <xmp highlight='rust'>
    // Storage buffers
    @group(0) @binding(0)
    var<storage,read> buf1: Buffer;       // Can read, cannot write.
    @group(0) @binding(0)
    var<storage> buf2: Buffer;            // Can read, cannot write.
    @group(0) @binding(1)
    var<storage,read_write> buf3: Buffer; // Can both read and write.

    // Uniform buffer. Always read-only, and has more restrictive layout rules.
    struct ParamsTable {weight: f32}
    @group(0) @binding(2)
    var<uniform> params: ParamsTable;     // Can read, cannot write.
  </xmp>
</div>

# 变量和值声明 # {#var-and-value}

## 值声明 ## {#value-decls}

[SHORTNAME] 作者可以使用 <dfn noexport>value declaration</dfn> 为不可变值声明名称，这些名称可以是：
   * [=let declarations=]，或者
   * [=override declarations=]，或者
   * [=creation-time constant=]

值声明没有任何关联的存储。
也就是说，没有与声明关联的 [=memory locations=]。

### `let` 声明 ### {#let-decls}

let 声明（<dfn noexport>let declaration</dfn>）指定值的名称。一旦计算出 let 声明的值，它就是不可变的。当标识符（[=identifier=]） 使用[=resolves=]至一个let-声明，该标识符表示该值。

当声明一个 `let` 标识符时没有明确指定的类型，例如
`let foo = 4`，类型是从 [=syntax/equals=] 标记右侧的表达式自动推断的。
`let` 声明的类型总是 [=concrete=]。
当指定类型时，例如 `let foo: i32 = 4`，初始化表达式必须计算为该类型。

`let`-声明只能出现在函数定义中。

<div class='example wgsl let declaration at function-scope' heading='let-declared constants at function scope'>
  <xmp highlight='rust'>
    // 'blockSize' 表示 i32 值 1024。
    let blockSize: i32 = 1024;

    // 'row_size' 表示 u32 值 16u。类型被指定。
    let row_size = 16u;
  </xmp>
</div>

变量（<dfn dfn noexport>variable</dfn>）是对内存的命名引用，可以包含特定可存储（[=storable=]）类型的值。

### `override` 声明 ### {#override-decls}

<dfn noexport>覆盖声明</dfn> 指定 [=pipeline-overridable=] 常量值的名称。
<dfn noexport>pipeline-overridable</dfn> 常量的值在管道创建时是固定的。

该值是由 WebGPU 管道创建方法指定的值（如果指定），否则是其初始化表达式的值。
当 [=identifier=] 将 [=resolves=] 用于覆盖声明时，标识符表示该值。
`override`-声明必须满足以下限制：
   * 声明只能出现在 [=module scope=]。
   * 声明必须至少具有声明类型、初始化表达式或两者之一。
   * 声明的类型（如果存在）必须是 [=scalar=]。
   * 初始化表达式，如果存在，必须：
       * 评估为 [=scalar=] 类型。
       * 如果存在，则评估为声明的类型。
        * 仅由 [=creation-time expressions=] 或所有标识符 [=resolve=] 到可覆盖常量、[=creation-time constants=] 或 [=creation-time functions=] 的表达式组成。这样的表达式称为<dfn noexport>override expressio/dfn>。
   * 如果声明应用了 [=attribute/id=]，则文字操作数称为 <dfn noexport>管道常量 ID</dfn>，并且必须是 0 到 65535 之间的整数值。
   * 管道常量 ID 在 WGSL 程序中必须是唯一的：两个“覆盖”-声明不得使用相同的管道常量 ID。
   * 应用程序可以在管道创建时为常量指定自己的值。
     管道创建 API 接受从可覆盖常量到常量类型值的映射。
     常量由 <dfn export>pipeline-overridable 常量标识符字符串</dfn>标识，如果指定，它是 [=pipeline constant ID=] 的 base-10 表示，否则声明的 [=name=] 常数。
   * <dfn export>管道可覆盖常量如果其声明具有初始化表达式，则具有默认值</dfn>。 如果没有，则必须在管道创建时提供一个值。

注意：覆盖表达式是 [=creation-time expressions=] 的超集。
<div class='example wgsl global-scope' heading='Module constants, pipeline-overrideable'>
  <xmp highlight='rust'>
    @id(0)    override has_point_light: bool = true;  // Algorithmic control
    @id(1200) override specular_param: f32 = 2.3;     // Numeric control
    @id(1300) override gain: f32;                     // Must be overridden
              override width: f32 = 0.0;              // Specified at the API level using
                                                      // the name "width".
              override depth: f32;                    // Specified at the API level using
                                                      // the name "depth".
                                                      // Must be overridden.
              override height = 2 * depth;            // The default value
                                                      // (if not set at the API level),
                                                      // depends on another
                                                      // overridable constant.

  </xmp>
</div>

### 创建时间常数 ### {#creation-time-consts}

<dfn noexport>creation-time constant</dfn> 指定固定在 [=shader module creation|shader-creation time=] 的值的名称。
一旦声明了常量，它的值就是不可变的。
当 [=identifier=] 将 [=resolves=] 用于创建时间常数时，标识符表示该值。

当声明创建时常量时没有明确指定类型，
例如 `const foo = 4`，类型是从 [=syntax/equals=] 标记右侧的表达式自动推断的。
创建时间常量的类型必须是：
* 一个 [=constructible=] 类型，或
* [=abstract numeric type=]，或
* 一个 [=vector=]，或
* 一个 [=matrix=]

当指定类型时，例如 `const foo : i32 = 4`，初始化表达式必须计算为该类型。

注意：由于 [=AbstractInt=] 和 [=AbstractFloat=] 在 WGSL 源代码中无法拼写，因此命名值只能通过类型推断来使用它们。

可以在模块范围或函数范围声明创建时间常量。
必须使用初始化程序声明创建时间常量，并且仅由 [=creation-time expressions=] 组成。
<div class='example wgsl global-scope' heading='Creation-time constants'>
  <xmp>
    const a = 4; // 值为 4 的 AbstractInt。
    const b : i32 = 4; // i32 值为 4。
    const c : u32 = 4; // u32，值为 4。
    const d : f32 = 4; // f32 值为 4。
    const e = vec3(a, a, a); // AbstractInt 的 vec3，值为 (4, 4, 4)。
    const f = 4.0; // 值为 4 的 AbstractFloat。
    const g = mat2x2(a, f, a, f); // 值为 ((2, 4), (2, 4)) 的 AbstractFloat 的 mat2x2。
  </xmp>
</div>

## `var` 声明 ## {#var-decls}
有两种类型与变量相关联：它的存储类型（[=store type=]）（可以放置在被引用内存中的值的类型）和它的引用类型（[=reference type=]）（变量本身的类型）。 如果变量具有存储类型 *T*、存储类（[=address space=]） *S* 和访问模式 *A*，则其引用类型为 ref&lt;*S*,*T*,*A*&gt;。
变量的 [=store type=] 始终是 [=concrete=]。

变量声明（<dfn noexport>variable declaration</dfn>）：

* 指定变量名称。
* 指定[=address spaces=], [=store type=], 和 [=access mode=]。这些一同构成变量的引用类型（[=reference type=]）。
* 确保执行环境在指定的地址空间中为存储类型的值分配内存，对变量的生命周期（[=lifetime=]）支持给定的访问模式。
* 如果变量在私有（[=address spaces/private=]）或函数（[=address spaces/function=]）地址空间中，可选择地有一个*初始化*表达式。 如果存在，初始化表达式必须计算为变量的存储类型。

当标识符（[=identifier=]）对变量声明使用[=resolves=]时，标识符是表示变量内存的引用内存视图（[=memory view=]）的表达式，其类型是变量的引用类型。见[[#var-identifier-expr]]。

有关可以在何处声明特定存储类中的变量以及何时需要、可选或禁止存储类修饰的规则，见[[#module-scope-variables]]和[[#function-scope-variables]]。

访问方式总是有默认的，除了[=storage classes/storage=]存储类中的变量，不得写入WGSL源文本。见[[#access-mode-defaults]]。

一个变量的生命周期（<dfn noexport>lifetime</dfn>）为该变量存在时进行着色器处理的期间。模块范围（[=module scope=]）变量的生命周期为着色器阶段的全部执行时间。

对于函数作用域（[=function scope=]）变量，每个调用都有其自己的独立变量版本。变量的生存周期取决于其作用域：
* 当控制写入变量声明时，它就开始了。
* 它包括从变量作用域内调用的任何函数的整个执行过程。
* 它在控制离开变量的作用域时结束，而不是从变量的作用域内调用函数。

两个生命周期重叠的变量不会有重叠的内存（[=overlap|overlapping memory=]）。当一个变量的生命周期结束时，它的内存可能会被另一个变量使用。

当一个变量被创建时，它的内存包含一个初始值，如下所示：

* 对于在私有（[=address spaces/private=]）或函数（[=address spaces/function=]）地址空间中的变量：
    * 如果变量声明没有初始化表达式，存储类型为零值（[=zero value=]）。
    * 否则它是对初始化表达式在程序执行处计算求值后的结果。
* 对于 [=address spaces/workgroup=] 地址空间中的变量：
     * 当商店类型为 [=constructible=] 时，商店类型的 [=zero value=]。
     * 否则，商店类型是一个可构造元素的数组，每个元素都被初始化为零值。
* 其他地址空间的变量是通过 [=draw command=] 或 [=dispatch command=] 中的绑定设置的 [=resources=]。

考虑如下WGSL片段：
<div class='example wgsl function-scope' heading='Variable initial values'>
  <xmp highlight='rust'>
    var i: i32;         // 初始值为 0。不是推荐的方式。
    loop {
      var twice: i32 = 2 * i;   // 重新计算每次迭代。
      i = i++;
      if i == 5 { break; }
    }
  </xmp>
</div>
循环体会执行 5 次，变量 `i` 会具有值0, 1, 2, 3, 4, 5, 且变量 `twice` 会具有值0, 2, 4, 6, 8。

考虑如下WGSL片段：
<div class='example wgsl function-scope' heading='Reading a variable multiple times'>
  <xmp highlight='rust'>
    var x: f32 = 1.0;
    let y = x * x + x + 1;
  </xmp>
</div>
由于 `x` 为一个变量，所有对齐的访问都变成了加载和存储操作。

然而，期望浏览器或驱动程序优化此中间表示，从而消除冗余负载。

## 模块作用域变量 ## {#module-scope-variables}

在整个程序中，变量名都是[=in scope=]。
模块作用域（[=module scope=]）内的变量被限制如下：

* 变量不能在函数（[=address spaces/function=]）地址空间中。
* 变量在[=address spaces/private=], [=address spaces/workgroup=], [=address spaces/uniform=], 或 [=address spaces/storage=] 地址空间中：
    * 必须使用显式地址空间修饰声明。
    * 必须使用[[#address-space]]中所描述的存储类型（[=store type=]）。
* 如果存储类型（[=store type=]）是纹理类型或采样器类型，则变量声明不得具有存储类修饰。存储类将始终是句柄（[=address spaces/handle=]）。

[=address spaces/uniform=] 地址空间中的变量是 <dfn noexport>uniform buffer</dfn> 变量。
它的 [=store type=] 必须是 [=host-shareable=] [=constructible=] 类型，并且必须满足 [地址空间布局约束](#address-space-layout-constraints)。

[=address spaces/storage=] 地址空间中的变量是 <dfn noexport>storage buffer</dfn> 变量。
它的 [=store type=] 必须是 [=host-shareable=] 类型并且必须满足 [地址空间布局约束](#address-space-layout-constraints)。
变量可以用 [=access/read=] 或 [=access/read_write=] 访问模式声明； 默认值为 [=access/read=]。

如[[#resource-interface]]中所述，统一缓冲区、存储缓冲区、纹理和采样器构成了着色器的资源接口（[=resource interface of a shader=]）。 此类变量使用组（[=attribute/group=]）和绑定（[=attribute/binding=]）修饰声明。

WGSL 定义了以下可应用于全局变量的属性：
   * [=attribute/binding=]
   * [=attribute/group=]

<div class='example wgsl global-scope' heading="Module scope variable declarations">
  <xmp highlight='rust'>
    var<private> decibels: f32;
    var<workgroup> worklist: array<i32,10>;

    struct Params {
      specular: f32,
      count: i32
    }
    @group(0) @binding(2)
    var<uniform> param: Params;    // A uniform buffer

    // A storage buffer, for reading and writing
    @group(0) @binding(2)
    var<storage,read_write> pbuf: array<vec2<f32>>;

    // Textures and samplers are always in "handle" space.
    @group(0) @binding(2)
    var filter_params: sampler;
  </xmp>
</div>


## 模块常量 ## {#module-constants}

出现在所有函数之外的 [[#value-decls|value declaration]] 声明了一个
[=module scope|module-scope=] 常量。

模块范围的常量必须是 [=override declarations=] 或 [=creation-time constants=]。

整个程序的名称是 [=in scope=]。

<div class='example wgsl global-scope' heading='Module constants'>
  <xmp highlight='rust'>
    // The golden ratio.
    const golden: f32 = 1.61803398875;

    // The second unit vector for three dimensions, with inferred type.
    const e2 = vec3<i32>(0,1,0);
  </xmp>
</div>

当在依赖于常量值的控制流中使用变量或特性时，则认为该变量或特性被程序使用。 无论常量的值如何，无论该值是来自常量声明的值还是来自管线覆盖的值，都是如此。

## 函数作用域变量和常量 ## {#function-scope-variables}

在函数体的声明语句中声明的变量或常量在 <dfn noexport>function scope</dfn> 中。
该名称可在其声明语句之后立即使用，直到用大括号分隔的语句列表的末尾立即包含该声明。

[=let declaration|let-declared=] 常量必须是 [=constructible=] 类型，
或 [=pointer type=]。

对于在函数作用域中声明的变量：
* 变量总是在 [=address spaces/function=] 地址空间中。
* 地址空间[=address space=] 装饰是可选的。
* 存储类型（[=store type=]）必须为可构造（[=constructible=]）类型。
* 当指定了初始化表达式时，可以从声明中省略存储类型。在这种情况下，存储类型是初始化表达式的计算结果的类型。

<div class='example wgsl global-scope' heading="Function scope variables and constants">
  <xmp highlight='rust'>
    fn f() {
       var<function> count: u32;  // 函数地址空间中的变量。
       var delta: i32;            // 函数地址空间中的另一个变量。
       var sum: f32 = 0.0;        // 拥有初始化值的函数存储类变量。
       var pi = 3.14159;          // 从初始化值推断出 f32 存储类型。
       let unit: i32 = 1;         // 未使用地址空间的let-声明常量。
    }
  </xmp>
</div>

在 `for` 语句的第一个子句中声明的变量或常量可用于第二个和第三个子句以及 `for` 语句的主体中。

函数作用域变量的实例是动态上下文（[=dynamic context=]）。每个一些调用范围内的变量都有一个重叠的生命周期（[=lifetime=]），因此，具有不重叠的内存。生命周期不重叠的变量可能会重用之前变量的内存；但是，不能保证同一变量的新实例使用相同的内存。

## 变量和值声明语法总结 ## {#var-and-value-decl-grammar}

<div class='syntax' noexport='true'>
  <dfn for=syntax>variable_statement</dfn> :

    | [=syntax/variable_decl=]

    | [=syntax/variable_decl=] [=syntax/equal=] [=syntax/expression=]

    | [=syntax/let=] ( [=syntax/ident=] | [=syntax/variable_ident_decl=] ) [=syntax/equal=] [=syntax/expression=]

    | [=syntax/const=] ( [=syntax/ident=] | [=syntax/variable_ident_decl=] ) [=syntax/equal=] [=syntax/expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>variable_decl</dfn> :

    | [=syntax/var=] [=syntax/variable_qualifier=] ? ( [=syntax/ident=] | [=syntax/variable_ident_decl=] )
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>variable_ident_decl</dfn> :

    | [=syntax/ident=] [=syntax/colon=] [=syntax/type_decl=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>variable_qualifier</dfn> :

    | [=syntax/less_than=] [=syntax/address_space=] ( [=syntax/comma=] [=syntax/access_mode=] ) ? [=syntax/greater_than=]
</div>

<div class='syntax' noexport='true'>
  <dfn for=syntax>global_variable_decl</dfn> :

    | [=syntax/attribute=] * [=syntax/variable_decl=] ( [=syntax/equal=] [=syntax/const_expression=] ) ?
</div>

<div class='syntax' noexport='true'>
  <dfn for=syntax>global_constant_decl</dfn> :

    | [=syntax/const=] ( [=syntax/ident=] | [=syntax/variable_ident_decl=] ) [=syntax/equal=] [=syntax/expression=]
    | [=syntax/attribute=] * [=syntax/variable_decl=] ( [=syntax/equal=] [=syntax/expression=] ) ?
</div>

# 表达式 # {#expressions}

表达式指定值如何被计算。
## 创建时间表达式 ## {#creation-time-expr}

在 [=shader module creation|shader-creation time=] 计算的表达式称为 <dfn noexport>creation-time 表达式</dfn>。
为了在着色器创建时计算表达式，表达式使用的所有 [=identifiers=] 必须 [=resolve=] 到 [=creation-time constants=] 或 [=creation-time functions=]。

创建时表达式的类型可以解析为包含 [=abstract numeric types=] 的类型。

示例：`(42)`分析如下：
* 术语 `42` 是 [=AbstractInt=] 值 42。
* 用括号括住该术语会产生一个新表达式 `(42)`，其类型为 [=AbstractInt=]，值为 42。

示例：`-5`分析如下：
* 术语“5”是 [=AbstractInt=] 值 5。
* 在该术语前面加上 '`-`' 会产生一个新的表达式 `-5`，它的类型为 [=AbstractInt=]，值为 -5。

示例：`-2147483648`分析如下：
* 术语“2147483648”是 [=AbstractInt=] 值 2147483648。
    请注意，此值**不**适合 32 位有符号整数。
* 在该术语前面加上 '`-`' 会产生一个新表达式 `-2147483648`，即
    [=AbstractInt=] 类型，值为 -2147483648。

示例：`const minint = -2147483648;`分析如下：
* 如上所述，`-2147483648` 的计算结果为 [=AbstractInt=] 值 -2147483648。
* A [=creation-time constant=] 允许初始化器是 [=abstract numeric type=]。
* 结果是 `minint` 被声明为 [=AbstractInt=] 值 -2147483648。

示例：`let minint = -2147483648;`分析如下：
* 如上所述，`-2147483648` 的计算结果为 [=AbstractInt=] 值 -2147483648。
* [=let 声明=] 要求初始化程序是 [=constructible=]。
* let 声明没有明确的类型，所以使用 [=overload resolution=]。
    应用的重载候选使用从 [=AbstractInt=] 到 [=i32=]、[=u32=] 或 [=f32=] 的 [=feasible automatic conversions=]。
    排名最低的是 [=i32=]，所以
    [=AbstractInt=] -2147483648 值转换为 [=i32=] 值 -2147483648。
* 结果是 `minint`被声明为i32值-2147483648。

## 文字表达式 ## {#literal-expressions}

<table class='data'>
  <caption>标量文字类型规则</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr><td>
      <td>`true`: bool
      <td>`true` boolean value.
  <tr><td>
      <td>`false`: bool
      <td>`false` boolean value.
  <tr><td>|e| is an [=integer literal=] with no suffix
      <td>|e|: AbstractInt
      <td>Abstract integer literal value.
  <tr><td>|e| is a [=floating point literal=] with no suffix
      <td>|e|: AbstractFloat
      <td>Abstract float literal value.
  <tr><td>|e| is an [=integer literal=] with `i` suffix
      <td>|e|: i32
      <td>32-bit signed integer literal value.
  <tr><td>|e| is an [=integer literal=] with `u` suffix
      <td>|e|: u32
      <td>32-bit unsigned integer literal value.
  <tr><td>|e| is an [=floating point literal=] with `f` suffix
      <td>|e|: f32
      <td>32-bit floating point literal value.
  <tr><td>|e| is an [=floating point literal=] with `h` suffix
      <td>|e|: f16
      <td>16-bit floating point literal value.
</table>

## 括号表达式 ## {#parenthesized-expressions}

<table class='data'>
  <caption>括号表达式类型规则</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="parenthesized expression">
      <td>|e| : |T|
      <td>`(` |e| `)` : |T|
      <td>计算为 |e| 。<br>
          使用括号与表达式周围文本分隔。
</table>

## 类型构造函数表达式 ## {#type-constructor-expr}

类型构造函数表达式显式创建给定 [=constructible=] 类型的值。
构造函数表达式共有三种：
* [[#construction-from-components]]
* [[#zero-value-expr]]
* [[#conversion-expr]]

### 从组件构造### {#construction-from-components}

本节中定义的表达式通过以下方式创建 [=constructible=] 值：
* 复制相同类型的现有值（即恒等函数），或
* 从一个显式的组件列表中创建一个复合值。

这里给出的标量形式是多余的，但提供了标量 [=conversion expressions=] 的对称性，
并可用于增强可读性。

向量和矩阵形式从具有匹配分量类型的分量和子向量的各种组合构造向量和矩阵值。
有用于构造向量和矩阵的重载[=overloads=] ，它们指定目标类型的维度而无需指定组件类型； 组件类型是从构造函数参数推断出来的。


<table class='data'>
  <caption>标量构造函数类型规则</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr><td>*e*: bool<td>`bool(e)`: bool<td>Identity.
  <tr><td>*e*: i32<td>`i32(e)`: i32<td>Identity.
  <tr><td>*e*: u32<td>`u32(e)`: u32<td>Identity.
  <tr><td>*e*: f32<td>`f32(e)`: f32<td>Identity.
  <tr><td>*e*: f16<td>`f16(e)`: f16<td>Identity.
</table>

<table class='data'>
  <caption>Vector constructor type rules, where *T* is a scalar type</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="construct a vector from copies of a single scalar">
    <td rowspan=2>|e|: |T|
    <td>`vec`|N|`<`|T|`>(`|e|`)`: vec|N|&lt;|T|&gt;
    <td rowspan=2>Evaluates |e| once. Results in the |N|-element vector where each component has the value of |e|.
  <tr>
    <td>`vec`|N|`(`|e|`)`: vec|N|&lt;|T|&gt;
  <tr>
    <td rowspan=2>*e1*: *T*<br>
        *e2*: *T*
    <td>`vec2<T>(e1,e2)`: vec2<*T*>
    <td rowspan=2>
  <tr>
    <td>`vec2(e1,e2)`: vec2<*T*>
  <tr>
    <td rowspan=2>*e*: vec2&lt;T&gt;
    <td>`vec2<T>(e)`: vec2<*T*>
    <td rowspan=2>Identity. The result is |e|.
  <tr>
    <td>`vec2(e)`: vec2<*T*>
  <tr>
    <td rowspan=2>*e1*: *T*<br>
        *e2*: *T*<br>
        *e3*: *T*
    <td>`vec3<T>(e1,e2,e3)`: vec3<*T*>
    <td rowspan=2>
  <tr>
    <td>`vec3(e1,e2,e3)`: vec3<*T*>
  <tr>
    <td rowspan=2>*e1*: *T*<br>
        *e2*: vec2<*T*>
    <td>`vec3<T>(e1,e2)`: vec3<*T*><br>
        `vec3<T>(e2,e1)`: vec3<*T*>
    <td rowspan=2>
  <tr>
    <td>`vec3(e1,e2)`: vec3<*T*><br>
        `vec3(e2,e1)`: vec3<*T*>
  <tr>
    <td rowspan=2>*e*: vec3&lt;T&gt;
    <td>`vec3<T>(e)`: vec3<*T*>
    <td rowspan=2>Identity. The result is |e|.
  <tr>
    <td>`vec3(e)`: vec3<*T*>
  <tr>
    <td rowspan=2>*e1*: *T*<br>
        *e2*: *T*<br>
        *e3*: *T*<br>
        *e4*: *T*
    <td class=nowrap>`vec4<T>(e1,e2,e3,e4)`: vec4<*T*>
    <td rowspan=2>
  <tr>
    <td class=nowrap>`vec4(e1,e2,e3,e4)`: vec4<*T*>
  <tr>
    <td rowspan=2>*e1*: *T*<br>
        *e2*: *T*<br>
        *e3*: vec2<*T*>
    <td class=nowrap>`vec4<T>(e1,e2,e3)`: vec4<*T*><br>
        `vec4<T>(e1,e3,e2)`: vec4<*T*><br>
        `vec4<T>(e3,e1,e2)`: vec4<*T*>
    <td rowspan=2>
  <tr>
    <td class=nowrap>`vec4(e1,e2,e3)`: vec4<*T*><br>
        `vec4(e1,e3,e2)`: vec4<*T*><br>
        `vec4(e3,e1,e2)`: vec4<*T*>
  <tr>
    <td rowspan=2>*e1*: vec2<*T*><br>
        *e2*: vec2<*T*>
    <td class=nowrap>`vec4<T>(e1,e2)`: vec4<*T*>
    <td rowspan=2>
  <tr>
    <td class=nowrap>`vec4(e1,e2)`: vec4<*T*>
  <tr>
    <td rowspan=2>*e1*: *T*<br>
        *e2*: vec3<*T*>
    <td class=nowrap>`vec4<T>(e1,e2)`: vec4<*T*><br>
        `vec4<T>(e2,e1)`: vec4<*T*>
    <td rowspan=2>
  <tr>
    <td>`vec4(e1,e2)`: vec4<*T*><br>
        `vec4(e2,e1)`: vec4<*T*>
  <tr>
    <td rowspan=2>*e*: vec4&lt;T&gt;
    <td class=nowrap>`vec4<T>(e)`: vec4<*T*>
    <td rowspan=2>Identity. The result is |e|.
  <tr>
    <td class=nowrap>`vec4(e)`: vec4<*T*>
</table>

<table class='data'>
  <caption>Matrix constructor type rules</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
   <tr>
     <td>|e|: mat2x2&lt;|T|&gt;
     <td>`mat2x2<`|T|`>(`|e|`)`: mat2x2&lt;|T|&gt;<br>
         `mat2x2(`|e|`)`: mat2x2&lt;|T|&gt;<br>
     <td rowspan=9>Identity type conversion. The result is |e|.
   <tr>
     <td>|e|: mat2x3&lt;|T|&gt;
     <td>`mat2x3<`|T|`>(`|e|`)`: mat2x3&lt;|T|&gt;<br>
         `mat2x3(`|e|`)`: mat2x3&lt;|T|&gt;
   <tr>
     <td>|e|: mat2x4&lt;|T|&gt;
     <td>`mat2x4<`|T|`>(`|e|`)`: mat2x4&lt;|T|&gt;<br>
         `mat2x4(`|e|`)`: mat2x4&lt;|T|&gt;
   <tr>
     <td>|e|: mat3x2&lt;|T|&gt;
     <td>`mat3x2<`|T|`>(`|e|`)`: mat3x2&lt;|T|&gt;<br>
         `mat3x2(`|e|`)`: mat3x2&lt;|T|&gt;
   <tr>
     <td>|e|: mat3x3&lt;|T|&gt;
     <td>`mat3x3<`|T|`>(`|e|`)`: mat3x3&lt;|T|&gt;<br>
         `mat3x3(`|e|`)`: mat3x3&lt;|T|&gt;
   <tr>
     <td>|e|: mat3x4&lt;|T|&gt;
     <td>`mat3x4<`|T|`>(`|e|`)`: mat3x4&lt;|T|&gt;<br>
         `mat3x4(`|e|`)`: mat3x4&lt;|T|&gt;
   <tr>
     <td>|e|: mat4x2&lt;|T|&gt;
     <td>`mat4x2<`|T|`>(`|e|`)`: mat4x2&lt;|T|&gt;<br>
         `mat4x2(`|e|`)`: mat4x2&lt;|T|&gt;
   <tr>
     <td>|e|: mat4x3&lt;|T|&gt;
     <td>`mat4x3<`|T|`>(`|e|`)`: mat4x3&lt;|T|&gt;<br>
         `mat4x3(`|e|`)`: mat4x3&lt;|T|&gt;
   <tr>
     <td>|e|: mat4x4&lt;|T|&gt;
     <td>`mat4x4<`|T|`>(`|e|`)`: mat4x4&lt;|T|&gt;<br>
         `mat4x4(`|e|`)`: mat4x4&lt;|T|&gt;
   <tr>
     <td rowspan=2>|e1|: |T|<br>
         ...<br>
         |eN|: |T|<br>
     <td>`mat2x2<T>(e1,e2,e3,e4)`: mat2x2&lt;|T|&gt;<br>
         `mat3x2<T>(e1,...,e6)`: mat3x2&lt;|T|&gt;<br>
         `mat2x3<T>(e1,...,e6)`: mat2x3&lt;|T|&gt;<br>
         `mat4x2<T>(e1,...,e8)`: mat4x2&lt;|T|&gt;<br>
         `mat2x4<T>(e1,...,e8)`: mat2x4&lt;|T|&gt;<br>
         `mat3x3<T>(e1,...,e9)`: mat3x3&lt;|T|&gt;<br>
         `mat4x3<T>(e1,...,e12)`: mat4x3&lt;|T|&gt;<br>
         `mat3x4<T>(e1,...,e12)`: mat3x4&lt;|T|&gt;<br>
         `mat4x4<T>(e1,...,e16)`: mat4x4&lt;|T|&gt;
     <td rowspan=2>Column-major construction by elements.<br>
   <tr>
     <td>`mat2x2(e1,e2,e3,e4)`: mat2x2&lt;|T|&gt;<br>
         `mat3x2(e1,...,e6)`: mat3x2&lt;|T|&gt;<br>
         `mat2x3(e1,...,e6)`: mat2x3&lt;|T|&gt;<br>
         `mat4x2(e1,...,e8)`: mat4x2&lt;|T|&gt;<br>
         `mat2x4(e1,...,e8)`: mat2x4&lt;|T|&gt;<br>
         `mat3x3(e1,...,e9)`: mat3x3&lt;|T|&gt;<br>
         `mat4x3(e1,...,e12)`: mat4x3&lt;|T|&gt;<br>
         `mat3x4(e1,...,e12)`: mat3x4&lt;|T|&gt;<br>
         `mat4x4(e1,...,e16)`: mat4x4&lt;|T|&gt;
   <tr>
     <td rowspan=2>*e1*: vec2&lt;|T|&gt;<br>
         *e2*: vec2&lt;|T|&gt;<br>
         *e3*: vec2&lt;|T|&gt;<br>
         *e4*: vec2&lt;|T|&gt;<br>
     <td>`mat2x2<T>(e1,e2)`: mat2x2&lt;|T|&gt;<br>
         `mat3x2<T>(e1,e2,e3)`: mat3x2&lt;|T|&gt;<br>
         `mat4x2<T>(e1,e2,e3,e4)`: mat4x2&lt;|T|&gt;
     <td rowspan=2>Column by column construction.<br>
   <tr>
     <td>`mat2x2(e1,e2)`: mat2x2&lt;|T|&gt;<br>
         `mat3x2(e1,e2,e3)`: mat3x2&lt;|T|&gt;<br>
         `mat4x2(e1,e2,e3,e4)`: mat4x2&lt;|T|&gt;
   <tr>
     <td rowspan=2>*e1*: vec3&lt;|T|&gt;<br>
         *e2*: vec3&lt;|T|&gt;<br>
         *e3*: vec3&lt;|T|&gt;<br>
         *e4*: vec3&lt;|T|&gt;<br>
     <td>`mat2x3<T>(e1,e2)`: mat2x3&lt;|T|&gt;<br>
         `mat3x3<T>(e1,e2,e3)`: mat3x3&lt;|T|&gt;<br>
         `mat4x3<T>(e1,e2,e3,e4)`: mat4x3&lt;|T|&gt;
     <td rowspan=2>Column by column construction.<br>
   <tr>
     <td>`mat2x3(e1,e2)`: mat2x3&lt;|T|&gt;<br>
         `mat3x3(e1,e2,e3)`: mat3x3&lt;|T|&gt;<br>
         `mat4x3(e1,e2,e3,e4)`: mat4x3&lt;|T|&gt;
   <tr>
     <td rowspan=2>*e1*: vec4&lt;|T|&gt;<br>
         *e2*: vec4&lt;|T|&gt;<br>
         *e3*: vec4&lt;|T|&gt;<br>
         *e4*: vec4&lt;|T|&gt;<br>
     <td>`mat2x4<T>(e1,e2)`: mat2x4&lt;|T|&gt;<br>
         `mat3x4<T>(e1,e2,e3)`: mat3x4&lt;|T|&gt;<br>
         `mat4x4<T>(e1,e2,e3,e4)`: mat4x4&lt;|T|&gt;
     <td rowspan=2>Column by column construction.<br>
   <tr>
     <td>`mat2x4(e1,e2)`: mat2x4&lt;|T|&gt;<br>
         `mat3x4(e1,e2,e3)`: mat3x4&lt;|T|&gt;<br>
         `mat4x4(e1,e2,e3,e4)`: mat4x4&lt;|T|&gt;
 </table>


<table class='data'>
  <caption>Array constructor type rules</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="array value construction">
    <td>|e1|: |T|<br>
        ...<br>
        |eN|: |T|,<br>
        |T| is [=constructible=]<br>
    <td class="nowrap">`array<`|T|,|N|`>(`|e1|,...,|eN|`)` : array&lt;|T|,|N|&gt;
    <td>Construction of an array from elements.

     注意：数组<|T|,|N|> 是 [=constructible=] 因为它的 [=element count=] 等于构造函数的参数数量，并且在 [=shader module creation|shader-creation=] 时完全确定。
</table>

<table class='data'>
  <caption>结构构造函数类型规则</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="structure value construction">
    <td>|e1|: |T1|<br>
        ...<br>
        |eN|: |TN|,<br>
        |S| is a [=constructible=] structure type with members having types |T1| ... |TN|.<br>
        The expression is in the scope of declaration of |S|.
    <td class="nowrap">|S|`(`|e1|,...,|eN|`)`: |S|
    <td>从成员进行的结构构造。
</table>

### 零值表达式 ### {#zero-value-expr}

每个可构造的（[=constructible=]） *T* 都有一个唯一的零值（<dfn noexport>zero value</dfn>），在 WGSL 中编写为，类型后面跟一对空括号：*T* `()`。

零值如下：

* `bool()` 为 `false`
* `i32()` 为 0
* `u32()` 为 0
* `f32()` 为 0.0
* `f16()` is 0.0

* 具有 *N* 个类型 *T* 元素的向量的零值为一个 *N*-元素向量，每个分量值为 *T* 的零值。
* *T* 类型的 *C* 列 *R* 行矩阵的零值是用 *T* 的零值填充的那些维度的矩阵。
* 具有可构造（[=constructible=]）元素类型 *E* 的 *N*-元素向量的零值为一个有 *N* 个元素的数组，数组的每个分量为 *E* 的零值。
* 可构造（[=constructible=]）类型 *S* 的零值为构造值 *S* 的零值成员。

注意：WGSL中原子类型（[=atomic types=]），[=runtime-sized=]数组，以及其他非可构造（[=constructible=]）类型没有零值表达式。

<table class='data'>
  <caption>标量零值类型规则</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr><td><td>`bool()`: bool<td>false<br>Zero value
  <tr><td><td>`i32()`: i32<td>0<br>Zero value
  <tr><td><td>`u32()`: u32<td>0u<br>Zero value
  <tr><td><td>`f32()`: f32<td>0.0<br>Zero value
  <tr><td><td>`f16()`: f16<td>0.0<br>Zero value
</table>

<table class='data'>
  <caption>向量零值类型规则，其中 |T| 为标量类型</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr>
    <td>
    <td>`vec2<T>()`: vec2<|T|>
    <td>Zero value
  <tr>
    <td>
    <td>`vec3<T>()`: vec3<|T|>
    <td>Zero value
  <tr>
    <td>
    <td>`vec4<T>()`: vec4<|T|>
    <td>Zero value
</table>


<div class='example' heading="Zero-valued vectors">
  <xmp highlight='rust'>
    vec2<f32>()                 // 两个 f32 元素的零值向量。
    vec2<f32>(0.0, 0.0)         // 相同的值，明确写入。

    vec3<i32>()                 // 三个 i32 元素的零值向量。
    vec3<i32>(0, 0, 0)          // 相同的值，明确写入。
  </xmp>
</div>

<table class='data'>
  <caption>矩阵零值类型规则</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <td>|T| is f32 or f16
    <td>`mat2x2<T>()`: mat2x2&lt;|T|&gt;<br>
        `mat3x2<T>()`: mat3x2&lt;|T|&gt;<br>
        `mat4x2<T>()`: mat4x2&lt;|T|&gt;
    <td>Zero value
  <tr>
    <td>
    <td>`mat2x3<T>()`: mat2x3&lt;|T|&gt;<br>
        `mat3x3<T>()`: mat3x3&lt;|T|&gt;<br>
        `mat4x3<T>()`: mat4x3&lt;|T|&gt;
    <td>Zero value
  <tr>
    <td>
    <td>`mat2x4<T>()`: mat2x4&lt;|T|&gt;<br>
        `mat3x4<T>()`: mat3x4&lt;|T|&gt;<br>
        `mat4x4<T>()`: mat4x4&lt;|T|&gt;
    <td>Zero value
</table>

<table class='data'>
  <caption>数组零值类型规则</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="array zero value">
    <td>|T| is a [=constructible=]
    <td>`array<`|T|,|N|`>()`: array&lt;|T|,|N|&gt;
    <td>零值数组 (OpConstantNull)
</table>

<div class='example' heading="Zero-valued arrays">
  <xmp highlight='rust'>
    array<bool, 2>()               // 两个布尔值的零值数组。
    array<bool, 2>(false, false)   // 相同的值，明确写入。
  </xmp>
</div>

<table class='data'>
  <caption>结构零值类型规则</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="structure zero value">
    <td>|S| is a [=constructible=] structure type.<br>
         The expression is in the scope of declaration of |S|.
    <td>|S|`()`: |S|
    <td>零值结构：类型为 |S| 的结构，每个成员为其成员类型的零值。
<br>
 (OpConstantNull)
</table>

<div class='example wgsl global-scope' heading="Zero-valued structures">
  <xmp highlight='rust'>
    struct Student {
      grade: i32,
      GPA: f32,
      attendance: array<bool,4>
    }

    fn func() {
      var s: Student;

      // Student 的零值。
      s = Student();

      // 相同的值，明确写入。
      s = Student(0, 0.0, array<bool,4>(false, false, false, false));

      // 相同的值，用零值成员写入。
      s = Student(i32(), f32(), array<bool,4>());
    }
  </xmp>
</div>


### 转换表达式 ### {#conversion-expr}

WGSL 不隐式转换或提升一个数值或布尔值为另外的类型。而是使用以下表格中描述的转换表达式<dfn>conversion expression</dfn>。

有关与浮点类型之间的转换的详细信息，请参阅 [[#floating-point-conversion]]。

<table class='data'>
  <caption>标量转换类型规则</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="从无符号强制转换为布尔值">
      <td>|e|: u32<td>`bool(`|e|`)`: bool
      <td>强制转换为布尔值。<br>
          如果 |e| 则结果为假为 0，否则为真。
  <tr algorithm="从签名强制转换为布尔值">
      <td>|e|: i32<td>`bool(`|e|`)`: bool
      <td>强制转换为布尔值。<br>
          如果 |e| 则结果为假为 0，否则为真。
  <tr algorithm="coercion to boolean from binary32 floating point">
      <td>|e|: f32<td>`bool(`|e|`)`: bool
      <td>强制转换为布尔值。<br>
          如果 |e| 则结果为假为 0.0 或 -0.0，否则为真。
          特别是 NaN 和无穷大值映射为真。
  <tr algorithm="coercion to boolean from binary16 floating point">
      <td>|e|: f16<td>`bool(`|e|`)`: bool
      <td>强制转换为布尔值。<br>
          如果 |e| 则结果为假为 0.0 或 -0.0，否则为真。
          特别是 NaN 和无穷大值映射为真。
  <tr algorithm="从布尔到有符号的转换">
      <td>|e|: bool<td>`i32(`|e|`)`: i32
      <td>将布尔值转换为有符号整数<br>
          如果 |e|，则结果为 1为真，否则为 0。<br>
  <tr algorithm="从无符号到有符号的标量重新解释">
      <td>|e|: u32<td>`i32(`|e|`)`: i32
      <td>重新解释比特。<br>
          结果是 [=i32=] 中的唯一值，它与 |e| 具有相同的位模式。
  <tr algorithm="从浮点到有符号整数的标量转换">
      <td>|e|: f32<td>`i32(`|e|`)`: i32
      <td>值转换，向零舍入。
  <tr algorithm="从二进制16浮点到有符号整数的标量转换">
      <td>|e|: f16<td>`i32(`|e|`)`: i32
      <td>值转换，向零舍入。
  <tr algorithm="从布尔到无符号的转换">
      <td>|e|: bool<td>`u32(`|e|`)`: u32
      <td>将布尔值转换为无符号整数。<br>
          如果 |e|，则结果为 1u为真，否则为 0u。
  <tr algorithm="从有符号整数到无符号整数的标量转换">
      <td>|e|：AbstractInt 或 i32<td>`u32(`|e|`)`：u32
      <td>重新解释比特。<br>
          结果是 [=u32=] 中的唯一值，它与 |e| 具有相同的位模式。
  <tr algorithm="从浮点到无符号整数的标量转换">
      <td>|e|: f32<td>`u32(`|e|`)`: u32
      <td>值转换，向零舍入。
  <tr algorithm="从二进制16浮点到无符号整数的标量转换">
      <td>|e|: f16<td>`u32(`|e|`)`: u32
      <td>值转换，向零舍入。
  <tr algorithm="从 boolean 到 binary32 浮点的转换">
      <td>|e|: bool<td>`f32(`|e|`)`: f32
      <td>将布尔值转换为浮点数。<br>
          如果 |e|，则结果为 1.0为真，否则为 0.0。
  <tr algorithm="从有符号整数到二进制32浮点的标量转换">
      <td>|e|: i32<td>`f32(`|e|`)`: f32<td>值转换，包括无效情况。
  <tr algorithm="从无符号整数到二进制32浮点的标量转换">
      <td>|e|: u32<td>`f32(`|e|`)`: f32<td>值转换，包括无效的情况。
  <tr algorithm="从 binary16 浮点到 binary32 浮点的标量转换">
      <td>|e|: f16<td>`f32(`|e|`)`: f32<td>精确值转换。
  <tr algorithm="从 boolean 到 binary16 浮点的转换">
      <td>|e|: bool<td>`f16(`|e|`)`: f16
      <td>布尔值到浮点的转换<br>
          如果 |e|，则结果为 1.0为真，否则为 0.0。
  <tr algorithm="从有符号整数到二进制16浮点的标量转换">
      <td>|e|: i32<td>`f16(`|e|`)`: f16<td>值转换，包括无效情况。
  <tr algorithm="从无符号整数到二进制16浮点的标量转换">
      <td>|e|: u32<td>`f16(`|e|`)`: f16<td>值转换，包括无效的情况。
  <tr algorithm="从 binary32 浮点到 binary16 浮点的标量转换">
      <td>|e|: f32<td>`f16(`|e|`)`: f16<td>有损值转换。
</table>

[[#floating-point-conversion]]中解释了与浮点之间的转换细节。

<tr algorithm="无符号整数到布尔值的向量强制">
     <td>|e|: vec|N|<u32>;
     <td>`vec`|N|&lt;`bool`&gt;`(`|e|`)`: vec|N|&lt;bool&gt
     <td>[=Component-wise=] 将无符号整数向量强制转换为布尔向量。

  <tr algorithm="有符号整数到布尔值的向量强制">
     <td>|e|: vec|N|<i32>;
     <td>`vec`|N|&lt;`bool`&gt;`(`|e|`)`: vec|N|&lt;bool&gt
     <td>[=Component-wise=] 将有符号整数向量强制转换为布尔向量。

  <tr algorithm="二进制32浮点到布尔的向量强制">
     <td>|e|: vec|N|<f32>;
     <td>`vec`|N|&lt;`bool`&gt;`(`|e|`)`: vec|N|&lt;bool&gt
     <td>[=Component-wise=] 将 binary32 浮点向量强制转换为布尔向量。

  <tr algorithm="二进制16浮点到布尔的向量强制">
     <td>|e|: vec|N|<f16>;
     <td>`vec`|N|&lt;`bool`&gt;`(`|e|`)`: vec|N|&lt;bool&gt
     <td>[=Component-wise=] 将 binary16 浮点向量强制转换为布尔向量。

  <tr algorithm="从bool到有符号的向量转换">
     <td>|e|: vec|N|<bool>;
     <td>`vec`|N|&lt;`i32`&gt;`(`|e|`)`: vec|N|&lt;i32&gt
     <td>[=Component-wise=] 将布尔向量转换为有符号向量。<br>
         组件 |i|结果是 `i32(`|e|`[`|i|`])`

  <tr algorithm="从无符号到有符号的向量重新解释">
     <td>|e|: vec|N|<u32>;
     <td>`vec`|N|&lt;`i32`&gt;`(`|e|`)`: vec|N|&lt;i32&gt
     <td>[=Component-wise=] 重新解释位。<br>
         组件 |i|结果是 `i32(`|e|`[`|i|`])`

  <tr algorithm="从二进制32浮点到有符号整数的向量转换">
     <td>|e|: vec|N|<f32>;
     <td>`vec`|N|&lt;`i32`&gt;`(`|e|`)`: vec|N|&lt;i32&gt;
     <td>[=Component-wise=] 值转换为有符号整数，包括无效情况。

  <tr algorithm="从二进制16浮点到有符号整数的向量转换">
     <td>|e|: vec|N|<f16>;
     <td>`vec`|N|&lt;`i32`&gt;`(`|e|`)`: vec|N|&lt;i32&gt;
     <td>[=Component-wise=] 值转换为有符号整数，包括无效情况。

  <tr algorithm="从 bool 到 unsigned 的向量转换">
     <td>|e|: vec|N|<bool>;
     <td>`vec`|N|&lt;`u32`&gt;`(`|e|`)`: vec|N|&lt;u32&gt
     <td>[=Component-wise=] 将布尔向量转换为无符号向量。<br>
         组件 |i|结果是 `u32(`|e|`[`|i|`])`

  <tr algorithm="从有符号到无符号的向量重新解释">
     <td>|e|: vec|N|&lt;AbstractInt&gt;或 vec|N|&lt;i32&gt;
     <td>`vec`|N|&lt;`u32`&gt;`(`|e|`)`: vec|N|&lt;u32&gt;
     <td>[=Component-wise=] 重新解释位。

  <tr algorithm="从二进制32浮点到无符号整数的向量转换">
     <td>|e|: vec|N|<f32>;
     <td>`vec`|N|&lt;`u32`&gt;`(`|e|`)`: vec|N|&lt;u32&gt;
     <td>[=Component-wise=] 值转换为无符号整数，包括无效的情况。

  <tr algorithm="从二进制16浮点到无符号整数的向量转换">
     <td>|e|: vec|N|<f16>;
     <td>`vec`|N|&lt;`u32`&gt;`(`|e|`)`: vec|N|&lt;u32&gt;
     <td>[=Component-wise=] 值转换为无符号整数，包括无效的情况。

  <tr algorithm="bool 到 binary32 浮点的向量转换">
     <td>|e|: vec|N|<bool>;
     <td>`vec`|N|&lt;`f32`&gt;`(`|e|`)`: vec|N|&lt;f32&gt
     <td>[=Component-wise=] 将布尔向量转换为浮点数。<br>
         组件 |i|结果是 `f32(`|e|`[`|i|`])`

  <tr algorithm="从有符号整数到二进制32浮点的向量转换">
     <td>|e|: vec|N|<i32>;
     <td>`vec`|N|&lt;`f32`&gt;`(`|e|`)`: vec|N|&lt;f32&gt;
     <td>[=Component-wise=] 值转换为 binary32 浮点，包括无效的情况。

  <tr algorithm="从无符号整数到二进制32浮点的向量转换">
     <td>|e|: vec|N|<f32>;
     <td>`vec`|N|&lt;`f32`&gt;`(`|e|`)`: vec|N|&lt;f32&gt;
     <td>[=Component-wise=] 值转换为 binary32 浮点，包括无效的情况。

  <tr algorithm="binary16浮点到binary32浮点的向量转换">
     <td>|e|: vec|N|<f16>;
     <td>`vec`|N|&lt;`f32`&gt;`(`|e|`)`: vec|N|&lt;f32&gt;
     <td>[=Component-wise=] 将精确值转换为 binary32 浮点数。

  <tr algorithm="bool 到 binary16 浮点的向量转换">
     <td>|e|: vec|N|<bool>;
     <td>`vec`|N|&lt;`f16`&gt;`(`|e|`)`: vec|N|&lt;f16&gt
     <td>[=Component-wise=] 将布尔向量转换为 binary16 浮点。<br>
         组件 |i|结果是 `f16(`|e|`[`|i|`])`

  <tr algorithm="从有符号整数到二进制16浮点的向量转换">
     <td>|e|: vec|N|<i32>;
     <td>`vec`|N|&lt;`f16`&gt;`(`|e|`)`: vec|N|&lt;f16&gt;
     <td>[=Component-wise=] 值转换为 binary16 浮点，包括无效的情况。

<tr algorithm="从无符号整数到二进制16浮点的向量转换">
      <td>|e|: vec|N|<u32>;
      <td>`vec`|N|&lt;`f16`&gt;`(`|e|`)`: vec|N|&lt;f&gt;
      <td>[=Component-wise=] 值转换为 binary16 浮点数，包括无效的情况。

   <tr algorithm="binary32浮点到binary16浮点的向量转换">
      <td>|e|: vec|N|<f32>;
      <td>`vec`|N|&lt;`f16`&gt;`(`|e|`)`: vec|N|&lt;f16&gt;
      <td>[=Component-wise=] 有损值转换为 binary16 浮点。
</table>

<表类='数据'>
   <caption>矩阵转换类型规则</caption>
   <头>
     <tr><th>前提条件<th>结论<th>注意事项
   </thead>
   <tr algorithm="binary16 浮点到 binary32 浮点的矩阵强制转换">
      <td>|e|: 垫子|C|x|R|<f16>;
      <td>`mat`|C|`x`|R|&lt;`f32`&gt;`(`|e|`)`: mat|C|x|R|&lt;f32&gt
      <td>[=Component-wise=] 将精确值转换为 binary32 浮点。

   <tr algorithm="binary32浮点到binary16浮点的向量强制">
      <td>|e|: 垫子|C|x|R|<f32>;
      <td>`mat`|C|`x`|R|&lt;`f16`&gt;`(`|e|`)`: mat|C|x|R|&lt;f16&gt
      <td>[=Component-wise=] 有损值转换为 binary16 浮点。

</table>

## 表示表达式的重新解释 ## {#bitcast-expr}

`bitcast`表达式用于将一种类型中的值的位表示重新解释为另一种类型中的值。

<table class='data'>
  <caption>Bitcast类型规则</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>

  <tr algorithm="身份重新解释">
    <td>|e|: |T|<br>
    |T|是 [=numeric scalar=] 或 [=numeric vector=] 类型
    <td class="nowrap">比特广播&lt;|T|&gt;(|e|): |T|
    <td>身份转换。 [=Component-wise=] 当 |T|是一个向量。<br>
    结果是|e|。

  <tr algorithm="32 位标量重新解释">
    <td>|e|: |T1|<br>
    |T1|是 i32、u32 还是 f32<br>
    |T2|不是 |T1|并且是 i32、u32 或 f32
    <td class="nowrap">比特广播&lt;|T2|&gt;(|e|): |T2|
    <td>将位重新解释为|T2|。 <br>
    结果是重新解释 |e| 中的位。作为 |T2|价值。

  <tr algorithm="32位元素向量重新解释">
    <td>|e|: vec|N|<|T1|><br>
    |T1|是 i32、u32 还是 f32<br>
    |T2|不是 |T1|并且是 i32、u32 或 f32
    <td class="nowrap">bitcast<vec|N|<|T2|&gt;&gt;(|e|): vec|N|<|T2|&gt;
    <td>[=Component-wise=] 将位重新解释为 |T2|。<br>
    结果是重新解释 |e| 中的位。作为 vec|N|<|T2|>;价值。

  <tr algorithm="binary16x2 to 32-bit scalar reinterpretation">
    <td>|e|: vec2<f16><br>
    |T|是 i32、u32 或 f32
    <td class="nowrap">比特广播&lt;|T|&gt;(|e|): |T|
    <td>将位重新解释为 |T|。<br>
    结果是重新解释 |e| 中的 32 位。作为 |T|值，遵循内部布局规则。

  <tr algorithm="32-bit scalar to binary16x2 reinterpretation">
    <td>|e|: |T|<br>
    |T|是 i32、u32 或 f32
    <td class="nowrap">bitcast&lt;vec2&lt;f16&gt;&gt;(|e|): vec2&lt;f16&gt;
    <td>将位重新解释为 vec2<f16>。<br>
    结果是重新解释 |e| 中的 32 位。作为 vec2&lt;f16&gt;值，遵循内部布局规则。

  <tr algorithm="binary16x4 to vec2 of 32-bit scalar reinterpretation">
    <td>|e|: vec4<f16><br>
    |T|是 i32、u32 或 f32
    <td class="nowrap">bitcast<vec2<|T|&gt;&gt;(|e|): vec2<|T|&gt;
    <td>将位重新解释为 vec2<|T|>.<br>
    结果是重新解释 |e| 中的 64 位。作为 vec2<|T|>;值，遵循内部布局规则。

  <tr algorithm="vec2 of 32-bit scalar to binary16x4 reinterpretation">
    <td>|e|: vec2<|T|><br>
    |T|是 i32、u32 或 f32
    <td class="nowrap">bitcast&lt;vec4&lt;f16&gt;&gt;(|e|): vec4&lt;f16&gt;
    <td>将位重新解释为 vec4<f16>。<br>
    结果是重新解释 |e| 中的 64 位。作为 vec4&lt;f16&gt;值，遵循内部布局规则。

</table>
内部布局规则在 [[#internal-value-layout]] 中描述。

## 复合值分解表达式 ## {#composite-value-decomposition-expr}

### 向量访问表达式 ### {#vector-access-expr}

访问向量的成员可以使用数组下标（例如 `a[2]`）或使用一系列便名，每个成员都映射到源向量的一个元素。

<ul>
  <li>颜色的便名集合为 `r`, `g`, `b`, `a` ，分别对应向量元素 0, 1, 2, 和 3。
  <li>维度的便名集合为 `x`, `y`, `z`, `w` ，分别对应向量元素 0, 1, 2, 和 3。
</ul>

便名访问通过 `.` 符号。（比如，`color.bgra`）

注意：便名字母不能倍混合使用。（即，你不能使用 `rybw`）

使用便名字母，或数组下标，访问超过向量末尾的元素会出现错误。

便名字母可以按任何顺序应用，包括根据需要复制字母。从向量中提取分量时，你可以提供 1 到 4 个字母。提供超过 4 个字母是错误的。

结果类型取决于提供的字母。假设为一个 `vec4<f32>`
<table>
  <thead>
    <tr><th>Accessor<th>Result type
  </thead>
  <tr><td>r<td>`f32`
  <tr><td>rg<td>`vec2<f32>`
  <tr><td>rgb<td>`vec3<f32>`
  <tr><td>rgba<td>`vec4<f32>`
</table>

<div class='example wgsl function-scope'>
  <xmp highlight='rust'>
    var a: vec3<f32> = vec3<f32>(1., 2., 3.);
    var b: f32 = a.y;          // b = 2.0
    var c: vec2<f32> = a.bb;   // c = (3.0, 3.0)
    var d: vec3<f32> = a.zyx;  // d = (3.0, 2.0, 1.0)
    var e: f32 = a[1];         // e = 2.0
  </xmp>
</div>

#### 向量单分量选择 #### {#vector-single-component}

<table class='data'>
  <caption>向量分解：单分量选择</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="first vector component selection"><td>|e|: vec|N|&lt;|T|&gt;<br>
       <td class="nowrap">
           |e|`.x`: |T|<br>
           |e|`.r`: |T|
       <td>选择 |e| 的第一个分量<br>
  <tr algorithm="second vector component selection"><td>|e|: vec|N|&lt;|T|&gt;<br>
       <td class="nowrap">
           |e|`.y`: |T|<br>
           |e|`.g`: |T|
       <td>选择 |e| 的第二个分量<br>
  <tr algorithm="third vector component selection"><td>|e|: vec|N|&lt;|T|&gt;<br>
          |N| is 3 or 4
       <td class="nowrap">
           |e|`.z`: |T|<br>
           |e|`.b`: |T|
       <td>选择 |e| 的第三个分量<br>
  <tr algorithm="fourth vector component selection"><td>|e|: vec4&lt;|T|&gt;
       <td class="nowrap">
           |e|`.w`: |T|<br>
           |e|`.a`: |T|
       <td>选择 |e| 的第四个分量<br>
  <tr algorithm="vector indexed component selection"><td>|e|: vec|N|&lt;|T|&gt;<br>
          |i|: [INT]
       <td class="nowrap">
           |e|[|i|]: |T|
       <td>选择 |e| 的第 |i| 个分量<br>
           第一个分量在 |i|=0 处。
           如果 |i| 在区间 [0,|N|-1] 外，那么 |T| 的任何值都可能被返回。
</table>

#### 向量多分量选择 #### {#vector-multi-component}

<table class='data'>
  <caption>向量分解：多分量选择
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="two component vector selection using .x .y">
       <td class="nowrap">
          |e|: vec|N|&lt;|T|&gt;<br>
          |I| 为字母 `x`, `y`, `z`, 或 `w`<br>
          |J| 为字母 `x`, `y`, `z`, 或 `w`<br>
       <td class="nowrap">
           |e|`.`|I||J|: vec2&lt;|T|&gt;<br>
       <td>使用第一个分量 |e|.|I| 和第二个分量 |e|.|J| 来计算2-元素向量。<br>
       仅当 |N| 为 3 或 4 时，字母 `z` 有效。<br>
       仅当 |N| 为 4 时，字母 `w` 有效。<br>
  <tr algorithm="two component vector selection using .r .g">
       <td class="nowrap">
          |e|: vec|N|&lt;|T|&gt;<br>
          |I| 为字母 `r`, `g`, `b`, 或 `a`<br>
          |J| 为字母 `r`, `g`, `b`, 或 `a`<br>
       <td class="nowrap">
           |e|`.`|I||J|: vec2&lt;|T|&gt;<br>
       <td>使用第一个分量 |e|.|I| 和第二个分量 |e|.|J| 来计算2-元素向量。<br>
       仅当 |N| 为 3 或 4 时，字母 `b` 有效。<br>
       仅当 |N| 为 4 时，字母 `a` 有效。<br>
  <tr algorithm="three component vector selection using .x .y">
       <td class="nowrap">
          |e|: vec|N|&lt;|T|&gt;<br>
          |I| 为字母 `x`, `y`, `z`, 或 `w`<br>
          |J| 为字母 `x`, `y`, `z`, 或 `w`<br>
          |K| 为字母 `x`, `y`, `z`, 或 `w`<br>
       <td class="nowrap">
           |e|`.`|I||J||K|: vec3&lt;|T|&gt;<br>
       <td>使用第一个分量 |e|.|I| 和第二个分量 |e|.|J|，以及第三个分量 |e|.|K| 来计算3-元素向量。<br>
       仅当 |N| 为 3 或 4 时，字母 `z` 有效。<br>
       仅当 |N| 为 4 时，字母 `w` 有效。<br>
  <tr algorithm="three component vector selection using .r .g">
       <td class="nowrap">
          |e|: vec|N|&lt;|T|&gt;<br>
          |I| 为字母 `r`, `g`, `b`, 或 `a`<br>
          |J| 为字母 `r`, `g`, `b`, 或 `a`<br>
          |K| 为字母 `r`, `g`, `b`, 或 `a`<br>
       <td class="nowrap">
           |e|`.`|I||J||K|: vec3&lt;|T|&gt;<br>
       <td>使用第一个分量 |e|.|I| 和第二个分量 |e|.|J|，以及第三个分量 |e|.|K| 来计算3-元素向量。<br>
       仅当 |N| 为 3 或 4 时，字母 `b` 有效。<br>
       仅当 |N| 为 4 时，字母 `a` 有效。<br>
  <tr algorithm="four component vector selection using .x .y">
       <td class="nowrap">
          |e|: vec|N|&lt;|T|&gt;<br>
          |I| 为字母 `x`, `y`, `z`, 或 `w`<br>
          |J| 为字母 `x`, `y`, `z`, 或 `w`<br>
          |K| 为字母 `x`, `y`, `z`, 或 `w`<br>
          |L| 为字母 `x`, `y`, `z`, 或 `w`<br>
       <td class="nowrap">
           |e|`.`|I||J||K||L|: vec4&lt;|T|&gt;<br>
       <td>使用第一个分量 |e|.|I| 和第二个分量 |e|.|J|，第三个分量 |e|.|K|，以及第四个分量 |e|.|L| 来计算4-元素向量。<br>
       仅当 |N| 为 3 或 4 时，字母 `z` 有效。<br>
       仅当 |N| 为 4 时，字母 `w` 有效。<br>
  <tr algorithm="four component vector selection using .r .g">
       <td class="nowrap">
          |e|: vec|N|&lt;|T|&gt;<br>
          |I| 为字母 `r`, `g`, `b`, 或 `a`<br>
          |J| 为字母 `r`, `g`, `b`, 或 `a`<br>
          |K| 为字母 `r`, `g`, `b`, 或 `a`<br>
          |L| 为字母 `r`, `g`, `b`, 或 `a`<br>
       <td class="nowrap">
           |e|`.`|I||J||K||L|: vec4&lt;|T|&gt;<br>
       <td>使用第一个分量 |e|.|I| 和第二个分量 |e|.|J|，第三个分量 |e|.|K|，以及第四个分量 |e|.|L| 来计算4-元素向量。<br>
       仅当 |N| 为 3 或 4 时，字母 `b` 有效。<br>
       仅当 |N| 为 4 时，字母 `a` 有效。<br>
</table>

#### 来自向量引用的分量引用 #### {#component-reference-from-vector-reference}

对向量的分量的写访问（[=write access=]）**可能** 访问与该向量相关联的所有内存位置（[=memory
location|memory locations=]）。

注意：这意味着如果至少一个访问是写访问，则通过不同调用对向量的不同组件的访问必须被同步。见[[#sync-builtin-functions]]。

<table class='data'>
  <caption>从对向量的引用获取对分量的引用</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="first vector component reference selection">
       <td>|r|: ref&lt;|S|,vec|N|&lt;|T|&gt;&gt;<br>
       <td class="nowrap">
           |r|`.x`: ref&lt;|S|,|T|&gt;<br>
           |r|`.r`: ref&lt;|S|,|T|&gt;<br>
       <td>计算引用 |r| 所引用的向量的第一个分量的引用。<br>
       结果引用的原始变量（[=originating variable=]）与 |r| 的原始变量相同。<br>
  <tr algorithm="second vector component reference selection">
       <td>|r|: ref&lt;|S|,vec|N|&lt;|T|&gt;&gt;<br>
       <td class="nowrap">
           |r|`.y`: ref&lt;|S|,|T|&gt;<br>
           |r|`.g`: ref&lt;|S|,|T|&gt;<br>
       <td>计算引用 |r| 所引用的向量的第二个分量的引用。<br>
       结果引用的原始变量（[=originating variable=]）与 |r| 的原始变量相同。<br>
  <tr algorithm="third vector component reference selection">
       <td>|r|: ref&lt;|S|,vec|N|&lt;|T|&gt;&gt;<br>
           |N| is 3 or 4
       <td class="nowrap">
           |r|`.z`: ref&lt;|S|,|T|&gt;<br>
           |r|`.b`: ref&lt;|S|,|T|&gt;<br>
       <td>计算引用 |r| 所引用的向量的第三个分量的引用。<br>
       结果引用的原始变量（[=originating variable=]）与 |r| 的原始变量相同。<br>
  <tr algorithm="fourth vector component reference selection">
       <td>|r|: ref&lt;|S|,vec4&lt;|T|&gt;&gt;<br>
       <td class="nowrap">
           |r|`.w`: ref&lt;|S|,|T|&gt;<br>
           |r|`.a`: ref&lt;|S|,|T|&gt;<br>
       <td>计算引用 |r| 所引用的向量的第四个分量的引用。<br>
       结果引用的原始变量（[=originating variable=]）与 |r| 的原始变量相同。<br>
  <tr algorithm="vector indexed component reference selection">
       <td>|r|: ref&lt;|S|,vec|N|&lt;|T|&gt;&gt;<br>
          |i|: [INT]
       <td class="nowrap">
           |r|[|i|] : ref&lt;|S|,|T|&gt;
       <td>计算引用 |r| 所引用的向量的第 |i| 个分量的引用。
       如果 |i| 在区间 [0,|N|-1] 外，则表达式计算为 [=invalid memory reference=]。
       结果引用的原始变量（[=originating variable=]）与 |r| 的原始变量相同。<br>
</table>

### 矩阵访问表达式 ### {#matrix-access-expr}

<table class='data'>
  <caption>列向量提取</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="matrix indexed column vector selection">
       <td class="nowrap">
          |e|: mat|C|x|R|&lt;|T|&gt;<br>
          |i|: [INT]
       <td class="nowrap">
           |e|[|i|]: vec|R|&lt;|T|&gt;
       <td>结果为向量 |e| 的第 |i| 列。如果 |i| 在区间 [0,|C|-1]，则可能返回 vec|R|&lt;|T|&gt; 的无效值。
</table>

<table class='data'>
  <caption>从对矩阵的引用获取对列向量的引用</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="matrix indexed column vector reference selection">
       <td class="nowrap">
          |r|: ref&lt;|S|,mat|C|x|R|&lt;|T|&gt;&gt;<br>
          |i|: [INT]
       <td class="nowrap">
           |r|[|i|] : ref&lt;vec|R|&lt;|S|,|T|&gt;&gt;
       <td>通过引用 |r| 计算矩阵第 |i| 个列向量的引用。
       如果 |i| 在区间 [0,|C|-1] 外，则表达式计算为无效内存引用（[=invalid memory reference=]）。
       结果引用的原始变量（[=originating variable=]）与 |r| 的原始变量相同。<br>
</table>


### 数组访问表达式 ### {#array-access-expr}

<table class='data'>
  <caption>数组元素提取</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="fixed-size array indexed element selection">
       <td class="nowrap">
          |e|: array&lt;|T|,|N|&gt;<br>
          |i|: [INT]
       <td class="nowrap">
           |e|[|i|] : |T|
       <td>结果为数组值 |e| 的第 |i| 个元素的值。
       如果 |i| 在区间 [0,|N|-1] 外，则任何 |T| 的有效值可能被返回。
</table>

<table class='data'>
  <caption>从对数组的引用获取对数组元素的引用</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="fixed-size array indexed reference selection">
       <td class="nowrap">
          |r|: ref&lt;|S|,array&lt;|T|,|N|&gt;&gt;<br>
          |i|: [INT]
       <td class="nowrap">
           |r|[|i|] : ref&lt;|S|,|T|&gt;
       <td>计算对由引用 |r| 引用的数组的第 |i| 个元素的引用。

       如果 |i| 在区间 [0,|N|-1] 外，则表达式计算为一个无效内存引用（[=invalid memory reference=]）。

       结果引用的原始变量（[=originating variable=]）与 |r| 的原始变量相同。
  <tr algorithm="array indexed reference selection">
       <td>|r|: ref&lt;|S|,array&lt;|T|&gt;&gt;<br>
          |i|: [INT]
       <td class="nowrap">
           |r|[|i|] : ref&lt;|S|,|T|&gt;
       <td>计算对由引用 |r| 引用的runtime-sized数组的第 |i| 个元素的引用。

       如果在运行时数组有 |N| 个元素，且 |i| 在区间 [0,|N|-1] 外，则表达式计算为一个无效内存引用（[=invalid memory reference=]）。

       结果引用的原始变量（[=originating variable=]）与 |r| 的原始变量相同。
</table>


### 结构访问表达式 ### {#struct-access-expr}

<table class='data'>
  <caption>结构成员提取</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="structure member extraction">
       <td class="nowrap">
          |S| 为一个结构类型<br>
          |M| 为类型为 |T| 的 |S| 中成员的标识符名称。<br>
          |e|: |S|<br>
       <td class="nowrap">
           |e|.|M|: |T|
       <td>结果是结构值 |e| 中名称为 |M| 的成员的值。

</table>

<table class='data'>
  <caption>从对结构的引用获取对结构成员的引用</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="structure member reference selection">
       <td class="nowrap">
          |S| 为一个结构类型<br>
          |M| 为类型为 |T| 的 |S| 中的成员名称。<br>
          |r|: ref&lt;|SC|,|S|&gt;<br>
       <td class="nowrap">
           |r|.|M|: ref&lt;|SC|,|T|&gt;
       <td>给定对结构的引用，结果是对标识符名称为 |M| 的结构成员的引用。结果引用的原始变量（[=originating variable=]）与 |r| 的原始变量相同。

</table>

## 逻辑表达式 ## {#logical-expr}
<table class='data'>
  <caption>一元逻辑运算</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="boolean negation"><td>|e|: bool<br>|T| 为布尔值或 vec|N|&lt;bool&gt;
  <td>`!`|e|: |T|
  <td>逻辑否定。

  当 |e| 为 `false` 时结果为 `true`，当 |e| 为 `true` 是结果为 `false`。

  当 |T| 为向量时，[=Component-wise=]。
</table>

<table class='data'>
  <caption>二元逻辑表达式</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="short-circuiting or"><td>|e1|: bool<br>|e2|: bool<td>|e1| `||` |e2|`: bool`
  <td>短路“或”。如果 |e1| 或 |e2| 为真，则为真； 仅当 |e1| 为假时才计算 |e2|。

  <tr algorithm="short-circuiting and"><td>|e1|: bool<br>|e2|: bool
  <td>|e1| `&&` |e2|`: bool`
  <td>短路“与”。 如果 |e1| 和 |e2| 都为真，则为真； 仅当 |e1| 为真时才计算 |e2|。

  <tr algorithm="logical or"><td>|e1|: |T|<br>|e2|: |T|<br>|T| 为布尔值或 vec|N|&lt;bool&gt;
  <td>|e1| `|` |e2|`:` |T|
  <td>逻辑“或”。

  当 |T| 是向量时，[=Component-wise=]。

  计算 |e1| 和 |e2|。
  Logical "or". [=Component-wise=] when |T| is a vector. Evaluates both |e1| and |e2|.

  <tr algorithm="logical and"><td>|e1|: |T|<br>|e2|: |T|<br>|T| 为布尔值或 vec|N|&lt;bool&gt;
  <td>|e1| `&` |e2|`:` |T|
  <td>逻辑“与”。

  当 |T| 是向量时，[=Component-wise=]。

  计算 |e1| 和 |e2|。
</table>


## 算术表达式 ## {#arithmetic-expr}

<table class='data'>
  <caption>一元算术表达式</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="negation"><td>|e|: |T|<br>
   |T| 是 AbstractInt, AbstractFloat, i32, f32, f16, vec|N|<AbstractInt>,
   vec|N|&lt;AbstractFloat&gt;、vec|N|&lt;i32&gt;、vec|N|&lt;f32&gt; 或 vec|N|&lt;f16&gt;
   <td>`-`|e|`:` |T|
   <td>否定。 [=Component-wise=] 当 |T| 是一个向量。
   如果 |T| 是整数类型，|e| 求最大负值，则结果为|e|。
</table>

<table class='data'>
  <caption>Binary arithmetic expressions</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>

   <tr 算法="加法">
     <td>|e1| : |T|<br>|e2| : |T|<br>[ALLNUMERICDECL]
     <td>|e1| `+` |e2| : |T|
     <td>加法。 [=Component-wise=] 当 |T| 是一个向量。
     如果 |T| 是 [=concrete=] 整数类型，则结果为模 2<sup>32</sup>。

   <tr 算法="减法">
     <td>|e1| : |T|<br>|e2| : |T|<br>[ALLNUMERICDECL]
     <td>|e1| `-` |e2| : |T|
     <td>减法 [=Component-wise=] 当 |T| 是一个向量。
     如果 |T| 是 [=concrete=] 整数类型，则结果为模 2<sup>32</sup>。

   <tr 算法="乘法">
     <td>|e1| : |T|<br>|e2| : |T|<br>[ALLNUMERICDECL]
     <td>|e1| `*` |e2| : |T|
     <td>乘法。 [=Component-wise=] 当 |T| 是一个向量。
     如果 |T| 是 [=concrete=] 整数类型，则结果为模 2<sup>32</sup>。

   <tr 算法="除法">
     <td>|e1| : |T|<br>|e2| : |T|<br>[ALLNUMERICDECL]
     <td>|e1| `/` |e2| : |T|
     <td>师。 [=Component-wise=] 当 |T| 是一个向量。

   如果 |T| 是有符号整数类型，标量情况，计算结果为：
        * |e1|，当 |e2| 等于零。
        * |e1|，当 |e1| 是 |T| 中的最大负值，|e2| 是-1。
        * 否则为  [=truncate=](|x|) ，其中 |x| 是实值商|e1|&nbsp;&div;&nbsp;|e2|。

        笔记：
             确保截断行为的需要可能需要实现比计算无符号除法时执行更多的操作。
             当已知两个操作数具有相同符号时，使用无符号除法。

        <!--
            其中 MINIT = |T| 中的最大负值
            其中 Divisor = select(e2, 1, (e2==0) | ((e1 == MININT) & (e2 == -1)))
            结果为 truncate(e1/Divisor)
        -->
        如果 |T| 是无符号整数类型，标量情况，计算结果为：
        * |e1|，当 |e2| 为零。
          
          ** |e1|，当 |e2| 为零。
                  * 否则，整数 |q| 使得 |e1|&nbsp;=&nbsp;|q|&nbsp;&times;&nbsp;|e2|&nbsp;+&nbsp;|r|，其中 0 &le; |r| &lt; |e2|。
  <tr algorithm="Remainder">
    <td>|e1| : |T|<br>|e2| : |T|<br>[ALLNUMERICDECL]
    <td>|e1| `%` |e2| : |T|
    <td>Remainder. [=Component-wise=] when |T| is a vector.

如果 |T| 是有符号整数标量类型，计算 |e1| 和 |e2| 一次，并评估为：
        * 0，当 |e2| 为零。
        * 0，当 |e1| 是 |T| 中的最大负值，|e2| 是-1。
        * 否则，|e1|&nbsp;-&nbsp;[=truncate=](|e1|&nbsp;&div;&nbsp;|e2|)&nbsp;&times;&nbsp;|e2|
            其中商被计算为实数值。

        笔记：
        当非零时，结果与|e1| 具有相同的符号。

        笔记：
        确保行为一致的需要可能需要实施
        比计算无符号余数时执行更多的操作。

         <!--
                其中 MINIT = |T| 中的最大负值
                其中除数 = select(e2, 1, (e2==0) | ((e1 == MININT) & (e2 == -1)))
                结果是 e1 - truncate(e1/Divisor) * Divisor
         -->
        如果 |T| 是无符号整数标量类型，计算结果为：
         * 0，当 |e2| 为零。
         * 否则，整数 |r| 这样
             |e1|&nbsp;=&nbsp;|q|&nbsp;&times;&nbsp;|e2|&nbsp;+&nbsp;|r|,
             |q| 是整数，0 &le; |r| &lt; |e2|。

        如果 |T| 是浮点类型，结果等于：<br> |e1| - |e2| * trunc(|e1| / |e2|)

</table>

<table class='data'>
  <caption>具有混合标量和向量操作数的二元算术表达式</caption>
  <thead>
    <th>Preconditions<th>Conclusions<th>Semantics
  </thead>
  <tr algorithm="vector-scalar arithmetic, any scalar type">
    <td rowspan="10">|S| 为 f32, f16, i32, u32 之一<br>
        |V| 为 vec|N|&lt;|S|&gt<br>
        |es|: |S|<br>
        |ev|: |V|
    <td>|ev| `+` |es|: |V|
    <td>|ev| `+` |V|(|es|)
  <tr>
    <td>|es| `+` |ev|: |V|
    <td>|V|(|es|) `+` |ev|
  <tr>
    <td>|ev| `-` |es|: |V|
    <td>|ev| `-` |V|(|es|)
  <tr>
    <td>|es| `-` |ev|: |V|
    <td>|V|(|es|) `-` |ev|
  <tr>
    <td>|ev| `*` |es|: |V|
    <td>|ev| `*` |V|(|es|)
  <tr>
    <td>|es| `*` |ev|: |V|
    <td>|V|(|es|) `*` |ev|
  <tr>
    <td>|ev| `/` |es|: |V|
    <td>|ev| `/` |V|(|es|)
  <tr>
    <td>|es| `/` |ev|: |V|
    <td>|V|(|es|) `/` |ev|
  <tr>
    <td>|ev| `%` |es|: |V|
    <td>|ev| `%` |V|(|es|)
  <tr>
    <td>|es| `%` |ev|: |V|
    <td>|V|(|es|) `%` |ev|
</table>

<table class='data'>
  <caption>矩阵运算</caption>
  <thead>
    <th>Preconditions<th>Conclusions<th>Semantics
  </thead>
<tr algorithm="矩阵加法">
    <td rowspan=2>|e1|, |e2|: mat|C|x|R|<|T|&gt<br>
        |T|是 AbstractFloat、f32 或 f16
    <td>|e1| `+` |e2|: mat|C|x|R|&lt;|T|&gt<br>
    <td>矩阵加法：列|i|结果是 |e1|[i] + |e2|[i]
  <tr algorithm="矩阵减法">
    <td>|e1| `-` |e2|: mat|C|x|R|&lt;|T|&gt
    <td>矩阵减法：列|i|结果是 |e1|[|i|] - |e2|[|i|]
  <tr algorithm="矩阵标量乘法">
    <td rowspan=2>|m|: mat|C|x|R|<|T|&gt<br>
        |s|: |T|<br>
        |T|是 AbstractFloat、f32 或 f16
    <td>|米| `*` |s|: mat|C|x|R|<|T|&gt<br>
    <td>组件级缩放：(|m| `*` |s|)[i][j] is |m|[i][j] `*` |s|
  <tr algorithm="标量矩阵乘法">
    <td>|s| `*` |m|: mat|C|x|R|<|T|&gt<br>
    <td>组件级缩放： (|s| `*` |m|)[i][j] is |m|[i][j] `*` |s|
  <tr algorithm="矩阵列向量乘法">
    <td>|m|: 垫子|C|x|R|<|T|&gt<br>
        |v|: vec|C|<|T|&gt<br>
        |T|是 AbstractFloat、f32 或 f16
    <td>|米| `*` |v|: vec|R|&lt;|T|&gt<br>
    <td>线性代数矩阵-列-向量积：
        组件 |i|结果是 `dot`(|m|[|i|],|v|)
  <tr algorithm="矩阵行向量乘法">
    <td>
        |m|: 垫子|C|x|R|<|T|><br>
        |v|: vec|R|<|T|&gt<br>
        |T|是 AbstractFloat、f32 或 f16
    <td>|v| `*` |m|: vec|C|&lt;|T|&gt<br>
    <td>线性代数行-向量-矩阵乘积：<br>
        [=转置=](转置(|m|) `*`转置(|v|))
  <tr 算法="矩阵-矩阵乘法">
    <td>|e1|: mat|K|x|R|<|T|&gt<br>
        |e2|: mat|C|x|K|<|T|><br>
        |T|是 AbstractFloat、f32 或 f16
    <td>|e1| `*` |e2|: mat|C|x|R|&lt;|T|&gt<br>
    <td>线性代数矩阵乘积。
</table>

## 比较表达式 ## {#comparison-expr}

<table class='data'>
  <caption>比较</caption>
  <thead>
    <tr><th>Precondtion<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="equality">
    <td>|e1|: |T|<br>|e2|: |T|<br>
    |S| is AbstractInt, AbstractFloat, bool, i32, u32, f32, or f16<br>
    |T| is |S| or vec|N|&lt;|S|&gt;<br>
    |TB| is bool if |T| is scalar or<br>
    vec|N|&lt;bool&gt; if |T| is a vector
    <td class="nowrap">|e1| `==` |e2|`:` |TB|
    <td>Equality. [=Component-wise=] when |T| is a vector.
  <tr algorithm="inequality">
    <td>|e1|: |T|<br>|e2|: |T|<br>
    |S| is AbstractInt, AbstractFloat, bool, i32, u32, or f32<br>
    |T| is |S| or vec|N|&lt;|S|&gt;<br>
    |TB| is bool if |T| is scalar or<br>
    vec|N|&lt;bool&gt; if |T| is a vector
    <td class="nowrap">|e1| `!=` |e2|`:` |TB|
    <td>Inequality. [=Component-wise=] when |T| is a vector.
  <tr algorithm="less than">
    <td>|e1|: |T|<br>|e2|: |T|<br>[ALLNUMERICDECL]<br>
    |TB| is bool if |T| is scalar, or<br>
    vec|N|&lt;bool&gt; if |T| is a vector
    <td class="nowrap">|e1| `<` |e2|`:` |TB|
    <td>Less than. [=Component-wise=] when |T| is a vector.
  <tr algorithm="less than equal">
    <td>|e1|: |T|<br>|e2|: |T|<br>[ALLNUMERICDECL]<br>
    |TB| is bool if |T| is scalar, or<br>
    vec|N|&lt;bool&gt; if |T| is a vector
    <td class="nowrap">|e1| `<=` |e2|`:` |TB|
    <td>Less than or equal. [=Component-wise=] when |T| is a vector.
  <tr algorithm="greater than">
    <td>|e1|: |T|<br>|e2|: |T|<br>[ALLNUMERICDECL]<br>
    |TB| is bool if |T| is scalar, or<br>
    vec|N|&lt;bool&gt; if |T| is a vector
    <td class="nowrap">|e1| `>` |e2|`:` |TB|
    <td>Greater than. [=Component-wise=] when |T| is a vector.
  <tr algorithm="greater than equal">
    <td>|e1|: |T|<br>|e2|: |T|<br>[ALLNUMERICDECL]<br>
    |TB| is bool if |T| is scalar, or<br>
    vec|N|&lt;bool&gt; if |T| is a vector
    <td class="nowrap">|e1| `>=` |e2|`:` |TB|
    <td>Greater than or equal. [=Component-wise=] when |T| is a vector.

</table>

## 位表达式 ## {#bit-expr}

<table class='data'>
  <caption>一元按位运算</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="complement">
    <td>|e|: |T|<br>
    [ALLINTEGRALDECL]

    |T| 为 [INTEGRAL]
    <td class="nowrap">`~`|e| : |T|
    <td>|e| 上的按位补码。

    结果中的每一位都与 |e| 中的相应位相反。

    当 |T| 是向量时，[=Component-wise=]。

    （OpNot）
</table>

<table class='data'>
  <caption>二元按位运算</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="bitwise or">
    <td>|e1|: |T|<br>
       |e2|: |T|<br>
       [ALLINTEGRALDECL]
    <td class="nowrap">|e1| `|` |e2|: |T|
    <td>Bitwise-or. [=Component-wise=] when |T| is a vector.
  <tr algorithm="bitwise and">
    <td>|e1|: |T|<br>
       |e2|: |T|<br>
       [ALLINTEGRALDECL]
    <td class="nowrap">|e1| `&` |e2|: |T|
    <td>Bitwise-and. [=Component-wise=] when |T| is a vector.
  <tr algorithm="bitwise exclusive or">
    <td>|e1|: |T|<br>
       |e2|: |T|<br>
       [ALLINTEGRALDECL]
    <td class="nowrap">|e1| `^` |e2|: |T|
    <td>Bitwise-exclusive-or. [=Component-wise=] when |T| is a vector.
</table>


<table class='data'>
  <caption>位移表达式</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>

  <tr algorithm="logical shift left">
    <td>|e1|: |T|<br>
    |e2|: |TS|<br>
    |T| 为 [INTEGRAL]<br>
    如果 |e1| 为标量，则 |TS| 为 u32<br>
    vec|N|&lt;u32&gt;.
    <td class="nowrap">|e1| `<<` |e2|: |T|
    <td>Logical shift left：<br>
    将 |e1| 左移，在最低有效位置插入零，并丢弃最高有效位。要移位的位数是 |e2| 的值 modulo |e1| 的位宽。

    当 T 是向量时，[=Component-wise=]。

    （OpShiftLeftLogical）

  <tr algorithm="logical shift right">
    <td>|e1|: |T|<br>
    |e2|: |T|<br>
    |T| is [UNSIGNEDINTEGRAL]
    <td class="nowrap">|e1| >> |e2|: |T|
    <td>逻辑右移：<br>

    将 |e1| 右移，在最高有效位置插入零，并丢弃最低有效位。要移位的位数是 |e2| 的值 modulo |e1| 的位宽。

    当 T 是向量时，[=Component-wise=]。

    （OpShiftRightLogical）

  <tr algorithm="arithmetic shift right">
    <td>|e1|: |T|<br>
    |e2|: |TS|<br>
    |T| is [SIGNEDINTEGRAL]<br>
    |TS| is u32 if |e1| is a scalar, or<br>
    vec|N|&lt;u32&gt;.
    <td class="nowrap">|e1| >> |e2|: |T|
    <td>算术右移：<br>

    将 |e1| 右移，在最高有效位置插入符号位的副本，并丢弃最低有效位。要移位的位数是 |e2| 的值 modulo |e1| 的位宽。

    当 T 是向量时，[=Component-wise=]。

    （OpShiftRightArithmetic）
</table>

## 函数调用表达式 ## {#function-call-expr}

函数调用表达式执行函数调用（[=function call=]），其中被调用函数具有返回类型（[=return type=]）。 如果被调用的函数没有返回值，则应使用函数调用语句代替。见[[#function-call-statement]]。

## 变量标识符表达式 ## {#var-identifier-expr}

<table class='data'>
  <caption>从变量名获取引用</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="variable reference">
       <td>
       |v| 是解析（[=resolves|resolving=]）为 [=address space=] |S| 中声明的 [=in scope|in-scope=] 变量的标识符（[=identifier=]），存储类型（[=store type=]）为 |T|
       <td class="nowrap">
          |v|: ref&lt;|S|,|T|&gt;
       <td>结果是对命名变量 |v| 的内存的引用。
</table>

## 形式参数表达式  ## {#formal-parameter-expr}

<table class='data'>
  <caption>获取声明为函数形式参数的标识符的值</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="formal parameter value">
       <td>
          |a| 是解析（[=resolves|resolving=]）为类型 |T| 的 [=in scope|in-scope=] 形式参数声明的标识符（[=identifier=]）
       <td class="nowrap">
          |a|: |T|
       <td>结果是在调用此函数实例的调用位置（[=call site=]）为相应函数调用操作数提供的值。
</table>

## 寻址表达式  ## {#address-of-expr}

寻址（<dfn noexport>address-of</dfn>）操作符将一个引用转换为其对应的指针。

<table class='data'>
  <caption>从引用获取指针</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="address-of expression">
       <td>
          |r|: ref&lt;|S|,|T|,|A|&gt;
       <td class="nowrap">
          `&`|r|: ptr&lt;|S|,|T|,|A|&gt;
       <td>结果是与引用值 |r| 相同的内存视图（[=memory view=]）对应的指针值。

       如果 |r| 是一个无效内存引用（[=invalid memory reference=]），作为结果的指针同样是无效内存引用。

       如果 |S| 为 [=storage classes/handle=] 存储类，则为一个着色器创建错误（[=shader-creation error=]）。
       这是一个 [=shader-creation error=]，如果 |r| 是 [[#component-reference-from-vector-reference|reference to a vector component]]。
</table>

## 间接寻址表达式  ## {#indirection-expr}

间接寻址运算符（<dfn noexport>indirection</dfn>）将指针转换为其相应的引用。

<table class='data'>
  <caption>从指针获取引用</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="indirection expression">
       <td>
          |p|: ptr&lt;|S|,|T|,|A|&gt;
       <td class="nowrap">
          `*`|p|: ref&lt;|S|,|T|,|A|&gt;
       <td>结果是与指针值 |p| 相同的内存视图（[=memory view=]）对应的引用值。

       如果 |p| 是一个无效内存引用（[=invalid memory reference=]），作为结果的指针同样是无效内存引用。

</table>

## 常量标识符表达式  ## {#constant-identifier-expr}

<table class='data'>
  <caption>获取 `let`-声明标识符的值</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="pipeline-overridable constant value">
       <td>
          |c| 是解析（[=resolves|resolving=]）为类型 |T| 的[=in scope|in-scope=]管线可覆盖（[=override declaration=]）的标识符（[=identifier=]）。
       <td class="nowrap">
          |c|: |T|
       <td>如果管线创建为常量 ID （[=pipeline constant ID|constant ID=]）指定了一个值，那么结果就是该值。对于不同的管线实例，此值可能不同。<br>

      否则，结果是为初始化表达式计算的值。管线可覆盖常量出现在模块范围内，因此在着色器开始执行之前进行计算。<br>

      注意：如果在 API 调用中没有指定初始值并且 `let`-声明没有初始化表达式，则管线创建将失败。
  <tr algorithm="constant value">
       <td>
          |c| 是解析（[=resolves|resolving=]）为类型 |T| 的[=in scope|in-scope=] `let` 声明的标识符（[=identifier=]），并且不为管线可覆盖（[=pipeline-overridable=]）的。
       <td class="nowrap">
          |c|: |T|
       <td>结果是为初始化表达式计算出的值。<br>

       对于模块范围内的 `let` 声明，计算发生在着色器开始执行之前。

       对于函数内部的 `let` 声明，每次控制到达声明时都会进行计算。<br>
</table>


## 表达式语法总结 ## {#expression-grammar}
当标识符用作 [=syntax/callable=] 项时，它是以下之一：
* [=user-defined function=] 或 [=built-in function=] 的名称，作为 [=function call=] 的一部分。
* [[#struct-types|structure type]] 或 [[#type-aliases|type alias]] 的名称，作为 [[#type-constructor-expr|constructor expression]] 的一部分。

[[#declaration-and-scope|Declaration and scope]] 规则确保这些名称始终是不同的。

<div class='syntax' noexport='true'>
  <dfn for=syntax>primary_expression</dfn> :

    | [=syntax/ident=]

    | [=syntax/callable=] [=syntax/argument_expression_list=]

    | [=syntax/const_literal=]

    | [=syntax/paren_expression=]

    | [=syntax/bitcast=] [=syntax/less_than=] [=syntax/type_decl=] [=syntax/greater_than=] [=syntax/paren_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>callable</dfn> :

    | [=syntax/ident=]

    | [=syntax/type_decl_without_ident=]

    | [=syntax/vec_prefix=]

    | [=syntax/mat_prefix=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>paren_expression</dfn> :

    | [=syntax/paren_left=] [=syntax/expression=] [=syntax/paren_right=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>argument_expression_list</dfn> :

    | [=syntax/paren_left=] ( ( [=syntax/expression=] [=syntax/comma=] ) * [=syntax/expression=] [=syntax/comma=] ? ) ? [=syntax/paren_right=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>postfix_expression</dfn> :

    | [=syntax/bracket_left=] [=syntax/expression=] [=syntax/bracket_right=] [=syntax/postfix_expression=] ?

    | [=syntax/period=] [=syntax/ident=] [=syntax/postfix_expression=] ?
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>unary_expression</dfn> :

    | [=syntax/singular_expression=]

    | [=syntax/minus=] [=syntax/unary_expression=]

    | [=syntax/bang=] [=syntax/unary_expression=]

    | [=syntax/tilde=] [=syntax/unary_expression=]

    | [=syntax/star=] [=syntax/unary_expression=]

    | [=syntax/and=] [=syntax/unary_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>singular_expression</dfn> :

    | [=syntax/primary_expression=] [=syntax/postfix_expression=] ?
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>lhs_expression</dfn> :

    | ( [=syntax/star=] | [=syntax/and=] ) * [=syntax/core_lhs_expression=] [=syntax/postfix_expression=] ?
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>core_lhs_expression</dfn> :

    | [=syntax/ident=]

    | [=syntax/paren_left=] [=syntax/lhs_expression=] [=syntax/paren_right=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>multiplicative_expression</dfn> :

    | [=syntax/unary_expression=]

    | [=syntax/multiplicative_expression=] [=syntax/star=] [=syntax/unary_expression=]

    | [=syntax/multiplicative_expression=] [=syntax/forward_slash=] [=syntax/unary_expression=]

    | [=syntax/multiplicative_expression=] [=syntax/modulo=] [=syntax/unary_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>additive_expression</dfn> :

    | [=syntax/multiplicative_expression=]

    | [=syntax/additive_expression=] [=syntax/plus=] [=syntax/multiplicative_expression=]

    | [=syntax/additive_expression=] [=syntax/minus=] [=syntax/multiplicative_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>relational_expression</dfn> :

    | [=syntax/additive_expression=]

    | [=syntax/additive_expression=] [=syntax/less_than=] [=syntax/additive_expression=]

    | [=syntax/additive_expression=] [=syntax/greater_than=] [=syntax/additive_expression=]

    | [=syntax/additive_expression=] [=syntax/less_than_equal=] [=syntax/additive_expression=]

    | [=syntax/additive_expression=] [=syntax/greater_than_equal=] [=syntax/additive_expression=]

    | [=syntax/additive_expression=] [=syntax/equal_equal=] [=syntax/additive_expression=]

    | [=syntax/additive_expression=] [=syntax/not_equal=] [=syntax/additive_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>short_circuit_and_expression</dfn> :

    | [=syntax/relational_expression=]

    | [=syntax/short_circuit_and_expression=] [=syntax/and_and=] [=syntax/relational_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>short_circuit_or_expression</dfn> :

    | [=syntax/relational_expression=]

    | [=syntax/short_circuit_or_expression=] [=syntax/or_or=] [=syntax/relational_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>binary_or_expression</dfn> :

    | [=syntax/unary_expression=]

    | [=syntax/binary_or_expression=] [=syntax/or=] [=syntax/unary_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>binary_and_expression</dfn> :

    | [=syntax/unary_expression=]

    | [=syntax/binary_and_expression=] [=syntax/and=] [=syntax/unary_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>binary_xor_expression</dfn> :

    | [=syntax/unary_expression=]

    | [=syntax/binary_xor_expression=] [=syntax/xor=] [=syntax/unary_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>bitwise_expression</dfn> :

    | [=syntax/binary_and_expression=] [=syntax/and=] [=syntax/unary_expression=]

    | [=syntax/binary_or_expression=] [=syntax/or=] [=syntax/unary_expression=]

    | [=syntax/binary_xor_expression=] [=syntax/xor=] [=syntax/unary_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>expression</dfn> :

    | [=syntax/relational_expression=]

    | [=syntax/short_circuit_or_expression=] [=syntax/or_or=] [=syntax/relational_expression=]

    | [=syntax/short_circuit_and_expression=] [=syntax/and_and=] [=syntax/relational_expression=]

    | [=syntax/bitwise_expression=]
</div>

# Statements # {#statements}

语句是控制其执行的程序片段。
语句一般按顺序执行； 然而，
[[#control-flow|control flow statements]] 可能会导致程序以非顺序执行。

## 复合语句 ## {#compound-statement-section}

<dfn>compound statement</dfn> 是用大括号括起来的零个或多个语句序列。
当 [=declaration=] 是这些语句之一时，它的 [=identifier=] 从下一条语句的开始到复合语句的结束都是 [=in scope=]。

<div class='syntax' noexport='true'>
  <dfn for=syntax>compound_statement</dfn> :

    | [=syntax/brace_left=] [=syntax/statement=] * [=syntax/brace_right=]
</div>

复合语句有两种特殊形式：
* [=syntax/continuing_compound_statement=] 构成 [[#continuing-statement|continuing]] 语句的主体，并允许在末尾添加可选的 [[#break-if-statement|break-if]] 语句。
* [=syntax/case_compound_statement=] 在 [[#switch-statement|switch]] 语句中形成 `case` 或 `default` 子句的主体，并允许可选的 [=syntax/fallthrough_statement|fallthrough=] 语句 在末尾。

## 赋值语句 ## {#assignment}

<dfn noexport dfn-for="statement">assignment</dfn> 计算表达式，并可选择将其存储在内存中（从而更新变量的内容）。

<div class='syntax' noexport='true'>
  <dfn for=syntax>assignment_statement</dfn> :

    | [=syntax/lhs_expression=] ( [=syntax/equal=] | [=syntax/compound_assignment_operator=] ) [=syntax/expression=]

    | [=syntax/underscore=] [=syntax/equal=] [=syntax/expression=]
</div>


等号左侧的文本是<dfn noexport>left-hand side</dfn>，
等号右边的表达式是<dfn noexport>right-hand side</dfn>。

### 简单赋值 ### {#simple-assignment-section}

当 [=left-hand side=] 是一个表达式并且运算符是 [=syntax/equal=] 标记时，[=statement/assignment=] 是一个 <dfn noexport> 简单赋值</dfn>。
在这种情况下，[=right-hand side=] 的值被写入左侧引用的内存中。

<table class='data'>
  <thead>
    <tr><th style="width:40%">Precondition<th>Statement<th>Description
  </thead>
  <tr algorithm="updating assignment">
    <td>|r|: ref<|S|,|T|,|A|>,<br>
        |A| is [=access/write=] or [=access/read_write=]<br>
        |e|: |T|,<br>
        |T| is a [=constructible=] type,<br>
        |S| is a writable [=address space=]
    <td class="nowrap">|r| = |e|
    <td>Evaluates |e|, evaluates |r|, then writes the value computed for |e| into
        the [=memory locations=] referenced by |r|.

        Note: if the reference is an [=invalid memory reference=], the write
        may not execute, or may write to a different memory location than
        expected.

        (OpStore)
</table>

在最简单的情况下，左侧是变量的名称。
其他情况见[[#forming-references-and-pointers]]。

    <div class='example wgsl' heading='Assignments'>
      <xmp highlight='rust'>
        struct S {
            age: i32,
            weight: f32
        }
        var<private> person: S;

        fn f() {
            var a: i32 = 20;
            a = 30;           // Replace the contents of 'a' with 30.

            person.age = 31;  // Write 31 into the age field of the person variable.

            var uv: vec2<f32>;
            uv.y = 1.25;      // Place 1.25 into the second component of uv.

            let uv_x_ptr: ptr<function,f32> = &uv.x;
            *uv_x_ptr = 2.5;   // Place 2.5 into the first component of uv.

            var friend: S;
            // Copy the contents of the 'person' variable into the 'friend' variable.
            friend = person;
        }
      </xmp>
    </div>

### 虚假赋值 ### {#phony-assignment-section}

当赋值的 [=left-hand side=] 是下划线标记时，
分配是一个<dfn noexport>虚假赋值</dfn>：
评估右侧，然后忽略。

<table class='data'>
  <thead>
    <tr><th>Precondition<th>Statement<th>Description
  </thead>
  <tr algorithm="phony-assignment">
    <td>|e|: |T|,<br>
        |T| is [=constructible=], a [=pointer type=], a [=texture=] type, or a [=sampler=] type
    <td class="nowrap">_ = |e|
    <td>Evaluates |e|.

        注意：结果值不会被存储。
        `_` 标记不是标识符，因此不能在表达式中使用。
</table>

虚假赋值对于以下场景有用:
* 调用返回值的函数，但明确表示不需要结果值。
* [=statically accessed|Statically accessing=]一个变量，从而将其建立为[=resource interface of a shader|shader's resource interface=]的一部分。

       注意：缓冲区变量的存储类型可能无法构造，例如 它包含原子类型或运行时大小的数组。
       在这些情况下，请改用指向变量内容的指针。

<div class='example wgsl global-scope' heading='Using phony-assignment to throw away an un-needed function result'>
  <xmp highlight=rust>
    var<private> counter: i32;

    fn increment_and_yield_previous() -> i32 {
      let previous = counter;
      counter = counter + 1;
      return previous;
    }

    fn user() {
      // Increment the counter, but don't use the result.
      _ = increment_and_yield_previous();
    }
  </xmp>
</div>


<div class='example wgsl global-scope' heading='Using phony-assignment to occupy bindings without using them'>
  <xmp highlight=rust>
    [[block]] struct BufferContents {
        counter: atomic<u32>,
        data: array<vec4<f32>>
    }
    @group(0) @binding(0) var<storage> buf: BufferContents;
    @group(0) @binding(1) var t: texture_2d<f32>;
    @group(0) @binding(2) var s: sampler;

    @fragment
    fn shade_it() -> @location(0) vec4<f32> {
      // Declare that buf, t, and s are part of the shader interface, without
      // using them for anything.
      _ = &buf;
      _ = t;
      _ = s;
      return vec4<f32>();
    }
  </xmp>
</div>

### 复合赋值 ### {#compound-assignment-sec}

[=statement/assignment=] 是 <dfn noexport> 复合赋值</dfn> 当 [=left-hand side=] 是一个表达式，并且运算符是 [=syntax/compound_assignment_operators=] 之一。

<div class='syntax' noexport='true'>
  <dfn for=syntax>compound_assignment_operator</dfn> :

    | [=syntax/plus_equal=]

    | [=syntax/minus_equal=]

    | [=syntax/times_equal=]

    | [=syntax/division_equal=]

    | [=syntax/modulo_equal=]

    | [=syntax/and_equal=]

    | [=syntax/or_equal=]

    | [=syntax/xor_equal=]

    | [=syntax/shift_right_equal=]

    | [=syntax/shift_left_equal=]
</div>

每个语句的类型要求、语义和行为被定义为好像复合赋值扩展如下表，除了引用表达式 |e1| 只评估一次。

<table class='data'>
  <thead>
    <tr><th>Statement<th>Expansion
  </thead>
<tr algorithm="add-assign">
    <td class="nowrap">|e1| += |e2|
    <td>|e1| = |e1| + (|e2|)
<tr algorithm="subtract-assign">
    <td class="nowrap">|e1| -= |e2|
    <td>|e1| = |e1| - (|e2|)
<tr algorithm="multiply-assign">
    <td class="nowrap">|e1| *= |e2|
    <td>|e1| = |e1| * (|e2|)
<tr algorithm="divide-assign">
    <td class="nowrap">|e1| /= |e2|
    <td>|e1| = |e1| / (|e2|)
<tr algorithm="modulus-assign">
    <td class="nowrap">|e1| %= |e2|
    <td>|e1| = |e1| % (|e2|)
<tr algorithm="bitwise-and-assign">
    <td class="nowrap">|e1| &= |e2|
    <td>|e1| = |e1| & (|e2|)
<tr algorithm="bitwise-or-assign">
    <td class="nowrap">|e1| |= |e2|
    <td>|e1| = |e1| | (|e2|)
<tr algorithm="bitwise-xor-assign">
    <td class="nowrap">|e1| ^= |e2|
    <td>|e1| = |e1| ^ (|e2|)
<tr algorithm="bitwise-shiftright-assign">
    <td class="nowrap">|e1| >>= |e2|
    <td>|e1| = |e1| >> (|e2|)
<tr algorithm="bitwise-shiftleft-assign">
    <td class="nowrap">|e1| <<= |e2|
    <td>|e1| = |e1| << (|e2|)
</table>

注意：语法不允许 [=compound assignment=] 也是 [=phony assignment=]。

注意：即使引用 |e1| 被评估一次，它的底层内存被访问两次：
首先 [=read access=] 获取旧值，然后 [=write access=] 存储更新的值。

<div class='example wgsl global-scope' heading="Compound assignment">
  <xmp highlight='rust'>
    var<private> next_item: i32 = 0;

    fn advance_item() -> i32 {
       next_item += 1;   // Adds 1 to next_item.
       return next_item - 1;
    }

    fn bump_item() {
      var data: array<f32,10>;
      next_item = 0;
      // Adds 5.0 to data[0], calling advance_item() only once.
      data[advance_item()] += 5.0;
      // next_item will be 1 here.
    }

    fn precedence_example() {
      var value = 1;
      // The right-hand side of a compound assignment is its own expression.
      value *= 2 + 3; // Same as value = value * (2 + 3);
      // 'value' now holds 5.
    }
  </xmp>
</div>

注意：复合赋值可以改写为不同的 WGSL 代码，使用 [=simple assignment=] 代替。
这个想法是使用一个指针来保存一次评估引用的结果。

<p class="note" algorithm="translation compound assignment not vector component">
例如，
当 |e1| 是 * 不是 * 对向量内组件的引用，然后
|e1|` += `|e2| 可以改写为
`{let p = &(`|e1|`); *p = *p + (`|e2|`);}`,
其中标识符 `p`被选择为不同于程序中的所有其他标识符。
</p>

<p class="note" algorithm="translation compound assignment vector component">
当 |e1| 是对向量内部组件的引用，需要修改上述技术，因为 WGSL 在这种情况下不允许 [[#address-of-expr|taking the address]]。
例如，如果 |ev| 是对向量的引用，语句 |ev|`[`|c|`] += ` |e2| 可以重写为 `{let p = &(`|ev|`); 让 c0 = ` |c|`; (*p)[c0] = (*p)[c0] + (`|e2|`);}`，
其中标识符 `c0` 和 `p` 被选择为不同于程序中的所有其他标识符。
</p>

## 递增和递减语句 ## {#increment-decrement}

<dfn noexport>increment statement</dfn> 给变量的内容加 1。
<dfn noexport>decrement statemnent</dfn> 从变量的内容中减去 1。

<div class='syntax' noexport='true'>
  <dfn for=syntax>increment_statement</dfn> :

    | [=syntax/lhs_expression=] [=syntax/plus_plus=]
</div>

<div class='syntax' noexport='true'>
  <dfn for=syntax>decrement_statement</dfn> :

    | [=syntax/lhs_expression=] [=syntax/minus_minus=]
</div>

该表达式的计算结果必须为具有 [=integer scalar=] [=store type=] 和 [=access/read_write=] [=access mode=] 的引用。

<table class='data'>
  <thead>
    <tr><th>Precondition<th>Statement<th>Description
  </thead>
  <tr algorithm="increment statement">
    <td class="nowrap">|r| : ref&lt;<var ignore>SC</var>,|T|,[=access/read_write=]&gt;,<br>
        |T| is [=integer scalar=]<br>
    <td class="nowrap">|r|`++`
    <td>Adds 1 to the contents of memory referenced by |r|.
        <br>Same as |r| += |T|(1)
  <tr algorithm="decrement statement">
    <td class="nowrap">|r| : ref&lt;<var ignore>SC</var>,|T|,[=access/read_write=]&gt;,<br>
        |T| is [=integer scalar=]<br>
    <td class="nowrap">|r|`--`
    <td>Subtracts 1 from the contents of memory referenced by |r|.
        <br>Same as |r| -= |T|(1)
</table>

<div class='example wgsl' heading='Increment and decrement'>
  <xmp highlight='rust'>
    fn f() {
        var a: i32 = 20;
        a++;
        // Now a contains 21
        a--;
        // Now a contains 20
    }
  </xmp>
</div>


## 控制流 ## {#control-flow}

控制流语句可能会导致程序以非顺序执行。

### 序列 ### {#sequence-statement}

控制流语句可能会导致程序以非顺序执行。

### If 语句 ### {#if-statement}

<div class='syntax' noexport='true'>
  <dfn for=syntax>if_statement</dfn> :

    | [=syntax/if=] [=syntax/expression=] [=syntax/compound_statement=] ( [=syntax/else=] [=syntax/else_statement=] ) ?
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>else_statement</dfn> :

    | [=syntax/compound_statement=]

    | [=syntax/if_statement=]
</div>

一个 <dfn noexport dfn-for="statement">if</dfn> 语句根据条件表达式的评估，有条件地执行至多一个 [=compound statement=]。

[=Type rule precondition=]:
WGSL 中的 `if` 语句使用 if/else if/else 结构，其中包含一个必需的 `if` 子句、零个或多个 `elseif` 子句和一个可选的 `else` 子句。
`if` 和 `else if` 子句条件的每个表达式都必须是标量布尔表达式。

`if` 语句执行如下：
* 评估与 `if` 子句关联的条件。
    如果结果为 `true`，则控制转移到第一个复合语句（紧接在括号中的条件表达式之后）。
* 否则，按文本顺序（如果存在）评估下一个 `else if` 子句的条件，如果结果为 `true`，则控制转移到关联的复合语句。
    * 对所有 `else if` 子句重复此行为，直到其中一个条件评估为 `true`。
* 如果没有条件评估为 `true`，则控制转移到与 `else` 子句（如果存在）相关联的复合语句。

### Switch 语句 ### {#switch-statement}

<div class='syntax' noexport='true'>
  <dfn for=syntax>switch_statement</dfn> :

    | [=syntax/switch=] [=syntax/expression=] [=syntax/brace_left=] [=syntax/switch_body=] + [=syntax/brace_right=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>switch_body</dfn> :

    | [=syntax/case=] [=syntax/case_selectors=] [=syntax/colon=] ? [=syntax/case_compound_statement=]

    | [=syntax/default=] [=syntax/colon=] ? [=syntax/case_compound_statement=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>case_selectors</dfn> :

    | [=syntax/const_literal=] ( [=syntax/comma=] [=syntax/const_literal=] ) * [=syntax/comma=] ?
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>case_compound_statement</dfn> :

    | [=syntax/brace_left=] [=syntax/statement=] * [=syntax/fallthrough_statement=] ? [=syntax/brace_right=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>fallthrough_statement</dfn> :

    | [=syntax/fallthrough=] [=syntax/semicolon=]
</div>

<dfn noexport dfn-for="statement">switch</dfn> 语句将控制转移到一组 case 子句中的一个子句或 `default` 子句，具体取决于选择器表达式的评估。

选择器表达式必须是标量整数类型。
如果选择器值等于案例选择器列表中的值，则控制转移到
该 case 子句的主体。
如果选择器值不等于任何 case 选择器值，则控制是
转移到 `default` 子句。

每个 switch 语句必须恰好有一个 default 子句。
[=Type rule precondition=]:
case 选择器值必须与计算选择器表达式的结果具有相同的类型。

一个表达值在 switch 语句的 case 选择器中不能出现多次。

注意：表达式的值才是重要的，而不是拼写。
例如 `0`和 `0x0000`都表示零值。

当控制到达 case 主体的末尾时，控制通常转移到 switch 语句之后的第一个语句。
或者，执行 <dfn noexport dfn-for="statement">fallthrough</dfn> 语句
将控制转移到下一个 case 子句或 default 子句的主体，以开关主体中的下一个出现为准。
`fallthrough` 语句不能作为 switch 的最后一个子句中的最后一个语句出现。
当一个 [=declaration=] 出现在 case body 中时，它的 [=identifier=] 是 [=in scope=] 从下一条语句的开始到 case body 的结束。

注意：在 case body 中声明的标识符不是 case body 的 [=in scope=]， 可以通过 `fallthrough` 语句访问。
<div class='example wgsl function-scope' heading='WGSL Switch'>
  <xmp highlight='rust'>
    var a : i32;
    let x : i32 = generateValue();
    switch x {
      case 0: {      // the colon is optional
        a = 1;
      }
      default {      // the default needn't appear last
        a = 2;
      }
      case 1, 2 {    // multiple selector values can be used
        a = 3;       // a will be overridden in the next case
        fallthrough;
      }
      case 3 {
        a = 4;
      }
    }
  </xmp>
</div>

############################
### Loop 语句 ### {#loop-statement}

<div class='syntax' noexport='true'>
  <dfn for=syntax>loop_statement</dfn> :

    | [=syntax/loop=] [=syntax/brace_left=] [=syntax/statement=] * [=syntax/continuing_statement=] ? [=syntax/brace_right=]
</div>

<dfn noexport dfn-for="statement">loop</dfn> 语句重复执行<dfn noexport>loop body</dfn>； 循环体被指定为 [=compound statement=]。
循环体的每次执行称为一次<dfn noexport>iteration</dfn>。

从下一条语句开始到循环体结束，循环中 [=declaration=] 的 [=identifier=] 是 [=in scope=]。
每次到达时都会执行声明，因此每次新迭代都会创建变量或常量的新实例，并重新初始化它。

这种重复可以被 [=statement/break=]、[=statement/return=] 或
[=statement/discard=] 声明。

可选地，循环体中的最后一条语句可以是
[=statement/continuing=]声明。

注意：loop 语句是与其他着色器语言的最大区别之一。

这种设计直接表达了编译代码中常见的循环习语。
特别是，将循环更新语句放在循环体的末尾允许它们自然地使用循环体中定义的值。

<div class='example glsl' heading='GLSL Loop'>
  <xmp>
    int a = 2;
    for (int i = 0; i < 4; i++) {
      a *= 2;
    }
  </xmp>
</div>

<div class='example wgsl function-scope' heading="WGSL Loop">
  <xmp highlight='rust'>
    let a: i32 = 2;
    var i: i32 = 0;      // <1>
    loop {
      if (i >= 4) { break; }

      a = a * 2;

      i = i++;
    }
  </xmp>
</div>
* <1> The initialization is listed before the loop.

<div class='example glsl' heading='GLSL Loop with continue'>
  <xmp>
    int a = 2;
    let int step = 1;
    for (int i = 0; i < 4; i += step) {
      if (i % 2 == 0) continue;
      a *= 2;
    }
  </xmp>
</div>

<div class='example wgsl function-scope' heading="WGSL Loop with continue">
  <xmp highlight='rust'>
    var a: i32 = 2;
    var i: i32 = 0;
    loop {
      if (i >= 4) { break; }

      let step: i32 = 1;

      i = i + step;
      if (i % 2 == 0) { continue; }

      a = a * 2;
    }
  </xmp>
</div>

<div class='example wgsl function-scope' heading="WGSL Loop with continue and continuing">
  <xmp highlight='rust'>
    var a: i32 = 2;
    var i: i32 = 0;
    loop {
      if (i >= 4) { break; }

      let step: i32 = 1;

      if (i % 2 == 0) { continue; }

      a = a * 2;

      continuing {   // <2>
        i = i + step;
      }
    }
  </xmp>
</div>
* <2> continue 构造被放置在 `loop` 的末尾

### For 语句 ### {#for-statement}

<div class='syntax' noexport='true'>
  <dfn for=syntax>for_statement</dfn> :

    | [=syntax/for=] [=syntax/paren_left=] [=syntax/for_header=] [=syntax/paren_right=] [=syntax/compound_statement=]
</div>

<div class='syntax' noexport='true'>
  <dfn for=syntax>for_header</dfn> :

    | [=syntax/for_init=] ? [=syntax/semicolon=] [=syntax/expression=] ? [=syntax/semicolon=] [=syntax/for_update=] ?
</div>

<div class='syntax' noexport='true'>
  <dfn for=syntax>for_init</dfn> :

    | [=syntax/variable_statement=]

    | [=syntax/increment_statement=]

    | [=syntax/decrement_statement=]

    | [=syntax/assignment_statement=]

    | [=syntax/func_call_statement=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>for_update</dfn> :

    | [=syntax/increment_statement=]

    | [=syntax/decrement_statement=]

    | [=syntax/assignment_statement=]

    | [=syntax/func_call_statement=]
</div>


<dfn dfn-for="statement">for</dfn> 语句采用 `for(initializer; condition; update_part) { body }` 的形式，
是同一个 `body` 在 [=statement/loop=] 语句之上的语法糖(在计算机科学中，语法糖是一种编程语言中的语法，旨在使事物更易于阅读或表达。 它使语言更适合人类使用：
可以更清晰、更简洁地表达事物，或者以某些人可能更喜欢的另一种风格表达)。
另外:
* 如果 `initializer` 不为空，它会在第一个 [=iteration=] 之前的一个额外的 [=scope=] 中执行。
       初始化程序中声明的范围扩展到循环体的末尾。
* 如果 `condition` 不为空，则在循环体的开始处进行检查，如果不满足则执行[[#break-statement]]。
* 如果 `update_part` 不为空，它会在循环体的末尾变成一个 [=statement/continuing=] 语句。

[=Type rule precondition=]: 条件必须为 [=bool=] 类型。

for 循环的 `initializer` 在执行循环之前执行一次。
当一个 [=declaration=] 出现在初始化器中时，它的 [=identifier=] 是 [=in scope=] 直到 `body` 的结尾。
与 `body` 中的声明不同，该声明不会在每次迭代时重新初始化。

`condition`、`body` 和 `update_part` 依次执行以形成一个循环 [=iteration=]。
`body` 是一种特殊形式的 [=compound statement=]。
`body` 中声明的标识符是 [=in scope=] 从下一条语句的开始到 `body` 的结尾。

每次到达时都会执行声明，因此每次新迭代都会创建变量或常量的新实例，并重新初始化它。

<div class='example glsl' heading="For to Loop transformation">
  <xmp>
    for(var i: i32 = 0; i < 4; i = i++) {
      if (a == 0) {
        continue;
      }
      a = a + 2;
    }
  </xmp>
</div>

转换为:

<div class='example wgsl function-scope' heading="For to Loop transformation">
  <xmp highlight='rust'>
    { // Introduce new scope for loop variable i
      var i: i32 = 0;
      var a: i32 = 0;
      loop {
        if (!(i < 4)) {
          break;
        }

        if (a == 0) {
          continue;
        }
        a = a + 2;

        continuing {
          i = i++;
        }
      }
    }
  </xmp>
</div>

### While Statement ### {#while-statement}

<div class='syntax' noexport='true'>
  <dfn for=syntax>while_statement</dfn> :

    | [=syntax/while=] [=syntax/expression=] [=syntax/compound_statement=]
</div>

<dfn noexport dfn-for="statement">while</dfn>语句是一种以条件为参数的循环。
在每次循环[=iteration=]开始时，一个布尔类型的条件被计算得到。
如果条件为假，while循环结束执行。
否则，剩余迭代部分被执行。

[=Type rule precondition=]: 条件必须为 [=bool=] 类型。

while循环可以被看作是[=statement/loop=]或[=statement/for=]语句的语法糖。
以下语句形式是等价的：
* `while`  *condition*  `{` *body_statements* `}`
* `loop { if !` *condition* `{break;}` *body_statements* `}`
* `for (;`  *condition* `;) {` *body_statements*  `}`

### Break 语句 ### {#break-statement}

<div class='syntax' noexport='true'>
  <dfn for=syntax>break_statement</dfn> :

    | [=syntax/break=]
</div>

<dfn noexport dfn-for="statement">break</dfn>语句将控制转移至最近封闭循环的主体或[=statement/switch=]语句之后，从而结束执行循环或switch语句。

`break` 语句必须仅在 [=statement/loop=]，[=statement/for=]，[=statement/while=]以及[=statement/switch=]语句之中使用。

不要放置 `break` 语句使得其退出循环的[[#continuing-statement|continuing]]语句。使用[[#break-if-statement|break-if]]代替。

<div class='example wgsl function-scope' heading="WGSL Invalid loop break from a continuing clause">
  <xmp highlight='rust'>
    var a: i32 = 2;
    var i: i32 = 0;
    loop {
      let step: i32 = 1;

      if (i % 2 == 0) { continue; }

      a = a * 2;

      continuing {
        i = i + step;
        if i >= 4 { break; } // Invalid.  Use break-if instead.
      }
    }
  </xmp>
</div>

### Break-If Statement ### {#break-if-statement}

<div class='syntax' noexport='true'>
  <dfn for=syntax>break_if_statement</dfn> :

    | [=syntax/break=] [=syntax/if=] [=syntax/expression=] [=syntax/semicolon=]
</div>

<dfn noexport dfn-for="statement">break-if</dfn>语句计算一个布尔条件。
如果条件为真，控制被转移到最近封闭的[=statement/loop=]语句主体之后，结束执行该循环。

[=Type rule precondition=]: 条件必须为 [=bool=] 类型。

注意：break-if语句仅可以出现在[[#continuing-statement|continuing]]语句主体的最后。

<div class='example wgsl function-scope' heading="WGSL Valid loop break-if from a continuing clause">
  <xmp highlight='rust'>
    var a: i32 = 2;
    var i: i32 = 0;
    loop {
      let step: i32 = 1;

      if i % 2 == 0 { continue; }

      a = a * 2;

      continuing {
        i = i + step;
        break if i >= 4;
      }
    }
  </xmp>
</div>

### Continue 语句 ### {#continue-statement}

<div class='syntax' noexport='true'>
  <dfn for=syntax>continue_statement</dfn> :

    | [=syntax/continue=]
</div>

<dfn noexport dfn-for="statement">continue</dfn> 语句在最近的封闭 [=statement/loop=] 中转移控制：

* 转发到循环体末尾的 [=statement/continuing=] 语句（如果存在）。
* 否则返回到循环体中的第一条语句，开始下一个 [=iteration=]。

`continue` 语句只能用在 [=statement/loop=], [=statement/for=] 或 [=statement/while=] 语句中。
`continue` 语句的放置不得将控制转移到封闭的 [=statement/continuing=] 语句。
（当分支到 `continuing` 语句时，它是一个 *forward* 分支。）

不得放置 `continue` 语句，以便将控制权转移到目标 [=statement/continuing=] 语句中使用的声明之后。

注意：如果为了传输嵌套在 `continuing` 语句中的另一个循环中的控制流，`continue` 仅能在 `continuing` 语句中使用。
也就是说，`continue` 不能被用于传输控制至当前执行的 `continuing` 语句开始处。

<div class='example wgsl function-scope expect-error' heading="Invalid continue bypasses declaration">
  <xmp highlight='rust'>
    var i: i32 = 0;
    loop {
      if (i >= 4) { break; }
      if (i % 2 == 0) { continue; } // <3>

      let step: i32 = 2;

      continuing {
        i = i + step;
      }
    }
  </xmp>
</div>
* <3> `continue` 无效，因为它绕过了 `continuing` 构造中使用的 `step` 声明

### Continuing 语句 ### {#continuing-statement}

<div class='syntax' noexport='true'>
  <dfn for=syntax>continuing_statement</dfn> :

    | [=syntax/continuing=] [=syntax/continuing_compound_statement=]
</div>

<div class='syntax' noexport='true'>
  <dfn for=syntax>continuing_compound_statement</dfn> :

    | [=syntax/brace_left=] [=syntax/statement=] * [=syntax/break_if_statement=] ? [=syntax/brace_right=]
</div>

<dfn dfn-for="statement">continuing</dfn> 语句指定要在循环 [=iteration=] 结束时执行的 [=compound statement=]。
该构造是可选的。

复合语句不得在任何复合语句嵌套级别包含 [=statement/return=]。

复合语句不得在任何复合语句嵌套级别或通过函数调用包含 [=statement/discard=]。
有关此规则的更正式描述，请参阅 [[#behaviors]]。

### Return 语句 ### {#return-statement}

<div class='syntax' noexport='true'>
  <dfn for=syntax>return_statement</dfn> :

    | [=syntax/return=] [=syntax/expression=] ?
</div>

<dfn noexport dfn-for="statement">return</dfn> 语句结束当前函数的执行。
如果函数是 [=entry point=]，则终止当前着色器调用。
否则，在对当前函数调用的 [=call site=] 进行评估之后，继续评估下一个表达式或语句。

如果函数没有 [=return type=]，则 [=statement/return=] 语句是可选的。 如果为这样的函数提供了 return 语句，则它不得
提供一个值。
否则表达式必须存在，称为<dfn>return value</dfn>。
在这种情况下，此函数调用的调用点计算为返回值。
返回值的类型必须与函数的返回类型匹配。

### Discard 语句 ### {#discard-statement}

<dfn dfn-for="statement">discard</dfn> 语句立即结束片段着色器调用的执行并丢弃片段。
`discard` 语句只能用于 [=fragment=] 着色器阶段。

更准确地说，执行 `discard` 语句将：

* 立即终止当前调用，并且
* 防止为 [=entry point=] 评估和生成 [=return value=]，以及
* 防止当前片段在 [=GPURenderPipeline=] 中被下游处理。

只有在 `discard` 语句之前执行的语句才会有可观察到的效果。

注意：`discard`语句可以被任何着色器阶段中的函数|片段阶段中的函数[=functions in a shader stage|function in a fragment stage=]执行，
效果是一样的：立即终止调用。

在执行 `discard` 语句后，控制流在入口点的持续时间内是不一致（[[=uniform control flow|non-uniform=]]）的。

<div class='example wgsl' heading='Using the discard statement to throw away a fragment'>
  <xmp highlight='rust'>
  var<private> will_emit_color: bool = false;

  fn discard_if_shallow(pos: vec4<f32>) {
    if (pos.z < 0.001) {
      // If this is executed, then the will_emit_color flag will
      // never be set to true.
      discard;
    }
    will_emit_color = true;
  }

  @fragment
  fn main(@builtin(position) coord_in: vec4<f32>)
    -> @location(0) vec4<f32>
  {
    discard_if_shallow(coord_in);

    // Set the flag and emit red, but only if the helper function
    // did not execute the discard statement.
    will_emit_color = true;
    return vec4<f32>(1.0, 0.0, 0.0, 1.0);
  }
  </xmp>
</div>

## Function Call 语句 ## {#function-call-statement}

<div class='syntax' noexport='true'>
  <dfn for=syntax>func_call_statement</dfn> :

    | [=syntax/ident=] [=syntax/argument_expression_list=]
</div>

函数调用语句执行 [=function call=]。

注意：如果函数 [=return value|returns a value=]，则忽略该值。

## 语句语法总结 ## {#statements-summary}

[=syntax/statement=] 规则匹配可以在函数体内大多数地方使用的语句。

<div class='syntax' noexport='true'>
  <dfn for=syntax>statement</dfn> :

    | [=syntax/semicolon=]

    | [=syntax/return_statement=] [=syntax/semicolon=]

    | [=syntax/if_statement=]

    | [=syntax/switch_statement=]

    | [=syntax/loop_statement=]

    | [=syntax/for_statement=]

    | [=syntax/func_call_statement=] [=syntax/semicolon=]

    | [=syntax/variable_statement=] [=syntax/semicolon=]

    | [=syntax/break_statement=] [=syntax/semicolon=]

    | [=syntax/continue_statement=] [=syntax/semicolon=]

    | [=syntax/discard=] [=syntax/semicolon=]

    | [=syntax/assignment_statement=] [=syntax/semicolon=]

    | [=syntax/compound_statement=]

    | [=syntax/increment_statement=] [=syntax/semicolon=]

    | [=syntax/decrement_statement=] [=syntax/semicolon=]
</div>

另外，特定语句仅能用于非常特定的情况：
* [=syntax/break_if_statement=]
* [=syntax/case_compound_statement=]
* [=syntax/continuing_compound_statement=]
* [=syntax/fallthrough_statement=]

## 语句行为分析 ## {#behaviors}
### 规则 ### {#behaviors-rules}
一些影响控制流的语句仅在某些上下文中有效。

例如，[=statement/fallthrough=]在[=statement/switch=]外无效，[=statement/continue=]在[=statement/loop=], [=statement/for=], 或 [=statement/while=]外无效。
此外，一致性分析（参见 [[#uniformity]]）需要知道控制流何时可以以多种不同方式退出语句。
这两个目标都是通过一个总结语句和表达式的执行行为的系统来实现的。 行为分析将每个语句和表达式映射到语句或表达式的评估完成后执行的可能方式集。
与值和表达式的类型分析一样，行为分析自下而上进行：首先确定某些基本语句的行为，然后通过应用组合规则确定更高级别结构的行为。
<dfn export>behavior</dfn> 是一个集合， 它的元素可能包括:
- Return
- Discard
- Break
- Continue
- Fallthrough
- Next

每一个都对应于退出复合语句的一种方式：通过关键字，或通过下一个语句（“Next”）。
我们注意到 "*s*: *B*" 表示 *s* 尊重有关行为的规则，并且具有 [=behavior=] *B*。

对于每个函数:
- 它的主体必须是这些规则的有效声明。
- 如果函数具有返回类型，则其主体的 [=behavior=] 必须是 {Return} 或 {Return, Discard} 之一。
- 否则，其主体的 [=behavior=] 必须是 {Next, Return, Discard} 的子集。

我们为每个函数分配一个 [=behavior=]：它是其主体的 [=behavior=]（将主体视为常规语句），任何“Return”都被“Next”替换。
由于上述规则，函数行为始终是 {}、{Next}、{Discard} 或 {Next, Discard} 之一。
类似地，我们为每个表达式分配一个 [=behavior=]，因为表达式可以包含可以丢弃的函数调用。
与函数一样，表达式行为始终是 {}、{Next}、{Discard} 或 {Next, Discard} 之一。
注意：当前没有有效的程序，其表达式的 [=behavior=] 中没有 Next。
原因是只有没有返回类型的函数才能有这样的[=behavior=]，而且没有复合表达式可以调用这样的函数。
<table class='data'>
  <caption>分析和验证语句行为的规则</caption>
  <thead>
    <tr><th>语句<th>先决条件<th>结果行为
  </thead>
  <tr>
    <td class="nowrap">{ }
    <td>
    <td class="nowrap">{Next}
  <tr algorithm="braced statement behavior">
    <td class="nowrap">{|s|}
    <td>|s|: |B|
    <td class="nowrap">|B|
  <tr algorithm="statement sequence behavior with next">
    <td class="nowrap" rowspan=2>|s1| |s2|
        Note: |s1| often ends in a semicolon.
    <td class="nowrap">|s1|: |B1|<br>
        Next in |B1|<br>
        |s2|: |B2|
    <td class="nowrap">(|B1|&#x2216;{Next}) &cup; |B2|
  <tr algorithm="statement sequence behavior without next">
    <td class="nowrap">|s1|: |B1|<br>
        Next not in |B1|<br>
        |s2|: <var ignore>B2</var>
    <td class="nowrap">|B1|
  <tr algorithm="variable declaration behavior">
    <td class="nowrap">var x:T;
    <td>
    <td>{Next}
  <tr algorithm="let declaration behavior">
    <td class="nowrap">let x = |e|;
    <td class="nowrap">|e|: |B|
    <td>|B|
  <tr algorithm="initialized variable declaration behavior">
    <td class="nowrap">var x = |e|;
    <td class="nowrap">|e|: |B|
    <td>|B|
  <tr algorithm="assignment behavior">
    <td class="nowrap">|x| = |e|;
    <td class="nowrap">|x|: |B1|<br>
      |e|: |B2|<br>
      |x| is not `_`
    <td>|B1| &cup; |B2|
  <tr algorithm="phony assignment behavior">
    <td class="nowrap">_ = |e|;
    <td class="nowrap">|e|: |B|
    <td>|B|
  <tr algorithm="function call statement behavior">
    <td class="nowrap">|f|(|e1|, ..., |en|);
    <td class="nowrap">|e1|: |B1|<br>
        ...<br>
        |en|: |Bn|<br>
        |f| has behavior |B|
    <td class="nowrap">|B| &cup; ((|B1| &cup; ... &cup; |Bn|)&#x2216;{Next})
  <tr algorithm="return baehviour">
    <td>return;
    <td>
    <td>{Return}
  <tr algorithm="return value behavior">
    <td class="nowrap">return |e|;
    <td class="nowrap">|e|: |B|<br>
    <td class="nowrap">(|B|&#x2216;{Next}) &cup; {Return}
  <tr algorithm="discard baehviour">
    <td>discard;
    <td>
    <td>{Discard}
  <tr algorithm="break behavior">
    <td>break;
    <td>
    <td>{Break}
  <tr algorithm="break if behavior">
    <td>break if |e|;
    <td class="nowrap">|e|: |B|
    <td>|B| &cup; {Break}
  <tr algorithm="continue behavior">
    <td>continue;
    <td>
    <td>{Continue}
  <tr algorithm="fallthrough behavior">
    <td>fallthrough;
    <td>
    <td>{Fallthrough}
  <tr algorithm="if statement behavior">
    <td class="nowrap">if (|e|) |s1| else |s2|
    <td class="nowrap">|e|: |B|<br>
        |s1|: |B1|<br>
        |s2|: |B2|
    <td class="nowrap">(|B|&#x2216;{Next}) &cup; |B1| &cup; |B2|
  <tr algorithm="loop with continuing without break behavior">
    <td class="nowrap" rowspan=2>loop {|s1| continuing {|s2|}}
    <td class="nowrap">|s1|: |B1|<br>
        |s2|: |B2|<br>
        None of {Continue, Return, Discard} are in |B2|<br>
        Break is not in (|B1| &cup; |B2|)
    <td class="nowrap">(|B1|&#x2216;{Continue}) &cup; (|B2|&#x2216{Next})
  <tr algorithm="loop with continuing with break behavior">
    <td class="nowrap">|s1|: |B1|<br>
        |s2|: |B2|<br>
        None of {Continue, Return, Discard} are in |B2|<br/>
        Break is in (|B1| &cup; |B2|)
    <td class="nowrap">(|B1| &cup; |B2| &cup; {Next})&#x2216;{Break, Continue}
  <tr algorithm="switch behavior">
    <td class="nowrap" rowspan=2>switch(|e|) {case <var ignore>c1</var>: |s1| ... case <var ignore>cn</var>: |sn|}
    <td class="nowrap">|e|: |B|<br>
        |s1|: |B1|<br>
        ...<br>
        |sn|: |Bn|<br>
        Fallthrough is not in |Bn|<br>
        Break is not in (|B1| &cup; ... &cup; |Bn|)
    <td class="nowrap">(|B| &cup; |B1| &cup; ... &cup; |Bn|)&#x2216;{Fallthrough}
  <tr algorithm="switch with break behavior">
    <td class="nowrap">|e|: |B|<br>
        |s1|: |B1|<br>
        ...<br>
        |sn|: |Bn|<br>
        Fallthrough is not in |Bn|<br>
        Break is in (|B1| &cup; ... &cup; |Bn|)
    <td class="nowrap">(|B| &cup; |B1| &cup; ... &cup; |Bn| &cup; {Next})&#x2216;{Break, Fallthrough}
</table>
出于本分析的目的：
- `for` 循环脱糖（见 [[#for-statement]]）
- `loop {s}` 被视为 `loop {s continue {}}`
- 没有 `else` 分支的 `if` 语句被视为有一个空的 else 分支（将 Next 添加到它们的 [=behavior=]）
- 带有 `else if` 分支的 `if` 语句被视为嵌套的简单 `if/else` 语句
- 以 `default` 开头的 [=syntax/switch_body=] 的行为就像以 `case _:` 开头的 [=syntax/switch_body=]

<table class='data'>
  <caption>用于分析和验证表达式行为的规则</caption>
  <thead>
    <tr><th>表达式<th>先决条件<th>结果行为
  </thead>
  <tr algorithm="function call behavior">
    <td class="nowrap">|f|(|e1|, ..., |en|)
    <td class="nowrap">|e1|: |B1|<br>
        ...<br>
        |en|: |Bn|<br>
        |f| has behavior |B|
    <td class="nowrap">|B| &cup; ((|B1| &cup; ... &cup; |Bn|)&#x2216;{Next})
  <tr algorithm="literal expression behavior">
    <td class="nowrap">Any literal
    <td>
    <td class="nowrap">{Next}
  <tr algorithm="variable expression behavior">
    <td class="nowrap">Any variable reference
    <td>
    <td class="nowrap">{Next}
  <tr algorithm="array-like index expression behavior">
    <td class="nowrap">|e1|[|e2|]
    <td class="nowrap">|e1|: |B1|<br>
        |e2|: |B2|
    <td class="nowrap">|B1| &cup; |B2|
  <tr algorithm="structure member expression behavior">
    <td class="nowrap">|e|.field
    <td class="nowrap">|e|: |B|
    <td class="nowrap">|B|
  <tr algorithm="short-circuiting or expression behavior">
    <td class="nowrap">|e1| || |e2|
    <td class="nowrap">|e1|: |B1|<br>
        |e2|: |B2|
    <td class="nowrap">|B1| &cup; |B2|
  <tr algorithm="short-circuiting and expression behavior">
    <td class="nowrap">|e1| && |e2|
    <td class="nowrap">|e1|: |B1|<br>
        |e2|: |B2|
    <td class="nowrap">|B1| &cup; |B2|
</table>
每个 [=built-in function=] 都有一个 [=behavior=] {Next}。
并且每个未在上表中列出的运算符应用程序都具有相同的 [=behavior=]，就好像它是一个具有相同操作数的函数调用，并且函数的 [=behavior=] 为 {Next}。
如果行为分析失败，则会产生 [=shader-creation error=]：
- 行为分析必须能够确定每个语句、表达式和函数的非空的 [=behavior=]。
- 函数行为必须满足上面给出的规则。
- 计算和顶点入口点的行为不得包含丢弃。

### 注意 ### {#behaviors-notes}
本节是信息性的，非规范性的。
以下是这些规则可能导致程序被拒绝的完整方式列表（这只是重申上面已经列出的信息）：
- 函数体（视为常规语句）具有 {Next, Return, Discard} 中未包含的行为。
- 具有返回类型的函数体的行为既不是 {Return} 也不是 {Return, Discard}。
- 连续块的行为包含任何 Continue、Return 或 Discard。
- 开关的最后一种情况的行为包含 Fallthrough。
- 计算或顶点入口点函数的行为包含丢弃。
- 一些明显的无限循环有一个空的行为集，因此是无效的。

该分析可以通过自下而上分析调用图在线性时间内运行（因为函数调用的行为可能取决于函数的代码）。
### 实例 ### {#behaviors-examples}
以下是一些示例，显示了此分析的实际效果：
<div class='example wgsl expect-error' heading='Trivially dead code is allowed'>
   <xmp highlight='rust'>
    fn simple() -> i32 {
      var a: i32;
      return 0;  // Behavior: {Return}
      a = 1;     // Valid, statically unreachable code.
                 //   Statement behavior: {Next}
                 //   Overall behavior (due to sequential statements): {Return}
      return 2;  // Valid, statically unreachable code. Behavior: {Return}
    } // Function behaviour: {Return}
   </xmp>
</div>
<div class='example wgsl expect-error' heading='Compound statements are supported'>
   <xmp highlight='rust'>
    fn nested() -> i32 {
      var a: i32;
      {             // The start of a compound statement.
        a = 2;      // Behavior: {Next}
        return 1;   // Behavior: {Return}
      }             // The compound statement as a whole has behavior {Return}
      a = 1;        // Valid, statically unreachable code.
                    //   Statement behavior: {Next}
                    //   Overall behavior (due to sequential statements): {Return}
      return 2;     // Valid, statically unreachable code. Behavior: {Return}
    }
   </xmp>
</div>
<div class='example wgsl' heading='if/then behaves as if there is an empty else'>
   <xmp highlight='rust'>
    fn if_example() {
      var a: i32 = 0;
      loop {
        if a == 5 {
          break;      // Behavior: {Break}
        }             // Behavior of the whole if compound statement: {Break, Next},
                      //   as the if has an implicit empty else
        a = a + 1;    // Valid, as the previous statement had "Next" in its behavior
      }
    }
   </xmp>
</div>
<div class='example wgsl expect-error' heading='if/then/else has the behavior of both sides'>
   <xmp highlight='rust'>
    fn if_example() {
      var a: i32 = 0;
      loop {
        if a == 5 {
          break;      // Behavior: {Break}
        } else {
          continue;   // Behavior: {Continue}
        }             // Behavior of the whole if compound statement: {Break, Continue}
        a = a + 1;    // Valid, statically unreachable code.
                      //   Statement behavior: {Next}
                      //   Overall behavior: {Break, Continue}
      }
    }
   </xmp>
</div>
<div class='example wgsl' heading='if/else if/else behaves like a nested if/else'>
   <xmp highlight='rust'>
    fn if_example() {
      var a: i32 = 0;
      loop {
        // if e1 s1 else if e2 s2 else s3
        // is identical to
        // if e1 else { if e2 s2 else s3 }
        if a == 5 {
          break;      // Behavior: {Break}
        } else if a == 42 {
          continue;   // Behavior: {Continue}
        } else {
          return;     // Behavior {Return}
        }             // Behavior of the whole if compound statement:
                      //   {Break, Continue, Return}
      }               // Behavior of the whole loop compound statement {Next, Return}
    }                 // Behavior of the whole function {Next}
   </xmp>
</div>
<div class='example wgsl' heading='Break in switch becomes Next'>
   <xmp highlight='rust'>
    fn switch_example() {
      var a: i32 = 0;
      switch a {
        default: {
          break;   // Behavior: {Break}
        }
      }            // Behavior: {Next}, as switch replaces Break by Next
      a = 5;       // Valid, as the previous statement had Next in its behavior
    }
   </xmp>
</div>
<div class='example wgsl' heading='Obviously infinite loops'>
   <xmp highlight='rust'>
    fn invalid_infinite_loop() {
      loop { }     // Behavior: { }.  Invalid because it's empty.
    }
   </xmp>
</div>
<div class='example wgsl' heading='A conditional continue with continuing statement'>
   <xmp highlight='rust'>
    fn conditional_continue() {
      var a: i32;
      loop {
        if a == 5 { break; } // Behavior: {Break, Next}
        if a % 2 == 1 {      // Valid, as the previous statement has Next in its behavior
          continue;          // Behavior: {Continue}
        }                    // Behavior: {Continue, Next}
        a = a * 2;           // Valid, as the previous statement has Next in its behavior
        continuing {         // Valid as the continuing statement has behavior {Next}
                             //  which does not include any of:
                             //  {Break, Continue, Discard, Return}
          a = a + 1;
        }
      }                      // The loop as a whole has behavior {Next},
                             //  as it absorbs "Continue" and "Next",
                             //  then replaces "Break" with "Next"
    }
   </xmp>
</div>
<div class='example wgsl' heading='A redundant continue with continuing statement'>
   <xmp highlight='rust'>
    fn redundant_continue_with_continuing() {
      var a: i32;
      loop {
        if (a == 5) { break; }
        continue;   // 有效的。 这是多余的，分支到下一个语句。
        continuing {
          a = a + 1;
        }
      }
    }
   </xmp>
</div>
<div class='example wgsl' heading='A continue at the end of a loop body'>
   <xmp highlight='rust'>
    fn continue_end_of_loop_body() {
      for (var i: i32 = 0; i < 5; i++ ) {
        continue;   // Valid. This is redundant,
                    //   branching to the end of the loop body.
      }             // Behavior: {Next},
                    //   as loops absorb "Continue",
                    //   and "for" loops always add "Next"
    }
   </xmp>
</div>
`for` 循环 desugar 到 `loop` 有条件中断。 如前面的示例所示，条件中断具有 [=behavior=] {Break, Next}，这导致将“Next”添加到循环的 [=behavior=]。
<div class='example wgsl expect-error' heading='Effect of a function that discards unconditionally'>
   <xmp highlight='rust'>
    fn always_discard() {
      discard;
    }                   // The whole function has behavior {Discard}
    fn code_after_discard() {
      var a: i32;
      always_discard(); // Behavior: {Discard}
      a = a + 1;        // Valid, statically unreachable code.
                        //   Statement behavior: {Next}
                        //   Overall behavior: {Discard}
    }
   </xmp>
</div>
<div class='example wgsl' heading='Effect of a function that discards conditionally'>
   <xmp highlight='rust'>
    fn sometimes_discard(a: i32) {
      if (a) {
        discard;        // 行为: {Discard}
      }                 // 行为: {Next, Discard}
    }                   // 整个函数有行为 {Next, Discard}
    fn code_after_discard() {
      var a: i32;
      a = 42;
      sometimes_discard(a);  // 行为: {Next, Discard}
      a = a + 1;             // 有效
    }                        // 整个函数有行为 {Next, Discard}
   </xmp>
</div>
<div class='example wgsl expect-error' heading='return required in functions that have a return type'>
   <xmp highlight='rust'>
    fn missing_return () -> i32 {
      var a: i32 = 0;
      if a == 42 {
        return a;       // Behavior: {Return}
      }                 // Behavior: {Next, Return}
    }                   // Error: Next is invalid in the body of a
                        //   function with a return type
   </xmp>
</div>
<div class='example wgsl expect-error' heading='continue must be in a loop'>
   <xmp highlight='rust'>
    fn continue_out_of_loop () {
      var a: i32 = 0;
      if (a) {
        continue;       // 行为: {Continue}
      }                 // 行为: {Next, Continue}
    }                   // Error: 在函数体中Continue无效
   </xmp>
</div>
如果 `continue` 被 `break` 或 `fallthrough` 代替，同样的例子也会因同样的原因而无效。

# Functions # {#functions}

<dfn dfn-for="function" noexport>function</dfn> 在调用时执行计算工作。

以下列方式之一调用函数：
* 通过评估函数调用表达式。 见[[#function-call-expr]]。
* 通过执行函数调用语句。 见[[#function-call-statement]]。
* [=entry point=] 函数由 WebGPU 实现调用，以在 [=pipeline=] 中执行 [=shader stage=] 的工作。 见 [[#entry-points]]

有两种功能：
* [=built-in function=] 由 WGSL 实现提供，
     并且始终可用于 WGSL 程序。
     参见 [[#builtin-functions]]。
* <dfn noexport>user-defined function</dfn>在 WGSL 程序中声明。

## 声明一个用户定义的函数 ## {#function-declaration-sec}

<dfn noexport>function declaration</dfn> 通过指定以下内容来创建用户定义的函数：
* 一组可选的[=attributes=]。
* 函数的名称。
* 形参列表：一个有序的零序列或更多 [=formal parameter=] 声明，用逗号分隔，和被括号包围。
* 一个可选的，可能是装饰的，<dfn noexport>返回类型</dfn>。
* <dfn noexport>function body</dfn>.

这是当函数为[=function call|called=]时要执行的语句集。

函数声明只能出现在 [=module scope=]。
整个程序的函数名称是 [=in scope=]。

<dfn noexport>形式参数</dfn> [=declaration=] 指定一个 [=identifier=] 名称和一个值的类型，该值在调用函数时必须提供。
形式参数可能具有属性。
见[[#function-calls]]。
标识符是 [=in scope=] 直到函数结束。
给定函数的两个形参不能同名。

注意：一些内置函数可能允许参数为[=abstract numeric types=]，但是，该功能尚不被用户定义函数支持。

<div class='syntax' noexport='true'>
  <dfn for=syntax>function_decl</dfn> :

    | [=syntax/attribute=] * [=syntax/function_header=] [=syntax/compound_statement=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>function_header</dfn> :

    | [=syntax/fn=] [=syntax/ident=] [=syntax/paren_left=] [=syntax/param_list=] ? [=syntax/paren_right=] ( [=syntax/arrow=] [=syntax/attribute=] * [=syntax/type_decl=] ) ?
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>param_list</dfn> :

    | ( [=syntax/param=] [=syntax/comma=] ) * [=syntax/param=] [=syntax/comma=] ?
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>param</dfn> :

    | [=syntax/attribute=] * [=syntax/variable_ident_decl=]
</div>

WGSL 定义了以下可应用于函数声明的属性:
 * [=pipeline stage attributes=]: [=attribute/顶点=], [=attribute/片元=], 和 [=attribute/计算=]
 * [=attribute/workgroup_size=]

WGSL 定义了以下可应用于函数参数和返回类型的属性:
 * [=attribute/builtin=]
 * [=attribute/location=]

<div class='example wgsl' heading='Simple functions'>
  <xmp highlight='rust'>
    // 声明 add_two 函数。
    // 它有两个形参，i 和 b。
    // 它的返回类型为 i32。
    // 它有一个带有 return 语句的主体。
    fn add_two(i: i32, b: f32) -> i32 {
      return i + 2;  // A formal parameter is available for use in the body.
    }

    // 一个计算着色器入口点函数，'main'。
    // 它没有指定的返回类型。
    // 它调用了ordinary_two 函数，并捕获
    // 命名值'six'中的结果值。
    @compute fn main() {
       let six: i32 = add_two(4, 5.0);
    }
  </xmp>
</div>

## Function Calls ## {#function-calls}

<dfn noexport>function call</dfn> 是调用函数的语句或表达式。

包含函数调用的函数是<dfn>calling function</dfn>，或<dfn noexport>caller</dfn>。
被调用的函数是<dfn>called function</dfn>，或<dfn noexport>callee</dfn>。

函数调用：
* 命名 [=called function=]，和
* 提供带括号、逗号分隔的参数值表达式列表。

函数调用必须提供相同数量的参数值
[=formal parameter|formal parameters=]在被调用的函数[=called function=]中。
每个参数值必须按位置计算为与相应形式参数相同的类型。

总之，在调用函数时：
1. [=calling function=] 的执行被暂停。
2. [=called function=] 执行直到它[=returns=]。
3. 继续执行 [=calling function=]。

被调用的函数<dfn>returns</dfn>如下：
* A [=built-in function=] 在其工作完成后返回。
* 带有 [=return type=] 的 [=user-defined function=] 在执行 [=statement/return=] 语句时返回。
* 没有 [=return type=] 的 [=user-defined function=] 在执行 [=statement/return=] 语句时返回，或者当执行到达其 [=function body=] 的末尾时返回。

详细地说，当执行函数调用时，会发生以下步骤：
1. 函数调用参数值被评估。
    评估的相对顺序是从左到右。
2. [=calling function=] 的执行被暂停。
    所有 [=function scope=] 变量和常量都保持其当前值。
3. 如果调用的函数是[=user-defined function|user-defined=]，
    为被调用函数中的每个函数作用域变量分配内存。
    * 初始化发生在 [[#var-and-value]] 中。
4. 被调用函数的形参值由函数调用参数值按位置匹配确定。
    例如，在被调用函数的主体中，第一个形参将表示
    [=call site=] 处第一个参数的值。
5. 如果调用的函数是 [=user-defined function|user-defined=]，
    控制被转移到其 [=function body|body=] 中的第一个语句。
6. 被调用的函数被执行，直到它[=returns=]。
7. 控制权移交给调用函数，被调用函数的执行不暂停。
    如果被调用的函数 [=return value|returns a value=]，则为函数调用表达式的值提供该值。

注意：如果被调用函数或任何后代被调用函数执行了 [=statement/discard=] 语句，当前函数将不会恢复执行。

函数调用的位置称为<dfn noexport>call site</dfn>。
调用站点是一个 [=dynamic context=]。
因此，相同的文本位置可能代表多个呼叫站点。

## 创建时函数 ## {#creation-time-funcs}
由[=attribute/const=]声明的函数参数可以在[=shader module creation|shader-creation time=]时被计算。
这些函数被称为<dfn noexport>creation-time functions</dfn>。
对这些函数的调用可以组成[=creation-time expressions=]。

如果函数包含任何非[=creation-time expressions=]表达式，或任何非[=creation-time constants=]声明，则为[=shader-creation error=]。

注意：[=attribute/const=] 属性不能被应用于用户声明的函数。

<div class='example wgsl' heading='Creation-time functions'>
  <xmp>
    const first_one = firstLeadingBit(1234 + 4567); // Evaluates to 12
                                                    // first_one has the type i32, because
                                                    // firstLeadingBit cannot operate on
                                                    // AbstractInt

    @id(1) override x : i32;
    override y = firstLeadingBit(x); // Creation-time expressions can be
                                     // used in override expressions.
                                     // firstLeadingBit(x) is not a
                                     // creation-time expression in this context.

    fn foo() {
      var a : array<i32, firstLeadingBit(257)>; // Creation-time functions can be used in
                                                // creation-time expressions if all their
                                                // parameters are creation-time expressions.
    }
  </xmp>
</div>

## 函数限制 ## {#function-restriction}

* [=vertex=] 着色器必须返回 `position` [=built-in output value=]。 参见 [[#builtin-values]]。
* 入口点（[=entry point=]）绝不能是 [=function call=] 的目标。
* 如果函数具有返回类型，则它必须是 [=constructible=] 类型。
* [=formal parameter|function parameter=] 必须是以下类型之一：
    * [=constructible=] 类型
    * [=pointer type|pointer=] 类型
    * [=texture=] 类型
    * [=sampler=] 类型
* 每个函数调用参数必须评估为相应函数参数的类型。
    * 特别是，作为指针的参数必须与地址空间、指针对象类型和访问模式上的形参一致。
* 对于[=user-defined functions=]，指针类型的参数必须在以下地址空间之一中:
    * [=address spaces/function=]
    * [=address spaces/private=]
    * [=address spaces/workgroup=]
* 对于 [=built-in functions=]，指针类型的参数必须在以下地址空间之一中:
    * [=address spaces/function=]
    * [=address spaces/private=]
    * [=address spaces/workgroup=]
    * [=address spaces/storage=]
* 指向 [=user-defined function=] 的指针类型的每个参数必须是以下参数之一:
    * [[#var-identifier-expr|variable identifier expression]] 的  [[#address-of-expr|address-of expression]]
    * 一个函数参数（[=formal parameter|function parameter=]）

注意：不允许递归，因为在任何类型的声明中都不允许循环。

### 别名内存视图 ### {#function-aliasing}

[=Memory locations=] 可以在函数执行期间使用 [=memory view=] 访问。
在一个函数中，每个 [=memory view=] 都有一个特定的根标识符。
根标识符可以是 [=originating variable=] 或 [=pointer type=] 的 [=formal parameter=]。

[=reference type|reference=] 或 [=pointer type|pointer] 类型的本地派生表达式可能会为特定的根标识符引入新名称，但每个表达式都有一个静态可确定的根标识符。
虽然根标识符的 [=originating variable=] 是一个动态概念，它取决于函数的 [=call sites=]，但可以静态分析 WGSL 程序以确定每个根标识符所有可能的 [=originating variables=] 集合。

当两个根标识符 <dfn noexport>alias</dfn> 具有相同的 [=originating variable=] 时，如果以下情况发生则出现[=dynamic error=]：
* 多个别名相同的根标识符访问相同的[=memory locations=], 及
* 至少一个访问为 [=write access|write=], 及
* 同一函数调用的执行期间出现的所有访问

注意：此别名限制应用于由函数内制[=function calls=]写入的内存地址。

注意：[=Originating variables=] 不能有 [=memory locations=] 别名。
详见 [[#var-decls]] and [[#resource-interface]]。

<div class='example wgsl' heading='Aliased memory views'>
  <xmp highlight='rust'>
    var x : i32 = 0;

    fn foo() {
      bar(&x, &x); // Both p and q parameters are aliases of x.
    }

    // This function produces a dynamic error because of the aliased
    // memory accesses.
    fn bar(p : ptr<private, i32>, q : ptr<private, i32>) {
      if (x == 0) {
        *p = 1;
      } else {
        *q = 2;
      }
    }
  </xmp>
</div>

<div class='example wgsl' heading='Aliasing in a helper function'>
  <xmp highlight='rust'>
    var x : i32 = 0;

    fn baz(p : ptr<private, i32>) {
      *p = 2;
    }

    // This function produces a dynamic error if x == 0, because x is read and
    // written through different root identifiers even though the write occurs
    // in the scope of baz.
    fn bar(p : ptr<private, i32>) {
      if (x == 0) {
        baz(p);
      }
    }

    fn foo() {
      bar(&x); // p in bar is aliased to x.
    }
  </xmp>
</div>

# 入口点 # {#entry-points}

<dfn noexport> entry point</dfn> 是一个 [=user-defined function=]，它为特定的 [=shader stage=] 执行工作。

## 着色器阶段 ## {#shader-stages-sec}

WebGPU 以 [=draw command|draw=] 或 [=dispatch commands=] 的形式向 GPU 发出工作。
这些命令在一组 [=pipeline input|inputs=]、[=pipeline output|outputs=] 和附加的 [=resources=] 的上下文中执行管道。

<dfn noexport>pipeline</dfn> 将要在 GPU 上执行的work描述为一系列阶段，其中一些阶段是可编程的。
在 WebGPU 中，在调度绘制或调度命令以执行之前创建管道。
有两种管道：GPUComputePipeline 和 GPURenderPipeline。

[=dispatch command=] 使用 <dfn noexport>GPUComputePipeline</dfn> 在具有可控并行度的逻辑点网格上运行
<dfn noexport>计算着色器阶段</dfn>，同时读取并且可能更新缓冲区和图像资源。

[=draw command=] 使用 <dfn noexport>GPURenderPipeline</dfn> 运行多阶段进程，其中包含两个可编程阶段以及其他固定功能阶段：

* <dfn noexport>vertex shader stage</dfn> 将单个顶点的输入属性映射到该顶点的输出属性。
* 固定功能阶段将顶点映射到图形基元（例如三角形）中，然后将其光栅化以生成片段。
* <dfn noexport>fragment shader stage</dfn> 处理每个片段，可能会产生片段输出。
* 固定功能阶段消耗片段输出，可能会更新外部状态，例如颜色附件以及深度和模板缓冲区。

WebGPU 规范更详细地描述了管道。

WGSL 定义了三个 <dfn noexport>shader stage</dfn>，对应流水线的可编程部分：

* <dfn noexport>compute</dfn>
* <dfn noexport>vertex</dfn>
* <dfn noexport>fragment</dfn>

每个着色器阶段都有自己的一组特性和约束，在别处描述。

## 入口点声明 ## {#entry-point-decl}

要创建 [=entry point=]，请使用 [=pipeline stage attributes=] 属性声明 [=user-defined function=]。

在 WebGPU API 中配置 [=pipeline=] 时，入口点的函数名称映射到 [[WebGPU#GPUProgrammableStage]] 对象的 `entryPoint` 属性。

入口点的 [=formal parameters=] 形成阶段的 [=pipeline inputs=]。
入口点的 [=return type=]（如果指定）形成阶段的 [=pipeline output=]。
每个输入和输出必须是一个 [=entry point IO type=]。

注意：[=Compute]计算入口点从来没有返回类型。

<div class='example wgsl global-scope' heading='Entry Point'>
  <xmp highlight='rust'>
    @vertex
    fn vert_main() -> @builtin(position) vec4<f32> {
      return vec4<f32>(0.0, 0.0, 0.0, 1.0);
    }

    @fragment
    fn frag_main(@builtin(position) coord_in: vec4<f32>) -> @location(0) vec4<f32> {
      return vec4<f32>(coord_in.x, coord_in.y, 0.0, 1.0);
    }

    @compute
    fn comp_main() { }
  </xmp>
</div>

着色器阶段中的 <dfn noexport> 函数集</dfn> 是以下各项的并集：

* 阶段的入口点函数。
* 着色器阶段函数体内的函数调用目标，无论该调用是否被执行。

联合被反复应用，直到它稳定。
它将在有限数量的步骤中稳定下来。

### 入口点的函数属性 ### {#entry-point-attributes}

WGSL 定义了以下可应用于入口点声明的属性:
 * [=pipeline stage attributes=]: [=attribute/vertext=], [=attribute/fragement=], and [=attribute/compute=]
 * [=attribute/workgroup_size=]

问题：我们可以查询工作组大小维度的上限吗？ 是独立于shader，还是创建shader模块后要查询的属性？

<div class='example wgsl global-scope' heading='workgroup_size Attribute'>
  <xmp highlight='rust'>
    @compute @workgroup_size(8,4,1)
    fn sorter() { }
       // OpEntryPoint GLCompute %sorter "sorter"
       // OpExecutionMode %sorter LocalSize 8 4 1

    @compute @workgroup_size(8u)
    fn reverser() { }
       // OpEntryPoint GLCompute %reverser "reverser"
       // OpExecutionMode %reverser LocalSize 8 1 1

    // Using an pipeline-overridable constant.
    @override(42) let block_width = 12u;
    @compute @workgroup_size(block_width)
    fn shuffler() { }
        // SPIR-V 转换使用 WorkgroupSize 修饰的常量，
        // 其中第一个组件是一个装饰有的 OpSpecConstant
        // SpecID 42，默认值为12，第二个和第三个组件
        // 使用默认值 1。

    // 错误：必须在计算着色器上指定 workgroup_size
    @compute
    fn bad_shader() { }
  </xmp>
</div>

## 着色器接口 ## {#shader-interface}

着色器接口是一组对象，着色器通过这些对象访问 [=shader stage=] 外部的数据，用于读取或写入。
接口包括:

* 管道输入和输出
* 缓存资源
* 纹理资源
* 采样器资源

这些对象由某些 [=address spaces=] 中的模块范围变量表示。

当在 [=function declaration=] [=resolves=] 中使用 [=identifier=] 到 [=module scope|module-scope=] 变量时，我们说该变量是 <dfn>statically accessed</dfn> 按功能。`let` 声明的常量的静态访问定义类似。
请注意，静态访问与着色器的执行是否将实际评估引用变量的表达式，或者甚至执行可能包含表达式的语句无关。

更准确地说，着色器阶段的接口<dfn noexport>interface of a shader stage</dfn>包括：
  - 入口点的所有参数
  - 入口点的结果值
  - 所有模块范围[=module scope=]变量静态访问[=statically accessed=]由着色器阶段中的函数|着色器阶段中的函数[=functions in a shader stage|functions in the shader stage=]，
        并且在地址空间中[=address spaces/uniform=]，[=address spaces/storage=]，或[=address spaces/handle=]。


### 内置输入和输出 ### {#builtin-inputs-outputs}

<dfn noexport>内置输入值</dfn>提供对系统生成的控制信息的访问。
内置输入集在 [[#builtin-values]] 中列出。

阶段 *S* 的内置输入，名称为 *X*，类型为 *T*<sub>*X*</sub>，可通过 a
[=formal parameter=] 到 [=shader stage=] *S* 的 [=entry point=]，采用以下两种方式之一：

1. 参数具有 `builtin(`*X*`)` 属性，类型为*T*<sub>*X*</sub>。
2. 参数具有结构类型，其中结构成员之一具有属性 `builtin(`*X*`)`，类型为*T*<sub>*X*</sub>。

相反，当入口点的参数或参数成员具有“内置”属性时，
相应的内置函数必须是入口点着色器阶段的输入。

着色器使用 <dfn noexport>build-in output value</dfn> 来传达
控制信息到管道中的后续处理步骤。
内置输出集列在 [[#builtin-values]] 中。

一个名为 *Y* 和类型 *T*<sub>*Y*</sub> 的阶段 *S* 的内置输出通过 [=return value=] 设置为
[=shader stage=] *S* 的 [=entry point=]，采用以下两种方式之一：

1. 入口点 [=return type=] 具有属性 `builtin(`*Y*`)` 并且是 *T*<sub>*Y*</sub> 类型。
2. 入口点 [=return type=] 具有结构类型，其中结构成员之一具有属性 `builtin(`*Y*`)`并且是*T*<sub>*Y*</sub>类型.

相反，当入口点的返回类型或返回类型的成员具有“内置”属性时，
相应的内置函数必须是入口点着色器阶段的输出。

注意：内置的 `position`既是顶点着色器的输出，也是片段着色器的输入。

#### 用户定义的输入和输出 #### {#user-defined-inputs-outputs}

用户定义的数据可以作为输入传递到管道的起点、在管道的各个阶段之间传递或从管道末端输出。
不得将用户定义的 IO 传递给 [=compute=] 着色器入口点。
用户定义的 IO 必须是 [=numeric scalar=] 或 [=numeric vector=] 类型，或者其成员是数字标量或向量的结构类型。
必须为所有用户定义的 IO 分配位置（请参阅 [[#input-output-locations]]）。

#### 插值 #### {#interpolation}

作者可以通过使用 [=attribute/interpolate=] 属性来控制如何插入用户定义的 IO 数据。
WGSL 提供了两个方面的插值来控制：插值的类型和插值的采样。

插值类型 <dfn noexport>interpolation type</dfn> 必须是以下之一:
* `perspective` - 值以透视正确的方式插入。
* `linear` - 值以线性、非透视的正确方式进行插值。
* `flat` - 值不是内插的。
    插值采样不与 `flat` 插值一起使用。

插值采样 <dfn noexport>interpolation sampling</dfn> 必须为以下之一:
* `center` - 在像素的中心执行插值。
* `centroid` - 插值在位于当前基元内的片段所覆盖的所有样本内的点处执行。该值对于基元中的所有样本都是相同的。
* `sample` - 对每个样本执行内插。当应用此属性时，每个样本调用一次 [=fragment=] 着色器。

用于标量或向量浮点类型的用户自定义IO:
* 如果未指定插值属性，则假定为 `@interpolate(perspective, center)`。
* 如果使用插值类型指定插值属性：
    * 如果插值类型为 `flat`，则不得指定插值采样。
    * 如果插值类型是 `perspective` 或 `linear`，则:
         * 任何插值采样都是有效的。
         * 如果未指定插值采样，则假定为 `center`。

标量或向量整数类型的用户定义 IO 必须始终指定为 `@interpolate(flat)`。

插值属性必须在 [=vertex=] 输出和 [=fragment=] 输入之间匹配，在相同的 [=pipeline=] 中具有相同的 [=attribute/location=] 分配。

#### 输入输出位置 #### {#input-output-locations}

每个位置最多可以存储 16 个字节的值。
类型的字节大小使用 [[#alignment-and-size]] 中的 *SizeOf* 列定义。
例如，浮点值的四元素向量占据一个位置。

位置通过 [=attribute/location=] 属性指定。

每个用户定义的输入和输出都必须有一组完全指定的位置。
入口点 IO 中的每个结构成员必须是内置值之一
（参见 [[#builtin-inputs-outputs]]），或分配一个位置。

位置不得在以下每个集合内重叠：
* 结构类型中的成员。
     这适用于任何结构，而不仅仅是管道输入或输出中使用的结构。
* 入口点的管道输入，
     即其形式参数的位置，或其结构类型的形式参数的成员。

注意：位置编号在输入和输出之间是不同的：
入口点管道输入的位置编号与入口点管道输出的位置编号不冲突。

注意：不需要额外的规则来防止入口点输出中的位置重叠。
当输出是一个结构时，上面的第一条规则可以防止重叠。
否则，输出是标量或向量，并且只能分配一个位置。

注意：入口点的可用位置数由 WebGPU API 定义。

<div class='example wgsl applying location attribute' heading='Applying location attributes'>
  <xmp highlight='rust'>
    struct A {
      @location(0) x: f32,
      // 尽管位置是 16 字节，但 x 和 y 不能共享位置
      @location(1) y: f32
    };

    // in1 occupies locations 0 and 1.
    // in2 occupies location 2.
    // The return value occupies location 0.
    @fragment
    fn fragShader(in1: A, @location(2) in2: f32) -> @location(0) vec4<f32> {
     // ...
    }
  </xmp>
</div>

用户定义的 IO 可以与同一结构中的内置值混合使用。 例如，

<div class='example wgsl mixing builtins and user-defined IO' heading='Mixing builtins and user-defined IO'>
  <xmp highlight='rust'>
    // Mixed builtins and user-defined inputs.
    struct MyInputs {
      @location(0) x: vec4<f32>,
      @builtin(front_facing) y: bool,
      @location(1) @interpolate(flat) z: u32
    };

    struct MyOutputs {
      @builtin(frag_depth) x: f32,
      @location(0) y: vec4<f32>
    };

    @fragment
    fn fragShader(in1: MyInputs) -> MyOutputs {
      // ...
    }
  </xmp>
</div>

<div class='example wgsl invalid locations' heading='Invalid location assignments'>
  <xmp highlight='rust'>
    struct A {
      @location(0) x: f32,
      // Invalid, x and y cannot share a location.
      @location(0) y: f32
    }

    struct B {
     @location(0) x: f32
    }

    struct C {
      // Invalid, structures with user-defined IO cannot be nested.
      b: B
    }

    struct D {
      x: vec4<f32>
    }

    @fragment
    // Invalid, location cannot be applied to a structure type.
    fn fragShader1(@location(0) in1: D) {
      // ...
    }

    @fragment
    // Invalid, in1 and in2 cannot share a location.
    fn fragShader2(@location(0) in1: f32, @location(0) in2: f32) {
      // ...
    }

    @fragment
    // Invalid, location cannot be applied to a structure.
    fn fragShader3(@location(0) in1: vec4<f32>) -> @location(0) D {
      // ...
    }
  </xmp>
</div>

### 资源接口 ### {#resource-interface}

<dfn noexport>resource</dfn> 是一个对象，除了 [[#builtin-inputs-outputs|pipeline input or output]]，它提供对 [=shader stage=] 外部数据的访问。
资源由着色器的所有调用共享。

有四种资源类型:

* [=uniform buffers=]
* [=storage buffers=]
* 纹路
* 采样器

着色器的资源接口<dfn noexport>resource interface of a shader</dfn>是模块范围的集合
资源变量静态访问 [=statically accessed=] 通过着色器阶段中的函数|着色器阶段中的函数
[=functions in a shader stage|functions in the shader stage=]。

每个资源变量都必须用 [=attribute/group=] 和 [=attribute/binding=] 属性声明。
与着色器的阶段一起，这些标识了着色器管道上资源的绑定地址。
参考 [[WebGPU#pipeline-layout|WebGPU &sect; GPUPipelineLayout]]。

绑定不能在着色器阶段内别名：当被视为一对值时，给定着色器的资源接口中的两个不同变量不能具有相同的组和绑定值。

### 资源布局兼容性 ### {#resource-layout-compatibility}

WebGPU 要求着色器的资源接口与使用着色器的 [[WebGPU#pipeline-layout|layout of the pipeline]] 匹配。

资源接口中的每个 WGSL 变量都必须绑定到具有兼容 [[WebGPU#binding-resource-type|resource type]]
和 [[WebGPU#binding-type|binding type]] 的 WebGPU 资源，其中兼容性为 由下表定义。
<table class='data'>
  <caption>WebGPU binding type compatibility</caption>
  <thead>
    <tr><th>WGSL resource
        <th>WebGPU<br>[[WebGPU#binding-resource-type|Resource type]]
        <th colspan=2>WebGPU [[WebGPU#binding-type|Binding type]]
  </thead>
  <tr><td>[=uniform buffer=]
      <td rowspan=3>[[WebGPU#dictdef-gpubufferbinding|GPUBufferBinding]]
      <td rowspan=3>GPUBufferBindingType
      <td>[[WebGPU#dom-gpubufferbindingtype-uniform|uniform]]
  <tr><td>[=storage buffer=] with [=access/read_write=] access
      <td>[[WebGPU#dom-gpubufferbindingtype-storage|storage]]
  <tr><td>[=storage buffer=] with [=access/read=] access
      <td>[[WebGPU#dom-gpubufferbindingtype-read-only-storage|read-only-storage]]
  <tr><td rowspan=2>sampler
      <td rowspan=3>[[WebGPU#gpusampler|GPUSampler]]
      <td rowspan=3>GPUSamplerBindingType
      <td>[[WebGPU#dom-gpusamplerbindingtype-filtering|filtering]]
  <tr>
      <td>[[WebGPU#dom-gpusamplerbindingtype-non-filtering|non-filtering]]
  <tr><td>sampler_comparison
      <td>[[WebGPU#dom-gpusamplerbindingtype-comparison|comparison]]
  <tr><td rowspan=5>sampled texture
      <td rowspan=5>[[WebGPU#gputextureview|GPUTextureView]]
      <td rowspan=5>GPUTextureSampleType
      <td>[[WebGPU#dom-gputexturesampletype-float|float]]
  <tr>
      <td>[[WebGPU#dom-gputexturesampletype-unfilterable-float|unfilterable-float]]
  <tr>
      <td>[[WebGPU#dom-gputexturesampletype-sint|sint]]
  <tr>
      <td>[[WebGPU#dom-gputexturesampletype-uint|uint]]
  <tr>
      <td>[[WebGPU#dom-gputexturesampletype-depth|depth]]
  <tr><td>[=write-only storage texture=]
      <td>[[WebGPU#gputextureview|GPUTextureView]]
      <td>GPUStorageTextureAccess
      <td>[[WebGPU#dom-gpustoragetextureaccess-write-only|write-only]]
</table>

请参阅 [[WebGPU#abstract-opdef-validating-gpuprogrammablestage|WebGPU API]]
接口验证要求规范。

# 语言扩展 # {#language-extensions}

WGSL 语言预计会随着时间的推移而发展。

<dfn noexport>extension</dfn> 是对 WGSL 规范的特定版本的一组连贯修改的命名分组，由以下任意组合组成：
* 通过新语法添加新概念和行为，包括：
     * 声明、语句、属性和内置函数。
* 删除当前规范或以前发布的扩展中的限制。
* 用于减少允许行为集的语法。
* 用于限制程序的一部分可用的功能的语法。
* 扩展如何与现有规范交互以及可选地与其他扩展交互的描述。

假设，扩展可用于:
* 添加数字标量类型，例如不同位宽的整数。
* 添加语法以限制浮点舍入模式。
* 添加语法以表示着色器不使用原子类型。
* 添加新的语句。
* 添加新的内置函数。
* 添加对着色器调用执行方式的约束。
* 添加新的着色器阶段。

## 启用指令 ## {#enable-directive-section}

<dfn noexport>enable directive</dfn> 表示由特定命名的 [=extension=] 可以被使用。
语法规则意味着所有启用指令必须出现在任何 [=declarations=] 之前。

该指令使用 [=identifier=], [=keyword=], 或 [=reserved word=] 来命名扩展。有效的扩展名列在 [[#extension-list]] 中。

指令对标识符的使用与将该标识符用作任何 [=declaration=] 中的名称不冲突。

<div class='syntax' noexport='true'>
  <dfn for=syntax>enable_directive</dfn> :

    | [=syntax/enable=] [=syntax/ident=] [=syntax/semicolon=]
</div>

注意：语法规则包括终止分号标记，确保附加功能仅在该分号之后可用。
因此，任何 WGSL 实现都可以解析整个 `enable` 指令。
当实现遇到不受支持的扩展的启用指令时，实现可以发出明确的诊断。

<div class='example wgsl using extensions expect-error' heading="Using hypothetical extensions">
  <xmp highlight='rust'>
    // Enable a hypothetical extension for arbitrary precision floating point types.
    enable aribtrary_precision_float;
    enable arbitrary_precision_float; // A redundant enable directive is ok.

    // Enable a hypothetical extension to control the rounding mode.
    enable rounding_mode;

    // Assuming arbitrary_precision_float enables use of:
    //    - a type f<E,M>
    //    - as a type in function return, formal parameters and let-declarations
    //    - as a type constructor from AbstractFloat
    //    - operands to division operator: /
    // Assuming @rounding_mode attribute is enabled by the rounding_mode enable directive.
    @rounding_mode(round_to_even)
    fn halve_it(x : f<8, 7>) -> f<8, 7> {
      let two = f<8, 7>(2);
      return x / 2; // uses round to even rounding mode.
    }
  </xmp>
</div>

## 扩展列表 ## {#extension-list}

<table class='data'>
  <caption>Extension identifier</caption>
  <thead>
    <tr><th>Identifier
        <th>WebGPU extension name
        <th>Description
  </thead>
  <tr><td><dfn noexport dfn-for="extension">`f16`</dfn>
      <td>`"shader-f16"`
      <td>Keyword `f16` and any [=floating point literal=] with a `h` suffix is valid if and only if this extension is enabled. Otherwise, using `f16` keyword or any [=floating point literal=] with a `h` suffix will result in a [=shader-creation error=].
</table>


# WGSL 项目 # {#wgsl-module}

WGSL 程序是一系列可选的 [=directives=] 后跟 [=module scope=] [=declarations=]。

<div class='syntax' noexport='true'>
  <dfn for=syntax>translation_unit</dfn> :

    | [=syntax/global_directive=] * [=syntax/global_decl=] *
</div>

<div class='syntax' noexport='true'>
  <dfn for=syntax>global_decl</dfn> :

    | [=syntax/semicolon=]

    | [=syntax/global_variable_decl=] [=syntax/semicolon=]

    | [=syntax/global_constant_decl=] [=syntax/semicolon=]

    | [=syntax/type_alias_decl=] [=syntax/semicolon=]

    | [=syntax/struct_decl=] [=syntax/semicolon=]

    | [=syntax/function_decl=]
</div>
## 限制条件 ## {#limits}

程序必须满足以下限制：

<table class='data'>
  <caption>可量化的着色器复杂性限制</caption>
  <thead>
    <tr><th>限制<th>最大值
  </thead>
    <tr><td>[=structure=] 类型中的成员数<td>16383
    <tr><td>[=composite=] 类型的[=Nesting depth=] <td>255
    <tr><td>函数的 [=formal parameter|parameters=] 的数量<td>255
    <tr><td>[=statement/switch=] 语句中的 case 选择器值的数量<td>16383
</table>

# Execution # {#execution}

[[#technical-overview]] 描述了如何调用着色器并将其划分为 [=invocations=]。
本节描述了对调用如何单独和集体执行的进一步限制。

## 调用中的程序顺序 ## {#program-order}

WGSL程序中的每个语句在执行过程中可能会被执行零次或多次。
对于给定的调用，给定语句的每次执行都代表一个唯一的<dfn noexport>动态语句实例</dfn>。

当语句包含表达式时，语句的语义决定：
* 表达式是否作为语句执行的一部分进行评估。
* 语句中独立表达式之间求值的相对顺序。

表达式嵌套定义了完成评估必须满足的数据依赖关系。
也就是说，必须先计算嵌套表达式，然后才能计算封闭表达式。
表达式操作数的计算顺序是从左到右
WGSL。
例如，`foo() + bar()` 必须在 `bar()` 之前计算 `foo()`。
参见 [[#expressions]]。

WGSL 程序中的语句按控制流顺序执行。
参见 [[#statements]] 和 [[#function-calls]]。

## 一致性## {#uniformity}
### 术语和概念### {#uniformity-concepts}

以下定义只是提供信息，试图对下一小节中的分析正在计算的内容给出一个直觉。
分析实际上定义了这些概念，以及程序何时有效或违反了统一性规则。
对于给定的一组调用：
- 如果给定范围内的所有调用都像在程序中的给定点同步执行一样执行，则称该点具有<dfn noexport>统一控制流</dfn>。
    - 对于一个[=计算着色器阶段=]，统一控制流的范围是同一个[=计算着色器阶段/workgroup=]中的所有调用.
    - 对于其他着色器阶段，统一控制流的范围是在同一 [=draw command=] 中对该 [=entry point=] 的所有调用。
- 如果一个表达式在统一控制流中执行，并且所有调用计算相同的值，则称它是 <dfn noexport>统一值</dfn>.
- 如果调用在局部变量的每个活动点都保持相同的值，则称其为 <dfn noexport>统一变量</dfn>

### 均匀度分析概述### {#uniformity-overview}

一些函数（例如屏障和导数）只有在[=统一控制流=]中调用才是安全的。
在本节中，我们指定了一个分析来验证这些函数是否仅在这样的上下文中被调用。

<div class="note">注意：此分析具有以下理想属性：
       - 声音（意味着它拒绝所有会破坏内置一致性要求的程序）
       - 线性时间复杂度（以程序中的令牌数量计）
       - 将一段代码重构为函数，或内联函数，如果着色器在转换之前有效，则不能使着色器无效
       - 如果分析拒绝一个程序，它会提供一个简单的暗示链，用户代理可以使用这些暗示来制作一个好的错误消息
</div>

该分析分析每个函数，验证是否存在可以安全调用此函数的上下文。 如果没有这样的上下文，它会拒绝该程序为无效。

同时，它计算有关函数的元数据，以依次帮助分析其调用者。
这意味着必须首先构建调用图，并且必须从叶子向上分析函数，即从不调用标准库之外的函数的函数到入口点。
这样，每当分析一个函数时，它的所有被调用者的元数据都已经被计算出来。
没有陷入循环的风险，因为语言中禁止重复。

注意：同样的事情的另一种说法是，我们对按“是（可能是间接的）被调用者”偏序排序的函数进行拓扑排序，并按该顺序分析它们。

### 分析函数的一致性要求 ### {#uniformity-function}

每个功能分两个阶段进行分析。

第一阶段遍历函数的语法，根据以下小节中的规则构建一个有向图。
第二阶段探索该图，导致要么拒绝程序，要么计算调用此函数的约束。
<div class="note">注：除了RequiredToBeUniform和MayBeNonUniform这两个特殊节点外，所有节点都可以理解为具有以下含义之一：
        - 一个程序特定节点必须在[=uniform control flow=]中执行。
        - 一个表达式必须为一个[=uniform value=]
        - 一个变量必须为一个[=uniform variable=]

        一条边可以理解为从其源节点对应的语句到其目标节点对应的语句的蕴涵。

        为了表达某些东西必须始终是统一的（例如，派生类调用站点的控制流），我们将一条从 RequiredToBeUniform 的边添加到相应的节点。
        理解这一点的一种方法是，RequiredToBeUniform 对应于命题 True，因此 RequiredToBeUniform -> X 等同于说 X 为真。

        反过来，为了表示我们无法确保某些事物的一致性（例如，保存线程 id 的变量），我们将一条从相应节点的边添加到 MayBeNonUniform。
        理解这一点的一种方法是，MayBeNonUniform 对应于命题 False，因此 X -> MayBeNonUniform 等同于说 X 为假。

        这种解释的一个结果是，从RequiredToBeUniform 可到达的每个节点都对应于程序必须是一致的东西才能有效，并且每个MayBeNonUniform 可以到达的节点都对应于我们无法保证其一致性的东西。如果存在从RequiredToBeUniform 到MayBeNonUniform 的任何路径，那么我们就会违反一致性（因此拒绝该程序）。
</div>

对于每个函数，两个标签被计算：
  * <dfn noexport>调用站点标签</dfn>描述函数[=call sites=]上的控制流一致性要求, 及
  * <dfn noexport>函数标签</dfn> 描述函数对均匀性的影响。

此外，对于函数的每个 [=formal parameter=]，<dfn noexport>参数标签</dfn>被计算出来，描述了参数值的一致性要求。

<table class='data'>
  <caption>[=Call site tag=] values</caption>
  <thead>
    <tr><th>Call Site Tag<th>Description
  </thead>
  <tr><td><dfn noexport>CallSiteRequiredToBeUniform</dfn>
      <td>The function must only be called from [=uniform control flow=].
  <tr><td><dfn noexport>CallSiteNoRestriction</dfn>
      <td>The function may be called from [=uniform control flow|non-uniform control flow=].
</table>

<table class='data'>
  <caption>[=Function tag=] values</caption>
  <thead>
    <tr><th>Function Tag<th>Description
  </thead>
  <tr><td><dfn noexport>SubsequentControlFlowMayBeNonUniform</dfn>
      <td>Calling this function may cause control flow to be non-uniform immediately after the [=call site=].
  <tr><td><dfn noexport>ReturnValueMayBeNonUniform</dfn>
      <td>The [=return value=] of the function may be non-uniform.
  <tr><td><dfn noexport>NoRestriction</dfn>
      <td>The function does not introduce non-uniformity.
</table>

<table class='data'>
  <caption>[=Parameter tag=] values</caption>
  <thead>
    <tr><th>Parameter Tag<th>Description
  </thead>
  <tr><td><dfn noexport>ParameterRequiredToBeUniform</dfn>
      <td>The parameter must be a [=uniform value=].
  <tr><td><dfn noexport>ParameterRequiredToBeUniformForSubsequentControlFlow</dfn>
      <td>The parameter must be a [=uniform value=] for control flow after the function call to be [=uniform control flow|uniform=].
  <tr><td><dfn noexport>ParameterRequiredToBeUniformForReturnValue</dfn>
      <td>The parameter must be a [=uniform value=] in order for the [=return value=] to be a uniform value.
  <tr><td><dfn noexport>ParameterNoRestriction</dfn>
      <td>The parameter value has no uniformity requirement.
</table>

以下算法描述了如何为给定函数计算这些标签：

* 创建名为“RequiredToBeUniform”、“MayBeNonUniform”、“CF_start”、“CF_return”的节点，如果函数为非 void，则创建名为“Value_return”的节点
* 为函数的每个参数创建一个节点，我们称之为“arg_i”
* 遍历函数的语法，按照下一节的规则向图中添加节点和边（[[#uniformity-statements]]、[[#uniformity-function-calls]]、[[#uniformity-expressions ]])，使用 CF_start 作为函数体的起始控制流。
* 查看从“RequiredToBeUniform”可以到达哪些节点
    * 如果该集合包含节点“MayBeNonUniform”，则拒绝该程序。
    * 如果该集合包括“CF_start”，则可以调用该函数的控制流是 AlwaysRequiredToBeUniform。
    * 否则[=调用站点标签=]为[=CallSiteNoRestriction=]
    * 对于这个集合中的每一个“arg_i”，对应[=参数标签=] 为 [=ParameterRequiredToBeUniform=]
    * 从图中删除所有已访问的节点
* 查看从“CF_return”可以到达哪些节点
    * 如果该集合包含“MayBeNonUniform”，则函数的[=function tag=]为[=SubsequentControlFlowMayBeNonUniform=]
    * 对于这个集合中的每一个“arg_i”，对应[=parameter tag=] 为 [=ParameterRequiredToBeUniformForSubsequentControlFlow=]
    * 从图中删除所有已访问的节点
* 如果“Value_return”存在，查看哪些节点可以从它到达
    * 如果该集合包含“MayBeNonUniform”，则[=function tag=] 为 [=ReturnValueMayBeNonUniform=]
    * 对于这个集合中的每一个“arg_i”，对应[=parameter tag=] 为 [=ParameterRequiredToBeUniformForReturnValue=]
* 如果[=function tag=]没有被分配一个[=parameter tag=]，那么它是 NoRestriction。
* 对于每个参数，如果没有分配标签，则为 NoRestriction。

注意：此时可以销毁整个图形。上面列出的标签是我们分析这个函数的调用者需要记住的所有标签。

### 语句的统一性规则 ### {#uniformity-statements}

分析语句的规则将语句本身和对应于它开头的控制流的节点（我们将在下面记为“CF”）作为参数，并返回以下两个：

* 出口对应控制流的节点
* 一组要添加到图中的新节点和边

在下表中，`(CF1, S) => CF2` 表示“从控制流 CF1 开始对 S 进行分析，将所需的更改应用于图形，并将生成的控制流命名为 CF2”。
类似地，`(CF1, E) => (CF2, V)` 表示“对表达式 E 运行分析，从控制流 CF1 开始，将所需的更改应用于图形，并将生成的控制流节点命名为 CF2 和生成的值节点 V”（表达式分析见下节）。

对于左值位置的表达式，我们有一组类似的规则，我们用 `LValue: (CF, E) => (CF, L)` 表示。它不是计算与值的一致性相对应的节点，而是计算与我们正在寻址的变量的一致性相对应的节点。

当必须创建多个边时，我们使用 `X -> {Y, Z}` 作为 `X -> Y, X -> Z` 的简写。
<table class='data'>
  <caption>语句的统一性规则</caption>
  <thead>
    <tr><th>语句<th>新节点<th>递归分析s<th>产生的控制流节点<th>新边缘
  </thead>
  <tr><td class="nowrap">{*s*}
      <td>
      <td class="nowrap">(*CF*, *s*) => *CF'*
      <td>*CF'*
      <td>
  <tr><td class="nowrap">*s1* *s2*,<br>
        with Next in behavior of *s1*

        Note: *s1* often ends in a semicolon.

      <td>
      <td class="nowrap">(*CF*, *s1*) => *CF1*<br>
          (*CF1*, *s2*) => *CF2*
      <td>*CF2*
      <td>
    <tr><td class="nowrap">*s1* *s2*,<br>
        without Next in behavior of *s1*

        Note: *s1* often ends in a semicolon.

      <td>
      <td>(*CF*, *s1*) => *CF1*<br>

      Note: *s2* is statically unreachable and not recursively analyzed.
      *s2* does not contribute to the uniformity analysis.
      <td>*CF1*
      <td>
    <tr><td class="nowrap">if *e* *s1* else *s2*<br> with behavior {Next}
      <td>
      <td rowspan=2 class="nowrap">(*CF*, *e*) => (*CF'*, *V*)<br>
          (*V*, *s1*) => *CF1*<br>
          (*V*, *s2*) => *CF2*
      <td>*CF*
      <td>
  <tr><td class="nowrap">if *e* *s1* else *s2*<br> with another behavior
      <td>*CFend*
      <td>*CFend*
      <td class="nowrap">*CFend* -> {*CF1*, *CF2*}
  <tr><td class="nowrap">loop {*s1* continuing {*s2*}}<br> with behavior {Next}
      <td rowspan=2>*CF'*
      <td rowspan=2 class="nowrap">(*CF'*, *s1*) => *CF1*<br>
          (*CF1*, *s2*) => *CF2*
      <td>*CF*
      <td rowspan=2 class="nowrap">*CF'* -> {*CF2*, *CF*}
  <tr><td class="nowrap">loop {*s1* continuing {*s2*}}<br> with another behavior
      <td>*CF'*
  <tr><td class="nowrap">loop {*s1*}, with behavior {Next}
      <td rowspan=2>*CF'*
      <td rowspan=2 class="nowrap">(*CF'*, *s1*) => *CF1*
      <td>*CF*
      <td rowspan=2 class="nowrap">*CF'* -> {*CF1*, *CF*}
  <tr><td class="nowrap">loop {*s1*}<br> with another behavior
      <td>*CF'*
  <tr><td class="nowrap">switch *e* case _: *s_1* .. case _: *s_n*<br> with behavior {Next}
      <td>
      <td rowspan=2 class="nowrap">(*CF*, *e*) => (*CF'*, *V*)<br>
        (*V*, *s_1*) => *CF_1*<br>
        ...<br>
        if *s_(n-1)* may fallthrough, (*CF_(n-1)*, *s_n*) => *CF_n*<br>
        else (*V*, *s_n*) => *CF_n*
      <td>*CF*
      <td>
  <tr><td class="nowrap">switch *e* case _: *s_1* .. case _: *s_n*<br> with another behavior
      <td>*CFend*
      <td>*CFend*
      <td class="nowrap">*CFend* -> {*CF_1*, ..., *CF_n*}
  <tr><td class="nowrap">var x: T;
      <td rowspan=2>
      <td rowspan=2>
      <td rowspan=2>*CF*
      <td rowspan=2>
  <tr><td class="nowrap">break;
  <tr><td class="nowrap">break if *e*;
    <td>
    <td class="nowrap">(*CF*, *e*) => (*CF'*, *V*)
    <td>*CF'*
    <td>
  <tr><td class="nowrap">continue;
      <td rowspan=3>
      <td rowspan=3>
      <td rowspan=3>*CF*
      <td rowspan=3>
  <tr><td class="nowrap">fallthrough;
  <tr><td class="nowrap">discard;
  <tr><td class="nowrap">return;
      <td>
      <td>
      <td>*CF*
      <td>*CF_return* -> *CF*
  <tr><td class="nowrap">return *e*;
      <td>
      <td class="nowrap">(*CF*, *e*) => (*CF'*, *V*)
      <td>*CF'*
      <td>*CF_return* -> *CF'*<br>
          *Value_return* -> *V*
  <tr><td class="nowrap">*e2* = *e1*;
      <td>
      <td class="nowrap">(*CF*, *e1*) => (*CF1*, *V1*)<br>
          LValue: (*CF1*, *e2*) => (*CF2*, *L2*)
      <td>*CF2*
      <td>*L2* -> *V1*
  <tr><td class="nowrap">_ = *e*
      <td>
      <td class="nowrap">(*CF*, *e*) => (*CF'*, *V*)
      <td>*CF'*
      <td>
  <tr><td class="nowrap">let x = *e*;
      <td rowspan=2>
      <td rowspan=2 class="nowrap">(*CF*, *e*) => (*CF'*, V)
      <td rowspan=2>*CF'*
      <td rowspan=2>
  <tr><td class="nowrap">var x = *e*;
</table>

注意：如果 if、switch 或循环语句的行为集（参见 [[#behaviors]]）是 {Next}，这意味着我们要么在语句内没有发散，要么重新收敛，所以我们选择 语句开头的控制流对应的节点作为语句出口的控制流对应的节点。

注意：在 switch 语句中，就一致性而言，默认块被视为与 case 块完全相同。
### 函数调用的统一性规则 ### {#uniformity-function-calls}

最复杂的规则是函数调用：
- 对于每个参数，应用相应的表达式规则，控制流位于前一个参数的出口处（使用第一个参数的函数调用开头的控制流）。将相应的值节点命名为“arg_i”，将相应的控制流节点命名为“CF_i”
- 创建两个新节点，分别命名为“Result”和“CF_after”
- 如果函数的[=call site tag=] 为 [=CallSiteRequiredToBeuniform=]，则从 RequiredToBeUniform 添加一条边到最后一个 CF_i
- 否则添加一条从 CF_after 到最后一个 CF_i 的边
- 如果[=function tag=] 为 [=SubsequentControlFlowMayBeNonUniform=]，则添加一条从 CF_after 到 MayBeNonUniform 的边
- 否则，如果[=function tag=] 为 [=ReturnValueMayBeNonUniform=]，则从 Result 添加一条边到 MayBeNonUniform
- 从 Result 添加一条边到 CF_after
- 对于每个参数 *i*：
    - 如果相应的[=parameter tag=] 为 [=ParameterRequiredToBeUniform=]，则从 RequiredToBeUniform 添加一条边到 arg_i
    - 否则，如果[=parameter tag=] 为 [=ParameterRequiredToBeUniformForSubsequentControlFlow=]，则将一条边从CF_after添加到arg_i
    - 否则，如果[=parameter tag=] 为 [=ParameterRequiredToBeUniformForReturnValue=]，则从Result添加一条边到arg_i

注意：请注意，此规则只需要添加以 3 + 函数参数数量为界的边数，而与函数的实现可能有多复杂无关。 这是整个算法线性复杂度的关键。

大多数内置函数都有以下标签：
- [=CallSiteNoRestriction=]的[=call site tag=]
- [=NoRestriction=]的[=function tag=]
- 对于每个参数：[=ParameterRequiredToBeUniformForReturnValue=]的[=parameter tag|tag=]

以下是例外列表：
- [[#sync-builtin-functions]] 中的所有函数都有一个 [=CallSiteRequiredToBeuniform=] 的 [=call site tag=]
- [[#derivative-builtin-functions]]、[[#texturesample]]、[[#texturesamplebias]]和[[#texturesamplecompare]]中的所有函数都有一个 [=CallSiteRequiredToBeUniform=] 的 [=call site tag=] 和一个 [=ReturnValueMayBeNonUniform=] 的 [=function tag=]

### 表达式的统一性规则 ### {#uniformity-expressions}

分析表达式的规则将表达式本身和对应于它开头的控制流的节点（我们将在下面记为“CF”）作为参数，并返回以下内容：

* 出口对应控制流的节点
* 一个节点对应其值
* 一组要添加到图中的新节点和边

<table class='data'>
  <caption>表达式的一致性规则（在正常的右值位置）</caption>
  <thead>
    <tr><th>表达式<th>新节点<th>递归分析<th>产生的控制流节点、值节点<th>新边缘
  </thead>
  <tr><td class="nowrap">*e1* || *e2*
      <td rowspan=2>
      <td rowspan=2 class="nowrap">(*CF*, *e1*) => (*CF1*, *V1*)<br>
          (*V1*, *e2*) => (*CF2*, *V2*)
      <td rowspan=2 class="nowrap">*CF2*, *V2*
      <td rowspan=2>
  <tr><td class="nowrap">*e1* && *e2*
  <tr><td class="nowrap">Literal
      <td>
      <td>
      <td class="nowrap">*CF*, *CF*
      <td>
   <tr><td>reference to function-scope variable, creation-time constant, let-declaration, or non-built-in parameter "x"
      <td>*Result*
      <td class="nowrap">*X* is the node corresponding to "x"
      <td class="nowrap">*CF*, *Result*
      <td class="nowrap">*Result* -> {*CF*, *X*}
   <tr><td class="nowrap">reference to uniform built-in value "x"
      <td>
      <td>
      <td class="nowrap">*CF*, *CF*
      <td>
   <tr><td class="nowrap">reference to non-uniform built-in value "x"
      <td>
      <td>
      <td class="nowrap">*CF*, *MayBeNonUniform*
      <td>
   <tr><td class="nowrap">reference to read-only module-scope variable "x"
      <td>
      <td>
      <td class="nowrap">*CF*, *CF*
      <td>
   <tr><td class="nowrap">reference to non-read-only module-scope variable "x"
      <td>
      <td>
      <td class="nowrap">*CF*, *MayBeNonUniform*
      <td>
   <tr><td class="nowrap">*op* *e*,<br> where *op* is a unary operator
      <td rowspan=2>
      <td rowspan=2 class="nowrap">(*CF*, *e*) => (*CF'*, *V*)
      <td rowspan=2 class="nowrap">*CF'*, *V*
      <td rowspan=2>
   <tr><td class="nowrap">*e*.field
   <tr><td>*e1* *op* *e2*,<br> where *op* is a non-short-circuiting binary operator
      <td rowspan=2> *Result*
      <td rowspan=2 class="nowrap">(*CF*, *e1*) => (*CF1*, *V1*)<br>
          (*CF1*, *e2*) => (*CF2*, *V2*)
      <td rowspan=2 class="nowrap">*CF2*, *Result*
      <td rowspan=2 class="nowrap">*Result* -> {*V1*, *V2*}
   <tr><td class="nowrap">e1[e2]
</table>

以下内置输入变量被认为是统一的：
- wordgroup_id
- num_workgroups

所有其他的（参见 [[#builtin-values]]）被认为是不均匀的。

<table class='data'>
  <caption>左值位置表达式的一致性规则</caption>
  <thead>
    <tr><th>表达式<th>新节点<th>递归分析<th>产生的控制流节点、值节点<<th>新边缘
  </thead>
  <tr><td>reference to function-scope variable, creation-time constant, let-declaration, or parameter "x"
      <td>
      <td class="nowrap">*X* is the node corresponding to "x"
      <td class="nowrap">*CF*, *X*
      <td>
  <tr><td class="nowrap">reference to module-scope variable "x"
      <td>
      <td>
      <td class="nowrap">*CF*, *MayBeNonUniform*
      <td>
  <tr><td class="nowrap">*e*.field
      <td>
      <td class="nowrap">LValue: (*CF*, *e*) => (*CF1*, *L1*)
      <td class="nowrap">*CF1*, *L1*
      <td>
  <tr><td class="nowrap">*e1*[*e2*]
      <td>
      <td class="nowrap">LValue: (*CF*, *e1*) => (*CF1*, *L1*)<br>
          (*CF1*, *e2*) => (*CF2*, *V2*)
      <td class="nowrap">*CF2*, *L1*
      <td class="nowrap">*L1* -> *V2*
</table>
### 注释控制流中每个点的一致性### {#uniformity-optional-diagnosis-mode}

这整个小节是非规范性的。

如果实现者想为开发人员提供一种诊断模式，显示整个着色器控制流中的每个点是否一致（以及因此调用需要一致的函数是否有效），我们建议下列：
- 运行前面小节中描述的（强制的、规范的）分析，保留每个函数的图表。
- 反转所有这些图中的所有边
- 遍历每个函数，从入口点开始，在访问所有调用者之前从不访问函数：
    - 将 MayBeNonUniform 的边添加到至少在一个调用者中不统一的每个参数
    - 如果函数在至少一个调用者的非统一控制流中被调用，则从 MayBeNonUniform 添加一条边到 CF_start
    - 查看 MayBeNonUniform 可以访问哪些节点。访问的每个节点都是控制流中的一个表达式或点，其一致性无法通过分析得到证明

这些可达性分析未访问的任何节点都可以通过分析证明是统一的（因此在那里调用导数或类似函数是安全的）。

注意：仍然需要自下而上的分析，因为它让我们知道在遇到调用时要向图中添加哪些边。

## 计算着色器和工作组 ## {#compute-shader-workgroups}

<dfn noexport for="compute shader stage">workgroup</dfn> 是一组调用，
它们同时执行 [=compute shader stage=] [=entry point=]，并共享对 [=address spaces/workgroup=] 地址空间。

计算着色器的 <dfn noexport>workgroup grid</dfn> 是具有整数坐标 *(i,j,k)* 的点集，其中：

*  0 &leq; i &lt; workgroup_size_x
*  0 &leq; j &lt; workgroup_size_y
*  0 &leq; k &lt; workgroup_size_z

其中 *(workgroup_size_x, workgroup_size_y, workgroup_size_z)* 是为入口点的 [=attribute/workgroup_size=] 属性指定的值。

对于工作组网格中的每个点，在工作组中恰好有一个调用。

调用的本地调用ID <dfn noexport>local invocation ID</dfn> 是调用对应的工作组网格点的坐标三元组。

当一个调用有[=local invocation ID=] (i,j,k)，那么它的<dfn noexport>local invocation index</dfn>是

  i +
  (j * workgroup_size_x) +
  (k * workgroup_size_x * workgroup_size_y)

<p algorithm="local index range">注意，如果一个工作组有|W| 调用，
然后每次调用 |I| 工作组有一个唯一的本地调用索引 |L|(|I|) 使得 0 &le; |L|(|I|) < |W|，覆盖整个范围。</p>

当 WebGPU 实现从队列中删除调度命令并开始在 GPU 上执行指定工作时，计算着色器开始执行。
dispatch 命令指定<dfn noexport>dispatch size</dfn>，
它是一个整数三元组*(group_count_x, group_count_y, group_count_z)*，指示要执行的工作组的数量，如下所述。

特定分派的 <dfn noexport>compute shader grid</dfn> 是具有整数坐标 *(CSi,CSj,CSk)* 的点集，其中：

*  0 &leq; CSi &lt; workgroup_size_x &times; group_count_x
*  0 &leq; CSj &lt; workgroup_size_y &times; group_count_y
*  0 &leq; CSk &lt; workgroup_size_z &times; group_count_z

其中*workgroup_size_x*，
*workgroup_size_y*，和
*workgroup_size_z* 与上述计算着色器入口点相同。

计算着色器分派要执行的工作是为计算着色器网格中的每个点恰好执行一次入口点调用。

调用的 <dfn noexport>global invocation ID</dfn> 是调用对应的计算着色器网格点的坐标三元组。

调用被组织成工作组，以便每个调用
*(CSi, CSj, CSk)* 用工作组网格点标识

   ( *CSi* mod workgroup_size_x ,
     *CSj* mod workgroup_size_y ,
     *CSk* mod workgroup_size_z )

在 <dfn noexport>workgroup ID</dfn> 中

   ( &lfloor; *CSi* &div; workgroup_size_x &rfloor;,
     &lfloor; *CSj* &div; workgroup_size_y &rfloor;,
     &lfloor; *CSk* &div; workgroup_size_z &rfloor;).

WebGPU 不提供任何保证:

* 来自不同工作组的调用是否并发执行。 也就是说，您不能假设一次执行多个工作组。
* 一旦来自一个工作组的调用开始执行，其他工作组是否被阻止执行。
     也就是说，您不能假设一次只有一个工作组执行。
     当工作组正在执行时，实现可以选择同时执行其他工作组，或其他排队但未阻塞的工作。
* 来自一个特定工作组的调用是否在另一个工作组的调用之前开始执行。
     也就是说，您不能假设工作组是按特定顺序启动的。

## 批量操作 ## {#collective-operations}

### Barrier ### {#barrier}

屏障是一个[[#sync-builtin-functions|synchronization built-in function]]，它对程序中的内存操作进行排序。
<dfn noexport>control barrier</dfn> 由同一个 [=compute shader stage/workgroup=] 中的所有调用执行，就好像它是并发执行的一样。
因此，控制屏障只能在 [=compute shader stage|compute=] 着色器中的[=uniform control flow=]中执行。

### 导数 ### {#derivatives}

偏导数<dfn noexport>partial derivative</dfn> 是值沿轴的变化率。

对相邻片元（在屏幕空间坐标中）操作的片段着色器调用协作计算近似偏导数。
这些相邻的片段被称为 <dfn noexport>quad</dfn>。

*片元坐标*的偏导数是作为以下内置函数运算的一部分隐式计算的：
* [[#texturesample|textureSample]]，
* [[#texturesamplebias|textureSampleBias]]， 和
* [[#texturesamplecompare|textureSampleCompare]]。

对于这些，导数有助于确定要采样的纹素的 mip 级别，或者在“textureSampleCompare”的情况下，对参考值进行采样和比较。

*调用指定*值的偏导数由
[[#derivative-builtin-functions]] 中描述的内置函数：
* `dpdx`、`dpdxCoarse` 和 `dpdxFine` 计算沿 x 轴的偏导数。
* `dpdy`、`dpdyCoarse` 和 `dpdyFine` 计算沿 y 轴的偏导数。
* `fwidth`、`fwidthCoarse` 和 `fwidthFine` 计算相关联的 x 和 y 偏导数的曼哈顿度量。

因为相邻调用必须协作计算导数，所以这些函数只能在片元着色器的[=uniform control flow=]中调用。

## 浮点计算 ## {#floating-point-evaluation}

WGSL 遵循 [[!IEEE-754|IEEE-754]] 浮点计算标准
以下例外:
* 不会产生浮点异常。
* 可能不会生成信令 NaN。
    任何信令 NaN 都可以转换为安静的 NaN。
* 实现可能假设 NaN 和无穷大不存在
     * 注意：这意味着一些函数（例如 `min` 和 `max`）
         由于存在优化，可能不会返回预期的结果
         NaN 和无穷大。
* 实现可能会忽略零的符号。
     也就是说，带正号的零可能表现得像带负号的零，反之亦然。
* 没有指定舍入模式。
* 实现可能会刷新 [[#floating-point-accuracy]] 中列出的任何操作的输入和/或输出的非规范化值。
    * 需要其他操作来保留非规范化数字。
* 操作的准确性在 [[#floating-point-accuracy]] 中给出。

### 浮点精度 ### {#floating-point-accuracy}

<div algorithm="correctly rounded">
让|x| 当以无限精度计算时，是操作的精确实值或无限结果。
<dfn>corrctly rounded</dfn>浮点类型运算的结果|T| 是:
* |x|，但 |x| 在 |T| 的范围内，
* 否则:
    * |T| 中的最小值 大于 |x|，或
    * |T| 中的最大值 小于 |x|。

</div>

也就是说，结果可能会向上或向下舍入：
WGSL 未指定舍入模式。

注意：浮点类型包括正无穷大和负无穷大，所以
正确舍入的结果可能是有限的或无限的。

最后一个单位（<dfn noexport>ULP</dfn>），对于浮点数 `x` 是两个不相等的浮点数 `a `和 `b` 之间的最小距离，
使得 `a` &le ; `x` &le; `b`（即 `ulp(x) = min`<sub>`a,b`</sub>`|b - a|`）。

在下表中，提供了五个操作的准确性
可能性：
* 正确的结果（对于非浮点返回值）。
* [=Correctly rounded=]。
* 相对误差界表示为 [=ULP=]。
* 精度为 <dfn noexport>inherited from</dfn> 的函数。
    也就是说，准确度等于按照导出函数执行运算。
* 绝对误差界限。

对于在一个范围内指定的任何精度值，该范围之外的结果的精度是不确定的。

如果任何操作的允许返回值的大小大于最大可表示的有限浮点值，则该操作可能另外返回具有相同符号的无穷大或具有相同符号的最大有限值。

<table class='data'>
  <caption>表达式的准确性</caption>
  <thead>
    <tr><th>Expression<th>f32的准确性<th>f16的准确性
  </thead>

  <tr><td>`x + y`<td colspan=2 style="text-align:left;">正确四舍五入
  <tr><td>`x - y`<td colspan=2 style="text-align:left;">正确四舍五入
  <tr><td>`x * y`<td colspan=2 style="text-align:left;">正确四舍五入
  <tr><td>`x / y`<td>2.5 ULP 对于在 [2<sup>-126</sup>, 2<sup>126</sup>] 范围内的 `|y|`
  <tr><td>`x % y`<td colspan=2 style="text-align:left;">派生自 `x - y * trunc(x/y)`
  <tr><td>`-x`<td colspan=2 style="text-align:left;">正确四舍五入

  <tr><td>`x == y`<td colspan=2 style="text-align:left;">正确结果
  <tr><td>`x != y`<td colspan=2 style="text-align:left;">正确结果
  <tr><td>`x < y`<td colspan=2 style="text-align:left;">正确结果
  <tr><td>`x <= y`<td colspan=2 style="text-align:left;">正确结果
  <tr><td>`x > y`<td colspan=2 style="text-align:left;">正确结果
  <tr><td>`x >= y`<td colspan=2 style="text-align:left;">正确结果
</table>

<table class='data'>
  <caption>内置函数的准确性</caption>
  <thead>
    <tr><th>内置函数<th>f32的准确性<th>f16的准确性
  </thead>

  <tr><td>`abs(x)`<td colspan=2 style="text-align:left;">正确四舍五入
  <tr><td>`acos(x)`<td colspan=2 style="text-align:left;">派生自 `atan2(sqrt(1.0 - x * x), x)`
  <tr><td>`acosh(x)`<td colspan=2 style="text-align:left;">派生自 `log(x + sqrt(x * x - 1.0))`
  <tr><td>`asin(x)`<td colspan=2 style="text-align:left;">派生自 `atan2(x, sqrt(1.0 - x * x))`
  <tr><td>`asinh(x)`<td colspan=2 style="text-align:left;">派生自 `log(x + sqrt(x * x + 1.0))`
  <tr><td>`atan(x)`<td>4096 ULP<td>5 ULP
  <tr><td>`atan2(y, x)`<td>4096 ULP<td>5 ULP
  <tr><td>`atanh(x)`<td colspan=2 style="text-align:left;">派生自 `log( (1.0 + x) / (1.0 - x) ) * 0.5`
  <tr><td>`ceil(x)`<td colspan=2 style="text-align:left;">正确四舍五入
  <tr><td>`clamp(x,low,high)`<td colspan=2 style="text-align:left;">正确四舍五入
  <tr><td>`cos(x)`<td>Absolute error &le; 2<sup>-11</sup>在范围[-&pi;, &pi;]内<td>Absolute error &le; 2<sup>-7</sup>在范围[-&pi;, &pi;]内
  <tr><td>`cosh(x)`<td colspan=2 style="text-align:left;">派生自 `(exp(x) - exp(-x)) * 0.5`
  <tr><td>`cross(x, y)`<td colspan=2 style="text-align:left;">派生自 `(x[i] * y[j] - x[j] * y[i])`
  <tr><td>`degrees(x)`<td colspan=2 style="text-align:left;">派生自 `x * 57.295779513082322865`
  <tr><td>`distance(x, y)`<td colspan=2 style="text-align:left;">派生自 `length(x - y)`
  <tr><td>`exp(x)`<td>`3 + 2 * |x|` ULP<td>`1 + 2 * |x|` ULP
  <tr><td>`exp2(x)`<td>`3 + 2 * |x|` ULP<td>`1 + 2 * |x|` ULP
  <tr><td class="nowrap">`faceForward(x, y, z)`<td colspan=2 style="text-align:left;">派生自 `select(-x, x, dot(z, y) < 0.0)`
  <tr><td>`floor(x)`<td colspan=2 style="text-align:left;">正确四舍五入
  <tr><td>`fma(x, y, z)`<td colspan=2 style="text-align:left;">派生自 `x * y + z`
  <tr><td>`fract(x)`<td colspan=2 style="text-align:left;">正确四舍五入
  <tr><td>`frexp(x)`<td colspan=2 style="text-align:left;">正确四舍五入
  <tr><td>`inverseSqrt(x)`<td colspan=2 style="text-align:left;">2 ULP
  <tr><td>`ldexp(x, y)`<td colspan=2 style="text-align:left;">正确四舍五入
  <tr><td>`length(x)`<td colspan=2 style="text-align:left;">派生自 `sqrt(dot(x, x))`
  <tr><td>`log(x)`<td>3 ULP outside the range [0.5, 2.0].<br>绝对错误 &lt; 2<sup>-21</sup> 在范围 [0.5, 2.0] 内<td>3 ULP 在范围 [0.5, 2.0] 外.<br>绝对错误 &lt; 2<sup>-7</sup> 在范围 [0.5, 2.0] 内
  <tr><td>`log2(x)`<td>3 ULP outside the range [0.5, 2.0].<br>绝对错误 &lt; 2<sup>-21</sup> 在范围 [0.5, 2.0] 内<td>3 ULP 在范围 [0.5, 2.0] 外.<br>绝对错误 &lt; 2<sup>-7</sup> 在范围 [0.5, 2.0] 内
  <tr><td>`max(x, y)`<td colspan=2 style="text-align:left;">正确四舍五入
  <tr><td>`min(x, y)`<td colspan=2 style="text-align:left;">正确四舍五入
  <tr><td>`mix(x, y, z)`<td colspan=2 style="text-align:left;">派生自 `x * (1.0 - z) + y * z`
  <tr><td>`modf(x)`<td colspan=2 style="text-align:left;">正确四舍五入
  <tr><td>`normalize(x)`<td colspan=2 style="text-align:left;">派生自 `x / length(x)`
  <tr><td>`pow(x, y)`<td colspan=2 style="text-align:left;">派生自 `exp2(y * log2(x))`
  <tr><td>`radians(x)`<td colspan=2 style="text-align:left;">派生自 `x * 0.017453292519943295474`
  <tr><td>`reflect(x, y)`<td colspan=2 style="text-align:left;">派生自 `x - 2.0 * dot(x, y) * y`
  <tr><td>`refract(x, y, z)`<td colspan=2 style="text-align:left;">派生自 `z * x - (z * dot(y, x) + sqrt(k)) * y`,<br>where `k = 1.0 - z * z * (1.0 - dot(y, x) * dot(y, x))`<br>If `k < 0.0` the result is precisely 0.0
  <tr><td>`round(x)`<td colspan=2 style="text-align:left;">正确四舍五入
  <tr><td>`sign(x)`<td colspan=2 style="text-align:left;">正确四舍五入
  <tr><td>`sin(x)`<td>Absolute error &le; 2<sup>-11</sup> 在范围 [-&pi;, &pi;] 内<td>绝对错误 &le; 2<sup>-7</sup> 在范围 [-&pi;, &pi;] 内
  <tr><td>`sinh(x)`<td colspan=2 style="text-align:left;">派生自 `(exp(x) - exp(-x)) * 0.5`
  <tr><td>`smoothstep(low, high, x)`<td colspan=2 style="text-align:left;">派生自 `t * t * (3.0 - 2.0 * t)`,<br>where `t = clamp((x - low) / (high - low), 0.0, 1.0)`
  <tr><td>`sqrt(x)`<td colspan=2 style="text-align:left;">派生自 `1.0 / inverseSqrt(x)`
  <tr><td>`step(edge, x)`<td colspan=2 style="text-align:left;">正确四舍五入
  <tr><td>`tan(x)`<td colspan=2 style="text-align:left;">派生自 `sin(x) / cos(x)`
  <tr><td>`tanh(x)`<td colspan=2 style="text-align:left;">派生自 `sinh(x) / cosh(x)`
  <tr><td>`trunc(x)`<td colspan=2 style="text-align:left;">正确四舍五入

</table>

<dfn noexport>Reassociation</dfn> 是对表达式中的操作进行重新排序，这样如果精确计算，答案是相同的。 例如：
* `(a + b) + c` 重新关联到 `a + (b + c)`
* `(a - b) + c` 重新关联到 `(a + c) - b`
* `(a * b) / c` 重新关联到 `(a / c) * b`

然而，当以浮点计算时，结果可能不一样。
由于近似，重新关联的结果可能不准确，或者在计算中间结果时可能会触发溢出或 NaN。

一个实现可以重新关联操作。

如果转换后的表达式至少与原始公式一样准确，则实现可以融合操作。
例如，一些融合的乘加实现可能比先乘后加法更准确。

### 浮点数转换 ### {#floating-point-conversion}

在本节中，浮点类型可以是以下任何一种：
* WGSL 中的 [=f32=] 和 [=f16=] 类型。
* 对应于 [[!IEEE-754|IEEE-754]] 浮点标准定义的二进制格式的假设类型。

注意：回想一下 [=f32=] WGSL 类型对应于 IEEE-754 binary32 格式，[=f16=] WGSL 类型对应于 IEEE-754 binary16 格式。

将浮点标量值转换为整数类型时：
* 如果原始值可以在目标类型中准确表示，则结果就是该值。
* 否则，原始值朝零四舍五入。
     * 如果舍入的值在目标类型中完全可表示，则结果就是该值。
     * 否则，结果是目标类型中最接近舍入值的值。

注意：换句话说，浮点到整数的转换会向零舍入，然后饱和。

注意：溢出情况下的结果可能不会产生目标类型中幅度最大的值，因为
该值可能无法在原始浮点类型中完全表示。
例如，[=u32=] 中的最大值是 4294967295，但是 4294967295.0 在 `f32` 中不能完全表示。
对于任何实数 |x| 与 4294967040 &leq; |x| &leq; 4294967295,
最接近 |x| 的 f32 值 大于 429467295 或向下舍入为 4294967040。
因此，浮点转换产生的最大 u32 值为 4294967040u。

将值转换为浮点类型时：
* 如果原始值可以在目标类型中准确表示，则结果就是该值。
    * 如果原始值为零且为整数类型，则结果值具有零符号位。
* 否则，原始值不能完全表示。
    * 如果原始值不同于但位于目标类型中可表示的两个相邻值之间，则结果是这两个值之一。
         WGSL 没有指定是选择较大还是较小的可表示值，并且此类转换的不同实例可能选择不同。
    * 否则，如果原始值位于目标类型的范围之外。
         * 当原始类型为 [=i32=] 或 [=u32=] 之一且目标类型为 [=f32=] 时，不会发生这种情况。
         * 当源类型是指数和尾数位较少的浮点类型时，不会发生这种情况。
         * 如果源类型是尾数位多于目标类型的浮点类型，则：
             * 可以丢弃源值的额外尾数位（将它们视为 0）。
                 * 如果结果值是目标类型的最大正常值，那么这就是结果。
             * 否则，结果是与源值具有相同符号的无穷大值。
    * 否则，如果源类型的原始值是 NaN，则结果是目标类型的 NaN。

注意：整数值可能位于两个相邻的可表示浮点值之间。
特别是，[=f32=] 类型使用 23 个显式小数位。
此外，当浮点值在正常范围内时（指数既不是极值），尾数就是小数位的集合，以及在位位置 23 的最高有效位置处的额外 1 位。
然后，例如，整数 2<sup>28</sup> 和 1+2<sup>28</sup> 都映射到相同的浮点值：
最低有效 1 位不能用浮点格式表示。
这种碰撞发生在大小至少为 2<sup>25</sup> 的相邻整数对中。

问题：(dneto) 默认舍入模式是一种实现选择。 那是我们想要的吗？

问题：检查 f32 到 f16 转换的行为是否超出了最大正常 f16 值。
我已经写了 NVIDIA GPU 的功能。 有关可执行的测试用例，请参阅 https://github.com/google/amber/pull/918。

# 内存模型 # {#memory-model}
通常，WGSL 遵循 [[!VulkanMemoryModel|Vulkan Memory Model]]。
本节的其余部分描述了 WGSL 程序如何映射到 Vulkan 内存模型。
注意：Vulkan 内存模型是[formal Alloy model](https://github.com/KhronosGroup/Vulkan-MemoryModel/blob/master/alloy/spirv.als) 的文本版本。

## Memory Operation ## {#memory-operation}
在 WGSL 中，[=read access=] 相当于 Vulkan 内存模型中的内存读取操作。
在 WGSL 中, [=write access=] 相当于 Vulkan Memory Model 中的内存写操作。
[=read access=] 当调用执行以下操作之一时发生：
* 对 [=Load Rule=] 的评估
* 任意 [[#texture-builtin-functions|texture builtin function]] 除了:
    * [[#texturedimensions|textureDimensions]]
    * [[#texturestore|textureStore]]
    * [[#texturenumlayers|textureNumLayers]]
    * [[#texturenumlevels|textureNumLevels]]
    * [[#texturenumsamples|textureNumSamples]]
* 除 [[#atomic-store|atomicStore]] 之外的任何原子内置函数

[=write access=] 当调用执行以下操作之一时发生：
* [=statement/assignment=] 语句
* [[#texturestore|textureStore]] 内置函数
* 除 [[#atomic-load|atomicLoad]] 之外的任何原子内置函数
    * [[#atomic-rmw|atomicCompareExchangeWeak]] 仅当返回结果的 `exchanged` 成员为 `true` 时才执行写入

[[#atomic-rmw|Atomic read-modify-write]] 内置函数执行单个内存操作，即 [=read access=] 和 [=write access=]。
在任何其他情况下都不会发生读和写访问。

读写访问在 Vulkan 中统称为[内存操作](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#memory-model-memory-operation) 内存模型。
内存操作准确访问与操作中使用的特定 [=memory view=] 相关联的一组 [=memory location|locations=]。 例如，从包含多个成员的结构访问 [=u32=] 的内存读取，仅读取与该 u32 关联的内存位置
成员。

<div class='example wgsl memory locations accessed' heading="Accessing memory locations">
  <xmp highlight='rust'>
    [[block]] struct S {
      a : f32,
      b : u32,
      c : f32
    }
    @group(0) @binding(0)
    var<storage> v : S;
    fn foo() {
      let x = v.b; // Does not access memory locations for v.a or v.c.
    }
  </xmp>
</div>

## 内存模型参考 ## {#memory-model-reference}
WGSL 中的每个模块范围变量形成一个唯一的 [memory model reference](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#memory-model-references) 在给定入口点的生命周期内。
WGSL 中的每个函数范围变量形成一个唯一的 [memory model reference](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#memory-model-references) 对于变量的生命周期。

## 范围操作 ## {#scoped-operations}
当一个调用执行一个作用域操作时，它会影响一个或两个集合的调用。
这些集合是内存范围和执行范围。 <dfn noexport>memory scope</dfn> 指定将看到任何
更新受操作影响的内存内容。
对于 [[#sync-builtin-functions|同步内置函数]]，这也是
表示所有受影响的内存操作程序在函数之前排序
对在函数之后排序的受影响的操作程序可见。
<dfn noexport>execution scope</dfn> 指定调用集
可能参与一个操作（参见 [[#collective-operations]]）。

[[#atomic-builtin-functions|Atomic built-in functions]] 映射到 [=memory model atomic
operation|atomic operations=] 其内存 [=memory model scope|scope=] 为：
* `Workgroup` 如果原子指针在 [=address spaces/workgroup=]
    地址空间
* `QueueFamily` 如果原子指针在 [=address spaces/storage=]
    地址空间

[[#sync-builtin-functions|同步内置函数]] 映射到控制
执行和内存 [=memory model scope|scopes=] 的障碍
`工作组`。

隐式和显式导数具有隐式 [=quad=] 执行范围。

注意：当生成不启用 `Vulkan` 内存模型的 SPIR-V 时，
应该使用 `Device` 范围而不是 `QueueFamily`。

## 内存语义 ## {#memory-semantics}
所有 [[#atomic-builtin-functions|Atomic built-in functions]] 使用 `Relaxed`
[memory
semantics](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#memory-model-memory-semantics)
因此，没有内存语义。
[[#sync-builtin-functions|workgroupBarrier]] 使用 `AcquireRelease` [memory
semantics](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#memory-model-memory-semantics)
和 `WorkgroupMemory` 内存语义。
[[#sync-builtin-functions|storageBarrier]] 使用 `AcquireRelease` [memory
semantics](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#memory-model-memory-semantics)
和 `UniformMemory` 内存语义。
注意:组合的“workgroupBarrier”和“storageBarrier”使用“AcquireRelease”排序语义以及“WorkgroupMemory”和“UniformMemory”内存语义。

注意：没有原子或同步内置函数使用 `MakeAvailable` 或 `MakeVisible` 语义。

## Private vs Non-private ## {#private-vs-non-private}
[=address spaces/storage=] 中的所有非原子 [=read accesses=] 或
[=address spaces/workgroup=] 地址空间被视为 [non-private](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#memory-model-non-private)
并对应于具有以下范围的 `NonPrivatePointer | MakePointerVisible` 内存操作数的读取操作：
* [=address spaces/workgroup=] 地址空间的 `Workgroup`
* `QueueFamily` 用于 [=storage classes/storage=] 存储类

[=storage classes/storage=] 中的所有非原子 [=write accesses=] 或
[=storage classes/workgroup=] 存储类别被考虑
[non-private](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#memory-model-non-private)
并对应于具有以下范围的 `NonPrivatePointer | MakePointerAvailable` 内存操作数的写操作：
* [=storage classes/workgroup=] 存储类的 `Workgroup`
* `QueueFamily` 用于 [=storage classes/storage=] 存储类

问题: https://github.com/gpuweb/gpuweb/issues/1621


# 关键字和符号摘要 # {#grammar}

## 关键字摘要 ## {#keyword-summary}

### 类型定义关键字 ### {#type-defining-keywords}

<div class='syntax' noexport='true'>
  <dfn for=syntax>array</dfn> :

    | `'array'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>atomic</dfn> :

    | `'atomic'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>bool</dfn> :

    | `'bool'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>float32</dfn> :

    | `'f32'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>float16</dfn> :

    | `'f16'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>int32</dfn> :

    | `'i32'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>mat2x2</dfn> :

    | `'mat2x2'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>mat2x3</dfn> :

    | `'mat2x3'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>mat2x4</dfn> :

    | `'mat2x4'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>mat3x2</dfn> :

    | `'mat3x2'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>mat3x3</dfn> :

    | `'mat3x3'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>mat3x4</dfn> :

    | `'mat3x4'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>mat4x2</dfn> :

    | `'mat4x2'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>mat4x3</dfn> :

    | `'mat4x3'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>mat4x4</dfn> :

    | `'mat4x4'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>override</dfn> :

    | `'override'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>pointer</dfn> :

    | `'ptr'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>sampler</dfn> :

    | `'sampler'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>sampler_comparison</dfn> :

    | `'sampler_comparison'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>struct</dfn> :

    | `'struct'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_1d</dfn> :

    | `'texture_1d'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_2d</dfn> :

    | `'texture_2d'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_2d_array</dfn> :

    | `'texture_2d_array'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_3d</dfn> :

    | `'texture_3d'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_cube</dfn> :

    | `'texture_cube'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_cube_array</dfn> :

    | `'texture_cube_array'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_multisampled_2d</dfn> :

    | `'texture_multisampled_2d'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_storage_1d</dfn> :

    | `'texture_storage_1d'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_storage_2d</dfn> :

    | `'texture_storage_2d'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_storage_2d_array</dfn> :

    | `'texture_storage_2d_array'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_storage_3d</dfn> :

    | `'texture_storage_3d'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_depth_2d</dfn> :

    | `'texture_depth_2d'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_depth_2d_array</dfn> :

    | `'texture_depth_2d_array'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_depth_cube</dfn> :

    | `'texture_depth_cube'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_depth_cube_array</dfn> :

    | `'texture_depth_cube_array'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_depth_multisampled_2d</dfn> :

    | `'texture_depth_multisampled_2d'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>uint32</dfn> :

    | `'u32'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>vec2</dfn> :

    | `'vec2'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>vec3</dfn> :

    | `'vec3'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>vec4</dfn> :

    | `'vec4'`
</div>

### Other Keywords ### {#other-keywords}

<div class='syntax' noexport='true'>
  <dfn for=syntax>bitcast</dfn> :

    | `'bitcast'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>break</dfn> :

    | `'break'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>case</dfn> :

    | `'case'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>continue</dfn> :

    | `'continue'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>continuing</dfn> :

    | `'continuing'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>default</dfn> :

    | `'default'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>discard</dfn> :

    | `'discard'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>else</dfn> :

    | `'else'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>enable</dfn> :

    | `'enable'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>fallthrough</dfn> :

    | `'fallthrough'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>false</dfn> :

    | `'false'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>fn</dfn> :

    | `'fn'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>for</dfn> :

    | `'for'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>function</dfn> :

    | `'function'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>if</dfn> :

    | `'if'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>let</dfn> :

    | `'let'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>loop</dfn> :

    | `'loop'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>private</dfn> :

    | `'private'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>return</dfn> :

    | `'return'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>storage</dfn> :

    | `'storage'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>switch</dfn> :

    | `'switch'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>true</dfn> :

    | `'true'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>type</dfn> :

    | `'type'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>uniform</dfn> :

    | `'uniform'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>var</dfn> :

    | `'var'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>workgroup</dfn> :

    | `'workgroup'`
</div>

## 保留字 ## {#reserved-words}

<dfn>reserved word</dfn> 是一个 [=token=] 保留供将来使用。
WGSL 程序不得包含保留字。

以下是保留字:

<div class='syntax' noexport='true'>
  <dfn for=syntax>_reserved</dfn> :

    | `'AppendStructuredBuffer'`   <!-- HLSL -->

    | `'BlendState'`   <!-- HLSL -->

    | `'Buffer'`   <!-- HLSL -->

    | `'ByteAddressBuffer'`   <!-- HLSL -->

    | `'CompileShader'`   <!-- HLSL -->

    | `'ComputeShader'`   <!-- HLSL -->

    | `'ConsumeStructuredBuffer'`   <!-- HLSL -->

    | `'DepthStencilState'`   <!-- HLSL -->

    | `'DepthStencilView'`   <!-- HLSL -->

    | `'DomainShader'`   <!-- HLSL -->

    | `'GeometryShader'`   <!-- HLSL -->

    | `'Hullshader'`   <!-- HLSL -->

    | `'InputPatch'`   <!-- HLSL -->

    | `'LineStream'`   <!-- HLSL -->

    | `'NULL'`   <!-- HLSL -->

    | `'OutputPatch'`   <!-- HLSL -->

    | `'PixelShader'`   <!-- HLSL -->

    | `'PointStream'`   <!-- HLSL -->

    | `'RWBuffer'`   <!-- HLSL -->

    | `'RWByteAddressBuffer'`   <!-- HLSL -->

    | `'RWStructuredBuffer'`   <!-- HLSL -->

    | `'RWTexture1D'`   <!-- HLSL -->

    | `'RWTexture1DArray'`   <!-- HLSL -->

    | `'RWTexture2D'`   <!-- HLSL -->

    | `'RWTexture2DArray'`   <!-- HLSL -->

    | `'RWTexture3D'`   <!-- HLSL -->

    | `'RasterizerState'`   <!-- HLSL -->

    | `'RenderTargetView'`   <!-- HLSL -->

    | `'SamplerComparisonState'`   <!-- HLSL -->

    | `'SamplerState'`   <!-- HLSL -->

    | `'Self'`   <!-- Rust -->

    | `'StructuredBuffer'`   <!-- HLSL -->

    | `'Texture1D'`   <!-- HLSL -->

    | `'Texture1DArray'`   <!-- HLSL -->

    | `'Texture2D'`   <!-- HLSL -->

    | `'Texture2DArray'`   <!-- HLSL -->

    | `'Texture2DMS'`   <!-- HLSL -->

    | `'Texture2DMSArray'`   <!-- HLSL -->

    | `'Texture3D'`   <!-- HLSL -->

    | `'TextureCube'`   <!-- HLSL -->

    | `'TextureCubeArray'`   <!-- HLSL -->

    | `'TriangleStream'`   <!-- HLSL -->

    | `'VertexShader'`   <!-- HLSL -->

    | `'abstract'`   <!-- Rust -->

    | `'active'`   <!-- GLSL(reserved) -->

    | `'alignas'`   <!-- C++ -->

    | `'alignof'`   <!-- C++ -->

    | `'as'`   <!-- ECMAScript2022 Rust -->

    | `'asm'`   <!-- C++ HLSL GLSL(reserved) WGSL -->

    | `'asm_fragment'`   <!-- HLSL -->

    | `'async'`   <!-- ECMAScript2022 -->

    | `'atomic_uint'`   <!-- GLSL -->

    | `'attribute'`   <!-- GLSL -->

    | `'auto'`   <!-- C++ -->

    | `'await'`   <!-- ECMAScript2022 -->

    | `'become'`   <!-- Rust -->

    | `'bf16'`   <!-- WGSL -->

    | `'buffer'`   <!-- GLSL -->

    | `'cast'`   <!-- GLSL(reserved) -->

    | `'catch'`   <!-- C++ ECMAScript2022 -->

    | `'cbuffer'`   <!-- HLSL -->

    | `'centroid'`   <!-- HLSL GLSL -->

    | `'char'`   <!-- C++ -->

    | `'class'`   <!-- C++ ECMAScript2022 HLSL GLSL(reserved) -->

    | `'co_await'`   <!-- C++ -->

    | `'co_return'`   <!-- C++ -->

    | `'co_yield'`   <!-- C++ -->

    | `'coherent'`   <!-- GLSL -->

    | `'column_major'`   <!-- HLSL -->

    | `'common'`   <!-- GLSL(reserved) -->

    | `'compile'`   <!-- HLSL -->

    | `'compile_fragment'`   <!-- HLSL -->

    | `'concept'`   <!-- C++ -->

    | `'const_cast'`   <!-- C++ -->

    | `'consteval'`   <!-- C++ -->

    | `'constexpr'`   <!-- C++ -->

    | `'constinit'`   <!-- C++ -->

    | `'crate'`   <!-- Rust -->

    | `'debugger'`   <!-- ECMAScript2022 -->

    | `'decltype'`   <!-- C++ -->

    | `'delete'`   <!-- C++ ECMAScript2022 -->

    | `'demote'`   <!-- WGSL -->

    | `'demote_to_helper'`   <!-- WGSL -->

    | `'do'`   <!-- C++ ECMAScript2022 Rust HLSL GLSL WGSL -->

    | `'dword'`   <!-- HLSL -->

    | `'dynamic_cast'`   <!-- C++ -->

    | `'enum'`   <!-- C++ ECMAScript2022 Rust GLSL(reserved) WGSL -->

    | `'explicit'`   <!-- C++ -->

    | `'export'`   <!-- C++ C++ ECMAScript2022 HLSL -->

    | `'extends'`   <!-- ECMAScript2022 -->

    | `'extern'`   <!-- C++ Rust HLSL GLSL(reserved) -->

    | `'external'`   <!-- GLSL(reserved) -->

    | `'f64'`   <!-- WGSL -->

    | `'filter'`   <!-- GLSL(reserved) -->

    | `'final'`   <!-- Rust -->

    | `'finally'`   <!-- ECMAScript2022 -->

    | `'fixed'`   <!-- GLSL(reserved) -->

    | `'flat'`   <!-- GLSL -->

    | `'friend'`   <!-- C++ -->

    | `'from'`   <!-- ECMAScript2022 -->

    | `'fvec2'`   <!-- GLSL(reserved) -->

    | `'fvec3'`   <!-- GLSL(reserved) -->

    | `'fvec4'`   <!-- GLSL(reserved) -->

    | `'fxgroup'`   <!-- HLSL -->

    | `'get'`   <!-- ECMAScript2022 -->

    | `'goto'`   <!-- C++ GLSL(reserved) -->

    | `'groupshared'`   <!-- HLSL -->

    | `'handle'`   <!-- WGSL -->

    | `'highp'`   <!-- GLSL -->

    | `'hvec2'`   <!-- GLSL(reserved) -->

    | `'hvec3'`   <!-- GLSL(reserved) -->

    | `'hvec4'`   <!-- GLSL(reserved) -->

    | `'i16'`   <!-- WGSL -->

    | `'i64'`   <!-- WGSL -->

    | `'i8'`   <!-- WGSL -->

    | `'iimage1D'`   <!-- GLSL -->

    | `'iimage1DArray'`   <!-- GLSL -->

    | `'iimage2D'`   <!-- GLSL -->

    | `'iimage2DArray'`   <!-- GLSL -->

    | `'iimage2DMS'`   <!-- GLSL -->

    | `'iimage2DMSArray'`   <!-- GLSL -->

    | `'iimage2DRect'`   <!-- GLSL -->

    | `'iimage3D'`   <!-- GLSL -->

    | `'iimageBuffer'`   <!-- GLSL -->

    | `'iimageCube'`   <!-- GLSL -->

    | `'iimageCubeArray'`   <!-- GLSL -->

    | `'image1D'`   <!-- GLSL -->

    | `'image1DArray'`   <!-- GLSL -->

    | `'image2D'`   <!-- GLSL -->

    | `'image2DArray'`   <!-- GLSL -->

    | `'image2DMS'`   <!-- GLSL -->

    | `'image2DMSArray'`   <!-- GLSL -->

    | `'image2DRect'`   <!-- GLSL -->

    | `'image3D'`   <!-- GLSL -->

    | `'imageBuffer'`   <!-- GLSL -->

    | `'imageCube'`   <!-- GLSL -->

    | `'imageCubeArray'`   <!-- GLSL -->

    | `'impl'`   <!-- Rust -->

    | `'implements'`   <!-- ECMAScript2022 -->

    | `'import'`   <!-- C++ ECMAScript2022 -->

    | `'in'`   <!-- ECMAScript2022 Rust HLSL GLSL -->

    | `'inline'`   <!-- C++ HLSL GLSL(reserved) -->

    | `'inout'`   <!-- HLSL GLSL -->

    | `'input'`   <!-- GLSL(reserved) -->

    | `'instanceof'`   <!-- ECMAScript2022 -->

    | `'interface'`   <!-- ECMAScript2022 HLSL GLSL(reserved) -->

    | `'invariant'`   <!-- GLSL -->

    | `'isampler1D'`   <!-- GLSL -->

    | `'isampler1DArray'`   <!-- GLSL -->

    | `'isampler2D'`   <!-- GLSL -->

    | `'isampler2DArray'`   <!-- GLSL -->

    | `'isampler2DMS'`   <!-- GLSL -->

    | `'isampler2DMSArray'`   <!-- GLSL -->

    | `'isampler2DRect'`   <!-- GLSL -->

    | `'isampler3D'`   <!-- GLSL -->

    | `'isamplerBuffer'`   <!-- GLSL -->

    | `'isamplerCube'`   <!-- GLSL -->

    | `'isamplerCubeArray'`   <!-- GLSL -->

    | `'isubpassInput'`   <!-- GLSL -->

    | `'isubpassInputMS'`   <!-- GLSL -->

    | `'itexture1D'`   <!-- GLSL -->

    | `'itexture1DArray'`   <!-- GLSL -->

    | `'itexture2D'`   <!-- GLSL -->

    | `'itexture2DArray'`   <!-- GLSL -->

    | `'itexture2DMS'`   <!-- GLSL -->

    | `'itexture2DMSArray'`   <!-- GLSL -->

    | `'itexture2DRect'`   <!-- GLSL -->

    | `'itexture3D'`   <!-- GLSL -->

    | `'itextureBuffer'`   <!-- GLSL -->

    | `'itextureCube'`   <!-- GLSL -->

    | `'itextureCubeArray'`   <!-- GLSL -->

    | `'layout'`   <!-- GLSL -->

    | `'line'`   <!-- HLSL -->

    | `'lineadj'`   <!-- HLSL -->

    | `'linear'`   <!-- HLSL -->

    | `'lowp'`   <!-- GLSL -->

    | `'macro'`   <!-- Rust -->

    | `'macro_rules'`   <!-- Rust -->

    | `'mat'`   <!-- WGSL -->

    | `'match'`   <!-- Rust -->

    | `'matrix'`   <!-- HLSL -->

    | `'mediump'`   <!-- GLSL -->

    | `'meta'`   <!-- ECMAScript2022 -->

    | `'mod'`   <!-- Rust -->

    | `'module'`   <!-- C++ -->

    | `'move'`   <!-- Rust -->

    | `'mut'`   <!-- Rust -->

    | `'mutable'`   <!-- C++ -->

    | `'namespace'`   <!-- C++ HLSL GLSL(reserved) -->

    | `'new'`   <!-- C++ ECMAScript2022 -->

    | `'nil'`   <!-- Smalltalk -->

    | `'noexcept'`   <!-- C++ -->

    | `'noinline'`   <!-- GLSL(reserved) -->

    | `'nointerpolation'`   <!-- HLSL -->

    | `'noperspective'`   <!-- HLSL GLSL -->

    | `'null'`   <!-- ECMAScript2022 WGSL -->

    | `'nullptr'`   <!-- C++ -->

    | `'of'`   <!-- ECMAScript2022 -->

    | `'operator'`   <!-- C++ -->

    | `'out'`   <!-- HLSL GLSL -->

    | `'output'`   <!-- GLSL(reserved) -->

    | `'package'`   <!-- ECMAScript2022 -->

    | `'packoffset'`   <!-- HLSL -->

    | `'partition'`   <!-- GLSL(reserved) -->

    | `'pass'`   <!-- HLSL -->

    | `'patch'`   <!-- GLSL -->

    | `'pixelfragment'`   <!-- HLSL -->

    | `'point'`   <!-- HLSL -->

    | `'precise'`   <!-- HLSL GLSL -->

    | `'precision'`   <!-- GLSL -->

    | `'premerge'`   <!-- WGSL -->

    | `'priv'`   <!-- Rust -->

    | `'protected'`   <!-- C++ ECMAScript2022 -->

    | `'pub'`   <!-- Rust -->

    | `'public'`   <!-- C++ ECMAScript2022 GLSL(reserved) -->

    | `'readonly'`   <!-- GLSL -->

    | `'ref'`   <!-- Rust -->

    | `'regardless'`   <!-- WGSL -->

    | `'register'`   <!-- C++ HLSL -->

    | `'reinterpret_cast'`   <!-- C++ -->

    | `'requires'`   <!-- C++ -->

    | `'resource'`   <!-- GLSL(reserved) -->

    | `'restrict'`   <!-- GLSL -->

    | `'row_major'`   <!-- HLSL -->

    | `'samper'`   <!-- HLSL -->

    | `'sample'`   <!-- HLSL GLSL -->

    | `'sampler1D'`   <!-- GLSL -->

    | `'sampler1DArray'`   <!-- GLSL -->

    | `'sampler1DArrayShadow'`   <!-- GLSL -->

    | `'sampler1DShadow'`   <!-- GLSL -->

    | `'sampler2D'`   <!-- GLSL -->

    | `'sampler2DArray'`   <!-- GLSL -->

    | `'sampler2DArrayShadow'`   <!-- GLSL -->

    | `'sampler2DMS'`   <!-- GLSL -->

    | `'sampler2DMSArray'`   <!-- GLSL -->

    | `'sampler2DRect'`   <!-- GLSL -->

    | `'sampler2DRectShadow'`   <!-- GLSL -->

    | `'sampler2DShadow'`   <!-- GLSL -->

    | `'sampler3D'`   <!-- GLSL -->

    | `'sampler3DRect'`   <!-- GLSL(reserved) -->

    | `'samplerBuffer'`   <!-- GLSL -->

    | `'samplerCube'`   <!-- GLSL -->

    | `'samplerCubeArray'`   <!-- GLSL -->

    | `'samplerCubeArrayShadow'`   <!-- GLSL -->

    | `'samplerCubeShadow'`   <!-- GLSL -->

    | `'samplerShadow'`   <!-- GLSL -->

    | `'self'`   <!-- Rust Smalltalk -->

    | `'set'`   <!-- ECMAScript2022 -->

    | `'shared'`   <!-- HLSL GLSL -->

    | `'signed'`   <!-- C++ -->

    | `'sizeof'`   <!-- C++ GLSL(reserved) -->

    | `'smooth'`   <!-- GLSL -->

    | `'snorm'`   <!-- HLSL -->

    | `'stateblock'`   <!-- HLSL -->

    | `'stateblock_state'`   <!-- HLSL -->

    | `'static'`   <!-- C++ ECMAScript2022 Rust HLSL GLSL(reserved) -->

    | `'static_assert'`   <!-- C++ -->

    | `'static_cast'`   <!-- C++ -->

    | `'std'`   <!-- WGSL -->

    | `'string'`   <!-- HLSL -->

    | `'subpassInput'`   <!-- GLSL -->

    | `'subpassInputMS'`   <!-- GLSL -->

    | `'subroutine'`   <!-- GLSL -->

    | `'super'`   <!-- ECMAScript2022 Rust Smalltalk -->

    | `'superp'`   <!-- GLSL(reserved) -->

    | `'target'`   <!-- ECMAScript2022 -->

    | `'tbuffer'`   <!-- HLSL -->

    | `'technique'`   <!-- HLSL -->

    | `'technique10'`   <!-- HLSL -->

    | `'technique11'`   <!-- HLSL -->

    | `'template'`   <!-- C++ GLSL(reserved) -->

    | `'texture'`   <!-- HLSL HLSL -->

    | `'texture1D'`   <!-- GLSL -->

    | `'texture1DArray'`   <!-- GLSL -->

    | `'texture2D'`   <!-- GLSL -->

    | `'texture2DArray'`   <!-- GLSL -->

    | `'texture2DMS'`   <!-- GLSL -->

    | `'texture2DMSArray'`   <!-- GLSL -->

    | `'texture2DRect'`   <!-- GLSL -->

    | `'texture3D'`   <!-- GLSL -->

    | `'textureBuffer'`   <!-- GLSL -->

    | `'textureCube'`   <!-- GLSL -->

    | `'textureCubeArray'`   <!-- GLSL -->

    | `'this'`   <!-- C++ ECMAScript2022 GLSL(reserved) -->

    | `'thread_local'`   <!-- C++ -->

    | `'throw'`   <!-- C++ ECMAScript2022 -->

    | `'trait'`   <!-- Rust -->

    | `'triangle'`   <!-- HLSL -->

    | `'triangleadj'`   <!-- HLSL -->

    | `'try'`   <!-- C++ ECMAScript2022 -->

    | `'typedef'`   <!-- C++ HLSL GLSL(reserved) WGSL -->

    | `'typeid'`   <!-- C++ -->

    | `'typename'`   <!-- C++ -->

    | `'typeof'`   <!-- ECMAScript2022 Rust -->

    | `'u16'`   <!-- WGSL -->

    | `'u64'`   <!-- WGSL -->

    | `'u8'`   <!-- WGSL -->

    | `'uimage1D'`   <!-- GLSL -->

    | `'uimage1DArray'`   <!-- GLSL -->

    | `'uimage2D'`   <!-- GLSL -->

    | `'uimage2DArray'`   <!-- GLSL -->

    | `'uimage2DMS'`   <!-- GLSL -->

    | `'uimage2DMSArray'`   <!-- GLSL -->

    | `'uimage2DRect'`   <!-- GLSL -->

    | `'uimage3D'`   <!-- GLSL -->

    | `'uimageBuffer'`   <!-- GLSL -->

    | `'uimageCube'`   <!-- GLSL -->

    | `'uimageCubeArray'`   <!-- GLSL -->

    | `'union'`   <!-- C++ Rust GLSL(reserved) -->

    | `'unless'`   <!-- WGSL -->

    | `'unorm'`   <!-- HLSL -->

    | `'unsafe'`   <!-- Rust -->

    | `'unsigned'`   <!-- C++ HLSL GLSL(reserved) -->

    | `'unsized'`   <!-- Rust -->

    | `'usampler1D'`   <!-- GLSL -->

    | `'usampler1DArray'`   <!-- GLSL -->

    | `'usampler2D'`   <!-- GLSL -->

    | `'usampler2DArray'`   <!-- GLSL -->

    | `'usampler2DMS'`   <!-- GLSL -->

    | `'usampler2DMSArray'`   <!-- GLSL -->

    | `'usampler2DRect'`   <!-- GLSL -->

    | `'usampler3D'`   <!-- GLSL -->

    | `'usamplerBuffer'`   <!-- GLSL -->

    | `'usamplerCube'`   <!-- GLSL -->

    | `'usamplerCubeArray'`   <!-- GLSL -->

    | `'use'`   <!-- Rust -->

    | `'using'`   <!-- C++ GLSL(reserved) WGSL -->

    | `'usubpassInput'`   <!-- GLSL -->

    | `'usubpassInputMS'`   <!-- GLSL -->

    | `'utexture1D'`   <!-- GLSL -->

    | `'utexture1DArray'`   <!-- GLSL -->

    | `'utexture2D'`   <!-- GLSL -->

    | `'utexture2DArray'`   <!-- GLSL -->

    | `'utexture2DMS'`   <!-- GLSL -->

    | `'utexture2DMSArray'`   <!-- GLSL -->

    | `'utexture2DRect'`   <!-- GLSL -->

    | `'utexture3D'`   <!-- GLSL -->

    | `'utextureBuffer'`   <!-- GLSL -->

    | `'utextureCube'`   <!-- GLSL -->

    | `'utextureCubeArray'`   <!-- GLSL -->

    | `'varying'`   <!-- GLSL -->

    | `'vec'`   <!-- WGSL -->

    | `'vector'`   <!-- HLSL -->

    | `'vertexfragment'`   <!-- HLSL -->

    | `'virtual'`   <!-- C++ Rust -->

    | `'void'`   <!-- C++ ECMAScript2022 HLSL GLSL WGSL -->

    | `'volatile'`   <!-- C++ HLSL GLSL -->

    | `'wchar_t'`   <!-- C++ -->

    | `'wgsl'`   <!-- WGSL -->

    | `'where'`   <!-- Rust -->

    | `'with'`   <!-- ECMAScript2022 -->

    | `'writeonly'`   <!-- GLSL -->

    | `'yield'`   <!-- ECMAScript2022 Rust -->
</div>

## 句法符号 ## {#syntactic-tokens}

<dfn>syntactic token</dfn> 是一个特殊代码点序列，用于：
* 拼写表达式运算符，或
* 作为标点符号：对其他语法元素进行分组、排序或分隔。

<div class='syntax' noexport='true'>
  <dfn for=syntax>and</dfn> :

    | `'&'` (Code point: `U+0026`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>and_and</dfn> :

    | `'&&'` (Code points: `U+0026` `U+0026`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>arrow</dfn> :

    | `'->'` (Code points: `U+002D` `U+003E`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>attr</dfn> :

    | `'@'` (Code point: `U+0040`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>forward_slash</dfn> :

    | `'/'` (Code point: `U+002F`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>bang</dfn> :

    | `'!'` (Code point: `U+0021`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>bracket_left</dfn> :

    | `'['` (Code point: `U+005B`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>bracket_right</dfn> :

    | `']'` (Code point: `U+005D`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>brace_left</dfn> :

    | `'{'` (Code point: `U+007B`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>brace_right</dfn> :

    | `'}'` (Code point: `U+007D`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>colon</dfn> :

    | `':'` (Code point: `U+003A`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>comma</dfn> :

    | `','` (Code point: `U+002C`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>equal</dfn> :

    | `'='` (Code point: `U+003D`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>equal_equal</dfn> :

    | `'=='` (Code points: `U+003D` `U+003D`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>not_equal</dfn> :

    | `'!='` (Code points: `U+0021` `U+003D`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>greater_than</dfn> :

    | `'>'` (Code point: `U+003E`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>greater_than_equal</dfn> :

    | `'>='` (Code points: `U+003E` `U+003D`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>less_than</dfn> :

    | `'<'` (Code point: `U+003C`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>less_than_equal</dfn> :

    | `'<='` (Code points: `U+003C` `U+003D`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>modulo</dfn> :

    | `'%'` (Code point: `U+0025`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>minus</dfn> :

    | `'-'` (Code point: `U+002D`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>minus_minus</dfn> :

    | `'--'` (Code points: `U+002D` `U+002D`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>period</dfn> :

    | `'.'` (Code point: `U+002E`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>plus</dfn> :

    | `'+'` (Code point: `U+002B`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>plus_plus</dfn> :

    | `'++'` (Code points: `U+002B` `U+002B`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>or</dfn> :

    | `'|'` (Code point: `U+007C`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>or_or</dfn> :

    | `'||'` (Code points: `U+007C` `U+007C`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>paren_left</dfn> :

    | `'('` (Code point: `U+0028`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>paren_right</dfn> :

    | `')'` (Code point: `U+0029`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>semicolon</dfn> :

    | `';'` (Code point: `U+003B`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>star</dfn> :

    | `'*'` (Code point: `U+002A`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>tilde</dfn> :

    | `'~'` (Code point: `U+007E`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>underscore</dfn> :

    | `'_'` (Code point: `U+005F`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>xor</dfn> :

    | `'^'` (Code point: `U+005E`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>plus_equal</dfn> :

    | `'+='` (Code points: `U+002B` `U+003D`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>minus_equal</dfn> :

    | `'-='` (Code points: `U+002D` `U+003D`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>times_equal</dfn> :

    | `'*='` (Code points: `U+002A` `U+003D`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>division_equal</dfn> :

    | `'/='` (Code points: `U+002F` `U+003D`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>modulo_equal</dfn> :

    | `'%='` (Code points: `U+0025` `U+003D`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>and_equal</dfn> :

    | `'&='` (Code points: `U+0026` `U+003D`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>or_equal</dfn> :

    | `'|='` (Code points: `U+007C` `U+003D`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>xor_equal</dfn> :

    | `'^='` (Code points: `U+005E` `U+003D`)
</div>

# 内置值 # {#builtin-values}

下表列出了可用的 [=built-in input values=] 和 [=built-in output values=]。

查看 [[#builtin-inputs-outputs]] 如何创建内置值。

<table class='data'>
  <thead>
    <tr><th>名称<th>阶段<th>输入或输出<th>类型<th>描述
  </thead>

  <tr><td>`vertex_index`
      <td>vertex
      <td>input
      <td>u32
      <td style="width:50%">当前 API 级绘制命令中当前顶点的索引，与绘制实例无关。

         对于非索引绘制，第一个顶点的索引等于绘制的 `firstVertex` 参数，无论是直接提供还是间接提供。
         绘制实例中每增加一个顶点，索引就会增加 1。

         对于索引绘制，索引等于顶点的索引缓冲区条目，加上绘制的 `baseVertex` 参数，无论是直接提供还是间接提供。

  <tr><td>`instance_index`
      <td>vertex
      <td>input
      <td>u32
      <td style="width:50%">当前 API 级绘制命令中当前顶点的实例索引。

         第一个实例的索引等于绘制的 `firstInstance` 参数，无论是直接提供还是间接提供。
         抽签中每增加一个实例，索引就会增加 1。

  <tr><td>`position`
      <td>vertex
      <td>output
      <td>vec4&lt;f32&gt;
      <td style="width:50%">当前顶点的输出位置，使用齐次坐标。
      在均匀归一化（其中 *x*、*y* 和 *z* 分量中的每一个除以 *w* 分量）之后，位置在 WebGPU 归一化设备坐标空间中。
      查看 [[WebGPU#coordinate-systems|WebGPU &sect; Coordinate Systems]]。

  <tr><td>`position`
      <td>fragment
      <td>input
      <td>vec4&lt;f32&gt;
      <td style="width:50%">当前片元在[[WebGPU#rasterization|framebuffer space]]中的的帧缓冲区位置。
      （*x*、*y* 和 *z* 分量已经被缩放，使得 *w* 现在为 1。）
      查看 [[WebGPU#coordinate-systems|WebGPU &sect; Coordinate Systems]]。

  <tr><td>`front_facing`
      <td>fragment
      <td>input
      <td>bool
      <td style="width:50%">当当前片段位于正面图元上时为True。
         否则为False
         查看 [[WebGPU#front-facing|WebGPU &sect; Front-facing]].

  <tr><td>`frag_depth`
      <td>fragment
      <td>output
      <td>f32
      <td style="width:50%">在视口深度范围内更新了片段的深度。
      查看 [[WebGPU#coordinate-systems|WebGPU &sect; Coordinate Systems]]。

  <tr><td>`local_invocation_id`
      <td>compute
      <td>input
      <td>vec3&lt;u32&gt;
      <td style="width:50%">当前调用的 [=local invocation ID=]，即它在 [=workgroup grid=] 中的位置。

  <tr><td>`local_invocation_index`
      <td>compute
      <td>input
      <td>u32
      <td style="width:50%">当前调用的 [=local invocation index=]，即 [=workgroup grid=] 中调用位置的线性化索引。

  <tr><td>`global_invocation_id`
      <td>compute
      <td>input
      <td>vec3&lt;u32&gt;
      <td style="width:50%">当前调用的 [=global invocation ID=]，即它在 [=compute shader grid=] 中的位置。

  <tr><td>`workgroup_id`
      <td>compute
      <td>input
      <td>vec3&lt;u32&gt;
      <td style="width:50%">当前调用的 [=workgroup ID=]，即工作组在 [=workgroup grid=] 中的位置。

  <tr><td>`num_workgroups`
      <td>compute
      <td>input
      <td>vec3&lt;u32&gt;
      <td style="width:50%">API 计算着色器 [[WebGPU#dom-gpucomputepassencoder-dispatch|dispatched]] 的 [=dispatch size=]、`vec<u32>(group_count_x, group_count_y, group_count_z)`。

  <tr><td>`sample_index`
      <td>fragment
      <td>input
      <td>u32
      <td style="width:50%">当前片段的示例索引。
         该值最小为 0，最大为 `sampleCount`-1，
         其中 [[WebGPU#dom-gpurenderpipelinedescriptor-samplecount|sampleCount]] 是为 GPU 渲染管道指定的 MSAA 样本数。
         <br>查看 [[WebGPU#render-pipeline|WebGPU &sect; GPURenderPipeline]]。

  <tr><td>`sample_mask`
      <td>fragment
      <td>input
      <td>u32
      <td style="width:50%">当前片元的样本覆盖掩码。
         它包含一个位掩码，指示正在渲染的图元覆盖此片段中的哪些样本。
         <br>查看 [[WebGPU#sample-masking|WebGPU &sect; Sample Masking]]。

  <tr><td>`sample_mask`
      <td>fragment
      <td>output
      <td>u32
      <td style="width:50%">当前片元的示例覆盖掩码控制。
         写入此变量的最后一个值成为 [[WebGPU#shader-output-mask|shader-output mask]]。
         写入值中的零位将导致颜色附件中的相应样本被丢弃。
         <br>查看 [[WebGPU#sample-masking|WebGPU &sect; Sample Masking]]。
</table>

<div class='example wgsl global-scope' heading="Declaring built-in values">
  <xmp highlight='rust'>
    struct VertexOutput {
      @builtin(position) my_pos: vec4<f32>
    }

    @vertex
    fn vs_main(
      @builtin(vertex_index) my_index: u32,
      @builtin(instance_index) my_inst_index: u32,
    ) -> VertexOutput {}

    struct FragmentOutput {
      @builtin(frag_depth) depth: f32,
      @builtin(sample_mask) mask_out: u32
    }

    @fragment
    fn fs_main(
      @builtin(front_facing) is_front: bool,
      @builtin(position) coord: vec4<f32>,
      @builtin(sample_index) my_sample_index: u32,
      @builtin(sample_mask) mask_in: u32,
    ) -> FragmentOutput {}

    @compute
    fn cs_main(
      @builtin(local_invocation_id) local_id: vec3<u32>,
      @builtin(local_invocation_index) local_index: u32,
      @builtin(global_invocation_id) global_id: vec3<u32>,
   ) {}
  </xmp>
</div>

# 内置函数 # {#builtin-functions}

某些函数是 [=predeclared=]，由实现提供，因此始终可用于 WGSL 程序。
这些被称为<dfn noexport>built-in functions</dfn>。

内建函数是一个函数族，它们都具有相同的名称，
但是通过它们的[=形式参数=]的数量、顺序和类型来区分。
这些不同的函数变体中的每一个都是 [=overload=]。

注意：每个 [=user-defined function=] 只有一个 [=overload=]。

每个 [=overload=] 描述如下：
* 类型参数化，如果有的话。
* 内置函数名，带括号的 [=formal parameters=] 列表，以及可选的 [=return type=]。
* 函数重载的行为。

由于内置函数始终在作用域内，因此尝试重新定义一个函数或将内置函数的名称用作任何其他[=module scope|module-scope=]声明的 [=identifier=] 都是错误的。

与 WGSL 程序中定义的普通函数不同，内置函数可以使用相同的函数名和不同的参数集。
换句话说，一个内置函数可能有多个*重载*，但 WGSL 中的普通函数定义可能没有。

调用内置函数时，函数的所有参数都会在函数求值开始之前求值。
见[[#function-calls]]。

## 逻辑内置函数 ## {#logical-builtin-functions}

<table class='data'>
  <thead>
    <tr><th>Parameterization<td style="width:40%;">Overload<td>Description
  </thead>
  <tr algorithm="vector all">
    <td>
    <td>`@const fn`<br>`all`(|e|: vec|N|&lt;bool&gt;) -> bool
    <td>如果|e|的每个组件都为真，则返回真。<br>

  <tr algorithm="scalar all">
    <td>|e|: bool
    <td>`@const fn`<br>`all(`|e|`)` -> bool
    <td>返回 |e|.

  <tr algorithm="vector any">
    <td>
    <td>`@const fn`<br>`any`(|e|: vec|N|&lt;bool&gt;) -> bool
    <td>如果|e|的任何一个组件为真，则返回真。<br>

  <tr algorithm="scalar any">
    <td>|e|: bool
    <td>`@const fn`<br>`any(`|e|`)` -> bool
    <td>返回 |e|.

  <tr algorithm="scalar select">
    <td>|T| 为 [=scalar=], [=abstract numeric type=], 或 [=vector=]
    <td>`@const fn`<br>`select`(|f|: |T|, |t|: |T|, |cond|: bool) -> |T|
    <td>当 |cond| 为真时返回 |t|，否则返回 |f|。

  <tr algorithm="vector select">
    <td>|T| 为 [=scalar=] or [=abstract numeric type=]
    <td class="nowrap">`@const fn`<br>`select`(|f|: vec|N|&lt;|T|&gt;, |t|: vec|N|&lt;|T|&gt;, |cond|: vec|N|&lt;bool&gt;) -> vec|N|&lt;|T|&gt;
    <td>[=Component-wise=] 选择。结果组件|i|被计算为 `select(`|f|`[`|i|`], `|t|`[`|i|`], `|cond|`[`|i|`])`.<br>
</table>

## 数组内置函数 ## {#array-builtin-functions}
<table class='data'>
  <thead>
    <tr><th>Parameterization<th>Overload<th>Description
  </thead>
  <tr algorithm="runtime-sized array length">
    <td>
      <td>`fn arrayLength`(|e|: ptr&lt;storage,array&lt;|T|&gt;&gt; ) -> u32
        <td>返回[=runtime-sized=]数组中的元素数量。<br>
</table>

## 浮动内置函数 ## {#float-builtin-functions}

<table class='data'>
  <thead>
    <tr><th>前提条件<th>结论<th>描述
  </thead>
  <tr algorithm="float abs">
    <td>|T| 是 [ALLFLOATING]
    <td class="nowrap">`@const fn`<br>`abs(`|e|`:` |T| `) -> ` |T|
    <td>返回 |e| 的绝对值 （例如 |e| 带有正符号位）。
    [=Component-wise=] 当 |T| 是一个向量。

  <tr algorithm="acos">
    <td>|T| 是 [ALLFLOATING]
    <td class="nowrap">`@const fn`<br>`acos(`|e|`:` |T| `) -> ` |T|
    <td>返回 |e| 的反余弦值。
    [=Component-wise=] 当 |T| 是一个向量。

  <tr algorithm="acosh">
    <td>|T| 是 [ALLFLOATING]
    <td class="nowrap">`@const fn`<br>`acosh(`|e|`:` |T| `) -> ` |T|
    <td>Returns the hyperbolic arc cosine of |e|.
    The result is 0 when |e| &lt; 1.<br>
    Computes the non-negative functional inverse of `cosh`.<br>
    [=Component-wise=] when |T| is a vector.

    Note: The result is not mathematically meaningful when |e| &lt; 1.

  <tr algorithm="asin">
    <td>|T| 是 [ALLFLOATING]
    <td class="nowrap">`@const fn`<br>`asin(`|e|`:` |T| `) -> ` |T|
    <td>返回 |e| 的反正弦。
    [=Component-wise=] 当 |T| 是一个向量。
  
  <tr algorithm="asinh">
    <td>|T| 为 [ALLFLOATING]
    <td class="nowrap">`@const fn`<br>`asinh(`|e|`:` |T| `) -> ` |T|
    <td>Returns the hyperbolic arc sine of |e|.<br>
    Computes the functional inverse of `sinh`.<br>
    [=Component-wise=] when |T| is a vector.

  <tr algorithm="atan">
    <td>|T| 是 [ALLFLOATING]
    <td class="nowrap">`@const fn`<br>`atan(`|e|`:` |T| `) -> ` |T|
    <td>返回 |e| 的反正切。
    [=Component-wise=] 当 |T| 是一个向量。
  
  <tr algorithm="atanh">
    <td>|T| 是 [ALLFLOATING]
    <td class="nowrap">`@const fn`<br>`atanh(`|e|`:` |T| `) -> ` |T|
    <td>返回 |e| 的双曲反正切。
    当 `abs`(|e|) &ge; 1，结果为0.<br>
    计算 `tanh` 的反函数。<br>
    当 |T| 为向量时 [=Component-wise=]

    注意：当 `abs`(|e|) &ge; 1 时结果不是数学上有意义的。<br>

  <tr algorithm="atan2">
    <td>|T| 是 [ALLFLOATING]
    <td class="nowrap">`@const fn`<br>`atan2(`|e1|`:` |T| `, `|e2|`:` |T| `) -> ` |T|
    <td>返回 |e1|/|e2| 的反正切。
    [=Component-wise=] 当 |T| 是一个向量。

  <tr algorithm="ceil">
    <td>|T| 是 [ALLFLOATING]
    <td class="nowrap">`@const fn`<br>`ceil(`|e|`:` |T| `) -> ` |T|
    <td>返回 |e| 的向上取整 [=ceiling expression|ceiling=]。
    [=Component-wise=] 当 |T| 是一个向量。

  <tr algorithm="clamp">
    <td>|T| 是 [ALLFLOATING]
    <td class="nowrap">`clamp(`|e|`:` |T| `,` |low|`:` |T| `,` |high|`:` |T|`) -> ` |T|
    <td>Returns either `min(max(`|e|`,`|low|`),`|high|`)`, or the median of the three values |e|, |low|, |high|.
    [=Component-wise=] 当 |T| 是一个向量。

  <tr algorithm="cos">
    <td>|T| 是 [ALLFLOATING]
    <td class="nowrap">`@const fn`<br>`cos(`|e|`:` |T| `) -> ` |T|
    <td>返回 |e| 的余弦。
    [=Component-wise=] 当 |T| 是一个向量。

  <tr algorithm="cosh">
    <td>|T| 是 [ALLFLOATING]
    <td class="nowrap">`@const fn`<br>`cosh(`|e|`:` |T| `) -> ` |T|
    <td>返回 |e| 的双曲余弦值。
    [=Component-wise=] 当 |T| 是一个向量。

  <tr algorithm="vector case, cross">
    <td>|T| 是 AbstractFloat, f32, or f16
    <td class="nowrap">`@const fn`<br>`cross(`|e1|`:` vec3<|T|> `, `|e2|`:` vec3<|T|>`) -> ` vec3<|T|>
    <td>返回 |e1| 和 |e2| 的叉积。 (GLSLstd450Cross)

  <tr algorithm="degrees">
    <td>|T| 是 [ALLFLOATING]
    <td class="nowrap">`@const fn`<br>`degrees(`|e1|`:` |T| `) -> ` |T|
    <td>将弧度转换为度，近似 |e1|&nbsp;&times;&nbsp;180&nbsp;&div;&nbsp;&pi;.
    [=Component-wise=] 当 |T| 是一个向量。<br>

  <tr algorithm="distance">
    <td>|T| 是 [ALLFLOATING]
    <td class="nowrap">`@const fn`<br>`distance(`|e1|`:` |T| `, `|e2|`:` |T| `) -> ` f32
    <td>返回 |e1| 和 |e2| 之间的距离（即 `length(`|e1|` - `|e2|`)`）。

  <tr algorithm="exp">
    <td>|T| 是 [ALLFLOATING]
    <td class="nowrap">`@const fn`<br>`exp(`|e1|`:` |T| `) -> ` |T|
    <td>返回 |e1| 的自然求幂 (即 `e`<sup>|e1|</sup>)。
    [=Component-wise=] 当 |T| 是一个向量。

  <tr algorithm="exp2">
    <td>|T| 是 [ALLFLOATING]
    <td class="nowrap">`@const fn`<br>`exp2(`|e|`:` |T| `) -> ` |T|
    <td>Returns 2 raised to the power |e| (e.g. `2`<sup>|e|</sup>).
    [=Component-wise=] 当 |T| 是一个向量。

  <tr algorithm="faceForward">
    <td>|T| 是 vec|N|&lt;AbstractFloat&gt;, vec|N|&lt;f32&gt;, 或 vec|N|&lt;f16&gt;
    <td class="nowrap">`@const fn`<br>`faceForward(`|e1|`:` |T| `, `|e2|`:` |T| `, `|e3|`:` |T| `) -> ` |T|
    <td>如果 `dot(`|e2|`,`|e3|`)` 是负的返回 |e1|, 否则返回 `-`|e1|。

  <tr algorithm="floor">
    <td>|T| 是 [ALLFLOATING]
    <td class="nowrap">`@const fn`<br>`floor(`|e|`:` |T| `) -> ` |T|
    <td>返回 |e| 的向下取整 [=floor expression|floor=]。
    [=Component-wise=] 当 |T| 是一个向量。

  <tr algorithm="fma">
    <td>|T| 是 [ALLFLOATING]
    <td class="nowrap">`@const fn`<br>`fma(`|e1|`:` |T| `, `|e2|`:` |T| `, `|e3|`:` |T| `) -> ` |T|
    <td>返回 |e1| `*` |e2| `+` |e3|.
    [=Component-wise=] 当 |T| 是一个向量。

  <tr algorithm="fract">
    <td>|T| 是 [ALLFLOATING]
    <td class="nowrap">`@const fn`<br>`fract(`|e|`:` |T| `) -> ` |T|
    <td>返回|e| 的小数部分，计算为|e| `- floor（`|e|`）`。<br>
    [=Component-wise=] 当 |T| 是一个向量。

  <tr algorithm="scalar case, binary32, frexp">
    <td>|T| 是 f32
    <td class="nowrap">`@const fn`<br>`frexp(`|e|`: `|T|`) -> __frexp_result`<br>
    <td>拆分 |e| 转换为 `significand * 2`<sup>`exponent`</sup>形式的有效数和指数。
    返回 `__frexp_result` 内置结构, 定义如下:
    ```rust
struct __frexp_result {
  sig : f32, // significand part
  exp : i32  // exponent part
}
    ```
    有效数的大小在 [0.5, 1.0) 或 0 的范围内。

    注意：一个值不能用类型 `__frexp_result` 显式声明，但一个值可以推断类型。
    <div class='example wgsl function-scope' heading='frexp usage'>
    <xmp highlight='rust'>
     // 推断结果类型
     let sig_and_exp = frexp(1.5);
     // 设置 fraction_direct 的值为 0.75
     let fraction_direct = frexp(1.5).sig;
    </xmp>
    </div>
    (GLSLstd450FrexpStruct)

  <tr algorithm="scalar case, binary16, frexp">
    <td>|T| 是 f16
    <td class="nowrap">`@const fn frexp(`|e|`: `|T|`) -> __frexp_result_f16`<br>
    <td>拆分 |e| 转换为 `significand * 2`<sup>`exponent`</sup> 形式的有效数和指数。
    返回 `__frexp_result_f16` 内置结构，定义如下：
    ```rust
struct __frexp_result_f16 {
  sig : f16, // significand part
  exp : i32  // exponent part
}
    ```
    有效数字的大小在 [0.5, 1.0) 或 0 的范围内。

    注意：一个值不能用 `__freexp_result_f16`类型显式声明，但是一个值可以推断出类型。

  <tr algorithm="vector case, binary32, frexp">
    <td>|T| 是 vec|N|&lt;f32&gt;
    <td class="nowrap">`@const fn`<br>`frexp(`|e|`: `|T|`) -> __frexp_result_vec`|N|<br>
    <td>拆分 |e| 的组件 转换为 `significand * 2`<sup>`exponent`</sup>形式的有效数和指数。
    返回 `__frexp_result_vec`|N| 内置结构，定义为：
    ```rust
struct __frexp_result_vecN {
  sig : vecN<f32>, // significand part
  exp : vecN<i32> // exponent part
}
    ```
    有效数的每个分量的大小在 [0.5, 1.0) 或 0 的范围内。

    注意：不能用 `__frexp_result_vec`|N| 类型显式声明值，但值可以推断类型。

  <tr algorithm="vector case, binary16, frexp">
    <td>|T| 是 vec|N|&lt;f16&gt;
    <td class="nowrap">`@const fn frexp(`|e|`: `|T|`) -> __frexp_result_vec`|N|`_f16`<br>
    <td>拆分 |e| 的组件 转换为 `significand * 2`<sup>`exponent`</sup> 形式的有效数和指数。
    返回 `__frexp_result_vec`|N| 内置结构, 定义如下:
    ```rust
struct __frexp_result_vecN_f16 {
  sig : vecN<f16>, // significand part
  exp : vecN<i32>  // exponent part
}
    ```
    有效数字的每个分量的大小在 [0.5, 1.0) 或 0 的范围内。

    注意：一个值不能用 `__freexp_result_vec`|N|`_f16`类型显式声明，但是一个值可以推断出类型。

  <tr algorithm="inverseSqrt">
    <td>|T| 是 [ALLFLOATING]
    <td class="nowrap">`@const fn`<br>`inverseSqrt(`|e|`:` |T| `) -> ` |T|
    <td>返回 `sqrt(`|e|`)` 的倒数。
    [=Component-wise=] 当 |T| 是一个向量。

  <tr algorithm="ldexp">
    <td>|T| 是 [ALLFLOATING]<br>
        |I| 是 ALLSIGNEDINTEGRAL, 在<br>
        如果 |T| 是标量，那么 |I| 是标量，或者<br>
        当 |T| 是向量，那么 |I| 是向量
    <td class="nowrap">`@const fn`<br>`ldexp(`|e1|`:` |T| `, `|e2|`:` |I| `) -> ` |T|
    <td>返回 |e1| `* 2`<sup>|e2|</sup>。
    [=Component-wise=] 当 |T| 是一个向量。

  <tr algorithm="length">
    <td>|T| 是 [ALLFLOATING]
    <td class="nowrap">`@const fn`<br>`length(`|e|`:` |T| `) -> ` f32
    <td>返回 |e| 的长度 （例如 `abs(`|e|`)` 如果 |T| 是标量，或者 `sqrt(`|e|`[0]`<sup>`2`</sup> `+` |e|` [1]`<sup>`2`</sup> `+ ...)` 如果 |T| 是向量）。

  <tr algorithm="log">
    <td>|T| 是 [ALLFLOATING]
    <td class="nowrap">`@const fn`<br>`log(`|e|`:` |T| `) -> ` |T|
    <td>返回 |e| 的自然对数。
    [=Component-wise=] 当 |T| 是一个向量。

  <tr algorithm="log2">
    <td>|T| 是 [ALLFLOATING]
    <td class="nowrap">`@const fn`<br>`log2(`|e|`:` |T| `) -> ` |T|
    <td>返回 |e| 的以 2 为底的对数。
    [=Component-wise=] 当 |T| 是一个向量。

  <tr algorithm="max">
    <td>|T| 是 [ALLFLOATING]
    <td class="nowrap">`@const fn`<br>`max(`|e1|`:` |T| `, `|e2|`:` |T| `) -> ` |T|
    <td>返回 |e2| 如果 |e1| 小于 |e2|，且 |e1| 除此以外。
    如果一个操作数是 NaN，则返回另一个操作数。
    如果两个操作数都是 NaN，则返回 NaN。
    [=Component-wise=] 当 |T| 是一个向量。

  <tr algorithm="min">
    <td>|T| 是 [ALLFLOATING]
    <td class="nowrap">`@const fn`<br>`min(`|e1|`:` |T| `, `|e2|`:` |T| `) -> ` |T|
    <td>返回 |e2| 如果|e2| 小于 |e1|，且 |e1| 除此以外。
    如果一个操作数是 NaN，则返回另一个操作数。
    如果两个操作数都是 NaN，则返回 NaN。
    [=Component-wise=] 当 |T| 是一个向量。

  <tr algorithm="mix all same type operands">
    <td>|T| 是 [ALLFLOATING]
    <td class="nowrap">`@const fn`<br>`mix(`|e1|`:` |T| `, `|e2|`:` |T| `, `|e3|`:` |T|`) -> ` |T|
    <td>返回 |e1| 和 |e2| 的线性混合（例如 |e1|`*(1-`|e3|`)+`|e2|`*`|e3|）。
    [=Component-wise=] 当 |T| 是一个向量。
    <br>

  <tr algorithm="vector mix with scalar blending factor">
    <td>|T| 是 AbstractFloat, f32, or f16<br>
        |T2| is vec|N|&lt;|T|&gt;
    <td class="nowrap">`@const fn`<br>`mix(`|e1|`:` |T2| `, `|e2|`:` |T2| `, `|e3|`:` f32 `) -> ` |T|
    <td>返回 |e1| 和 |e2| 的分量线性混合，
    使用标量混合因子 |e3| 对于每个组件。<br>
    与 `mix(`|e1|`, `|e2|`, `|T2|`(`|e3|`))` 相同

  <tr algorithm="scalar case, binary32, modf">
    <td>|T| 是 f32
    <td class="nowrap">`@const fn`<br>`modf(`|e|`: `|T|`) -> __modf_result`<br>
    <td>拆分 |e| 分为小数部分和整数部分。
    返回 `__modf_result` 内置结构, 定义如下:
    ```rust
struct __modf_result {
  fract : f32, // fractional part
  whole : f32  // whole part
}
    ```

    注意：一个值不能用 `__modf_result` 类型显式声明，但一个值可以推断类型。
    <div class='example wgsl function-scope' heading='modf usage'>
    <xmp highlight='rust'>
     // 推断结果类型
     let fract_and_whole = modf(1.5);
     // 设置 fract_direct 的值为 0.5
     let fract_direct = modf(1.5).fract;
    </xmp>
    </div>

  <tr algorithm="scalar case, binary16, modf">
    <td>|T| 是 f16
    <td class="nowrap">`@const fn modf(`|e|`: `|T|`) -> __modf_result_f16`<br>
    <td>拆分 |e| 分成小数部分和整数部分。
    返回 `__modf_result_f16` 内置结构, 定义如下:
    ```rust
struct __modf_result_f16 {
  fract : f16, // fractional part
  whole : f16  // whole part
}
    ```

    注意：一个值不能用 `__modf_result_f16` 类型显式声明，但一个值可以推断类型.

  <tr algorithm="vector case, binary32, modf">
    <td>|T| 是 vec|N|&lt;f32&gt;
    <td class="nowrap">`@const fn`<br>`modf(`|e|`: `|T|`) -> __modf_result_vec`|N|<br>
    <td>拆分 |e| 的组件分为小数部分和整数部分。
    返回 `__modf_result_vec`|N| 内置结构，定义为：
    ```rust
struct __modf_result_vecN {
  fract : vecN<f32>, // fractional part
  whole : vecN<f32>  // whole part
}
    ```

    注意：不能用类型 `__modf_result_vec`|N| 显式声明值，但值可以推断类型。

  <tr algorithm="vector case, binary16, modf">
    <td>|T| 是 vec|N|&lt;f16&gt;
    <td class="nowrap">`@const fn modf(`|e|`: `|T|`) -> __modf_result_vec`|N|`_f16`<br>
    <td>拆分 |e| 的组件 分成小数部分和整数部分.
    返回 `__modf_result_vec`|N|`_f16` 内置结构, 定义如下:
    ```rust
struct __modf_result_vecN_f16 {
  fract : vecN<f16>, // fractional part
  whole : vecN<f16>  // whole part
}
    ```

注意：一个值不能用 `__modf_result_vec`|N|`_f16`类型显式声明，但是一个值可以推断出类型.

  <tr algorithm="vector case, normalize">
    <td>|T| 是 AbstractFloat, f32, or f16
    <td class="nowrap">`@const fn`<br>`normalize(`|e|`:` vec|N|<|T|> `) -> ` vec|N|<|T|>
    <td>返回与 |e| 方向相同的单位向量。

  <tr algorithm="pow">
    <td>|T| 是 [ALLFLOATING]
    <td class="nowrap">`@const fn`<br>`pow(`|e1|`:` |T| `, `|e2|`:` |T| `) -> ` |T|
    <td>返回 |e1| 提升到 |e2| 的幂。
    [=Component-wise=] 当 |T| 是一个向量。

  <tr algorithm="quantize to f16">
    <td>|T| 是 f32 or vec|N|&lt;f32&gt;
    <td class="nowrap">`@const fn quantizeToF16(`|e|`:` |T| `) -> ` |T|
    <td>量化 32 位浮点值 |e| 好像 |e| 被转换为 [[!IEEE-754|IEEE 754]] binary16 值，
        然后转换回 IEEE 754 binary32 值。<br>
        查看 [[#floating-point-conversion]]。<br>
        [=Component-wise=] 当 |T| 是一个向量。<br>

        注意: vec2&lt;f32&gt; 的情况和 `unpack2x16float(pack2x16float(`|e|`))` 一样。

  <tr algorithm="radians">
    <td>|T| 是 [ALLFLOATING]
    <td class="nowrap">`@const fn`<br>`radians(`|e1|`:` |T| `) -> ` |T|
    <td>将度数转换为弧度，近似于 |e1|&nbsp;&times;&nbsp;&pi;&nbsp;&div;&nbsp;180。[=Component-wise=] 当 |T| 是一个向量<br>

  <tr algorithm="reflect">
    <td>|T| 是 vec|N|&lt;AbstractFloat&gt;, vec|N|&lt;f32&gt;, or vec|N|&lt;f16&gt;
    <td class="nowrap">`@const fn`<br>`reflect(`|e1|`:` |T| `, `|e2|`:` |T| `) -> ` |T|
    <td>对于事件向量 |e1| 和表面方向|e2|，返回反射方向 |e1|`-2*dot(`|e2|`,`|e1|`)*`|e2|。

  <tr algorithm="refract">
    <td>|T| 是 vec|N|&lt;|I|&gt;<br>I is AbstractFloat, f32, or f16
    <td class="nowrap">`@const fn`<br>`refract(`|e1|`:` |T| `, `|e2|`:` |T| `, `|e3|`:` |I| `) -> ` |T|
    <td>对于事件向量 |e1| 和表面法线|e2|，以及折射率比|e3|，
    让 `k = 1.0 - `|e3|` * `|e3|` * (1.0 - dot(`|e2|`, `|e1|`) * dot(`|e2|`, `|e1|`) )`。 如果 `k < 0.0`，则返回
    折射向量 0.0，否则返回折射向量
    |e3|` * `|e1|` - (`|e3|` * dot(`|e2|`, `|e1|`) + sqrt(k)) * `|e2|。

  <tr algorithm="round">
    <td>|T| 是 [ALLFLOATING]
    <td class="nowrap">`@const fn`<br>`round(`|e|`:` |T| `) -> ` |T|
    <td>返回值是最接近 |e| 的整数 |k|，作为浮点值。<br>
        当 |e| 位于 |k| 和 |k|+1 的中间的整数，
        结果是 |k| 当|k| 是偶数，当 |k| 是奇数时，返回 |k|+1 。<br>
        [=Component-wise=] 当 |T| 是一个向量。

  <tr algorithm="float sign">
    <td>|T| 是 [ALLFLOATING]
    <td class="nowrap">`@const fn`<br>`sign(`|e|`:` |T| `) -> ` |T|
    <td>返回 |e| 的符号。
    [=Component-wise=] 当 |T| 是一个向量。

  <tr algorithm="sin">
    <td>|T| 是 [ALLFLOATING]
    <td class="nowrap">`@const fn`<br>`sin(`|e|`:` |T| `) -> ` |T|
    <td>返回 |e| 的正弦值。
    [=Component-wise=] 当 |T| 是一个向量。

  <tr algorithm="sinh">
    <td>|T| 是 [ALLFLOATING]
    <td class="nowrap">`@const fn`<br>`sinh(`|e|`:` |T| `) -> ` |T|
    <td>返回 |e| 的双曲正弦值。
    [=Component-wise=] 当 |T| 是一个向量。

  <tr algorithm="smoothstep">
    <td>|T| 是 [ALLFLOATING]
    <td class="nowrap">`@const fn`<br>`smoothstep(`|low|`:` |T| `,` |high|`:` |T| `,` |x|`:` |T| `) -> ` |T|
    [=Component-wise=] 当 |T| 是一个向量。
    对于标量 |T|，结果为：
        |t| * |t| * (3.0 - 2.0 * |t|),
        where |t| = clamp((|x| - |low|) / (|high| - |low|), 0.0, 1.0).

  <tr algorithm="sqrt">
    <td>|T| 是 [ALLFLOATING]
    <td class="nowrap">`@const fn`<br>`sqrt(`|e|`:` |T| `) -> ` |T|
    <td>返回 |e| 的平方根。
    [=Component-wise=] 当 |T| 是一个向量。

  <tr algorithm="step">
    <td>|T| 是 [ALLFLOATING]
    <td class="nowrap">`@const fn`<br>`step(`|edge|`:` |T| `, `|x|`:` |T| `) -> ` |T|
    <td>如果 |edge| &le;  |x| 返回 1.0 ，否则为 0.0。
    [=Component-wise=] 当 |T| 是一个向量。

  <tr algorithm="tan">
    <td>|T| 是 [ALLFLOATING]
    <td class="nowrap">`@const fn`<br>`tan(`|e|`:` |T| `) -> ` |T|
    <td>返回 |e| 的正切。
    [=Component-wise=] 当 |T| 是一个向量。

  <tr algorithm="tanh">
    <td>|T| 是 [ALLFLOATING]
    <td class="nowrap">`@const fn`<br>`tanh(`|e|`:` |T| `) -> ` |T|
    <td>返回 |e| 的双曲正切值。
    [=Component-wise=] 当 |T| 是一个向量。

  <tr algorithm="trunc">
    <td>|T| 是 [ALLFLOATING]
    <td class="nowrap">`@const fn`<br>`trunc(`|e|`:` |T| `) -> ` |T|
    <td>返回最近的绝对值小于或等于 |e| 的整数。
    [=Component-wise=] 当 |T| 是一个向量。
</table>

## 整数内置函数 ## {#integer-builtin-functions}

<table class='data'>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="integral abs">
    <td>[ALLINTEGRALDECL]
    <td class="nowrap">`@const fn`<br>`abs`(|e|: |T| ) -> |T|
    <td>|e| 的绝对值。
        [=Component-wise=] 当 |T| 是一个向量。
        如果 |e| 是有符号整数标量类型，求最大负值，则结果为|e|。
        如果 |e| 是无符号整数类型，则结果为 |e|。

  <tr algorithm="integral clamp">
    <td>[ALLINTEGRALDECL]
    <td class="nowrap">`@const fn`<br>`clamp(`|e|`:` |T| `,` |low|`:` |T|`,` |high|`:` |T|`) ->` |T|
    <td>返回 `min(max(`|e|`,`|low|`),`|high|`)`。
    [=Component-wise=] 当 |T| 是一个向量。

  <tr algorithm="signed clamp">
    <td>|T| 是 [SIGNEDINTEGRAL]
    <td class="nowrap">`@const fn`<br>`clamp(`|e|`:` |T| `, `|low|`:` |T|`, `|high|`:` |T|`) ->` |T|
    <td>返回 `min(max(`|e|`,`|low|`),`|high|`)`。
    [=Component-wise=] 当 |T| 是一个向量。

  <tr 算法="count leading zeros">
     <td>|T| 是 [INTEGRAL]
     <td class="nowrap">`@const fn`<br>`countLeadingZeros(`|e|`:` |T| `) ->` |T|
     <td>从|e| 的最高位开始的连续0 位的个数，当|T| 时 是标量类型。<br>
         [=Component-wise=] 当 |T| 是一个向量。<br>
         在某些语言中也称为 “clz”。<br>

  <tr algorithm="count 1 bits">
    <td>|T| 是 [INTEGRAL]
    <td class="nowrap">`@const fn`<br>`countOneBits(`|e|`:` |T| `) ->` |T|
    <td>|e| 的表示中 1 的位数。<br>
        也叫作 "population count"。<br>
        [=Component-wise=] 当 |T| 是一个向量。
        (SPIR-V OpBitCount)

  <tr algorithm="count trailing zeroes">
    <td>|T| is [INTEGRAL]
    <td class="nowrap">`@const fn`<br>`countTrailingZeros(`|e|`:` |T| `) ->` |T|
    <td>从 |e| 的最低有效位开始的连续 0 位的数量，当 |T| 是标量类型。<br>
        [=Component-wise=] 当 |T| 是矢量。<br>
        在某些语言中也称为 “ctz”.<br>

  <tr algorithm="signed find most significant one bit">
    <td>|T| is [SIGNEDINTEGRAL]
    <td class="nowrap">`@const fn`<br>`firstBitHigh(`|e|`:` |T| `) ->` |T|
    <td>当 |T| 是标量，结果为:
        <ul>
        <li>-1 如果 |e| 是 0 或 -1。
        <li>否则 |e| 中最高位的位置 这与|e| 的符号位不同。
        </ul>

        注意：由于有符号整数使用二进制补码表示，符号位出现在最高有效位位置。

        [=Component-wise=] 当 |T| 是标量。<br>

  <tr algorithm="unsigned find most significant one bit">
    <td>|T| is [UNSIGNEDINTEGRAL]
    <td class="nowrap">`@const fn`<br>`firstBitHigh(`|e|`:` |T| `) ->` |T|
    <td>对于矢量 |T|，结果为:
        <ul>
        <li>|T|(-1) 如果 |e| 是 0。
        <li>否则 |e| 中最重要的 1 位的位置。
        </ul>
        [=Component-wise=] 当 |T| 为矢量。<br>

  <tr algorithm="find least significant one bit">
    <td>|T| is [INTEGRAL]
    <td class="nowrap">`@const fn`<br>`firstBitLow(`|e|`:` |T| `) ->` |T|
    <td>对于矢量 |T|，结果为:
        <ul>
        <li>|T|(-1) 如果 |e| 是 0。
        <li>否则 |e| 中最低有效 1 位的位置。
        </ul>
        [=Component-wise=] 当 |T| 为矢量

  <tr algorithm="signed extract bits">
    <td>|T| is [SIGNEDINTEGRAL]
    <td class="nowrap">`@const fn`<br>`extractBits(`<br>&nbsp;|e|`:` |T|`,`<br>&nbsp;|offset|`: u32,`<br>&nbsp;|count|` : u32) ->` |T|
    <td>从整数中读取位，带符号扩展。

    当 |T| 是一个标量，那么:
    <ul>
    <li>|w| 是 |T| 的比特位的宽度
    <li>|o| = min(|offset|,|w|)
    <li>|c| = min(|count|, |w| - |o|)
    <li>结果为 0 如果 |c| 是 0。
    <li>否则， 结果的位 0..|c|-1 从位复制|e|的 |o|..|o|+|c|-1。
        结果的其他位与结果的位|c|-1 相同。
    </ul>
    [=Component-wise=] 当 |T| 为矢量。
    <br>

  <tr algorithm="unsigned extract bits">
    <td>|T| is [UNSIGNEDINTEGRAL]
    <td class="nowrap">`@const fn`<br>`extractBits(`<br>&nbsp;|e|`:` |T|`,`<br>&nbsp;|offset|`: u32,`<br>&nbsp;|count|` : u32) ->` |T|
    <td>从整数中读取位，没有符号扩展。

    当 |T| 是一个标量，那么:
    <ul>
    <li>|w| 是 |T| 的比特位的宽度
    <li>|o| = min(|offset|,|w|)
    <li>|c| = min(|count|, |w| - |o|)
    <li>结果为 0 ，如果 |c| 是 0。
    <li>否则， 结果的位 0..|c|-1 从位复制|e|的 |o|..|o|+|c|-1。
       其他的位为 0.
    </ul>
    [=Component-wise=] 当 |T| 为矢量。
    <br>

  <tr algorithm="insert bits">
    <td>|T| is [INTEGRAL]
    <td class="nowrap">`@const fn`<br>`insertBits(`<br>&nbsp;|e|`:` |T|`,`<br>&nbsp;|newbits|`:`|T|`,`<br>&nbsp;|offset|`: u32,`<br>&nbsp;|count|` : u32) ->` |T|
    <td>以整数设置位。

    当 |T| 是一个标量，那么:
    <ul>
    <li>||w| 是 |T| 的比特位的宽度
    <li>|o| = min(|offset|,|w|)
    <li>|c| = min(|count|, |w| - |o|)
    <li>结果为 0 ，如果 |c| 是 0。
    <li>否则，
       结果的位 |o|..|o|+|c|-1 从 |newbits| 的位 0..|c|-1 复制。
       结果的其他位从|e| 复制。
    </ul>
    [=Component-wise=] 当 |T| 为矢量。
    <br>

  <tr algorithm="integral max">
    <td>[ALLINTEGRALDECL]
    <td class="nowrap">`@const fn`<br>`max(`|e1|`:` |T| `, `|e2|`:` |T|`) ->` |T|
    <td>返回 |e2| 如果 |e1| 小于 |e2|， 否则返回 |e1|。
    [=Component-wise=] 当 |T| 是一个向量。

  <tr algorithm="integral min">
    <td>[ALLINTEGRALDECL]
    <td class="nowrap">`@const fn`<br>`min(`|e1|`:` |T| `, `|e2|`:` |T|`) ->` |T|
    <td>返回 |e1| 如果 |e1| 小于 |e2|， 否则返回 |e2|。
    [=Component-wise=] 当 |T| 是一个向量。

  <tr algorithm="bit reversal">
    <td>|T| 是 [INTEGRAL]
    <td class="nowrap">`@const fn`<br>`reverseBits(`|e|`:` |T| `) ->`  |T|
    <td>反转 |e| 中的位：结果的位置 |k| 处的位 等于 |e| 的位置 31-|k| 处的位。<br>
        [=Component-wise=] 当 |T| 是一个向量。
  
    <tr algorithm="shift left">
    <td>[ALLINTEGRALDECL]<br>
    |TS| 如果 |T| 是 AbstractInt 或 u32 是标量，或<br>
    vec|N|&lt;AbstractInt&gt;, or vec|N|&lt;u32&gt; 否则
    <td class="nowrap">`@const fn shiftLeft(`|e1|`:` |T|`,` |e2|`:` |TS|`) ->` |T|
    <td>逻辑左移。<br>
    换档 |e1| 左，在最低有效位插入零位，并丢弃最高有效位。

    要移位的位数是|e2| 的值。
    如果 |e1| 具有 [=concrete=] 类型，移位值以 |e1| 的位宽为模。<br> [=Component-wise=] 当 |T| 是一个向量。

    如果 |e2| 是 [=AbstractInt=] 或 vec|N|<AbstractInt>，它是 [=shader-creation error=] 如果任何值小于 0。

  <tr algorithm="shift right">
    <td>[ALLINTEGRALDECL]>br>
    |TS| 如果 |T| 是 AbstractInt 或 u32 是标量，或<br>
    vec|N|&lt;AbstractInt&gt;, 或 vec|N|&lt;u32&gt; otherwise
    <td class="nowrap">`@const fn shiftRight(`|e1|`:` |T|`,` |e2|`:` |TS|`) ->` |T|
    <td>逻辑右移<br>
    如果 |e1| 有符号，移位 |e1| 对，在最高有效位插入零位，并丢弃最低有效位。
    如果 |e1| 无符号，移位 |e1| 对，复制|e1| 的符号位 进入最高有效位，并丢弃最低有效位。

    要移位的位数是|e2| 的值。
    如果 |e1| 具有 [=concrete=] 类型，移位值以 |e1| 的位宽为模。<br> [=Component-wise=] 当 |T| 是一个向量。

    如果 |e2| 是 [=AbstractInt=] 或 vec|N|<AbstractInt>，它是 [=shader-creation error=] 如果任何值小于 0。
</table>

## 矩阵内置函数 ## {#matrix-builtin-functions}
<table class='data'>
  <thead>
    <tr><th>前提条件<th>结果<th>描述
  </thead>
  <tr algorithm="determinant">
    <td>|T| is AbstractFloat, f32, or f16
    <td class="nowrap">`determinant(`|e|`:` mat|C|x|C|<|T|> `) -> ` |T|
    <td>返回 |e| 的行列式。
  <tr algorithm="transpose">
    <td>|T| is AbstractFloat, f32, or f16
    <td class="nowrap">`transpose(`|e|`:` mat|R|x|C|<|T|> `) -> ` mat|C|x|R|<|T|>
    <td>返回 |e| 的转置。
</table>

## 向量内置函数 ## {#vector-builtin-functions}

<table class='data'>
  <thead>
    <tr><th>Parameterization<td>Overload<td>Description
  </thead>
  <tr algorithm="dot"><td>|T| 是 AbstractInt, AbstractFloat, i32, u32, f32, 或 f16
    <td class="nowrap">`@const fn`<br>`dot(`|e1|`: vecN<`|T|`>, `|e2|`: vecN<`|T|`>) ->` |T|
    <td>返回 |e1| 和 |e2| 的点积.
</table>

## 导数内置函数 ## {#derivative-builtin-functions}

查看 [[#derivatives]].

这些函数:
* 只能在 [=fragment=] 着色器阶段使用。
* 只能在 [=uniform control flow=] 中调用。

<table class='data'>
  <thead>
    <tr><th>前提条件<th>结论<th>解释
  </thead>
  <tr algorithm="dpdx">
  <td rowspan=9>|T| 是 f32 或 vecN&lt;f32&gt;
    <td class="nowrap">`fn dpdx(`|e|`: `|T|`) ->` |T|
    <td>|e| 的偏导数对应窗口 x 的坐标。
    结果与 `dpdxFine(`|e|`)` 或 `dpdxCoarse(`|e|`)` 相同。
  <tr algorithm="dpdxCoarse">
    <td class="nowrap">`fn dpdxCoarse(`|e|`: `|T|`) -> `|T|
    <td>返回 |e| 的偏导数相对于窗口 x 坐标，使用局部差异。
     这可能会导致比 `dpdxFine(`|e|`)` 更少的独特位置。
  <tr algorithm="dpdxFine">
    <td class="nowrap">`fn dpdxFine(`|e|`: `|T|`) -> `|T|
    <td>返回 |e| 的偏导数相对于窗口 x 坐标。
  <tr algorithm="dpdy">
    <td class="nowrap">`fn dpdy(`|e|`: `|T|`) -> `|T|
    <td>返回 |e| 的偏导数相对于窗口 y 坐标。
    结果与 `dpdyFine(`|e|`)` 或 `dpdyCoarse(`|e|`)` 相同。
  <tr algorithm="dpdyCoarse">
    <td class="nowrap">`fn dpdyCoarse(`|e|`: `|T|`) -> `|T|
    <td>返回 |e| 的偏导数相对于窗口 y 坐标，使用局部差异。
    这可能会导致比 `dpdyFine(`|e|`)` 更少的独特位置。
  <tr algorithm="dpdyFine">
    <td class="nowrap">`fn dpdyFine(`|e|`: `|T|`) -> `|T|
    <td>返回 |e| 的偏导数相对于窗口y坐标。
  <tr algorithm="fwidth">
    <td class="nowrap">`fn fwidth(`|e|`: `|T|`) -> `|T|
    <td>返回 `abs(dpdx(`|e|`)) + abs(dpdy(`|e|`))`.
  <tr algorithm="fwidthCoarse">
    <td class="nowrap">`fn fwidthCoarse(`|e|`: `|T|`) -> `|T|
    <td>返回 `abs(dpdxCoarse(`|e|`)) + abs(dpdyCoarse(`|e|`))`.
  <tr algorithm="fwidthFine">
    <td class="nowrap">`fn fwidthFine(`|e|`: `|T|`) -> `|T|
    <td>返回 `abs(dpdxFine(`|e|`)) + abs(dpdyFine(`|e|`))`.
</table>

## 纹理内置函数 ## {#texture-builtin-functions}

在本节中，显示的纹理类型具有以下参数：
* |T|，采样类型。
* <var ignore>F</var>，[=texel format=]。
* <var ignore>A</var>，[=access mode=]。

参数值必须对相应的纹理类型有效。

### `textureDimensions` ### {#texturedimensions}

返回纹理的尺寸，或以 texels 为单位的纹理的 mip 级别。

```rust
fn textureDimensions(t: texture_1d<T>) -> i32
fn textureDimensions(t: texture_1d<T>, level: i32) -> i32
fn textureDimensions(t: texture_2d<T>) -> vec2<i32>
fn textureDimensions(t: texture_2d<T>, level: i32) -> vec2<i32>
fn textureDimensions(t: texture_2d_array<T>) -> vec2<i32>
fn textureDimensions(t: texture_2d_array<T>, level: i32) -> vec2<i32>
fn textureDimensions(t: texture_3d<T>) -> vec3<i32>
fn textureDimensions(t: texture_3d<T>, level: i32) -> vec3<i32>
fn textureDimensions(t: texture_cube<T>) -> vec2<i32>
fn textureDimensions(t: texture_cube<T>, level: i32) -> vec2<i32>
fn textureDimensions(t: texture_cube_array<T>) -> vec2<i32>
fn textureDimensions(t: texture_cube_array<T>, level: i32) -> vec2<i32>
fn textureDimensions(t: texture_multisampled_2d<T>)-> vec2<i32>
fn textureDimensions(t: texture_depth_2d) -> vec2<i32>
fn textureDimensions(t: texture_depth_2d, level: i32) -> vec2<i32>
fn textureDimensions(t: texture_depth_2d_array) -> vec2<i32>
fn textureDimensions(t: texture_depth_2d_array, level: i32) -> vec2<i32>
fn textureDimensions(t: texture_depth_cube) -> vec2<i32>
fn textureDimensions(t: texture_depth_cube, level: i32) -> vec2<i32>
fn textureDimensions(t: texture_depth_cube_array) -> vec2<i32>
fn textureDimensions(t: texture_depth_cube_array, level: i32) -> vec2<i32>
fn textureDimensions(t: texture_depth_multisampled_2d)-> vec2<i32>
fn textureDimensions(t: texture_storage_1d<F,A>) -> i32
fn textureDimensions(t: texture_storage_2d<F,A>) -> vec2<i32>
fn textureDimensions(t: texture_storage_2d_array<F,A>) -> vec2<i32>
fn textureDimensions(t: texture_storage_3d<F,A>) -> vec3<i32>
fn textureDimensions(t: texture_external) -> vec2<i32>
```

**参数:**

<table class='data'>
  <tr><td>`t`<td>
  [sampled](#sampled-texture-type),
  [multisampled](#multisampled-texture-type)， [depth](#texture-depth),
  [storage](#texture-storage)，或者 [external](#external-texture-type) 纹理。
  <tr><td>`level`<td>
  mip 级别，级别 0 包含纹理的全尺寸版本。<br>
  如果省略，则返回级别 0 的维度。
</table>

**返回:**

以纹素为单位的纹理尺寸。

对于基于立方体的纹理，结果是立方体每个面的尺寸。
立方体面是正方形，因此结果的 x 和 y 分量相等。

如果 `level` 在范围 `[0, textureNumLevels(t))` 之外，则可以返回返回类型的任何有效值。

### `textureGather` ### {#texturegather}

<dfn noexport>texture gather</dfn> 操作从二维、二维数组、立方体或立方体数组纹理中读取，计算四元素向量如下：
* 从 [=mip level=] 0 中找出将在带有线性过滤的采样操作中使用的四个纹素：
     * 使用指定的坐标、数组索引（如果存在）和偏移量（如果存在）。
     * 当考虑纹理空间坐标 (*u*,*v*) 时，纹素是相邻的，形成一个正方形。
     * 在纹理边缘、立方体面边缘或立方体角处选择的纹素像在普通纹理采样中一样处理。
* 对于每个纹素，读取一个通道并将其转换为标量值。
     * 对于非深度纹理，从零开始的 `component` 参数指定要使用的通道。
         * 如果纹理格式支持指定的通道，即有多个 `component`通道：
              * 当 texel 值为 `v` 时，产生标量值 `v[component]`。
         * 否则：
              * 当 `component` 为 1 或 2 时，产量为 0.0。
              * 当 `component` 为 3（alpha 通道）时，产量为 1.0。
     * 对于深度纹理，产生纹素值。 （深度纹理只有一个通道。）
* 产生四元素向量，根据纹素的相对坐标将上一步产生的标量排列成分量，如下：
    * <table>
        <thead class='data'><td>Result component<td>Relative texel coordinate</thead>
        <tr><td>x<td>(*u*<sub>min</sub>,*v*<sub>max</sub>)
        <tr><td>y<td>(*u*<sub>max</sub>,*v*<sub>max</sub>)
        <tr><td>z<td>(*u*<sub>max</sub>,*v*<sub>min</sub>)
        <tr><td>w<td>(*u*<sub>min</sub>,*v*<sub>min</sub>)
        </table>

TODO：四个纹素是 WebGPU 规范应描述的“样本足迹”。
https://github.com/gpuweb/gpuweb/issues/2343

```rust
fn textureGather(component: i32, t: texture_2d<T>, s: sampler, coords: vec2<f32>) -> vec4<T>
fn textureGather(component: i32, t: texture_2d<T>, s: sampler, coords: vec2<f32>, offset: vec2<i32>) -> vec4<T>
fn textureGather(component: i32, t: texture_2d_array<T>, s: sampler, coords: vec2<f32>, array_index: i32) -> vec4<T>
fn textureGather(component: i32, t: texture_2d_array<T>, s: sampler, coords: vec2<f32>, array_index: i32, offset: vec2<i32>) -> vec4<T>
fn textureGather(component: i32, t: texture_cube<T>, s: sampler, coords: vec3<f32>) -> vec4<T>
fn textureGather(component: i32, t: texture_cube_array<T>, s: sampler, coords: vec3<f32>, array_index: i32) -> vec4<T>
fn textureGather(t: texture_depth_2d, s: sampler, coords: vec2<f32>) -> vec4<f32>
fn textureGather(t: texture_depth_2d, s: sampler, coords: vec2<f32>, offset: vec2<i32>) -> vec4<f32>
fn textureGather(t: texture_depth_2d_array, s: sampler, coords: vec2<f32>, array_index: i32) -> vec4<f32>
fn textureGather(t: texture_depth_2d_array, s: sampler, coords: vec2<f32>, array_index: i32, offset: vec2<i32>) -> vec4<f32>
fn textureGather(t: texture_depth_cube, s: sampler, coords: vec3<f32>) -> vec4<f32>
fn textureGather(t: texture_depth_cube_array, s: sampler, coords: vec3<f32>, array_index: i32) -> vec4<f32>
```

**参数:**

<table class='data'>
  <tr><td>`component`<td>
  仅适用于非深度纹理。
  <br>从所选纹素读取的通道索引。
  <br>When provided, the `component` expression must a [=creation-time expression=] (e.g. `1`).<br>
  它的值必须至少为 0，最多为 3。
  超出此范围的值将导致 [=shader-creation error=]。
  <tr><td>`t`<td>
  The [sampled](#sampled-texture-type) or [depth](#texture-depth) texture to read from.
  <tr><td>`s`<td>
  The [sampler type](#sampler-type).
  <tr><td>`coords`<td>
  纹理坐标。
  <tr><td>`array_index`<td>
  从 0 开始的纹理数组索引。
  <tr><td>`offset`<td>
  在对纹理进行采样之前应用于未归一化纹理坐标的可选纹理像素偏移。 在应用任何纹理环绕模式之前应用此偏移量。<br>
  `offset` 表达式必须是:
    * 一个 `const_expression` 表达式（例如 `vec2<i32>(1, 2)`）。<br>
    * 一个 [=module scope|module-scope=]的 [=let declaration] 的名称
        每个 `offset` 组件必须至少为 `-8`，最多为 `7`。 超出此范围的值将导致 [=shader-creation error=]。
</table>

**返回:**

一个四元素向量，其分量从选定的纹素的指定通道中提取，如上所述。

<div class='example wgsl global-scope' heading="Gather components from texels in 2D texture">
  <xmp highlight='rust'>
    @group(0) @binding(0) var t: texture_2d<f32>;
    @group(0) @binding(1) var dt: texture_depth_2d;
    @group(0) @binding(2) var s: sampler;

    fn gather_x_components(c: vec2<f32>) -> vec4<f32> {
      return textureGather(0,t,s,c);
    }
    fn gather_y_components(c: vec2<f32>) -> vec4<f32> {
      return textureGather(1,t,s,c);
    }
    fn gather_z_components(c: vec2<f32>) -> vec4<f32> {
      return textureGather(2,t,s,c);
    }
    fn gather_depth_components(c: vec2<f32>) -> vec4<f32> {
      return textureGather(dt,s,c);
    }
  </xmp>
</div>

### `textureGatherCompare` ### {#texturegathercompare}

<dfn noexport>texture gather compare</dfn> 操作对深度纹理中的四个纹素进行深度比较，并将结果收集到单个向量中，如下所示：

* 找出将在线性过滤的深度采样操作中使用的四个纹素，
     从 [=mip level=] 0:
     * 使用指定的坐标、数组索引（如果存在）和偏移量（如果存在）。
     * 当考虑纹理空间坐标 (*u*,*v*) 时，纹素是相邻的，形成一个正方形。
     * 在纹理边缘、立方体面边缘或立方体角处选择的纹素像在普通纹理采样中一样处理。
* 对于每个纹素，执行与深度参考值的比较，产生 0.0 或 1.0 值，由比较采样器参数控制。
* 产生四元素向量，其中分量是与具有相对纹素坐标的纹素的比较结果，如下所示：
    * <table>
        <thead class='data'><td>Result component<td>Relative texel coordinate</thead>
        <tr><td>x<td>(*u*<sub>min</sub>,*v*<sub>max</sub>)
        <tr><td>y<td>(*u*<sub>max</sub>,*v*<sub>max</sub>)
        <tr><td>z<td>(*u*<sub>max</sub>,*v*<sub>min</sub>)
        <tr><td>w<td>(*u*<sub>min</sub>,*v*<sub>min</sub>)
        </table>

```rust
fn textureGatherCompare(t: texture_depth_2d, s: sampler_comparison, coords: vec2<f32>, depth_ref: f32) -> vec4<f32>
fn textureGatherCompare(t: texture_depth_2d, s: sampler_comparison, coords: vec2<f32>, depth_ref: f32, offset: vec2<i32>) -> vec4<f32>
fn textureGatherCompare(t: texture_depth_2d_array, s: sampler_comparison, coords: vec2<f32>, array_index: i32, depth_ref: f32) -> vec4<f32>
fn textureGatherCompare(t: texture_depth_2d_array, s: sampler_comparison, coords: vec2<f32>, array_index: i32, depth_ref: f32, offset: vec2<i32>) -> vec4<f32>
fn textureGatherCompare(t: texture_depth_cube, s: sampler_comparison, coords: vec3<f32>, depth_ref: f32) -> vec4<f32>
fn textureGatherCompare(t: texture_depth_cube_array, s: sampler_comparison, coords: vec3<f32>, array_index: i32, depth_ref: f32) -> vec4<f32>
```
**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [depth](#texture-depth) texture to read from.
  <tr><td>`s`<td>
  The [sampler comparison](#sampler-type).
  <tr><td>`coords`<td>
  The texture coordinates.
  <tr><td>`array_index`<td>
  The 0-based texture array index.
  <tr><td>`depth_ref`<td>
  The reference value to compare the sampled depth value against.
  <tr><td>`offset`<td>
在对纹理进行采样之前应用于未归一化纹理坐标的可选纹理像素偏移。 在应用任何纹理环绕模式之前应用此偏移量。<br>
  The `offset` expression must be a [=creation-time expression=] (e.g. `vec2<i32>(1, 2)`).<br>
  每个 `offset` 组件必须至少为 `-8`，最多为 `7`。 超出此范围的值将导致 [=shader-creation error=]。
</table>

**返回:**

如上所述，具有所选纹素的比较结果的四元素向量。

<div class='example wgsl global-scope' heading="Gather depth comparison">
  <xmp highlight='rust'>
    @group(0) @binding(0) var dt: texture_depth_2d;
    @group(0) @binding(1) var s: sampler;

    fn gather_depth_compare(c: vec2<f32>, depth_ref: f32) -> vec4<f32> {
      return textureGatherCompare(dt,s,c,depth_ref);
    }
  </xmp>
</div>


### `textureLoad` ### {#textureload}

从纹理中读取单个纹素，无需采样或过滤。

```rust
fn textureLoad(t: texture_1d<T>, coords: i32, level: i32) -> vec4<T>
fn textureLoad(t: texture_2d<T>, coords: vec2<i32>, level: i32) -> vec4<T>
fn textureLoad(t: texture_2d_array<T>, coords: vec2<i32>, array_index: i32, level: i32) -> vec4<T>
fn textureLoad(t: texture_3d<T>, coords: vec3<i32>, level: i32) -> vec4<T>
fn textureLoad(t: texture_multisampled_2d<T>, coords: vec2<i32>, sample_index: i32)-> vec4<T>
fn textureLoad(t: texture_depth_2d, coords: vec2<i32>, level: i32) -> f32
fn textureLoad(t: texture_depth_2d_array, coords: vec2<i32>, array_index: i32, level: i32) -> f32
fn textureLoad(t: texture_depth_multisampled_2d, coords: vec2<i32>, sample_index: i32)-> f32
fn textureLoad(t: texture_external, coords: vec2<i32>) -> vec4<f32>
```

**参数:**

<table class='data'>
  <tr><td>`t`<td>
  [sampled](#sampled-texture-type)，
  [multisampled](#multisampled-texture-type)， [depth](#texture-depth),
  或者 [external](#external-texture-type) 纹理。
  <tr><td>`coords`<td>
  基于 0 的纹素坐标。
  <tr><td>`array_index`<td>
  从 0 开始的纹理数组索引。
  <tr><td>`level`<td>
  mip 级别，级别 0 包含纹理的全尺寸版本。
  <tr><td>`sample_index`<td>
  多重采样纹理的基于 0 的样本索引。
</table>

**返回:**

未过滤的纹素数据。

如果发生越界访问:
* `coords` 的任何元素都在相应元素的 `[0, textureDimensions(t, level))` 范围之外，或
* `array_index` 超出范围 `[0, textureNumLayers(t))`，或
* `level` 超出范围 `[0, textureNumLevels(t))`

如果发生越界访问，内置函数返回以下之一：
* 纹理边界内某些纹素的数据
* 非深度纹理的适当类型的向量 (0,0,0,0) 或 (0,0,0,1)
* 0.0 深度纹理

### `textureNumLayers` ### {#texturenumlayers}

返回数组纹理的层数（元素数）。

```rust
fn textureNumLayers(t: texture_2d_array<T>) -> i32
fn textureNumLayers(t: texture_cube_array<T>) -> i32
fn textureNumLayers(t: texture_depth_2d_array) -> i32
fn textureNumLayers(t: texture_depth_cube_array) -> i32
fn textureNumLayers(t: texture_storage_2d_array<F,A>) -> i32
```

**参数:**

<table class='data'>
  <tr><td>`t`<td>
  [sampled](#sampled-texture-type)，
  [multisampled](#multisampled-texture-type)， [depth](#texture-depth) 或
  [storage](#texture-storage) 数组纹理。
</table>

**返回:**

数组纹理的层数（元素）。


### `textureNumLevels` ### {#texturenumlevels}

返回纹理的 mip 级别数。

```rust
fn textureNumLevels(t: texture_1d<T>) -> i32
fn textureNumLevels(t: texture_2d<T>) -> i32
fn textureNumLevels(t: texture_2d_array<T>) -> i32
fn textureNumLevels(t: texture_3d<T>) -> i32
fn textureNumLevels(t: texture_cube<T>) -> i32
fn textureNumLevels(t: texture_cube_array<T>) -> i32
fn textureNumLevels(t: texture_depth_2d) -> i32
fn textureNumLevels(t: texture_depth_2d_array) -> i32
fn textureNumLevels(t: texture_depth_cube) -> i32
fn textureNumLevels(t: texture_depth_cube_array) -> i32
```

**参数:**

<table class='data'>
  <tr><td>`t`<td>
  [sampled](#sampled-texture-type) 或 [depth](#texture-depth) 纹理。
</table>

**返回:**

纹理的 mip 级别数。


### `textureNumSamples` ### {#texturenumsamples}

返回多重采样纹理中每个纹素的样本数。

```rust
textureNumSamples(t: texture_multisampled_2d<T>) -> i32
textureNumSamples(t: texture_depth_multisampled_2d) -> i32
```

**参数:**

<table class='data'>
  <tr><td>`t`<td>
  [multisampled](#multisampled-texture-type) 纹理。
</table>

**返回:**

如果多重采样纹理中每个纹素的样本数。

多重采样纹理中每个纹素的采样数。

### `textureSample` ### {#texturesample}

采样纹理。

只能在 [=fragment=] 着色器阶段使用。
只能在 [=uniform control flow=] 中调用。

```rust
fn textureSample(t: texture_1d<f32>, s: sampler, coords: f32) -> vec4<f32>
fn textureSample(t: texture_2d<f32>, s: sampler, coords: vec2<f32>) -> vec4<f32>
fn textureSample(t: texture_2d<f32>, s: sampler, coords: vec2<f32>, offset: vec2<i32>) -> vec4<f32>
fn textureSample(t: texture_2d_array<f32>, s: sampler, coords: vec2<f32>, array_index: i32) -> vec4<f32>
fn textureSample(t: texture_2d_array<f32>, s: sampler, coords: vec2<f32>, array_index: i32, offset: vec2<i32>) -> vec4<f32>
fn textureSample(t: texture_3d<f32>, s: sampler, coords: vec3<f32>) -> vec4<f32>
fn textureSample(t: texture_3d<f32>, s: sampler, coords: vec3<f32>, offset: vec3<i32>) -> vec4<f32>
fn textureSample(t: texture_cube<f32>, s: sampler, coords: vec3<f32>) -> vec4<f32>
fn textureSample(t: texture_cube_array<f32>, s: sampler, coords: vec3<f32>, array_index: i32) -> vec4<f32>
fn textureSample(t: texture_depth_2d, s: sampler, coords: vec2<f32>) -> f32
fn textureSample(t: texture_depth_2d, s: sampler, coords: vec2<f32>, offset: vec2<i32>) -> f32
fn textureSample(t: texture_depth_2d_array, s: sampler, coords: vec2<f32>, array_index: i32) -> f32
fn textureSample(t: texture_depth_2d_array, s: sampler, coords: vec2<f32>, array_index: i32, offset: vec2<i32>) -> f32
fn textureSample(t: texture_depth_cube, s: sampler, coords: vec3<f32>) -> f32
fn textureSample(t: texture_depth_cube_array, s: sampler, coords: vec3<f32>, array_index: i32) -> f32
```

**参数:**

<table class='data'>
  <tr><td>`t`<td>
  [sampled](#sampled-texture-type), [depth](#texture-depth),
  或 [external](#external-texture-type)
  纹理采样.
  <tr><td>`s`<td>
  The [sampler type](#sampler-type).
  <tr><td>`coords`<td>
  用于采样的纹理坐标。
  <tr><td>`array_index`<td>
  要采样的基于 0 的纹理数组索引。
  <tr><td>`offset`<td>
  在对纹理进行采样之前应用于非标准化纹理坐标的可选纹理像素偏移。 在应用任何纹理环绕模式之前应用此偏移量.<br>
  The `offset` expression must be a [=creation-time expression=] (e.g. `vec2<i32>(1, 2)`).<br>
  每个“偏移”分量必须至少为“-8”，最多为“7”。 超出此范围的值将导致 [=shader-creation error=]。
</table>

**返回:**

采样值。

### `textureSampleBias` ### {#texturesamplebias}

对具有 mip 级别偏差的纹理进行采样。

只能在 [=fragment=] 着色器阶段使用。
只能在 [=uniform control flow=] 中调用.

```rust
fn textureSampleBias(t: texture_2d<f32>, s: sampler, coords: vec2<f32>, bias: f32) -> vec4<f32>
fn textureSampleBias(t: texture_2d<f32>, s: sampler, coords: vec2<f32>, bias: f32, offset: vec2<i32>) -> vec4<f32>
fn textureSampleBias(t: texture_2d_array<f32>, s: sampler, coords: vec2<f32>, array_index: i32, bias: f32) -> vec4<f32>
fn textureSampleBias(t: texture_2d_array<f32>, s: sampler, coords: vec2<f32>, array_index: i32, bias: f32, offset: vec2<i32>) -> vec4<f32>
fn textureSampleBias(t: texture_3d<f32>, s: sampler, coords: vec3<f32>, bias: f32) -> vec4<f32>
fn textureSampleBias(t: texture_3d<f32>, s: sampler, coords: vec3<f32>, bias: f32, offset: vec3<i32>) -> vec4<f32>
fn textureSampleBias(t: texture_cube<f32>, s: sampler, coords: vec3<f32>, bias: f32) -> vec4<f32>
fn textureSampleBias(t: texture_cube_array<f32>, s: sampler, coords: vec3<f32>, array_index: i32, bias: f32) -> vec4<f32>
```

**参数:**

<table class='data'>
  <tr><td>`t`<td>
  要采样的 [texture](#sampled-texture-type)。
  <tr><td>`s`<td>
  [sampler type](#sampler-type).
  <tr><td>`coords`<td>
  用于采样的纹理坐标。
  <tr><td>`array_index`<td>
  要采样的基于 0 的纹理数组索引。
  <tr><td>`bias`<td>
  采样前应用于 mip 级别的偏差。
  `bias` 必须介于 `-16.0` 和 `15.99` 之间。
  <tr><td>`offset`<td>
  在对纹理进行采样之前应用于未归一化纹理坐标的可选纹理像素偏移。 在应用任何纹理环绕模式之前应用此偏移量。<br>
  The `offset` expression must be a [=creation-time expression=] (e.g. `vec2<i32>(1, 2)`).<br>
  每个 `offset` 组件必须最少为 `-8`，最多为 `7`。 超出此范围的值将导致 [=shader-creation error=]。
</table>

**返回:**

采样值。


### `textureSampleCompare` ### {#texturesamplecompare}

对深度纹理进行采样并将采样的深度值与参考值进行比较。

只能在 [=fragment=] 着色器阶段使用。
只能在 [=uniform control flow=] 中调用。

```rust
fn textureSampleCompare(t: texture_depth_2d, s: sampler_comparison, coords: vec2<f32>, depth_ref: f32) -> f32
fn textureSampleCompare(t: texture_depth_2d, s: sampler_comparison, coords: vec2<f32>, depth_ref: f32, offset: vec2<i32>) -> f32
fn textureSampleCompare(t: texture_depth_2d_array, s: sampler_comparison, coords: vec2<f32>, array_index: i32, depth_ref: f32) -> f32
fn textureSampleCompare(t: texture_depth_2d_array, s: sampler_comparison, coords: vec2<f32>, array_index: i32, depth_ref: f32, offset: vec2<i32>) -> f32
fn textureSampleCompare(t: texture_depth_cube, s: sampler_comparison, coords: vec3<f32>, depth_ref: f32) -> f32
fn textureSampleCompare(t: texture_depth_cube_array, s: sampler_comparison, coords: vec3<f32>, array_index: i32, depth_ref: f32) -> f32
```

**参数:**

<table class='data'>
  <tr><td>`t`<td>
  要采样的 [depth](#texture-depth) 纹理。
  <tr><td>`s`<td>
  [sampler comparision](#sampler-type) 类型。
  <tr><td>`coords`<td>
  用于采样的纹理坐标。
  <tr><td>`array_index`<td>
  要采样的基于 0 的纹理数组索引。
  <tr><td>`depth_ref`<td>
  用于比较采样深度值的参考值。
  <tr><td>`offset`<td>
  在对纹理进行采样之前应用于未归一化纹理坐标的可选纹理像素偏移。 在应用任何纹理环绕模式之前应用此偏移量。<br>
  The `offset` expression must be a [=creation-time expression=] (e.g. `vec2<i32>(1, 2)`).<br>
  每个 `offset` 组件必须至少为 `-8`，最多为 `7`。 超出此范围的值将导致 [=shader-creation error=]。
</table>

**返回:**

在 `[0.0..1.0]` 范围内的一个值。

使用 `sampler_comparison`，定义的比较运算符将每个采样的纹素与参考值进行比较，从而为每个纹素生成“0”或“1”值。

如果采样器使用双线性过滤，则返回值是这些值的过滤平均值，否则返回单个纹素的比较结果。


### `textureSampleCompareLevel` ### {#texturesamplecomparelevel}

对深度纹理进行采样并将采样的深度值与参考值进行比较。

```rust
fn textureSampleCompareLevel(t: texture_depth_2d, s: sampler_comparison, coords: vec2<f32>, depth_ref: f32) -> f32
fn textureSampleCompareLevel(t: texture_depth_2d, s: sampler_comparison, coords: vec2<f32>, depth_ref: f32, offset: vec2<i32>) -> f32
fn textureSampleCompareLevel(t: texture_depth_2d_array, s: sampler_comparison, coords: vec2<f32>, array_index: i32, depth_ref: f32) -> f32
fn textureSampleCompareLevel(t: texture_depth_2d_array, s: sampler_comparison, coords: vec2<f32>, array_index: i32, depth_ref: f32, offset: vec2<i32>) -> f32
fn textureSampleCompareLevel(t: texture_depth_cube, s: sampler_comparison, coords: vec3<f32>, depth_ref: f32) -> f32
fn textureSampleCompareLevel(t: texture_depth_cube_array, s: sampler_comparison, coords: vec3<f32>, array_index: i32, depth_ref: f32) -> f32
```

`textureSampleCompareLevel` 函数与 `textureSampleCompare` 相同，除了：

* `textureSampleCompareLevel` 总是从 mip 级别 0 采样纹素。
    * 该函数不计算导数。
    * There is no requirement for `textureSampleCompareLevel` to be invoked in [=uniform control flow=].
* `textureSampleCompareLevel` 可以在任何着色器阶段调用。

### `textureSampleGrad` ### {#texturesamplegrad}

使用显式渐变对纹理进行采样。

```rust
fn textureSampleGrad(t: texture_2d<f32>, s: sampler, coords: vec2<f32>, ddx: vec2<f32>, ddy: vec2<f32>) -> vec4<f32>
fn textureSampleGrad(t: texture_2d<f32>, s: sampler, coords: vec2<f32>, ddx: vec2<f32>, ddy: vec2<f32>, offset: vec2<i32>) -> vec4<f32>
fn textureSampleGrad(t: texture_2d_array<f32>, s: sampler, coords: vec2<f32>, array_index: i32, ddx: vec2<f32>, ddy: vec2<f32>) -> vec4<f32>
fn textureSampleGrad(t: texture_2d_array<f32>, s: sampler, coords: vec2<f32>, array_index: i32, ddx: vec2<f32>, ddy: vec2<f32>, offset: vec2<i32>) -> vec4<f32>
fn textureSampleGrad(t: texture_3d<f32>, s: sampler, coords: vec3<f32>, ddx: vec3<f32>, ddy: vec3<f32>) -> vec4<f32>
fn textureSampleGrad(t: texture_3d<f32>, s: sampler, coords: vec3<f32>, ddx: vec3<f32>, ddy: vec3<f32>, offset: vec3<i32>) -> vec4<f32>
fn textureSampleGrad(t: texture_cube<f32>, s: sampler, coords: vec3<f32>, ddx: vec3<f32>, ddy: vec3<f32>) -> vec4<f32>
fn textureSampleGrad(t: texture_cube_array<f32>, s: sampler, coords: vec3<f32>, array_index: i32, ddx: vec3<f32>, ddy: vec3<f32>) -> vec4<f32>
```

**参数:**

<table class='data'>
  <tr><td>`t`<td>
  要采样的 [texture](#sampled-texture-type)。
  <tr><td>`s`<td>
  [sampler type](#sampler-type).
  <tr><td>`coords`<td>
  用于采样的纹理坐标。
  <tr><td>`array_index`<td>
  要采样的基于 0 的纹理数组索引。
  <tr><td>`ddx`<td>
  用于计算采样位置的 x 方向导数向量。
  <tr><td>`ddy`<td>
  用于计算采样位置的 y 方向导数向量。
  <tr><td>`offset`<td>
  在对纹理进行采样之前应用于未归一化纹理坐标的可选纹理像素偏移。 在应用任何纹理环绕模式之前应用此偏移量。<br>
  The `offset` expression must be a [=creation-time expression=] (e.g. `vec2<i32>(1, 2)`).<br>
  每个 `offset` 组件必须至少为 `-8`，最多为 `7`。 超出此范围的值将导致 [=shader-creation error=]。
</table>

**返回:**

采样值。


### `textureSampleLevel` ### {#texturesamplelevel}

使用显式 mip 级别或 mip 级别 0 对纹理进行采样。

```rust
fn textureSampleLevel(t: texture_2d<f32>, s: sampler, coords: vec2<f32>, level: f32) -> vec4<f32>
fn textureSampleLevel(t: texture_2d<f32>, s: sampler, coords: vec2<f32>, level: f32, offset: vec2<i32>) -> vec4<f32>
fn textureSampleLevel(t: texture_2d_array<f32>, s: sampler, coords: vec2<f32>, array_index: i32, level: f32) -> vec4<f32>
fn textureSampleLevel(t: texture_2d_array<f32>, s: sampler, coords: vec2<f32>, array_index: i32, level: f32, offset: vec2<i32>) -> vec4<f32>
fn textureSampleLevel(t: texture_3d<f32>, s: sampler, coords: vec3<f32>, level: f32) -> vec4<f32>
fn textureSampleLevel(t: texture_3d<f32>, s: sampler, coords: vec3<f32>, level: f32, offset: vec3<i32>) -> vec4<f32>
fn textureSampleLevel(t: texture_cube<f32>, s: sampler, coords: vec3<f32>, level: f32) -> vec4<f32>
fn textureSampleLevel(t: texture_cube_array<f32>, s: sampler, coords: vec3<f32>, array_index: i32, level: f32) -> vec4<f32>
fn textureSampleLevel(t: texture_depth_2d, s: sampler, coords: vec2<f32>, level: i32) -> f32
fn textureSampleLevel(t: texture_depth_2d, s: sampler, coords: vec2<f32>, level: i32, offset: vec2<i32>) -> f32
fn textureSampleLevel(t: texture_depth_2d_array, s: sampler, coords: vec2<f32>, array_index: i32, level: i32) -> f32
fn textureSampleLevel(t: texture_depth_2d_array, s: sampler, coords: vec2<f32>, array_index: i32, level: i32, offset: vec2<i32>) -> f32
fn textureSampleLevel(t: texture_depth_cube, s: sampler, coords: vec3<f32>, level: i32) -> f32
fn textureSampleLevel(t: texture_depth_cube_array, s: sampler, coords: vec3<f32>, array_index: i32, level: i32) -> f32
fn textureSampleLevel(t: texture_external, s: sampler, coords: vec2<f32>) -> vec4<f32>
```

**参数:**

<table class='data'>
  <tr><td>`t`<td>
  要采样的 [sampled](#sampled-texture-type) 或 [depth](#texture-depth) 纹理。
  <tr><td>`s`<td>
  [sampler type](#sampler-type).
  <tr><td>`coords`<td>
  用于采样的纹理坐标。
  <tr><td>`array_index`<td>
  要采样的基于 0 的纹理数组索引。
  <tr><td>`level`<td>
  mip 级别，级别 0 包含纹理的全尺寸版本。
  对于 `level` 是 `f32` 的函数，如果格式是可过滤的，则可以在两个级别之间插入小数值根据
  [Texture Format Capabilities](https://gpuweb.github.io/gpuweb/#texture-format-caps)。<br>
  如果未指定，则对 mip 级别 0 进行采样。
  <tr><td>`offset`<td>
  在对纹理进行采样之前应用于未归一化纹理坐标的可选纹理像素偏移。 在应用任何纹理环绕模式之前应用此偏移量。<br>
  The `offset` expression must be a [=creation-time expression=] (e.g. `vec2<i32>(1, 2)`).<br>
  每个 `offset` 组件必须至少为 `-8`，最多为 `7`。 超出此范围的值将导致 [=shader-creation error=]。
</table>

**返回:**

采样值。


### `textureStore` ### {#texturestore}

将单个纹素写入纹理。

```rust
fn textureStore(t: texture_storage_1d<F,write>, coords: i32, value: vec4<T>)
fn textureStore(t: texture_storage_2d<F,write>, coords: vec2<i32>, value: vec4<T>)
fn textureStore(t: texture_storage_2d_array<F,write>, coords: vec2<i32>, array_index: i32, value: vec4<T>)
fn textureStore(t: texture_storage_3d<F,write>, coords: vec3<i32>, value: vec4<T>)
```

通道格式“T”取决于存储纹素格式“F”。
【查看texel格式表】(#storage-texel-formats) 有关texel格式到通道格式的映射。

**参数:**

<table class='data'>
  <tr><td>`t`<td>
  [write-only storage texture](#texture-storage).
  <tr><td>`coords`<td>
  基于 0 的纹素坐标。<br>
  <tr><td>`array_index`<td>
  从 0 开始的纹理数组索引。
  <tr><td>`value`<td>
  新的纹素值。<br>
</table>

**注意:**

如果出现以下情况，则会发生越界访问：
* `coords` 的任何元素都在相应元素的 `[0, textureDimensions(t))` 范围之外，或者
* `array_index` 超出了 `[0, textureNumLayers(t))` 的范围

如果发生越界访问，内置函数可以执行以下任一操作：
* 不被执行
* 将 `value` 存储到一些边界 texel

## 原子内置函数 ## {#atomic-builtin-functions}

原子内置函数可用于 读/写/读-修改-写 原子
对象。 它们是 [[#atomic-types]] 上唯一允许的操作。

所有原子内置函数都使用一个 `relaxed` [[#memory-semantics|memory ordering]]（**0**-SPIR-V 中所有 `Memory Semantics` 操作数的整数常量）。
这意味着同步和排序保证仅适用于作用于相同 [=Memory locations=] 的原子操作。
原子和非原子内存访问之间或作用于不同内存位置的原子访问之间没有同步或排序保证。

原子内置函数“不得”用在 [=vertex=] 着色器阶段。

所有原子内置函数 `atomic_ptr` 参数的存储类 `SC` 必须是[=address spaces/storage=]或[=address spaces/workgroup=]。
[=address spaces/workgroup=] 原子在 SPIR-V 中具有 **Workgroup** 内存范围，而 [=address spaces/storage=] 原子在
SPIR-V 中具有 **Queue Family** 内存范围。

所有原子内置函数中的访问模式 `A` 必须是[=access/read_write=]。

### 原子负载 ### {#atomic-load}

```rust
fn atomicLoad(atomic_ptr: ptr<SC, atomic<T>, A>) -> T
```

返回原子加载的 `atomic_ptr` 指向的值。
它不原子修改|修改 [=atomic modification|modify=] 对象。

### 原子商店 ### {#atomic-store}

```rust
fn atomicStore(atomic_ptr: ptr<SC, atomic<T>, A>, v: T)
```

以原子方式将值 `v` 存储在 `atomic_ptr` 指向的原子对象中。
### 原子 读-修改-写### {#atomic-rmw}

```rust
fn atomicAdd(atomic_ptr: ptr<SC, atomic<T>, A>, v: T) -> T
fn atomicSub(atomic_ptr: ptr<SC, atomic<T>, A>, v: T) -> T
fn atomicMax(atomic_ptr: ptr<SC, atomic<T>, A>, v: T) -> T
fn atomicMin(atomic_ptr: ptr<SC, atomic<T>, A>, v: T) -> T
fn atomicAnd(atomic_ptr: ptr<SC, atomic<T>, A>, v: T) -> T
fn atomicOr(atomic_ptr: ptr<SC, atomic<T>, A>, v: T) -> T
fn atomicXor(atomic_ptr: ptr<SC, atomic<T>, A>, v: T) -> T
```
每个函数原子地执行以下步骤：

1.加载 `atomic_ptr` 指向的原始值。
2. 通过对函数名称执行操作（例如 max）来获得一个新值，其值为 |v|。
3. 使用 `atomic_ptr` 存储新值。

每个函数返回存储在原子对象中的原始值。

```rust
fn atomicExchange(atomic_ptr: ptr<SC, atomic<T>, A>, v: T) -> T
```

以原子方式将值 `v` 存储在指向 `atomic_ptr` 的原子对象中，并返回存储在原子对象中的原始值。

```rust
fn atomicCompareExchangeWeak(atomic_ptr: ptr<SC, atomic<T>, A>, cmp: T, v: T) -> __atomic_compare_exchange_result<T>

struct __atomic_compare_exchange_result<T> {
  old_value : T; // old value stored in the atomic
  exchanged : bool; // true if the exchange was done
}

// Maps to the SPIR-V instruction OpAtomicCompareExchange.
```

注意：不能使用类型 `__compare_exchange_result` 显式声明值，但值可以推断类型。

以原子方式执行以下步骤：

1. 加载 `atomic_ptr` 指向的原始值。
2. 使用相等运算将原始值与值 `v` 进行比较。
3. 仅当相等比较的结果为 `true` 时才存储值 `v`。

返回一个双成员结构，其中第一个成员 `old_value` 是原子对象的原始值，第二个成员 `exchanged` 是比较是否成功。

注意：在某些实现中，相等比较可能会失败。 也就是说，即使结果向量的第一个元素等于 `cmp`，结果向量的第二个元素也可能是 `false`。

## 数据打包内置函数 ## {#pack-builtin-functions}

数据打包内置函数可用于使用与 WGSL 中的类型不直接对应的数据格式对值进行编码。
这使程序能够将许多密集打包的值写入内存，从而减少着色器的内存带宽需求。

<table class='data'>
  <thead>
    <tr><td>结论<td>解释
  </thead>
  <tr algorithm="packing 4x8snorm">
    <td class="nowrap">`@const fn pack4x8snorm`(|e|: vec4&lt;f32&gt;) -> u32
    <td>将四个标准化浮点值转换为 8 位有符号整数，然后将它们组合成一个 `u32` 值。<br>
        输入的分量 |e|[|i|] 被转换为 8 位二进制补码整数值 &lfloor; 0.5 + 127 × min(1, max(-1, |e|[|i|])) &rfloor;
        然后放置在位 8 &times; |i| 通过 8 &times; |i| + 7 结果。

  <tr algorithm="packing 4x8unorm">
    <td class="nowrap">`@const fn pack4x8unorm`(|e|: vec4&lt;f32&gt;) -> u32
    <td>将四个标准化的浮点值转换为 8 位无符号整数，然后将它们组合成一个 `u32` 值。<br>
        输入的分量 |e|[|i|] 被转换为 8 位无符号整数值 &lfloor; 0.5 + 255 × min(1, max(0, |e|[|i|])) &rfloor;
        然后放置在位 8 &times; |i| 通过 8 &times; |i| + 7 结果。

  <tr algorithm="packing 2x16snorm">
    <td class="nowrap">`@const fn pack2x16snorm`(|e|: vec2&lt;f32&gt;) -> u32
    <td>将两个标准化浮点值转换为 16 位有符号整数，然后将它们组合成一个 `u32` 值。<br>
        输入的分量 |e|[|i|] 被转换为 16 位二进制补码整数值 &lfloor; 0.5 + 32767 × min(1, max(-1, |e|[|i|])) &rfloor;
        然后放置在位 16 &times; |i| 通过 16 &times; |i| + 15 结果。

  <tr algorithm="packing 2x16unorm">
    <td class="nowrap">`@const fn pack2x16unorm`(|e|: vec2&lt;f32&gt;) -> u32
    <td>将两个标准化浮点值转换为 16 位无符号整数，然后将它们组合成一个 `u32` 值。<br>
        输入的分量 |e|[|i|] 被转换为 16 位无符号整数值 &lfloor; 0.5 + 65535 × min(1, max(0, |e|[|i|])) &rfloor;
        然后放置在位 16 &times; |i| 通过 16 &times; |i| + 15 结果。

  <tr algorithm="packing 2x16float">
    <td class="nowrap">`@const fn pack2x16float`(|e|: vec2&lt;f32&gt;) -> u32
    <td>将两个浮点值转换为半精度浮点数，然后将它们合并为一个 `u32` 值。<br>
        输入的分量 |e|[|i|] 被转换为 [[!IEEE-754|IEEE-754]] binary16 值，然后将其放置在位 16 × |i| 通过 16 &times; |i| + 15 结果。
        查看 [[#floating-point-conversion]].
</table>

## 数据解包内置函数 ## {#unpack-builtin-functions}

数据解包内置函数可用于解码与 WGSL 中的类型不直接对应的数据格式中的值。
这使程序能够从内存中读取许多密集打包的值，从而减少着色器的内存带宽需求。

<table class='data'>
  <thead>
    <tr><td>结论<td>解释
  </thead>
  <tr algorithm="unpacking 4x8snorm">
    <td class="nowrap">`@const fn unpack4x8snorm`(|e|: u32) -> vec4&lt;f32&gt;
    <td>将 32 位值分解为四个 8 位块，然后将每个块重新解释为有符号的标准化浮点值。<br>
        组件 |i| 结果的最大值是 max(|v| &div; 127, -1)，其中 |v| 是位 8&times;|i| 的解释 通过 8&times;|i|+7 的 |e| 作为二进制补码的有符号整数。

  <tr algorithm="unpacking 4x8unorm">
    <td class="nowrap">`@const fn unpack4x8unorm`(|e|: u32) -> vec4&lt;f32&gt;
    <td>将 32 位值分解为四个 8 位块，然后将每个块重新解释为无符号标准化浮点值。<br>
        组件 |i| 结果是|v| &div; 255，其中|v| 是位 8&times;|i| 的解释 通过 8&times;|i|+7 的 |e| 作为无符号整数。

  <tr algorithm="unpacking 2x16snorm">
    <td class="nowrap">`@const fn unpack2x16snorm`(|e|: u32) -> vec2&lt;f32&gt;
    <td>将 32 位值分解为两个 16 位块，然后将每个块重新解释为有符号的标准化浮点值。<br>
        组件 |i| 结果的最大值是 max(|v| &div; 32767, -1)，
        其中 |v| 是位 16&times;|i| 的解释 通过 |e| 的 16&times;|i|+15 作为二进制补码的有符号整数。

  <tr algorithm="unpacking 2x16unorm">
    <td class="nowrap">`@const fn unpack2x16unorm`(|e|: u32) -> vec2&lt;f32&gt;
    <td>将 32 位值分解为两个 16 位块，然后将每个块重新解释为无符号标准化浮点值。<br>
        组件 |i| 结果是|v| &div; 65535，其中|v| 是位 16&times;|i| 的解释 通过 |e| 的 16&times;|i|+15 作为无符号整数。

  <tr algorithm="unpacking 2x16float">
    <td class="nowrap">`@const fn unpack2x16float`(|e|: u32) -> vec2&lt;f32&gt;
    <td>将 32 位值分解为两个 16 位块，并将每个块重新解释为浮点值。<br>
        组件 |i| 结果的 f32 表示 |v|，其中 |v| 是位 16&times;|i| 的解释
        通过 |e| 的 16&times;|i|+15 作为 [[!IEEE-754|IEEE-754]] binary16 值。
        查看 [[#floating-point-conversion]]。
</table>


## 同步内置函数 ## {#sync-builtin-functions}

WGSL 提供以下同步函数:

```rust
fn storageBarrier()
fn workgroupBarrier()
```

所有同步函数都执行一个 [=control barrier=] 和 Acquire/Release [[#memory-semantics|memory ordering]]。
也就是说，所有的同步函数，以及受影响的内存和原子操作都按照 [[#program-order|program order]] 相对于同步函数进行排序。
此外，在同步功能由工作组成员执行之后的任何受影响的内存或原子操作程序排序之前，在同步功能之前受影响的内存和原子操作必须对工作组中的所有其他线程可见。
所有同步函数都使用 `Workgroup` [=memory scope=]。
所有同步功能都有一个“工作组”[=execution scope=]。
所有同步函数只能在 [=compute=] 着色器阶段使用。

`storageBarrier` 影响 [=address spaces/storage=] 存储类中的内存和原子操作。

`workgroupBarrier` 影响 [=address spaces/workgroup=] 存储类中的内存和原子操作。