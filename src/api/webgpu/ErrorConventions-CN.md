# 错误同步性约定 / 指导

WebGPU中每个错误实例的行为都是由用例规范定义的。一个错误会有以下行为之一：

* 同步地抛出JS异常。
* 异步发生：
  * 导致WebGPU对象为空。产生一个错误日志入口。
  * 导致一个操作至无操作。产生一个错误日志入口。
* 如果操作返回一个Promise，它拒绝（同时可能产生一个错误日志入口）。

（如果开启开发模式，作为异常所有校验错误被同步地抛出。设备损耗可能是同步的并且它的行为可以具体实施。内存溢出错误当应用程序有机会将它们恢复时，不能被同步产生。）

**以下指导的意义是帮助选择单独的用例规范，但是每个例子都会被规范。这不允许“具体实施中再定义”的行为。注意一个事实如果它是异步程序可以轻易显露一个同步错误，但是反之则不行，所以在规范中我们更愿意去在异步端抛错。

作为一个通用规则，那些错误用例应当遵循以下指导，但是在单独用例中允许偏离。WebGPU函数调用`o.f(a, b, …)`，用`A = {a: a, b: b, …}`表示传入`o.f`的对象表。

* 如果WebIDL的捆绑规则将要抛出一个异常：错误**一定是**同步的。比如：
    即:
    * 一个传入参数的类型和WebIDL声明的不一致。

* 如果`o.f`方法是不可用特性的一部分：错误**一定是**同步的。
    * 如果该特性是已知的但是不可用，`o.f`可以被调用，但是抛出一个异常（具体实施时）。
    * 如果该特性未知，`o.f`是`undefined`类型，调用`undefined`会抛出一个异常。

* 如果`o.f`方法可用，但是会返回一个包含无法使用特性的接口实例：错误**一定是**同步的。
    * （我们可能没有这样的例子。）

* 如果`o`**是**一个定义了不可用特性的接口（不是实例）：错误**一定是**同步的。但是，注意行为不能确切匹配：
    * 如果特性*已知但不可用*，`o.f`可以被调用，但是会抛出一个异常（具体实施时）。
    * 如果特性*未知*，`o`未定义，所以访问`o`抛出一个异常（另外访问`window.o`得到`undefined`）。

* 如果任何`A`包含的键不是可用特性的核心部分：错误**一定是**同步的。
    * 这明确使得规则比通常WebIDL字典捆绑规则更严格。

* 如果任何`A`中的对象缺少必要的键（给出的当前特性）：错误**一定是**同步的。

* A中仅仅依靠单独基元的校验，`device.limits`，以及`device.features`：错误**可以（但不一定）**是同步的。比如：
    *一个`Number`超过`limits`中联合入口。
    * 两个数组应当长度匹配，但没有。
    * 一个比特标志有两个冲突的比特。

* *可以被用户端追踪到*的依靠状态的校验：错误**可能（但通常不会）**是同步的。比如：
    * `queue.signalFence(fence, 3); queue.signalFence(fence, 2);`
    * 建立一个无效的命令缓冲（比如，一次通过中资源冲突）：可能不是同步的。

* 用户端同步无法得知的依靠状态的校验：错误**一定不是**同步的。比如：
    * 一个WebGPU接口对象参数内部为空。
    * 设备缺失。
    * 有内存溢出的情况。
