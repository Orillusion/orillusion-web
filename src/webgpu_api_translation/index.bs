<pre class='metadata'>
Title: WebGPU
Shortname: webgpu
Level: None
Status: w3c/ED
Group: webgpu
ED: https://gpuweb.github.io/gpuweb/
TR: https://www.w3.org/TR/webgpu/
Repository: gpuweb/gpuweb
!Participate: <a href="https://github.com/gpuweb/gpuweb/issues/new">File an issue</a> (<a href="https://github.com/gpuweb/gpuweb/issues">open issues</a>)

Editor: Dzmitry Malyshau, Mozilla https://www.mozilla.org, dmalyshau@mozilla.com, w3cid 96977
Editor: Kai Ninomiya, Google https://www.google.com, kainino@google.com, w3cid 99487
Former Editor: Justin Fan, Apple https://www.apple.com, justin_fan@apple.com, w3cid 115633
Abstract: WebGPU exposes an API for performing operations, such as rendering and computation, on a Graphics Processing Unit.
Markup Shorthands: markdown yes
Markup Shorthands: dfn yes
Markup Shorthands: idl yes
Markup Shorthands: css no
Assume Explicit For: yes
</pre>

<pre class=biblio>
{
  "WGSL": {
    "authors": [
      "David Neto",
      "Myles C. Maxfield"
    ],
    "href": "https://gpuweb.github.io/gpuweb/wgsl/",
    "title": "WebGPU Shading Language",
    "status": "Editor's Draft",
    "publisher": "W3C",
    "deliveredBy": [
      "https://github.com/gpuweb/gpuweb"
    ]
  },
  "SourceMap": {
    "authors": [
      "John Lenz",
      "Nick Fitzgerald"
    ],
    "href": "https://sourcemaps.info/spec.html",
    "title": "Source Map Revision 3 Proposal"
  }
}
</pre>

<pre class="link-defaults">
spec:html;
    type:interface; text:Navigator
spec:webidl;
    type:interface; text:Promise
</pre>

<pre class='anchors'>
spec: ECMA-262; urlPrefix: https://tc39.es/ecma262/#
    type: dfn
        text: agent; url: agent
        text: surrounding agent; url: surrounding-agent
        text: agent cluster; url: sec-agent-clusters
spec: webidl; urlPrefix: https://heycam.github.io/webidl/#
    type: dfn
        text: resolve; url: resolve
spec: web-apis; urlPrefix: https://html.spec.whatwg.org/multipage/webappapis.html#
    type: dfn
        text: cross-origin isolated capability; url: concept-settings-object-cross-origin-isolated-capability
spec: canvas; urlPrefix: https://html.spec.whatwg.org/multipage/canvas.html#
    type: dfn
        text: origin-clean; url: concept-canvas-origin-clean
        text: placeholder canvas element; url: offscreencanvas-placeholder
        text: canvas context mode; url: concept-canvas-context-mode
        text: OffscreenCanvas context mode; url: offscreencanvas-context-mode
        text: check the usability of the image argument; url: check-the-usability-of-the-image-argument
spec: WGSL; urlPrefix: https://gpuweb.github.io/gpuweb/wgsl/#
    type: dfn
        text: location; url: input-output-locations
        text: interpolation; url: interpolation
        text: pipeline-overridable; url: pipeline-overridable
        text: pipeline-overridable constant identifier string; url: pipeline-overridable-constant-identifier-string
        text: pipeline-overridable constant has a default value; url: pipeline-overridable-constant-has-a-default-value
        text: statically accessed; url: statically-accessed
        text: wgsl-declaration; url: declaration
        text: wgsl-type; url: type
        text: pipeline output; url: pipeline-output
        text: pipeline input; url: pipeline-input
        text: builtin; url: builtin-variables
        text: channel formats; url: channel-formats
        text: invalid memory reference; url: invalid-memory-reference
</pre>

<style>
/* Make <dl> blocks more distinct from their surroundings. */
main dl:not(.switch) {
    border-left: thin solid #f3e48c;
    padding-left: .5em;
}

/** In switches, make multiple consecutive <dd> entries distinguishable. */
dl.switch > dd {
    display: list-item;
}

/* <p> by default has these margins. Update ul/ol/dl to match,
 * since they are also put in places where paragraphs go. */
p, ul, ol, dl {
    margin: 1em 0;
}

/* Box for Valid Usage requirements. */
div.validusage {
    padding: .5em;
    border: thin solid #88e !important;
    border-radius: .5em;
}
/*
 * If the Valid Usage requirements are the first child of a *-timeline block give it a larger top
 * margin to prevent the block labels from overlapping.
 */
.content-timeline>.validusage:first-child,
.device-timeline>.validusage:first-child,
.queue-timeline>.validusage:first-child {
    margin-top: 1.5em;
}

/*
 * Boxes for steps that occur on a particular timeline.
 */
div.content-timeline, div.device-timeline, div.queue-timeline {
    padding: .5em;
    border-radius: .5em;
}
.content-timeline {
    background: rgba(0, 255, 0, 0.05);
    background: var(--tint-green);
}
.device-timeline {
    background: rgba(255, 0, 0, 0.05);
    background: var(--tint-red);
}
.queue-timeline {
    background: rgba(255, 0, 255, 0.05);
    background: var(--tint-purple);
}

/*
 * Stylistic labels, for clarity of presentation of these blocks.
 *
 * NOTE: This text is non-accessible and non-selectable; surrounding
 * text must also explain the context.
 */
.validusage, .content-timeline, .device-timeline, .queue-timeline {
    position: relative;
}
.validusage::before,
.content-timeline::before,
.device-timeline::before,
.queue-timeline::before {
    font-weight: bold;
    font-style: italic;
    font-size: 130%;
    color: rgba(0, 0, 0, 0.15);
    color: var(--watermark-text);
    position: absolute;
    right: .3em;
    top: -.1em;
}
.validusage::before {
    content: "Valid Usage";
}
.content-timeline::before {
    content: "Content Timeline";
}
.device-timeline::before {
    content: "Device Timeline";
}
.queue-timeline::before {
    content: "Queue Timeline";
}

/*
 * Ensure that argumentdef blocks don't overflow algorithm section borders. This is made far harder
 * than it needs to be because the top-level W3C stylesheet has several @media + min-width variants
 * that mark themselves as !important and then proceed to do the wrong thing.
 */
@media screen and (min-width: 78em) {
    body:not(.toc-inline) .algorithm .overlarge {
        margin-right: auto !important;
    }
}
@media screen and (min-width: 90em) {
    body:not(.toc-inline) .algorithm .overlarge {
        margin-right: auto !important;
    }
}
.algorithm .overlarge {
    margin-right: auto !important;
}

/*
 * The default algorithm style has a caption that doesn't suit this spec's
 * formatting particularly well. Hide it.
 */
.algorithm .argumentdef {
    margin-top: 0;
}
.algorithm .argumentdef>caption {
    display: none;
}

/*
 * Add vertical lines to demarcate multi-column cells.
 */
table.data td[colspan] {
    border-left-style: dotted;
    border-right-style: dotted;
}

table.data.no-colspan-center td[colspan],
table.data.no-colspan-center th[colspan] {
    text-align: unset;
}

table.data tr.row-continuation td,
table.data tr.row-continuation th {
    border-top: none;
}

/*
 * Sticky table headers.
 */
.overlarge {
    /* position: sticky doesn't work inside scrollable elements. */
    overflow-x: unset;
}
thead.stickyheader th, th.stickyheader {
    position: sticky;
    top: 0;
    background: #f8f8f8;
    background: var(--stickyheader-background);
}

/*
 * Darkmode colors
 */
:root {
    --watermark-text: rgba(0, 0, 0, 15%);
    --stickyheader-background: #f8f8f8;
    --tint-red: rgba(255, 0, 0, 6%);
    --tint-green: rgba(0, 255, 0, 10%);
    --tint-blue: rgba(0, 0, 255, 5%);
    --tint-purple: rgba(255, 0, 255, 5%);
}
@media (prefers-color-scheme:dark) {
    :root {
        --watermark-text: rgba(255, 255, 255, 25%);
        --stickyheader-background: #181818;
        --tint-red: rgba(255, 0, 0, 20%);
        --tint-green: rgba(0, 255, 0, 18%);
        --tint-blue: rgba(0, 130, 255, 24%);
        --tint-purple: rgba(255, 0, 255, 22%);
    }
}

</style>


# Introduction # {#intro}

*This section is non-normative.*

[Graphics Processing Units](https://en.wikipedia.org/wiki/Graphics_processing_unit), or GPUs for short,
have been essential in enabling rich rendering and computational applications in personal computing.
WebGPU is an API that exposes the capabilities of GPU hardware for the Web.
The API is designed from the ground up to efficiently map to (post-2014) native GPU APIs.
WebGPU is not related to [WebGL](https://www.khronos.org/webgl/) and does not explicitly target OpenGL ES.

WebGPU sees physical GPU hardware as {{GPUAdapter}}s. It provides a connection to an adapter via
{{GPUDevice}}, which manages resources, and the device's {{GPUQueue}}s, which execute commands.
{{GPUDevice}} may have its own memory with high-speed access to the processing units.
{{GPUBuffer}} and {{GPUTexture}} are the <dfn dfn>physical resources</dfn> backed by GPU memory.
{{GPUCommandBuffer}} and {{GPURenderBundle}} are containers for user-recorded commands.
{{GPUShaderModule}} contains [=shader=] code. The other resources,
such as {{GPUSampler}} or {{GPUBindGroup}}, configure the way [=physical resources=] are used by the GPU.

GPUs execute commands encoded in {{GPUCommandBuffer}}s by feeding data through a [=pipeline=],
which is a mix of fixed-function and programmable stages. Programmable stages execute
<dfn dfn>shaders</dfn>, which are special programs designed to run on GPU hardware.
Most of the state of a [=pipeline=] is defined by
a {{GPURenderPipeline}} or a {{GPUComputePipeline}} object. The state not included
in these [=pipeline=] objects is set during encoding with commands,
such as {{GPUCommandEncoder/beginRenderPass()}} or {{GPURenderPassEncoder/setBlendConstant()}}.


# Malicious use considerations # {#malicious-use}

*This section is non-normative.* It describes the risks associated with exposing this API on the Web.

## Security ## {#security}

The security requirements for WebGPU are the same as ever for the web, and are likewise non-negotiable.
The general approach is strictly validating all the commands before they reach GPU,
ensuring that a page can only work with its own data.

### CPU-based undefined behavior ### {#security-cpu-ub}

A WebGPU implementation translates the workloads issued by the user into API commands specific
to the target platform. Native APIs specify the valid usage for the commands
(for example, see [vkCreateDescriptorSetLayout](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/vkCreateDescriptorSetLayout.html))
and generally don't guarantee any outcome if the valid usage rules are not followed.
This is called "undefined behavior", and it can be exploited by an attacker to access memory
they don't own, or force the driver to execute arbitrary code.

In order to disallow insecure usage, the range of allowed WebGPU behaviors is defined for any input.
An implementation has to validate all the input from the user and only reach the driver
with the valid workloads. This document specifies all the error conditions and handling semantics.
For example, specifying the same buffer with intersecting ranges in both "source" and "destination"
of {{GPUCommandEncoder/copyBufferToBuffer()}} results in {{GPUCommandEncoder}}
generating an error, and no other operation occurring.

See [[#errors-and-debugging]] for more information about error handling.

## GPU-based undefined behavior ## {#security-gpu-ub}

WebGPU [=shader=]s are executed by the compute units inside GPU hardware. In native APIs,
some of the shader instructions may result in undefined behavior on the GPU.
In order to address that, the shader instruction set and its defined behaviors are
strictly defined by WebGPU. When a shader is provided to {{GPUDevice/createShaderModule()}},
the WebGPU implementation has to validate it
before doing any translation (to platform-specific shaders) or transformation passes.

## Uninitialized data ## {#security-uninitialized}

Generally, allocating new memory may expose the leftover data of other applications running on the system.
In order to address that, WebGPU conceptually initializes all the resources to zero, although in practice
an implementation may skip this step if it sees the developer initializing the contents manually.
This includes variables and shared workgroup memory inside shaders.

The precise mechanism of clearing the workgroup memory can differ between platforms.
If the native API does not provide facilities to clear it, the WebGPU implementation transforms the compute
shader to first do a clear across all invocations, synchronize them, and continue executing developer's code.

## Out-of-bounds access in shaders ## {#security-shader}

[=Shader=]s can access [=physical resource=]s either directly
(for example, as a {{GPUBufferBindingType/"uniform"}} {{GPUBufferBinding}}), or via <dfn dfn>texture unit</dfn>s,
which are fixed-function hardware blocks that handle texture coordinate conversions.
Validation on the API side can only guarantee that all the inputs to the shader are provided and
they have the correct usage and types.
The host API side can not guarantee that the data is accessed within bounds
if the [=texture unit=]s are not involved.

Issue: define the host API distinct from the shader API

In order to prevent the shaders from accessing GPU memory an application doesn't own,
the WebGPU implementation may enable a special mode (called "robust buffer access") in the driver
that guarantees that the access is limited to buffer bounds.

Alternatively, an implementation may transform the shader code by inserting manual bounds checks.
When this path is taken, the out-of-bound checks only apply to array indexing. They aren't needed
for plain field access of shader structures due to the {{GPUBufferBindingLayout/minBindingSize}}
validation on the host side.

If the shader attempts to load data outside of [=physical resource=] bounds,
the implementation is allowed to:
  1. return a value at a different location within the resource bounds
  2. return a value vector of "(0, 0, 0, X)" with any "X"
  3. partially discard the draw or dispatch call

If the shader attempts to write data outside of [=physical resource=] bounds,
the implementation is allowed to:
  1. write the value to a different location within the resource bounds
  2. discard the write operation
  3. partially discard the draw or dispatch call

## Invalid data ## {#security-invalid-data}

When uploading [floating-point](https://en.wikipedia.org/wiki/IEEE_754) data from CPU to GPU,
or generating it on the GPU, we may end up with a binary representation that doesn't correspond
to a valid number, such as infinity or NaN (not-a-number). The GPU behavior in this case is
subject to the accuracy of the GPU hardware implementation of the IEEE-754 standard.
WebGPU guarantees that introducing invalid floating-point numbers would only affect the results
of arithmetic computations and will not have other side effects.

### Driver bugs ### {#security-driver-bugs}

GPU drivers are subject to bugs like any other software. If a bug occurs, an attacker
could possibly exploit the incorrect behavior of the driver to get access to unprivileged data.
In order to reduce the risk, the WebGPU working group will coordinate with GPU vendors
to integrate the WebGPU Conformance Test Suite (CTS) as part of their driver testing process,
like it was done for WebGL.
WebGPU implementations are expected to have workarounds for some of the discovered bugs,
and disable WebGPU on drivers with known bugs that can't be worked around.

### Timing attacks ### {#security-timing}

WebGPU is designed for multi-threaded use via Web Workers. As such, it is designed not to open
the users to modern high-precision timing attacks. Some of the objects,
like {{GPUBuffer}} or {{GPUQueue}}, have shared state which can be simultaneously accessed.
This allows race conditions to occur, similar to those of accessing a `SharedArrayBuffer`
from multiple Web Workers, which makes the thread scheduling observable.

WebGPU addresses this by limiting the ability to deserialize (or share) objects only to
the [=agents=] inside the [=agent cluster=], and only if
the [cross-origin isolated](https://web.dev/coop-coep/) policies are in place.
This restriction matches the [mitigations](https://hacks.mozilla.org/2020/07/safely-reviving-shared-memory/)
against the malicious `SharedArrayBuffer` use. Similarly, the user agent may also
serialize the [=agents=] sharing any handles to prevent any concurrency entirely.

In the end, the attack surface for races on shared state in WebGPU will be
a small subset of the `SharedArrayBuffer` attacks.

WebGPU also specifies the {{GPUFeatureName/"timestamp-query"}} feature, which
provides high precision timing of GPU operations. The feature is optional, and a WebGPU
implementation may limit its exposure only to those scenarios that are trusted. Alternatively,
the timing query results could be processed by a compute shader and aligned to a lower precision.

### Row hammer attacks ### {#security-rowhammer}

[Row hammer](https://en.wikipedia.org/wiki/Row_hammer) is a class of attacks that exploit the
leaking of states in DRAM cells. It could be used [on GPU](https://www.vusec.net/projects/glitch/).
WebGPU does not have any specific mitigations in place, and relies on platform-level solutions,
such as reduced memory refresh intervals.

## Denial of service ## {#security-dos}

WebGPU applications have access to GPU memory and compute units. A WebGPU implementation may limit
the available GPU memory to an application, in order to keep other applications responsive.
For GPU processing time, a WebGPU implementation may set up "watchdog" timer that makes sure an
application doesn't cause GPU unresponsiveness for more than a few seconds.
These measures are similar to those used in WebGL.

## Workload identification ## {#security-workload-identification}

WebGPU provides access to constrained global resources shared between different programs
(and web pages) running on the same machine. An application can try to indirectly probe
how constrained these global resources are, in order to reason about workloads performed
by other open web pages, based on the patterns of usage of these shared resources.
These issues are generally analogous to issues with Javascript,
such as system memory and CPU execution throughput. WebGPU does not provide any additional
mitigations for this.

### Memory resources ### {#security-memory-resources}

WebGPU exposes fallible allocations from machine-global memory heaps, such as VRAM.
This allows for probing the size of the system's remaining available memory
(for a given heap type) by attempting to allocate and watching for allocation failures.

GPUs internally have one or more (typically only two) heaps of memory
shared by all running applications. When a heap is depleted, WebGPU would fail to create a resource.
This is observable, which may allow a malicious application to guess what heaps
are used by other applications, and how much they allocate from them.

### Computation resources ### {#security-computation-resources}

If one site uses WebGPU at the same time as another, it may observe the increase
in time it takes to process some work. For example, if a site constantly submits
compute workloads and tracks completion of work on the queue,
it may observe that something else also started using the GPU.

A GPU has many parts that can be tested independently, such as the arithmetic units,
texture sampling units, atomic units, etc. A malicious application may sense when
some of these units are stressed, and attempt to guess the workload of another
application by analyzing the stress patterns. This is analogous to the realities
of CPU execution of Javascript.

## Privacy ## {#security-privacy}

### Machine-specific limits ### {#security-machine-limits}

WebGPU can expose a lot of detail on the underlying GPU architecture and the device geometry.
This includes available physical adapters, many limits on the GPU and CPU resources
that could be used (such as the maximum texture size), and any optional hardware-specific
capabilities that are available.

User agents are not obligated to expose the real hardware limits, they are in full contol of
how much the machine specifics are exposed. One strategy to reduce fingerprinting is binning
all the target platforms into a few number of bins. In general, the privacy impact of exposing
the hardware limits matches the one of WebGL.

The default limits are also deliberately high enough
to allow most application to work without requesting higher limits.
All the usage of the API is validated according to the requested limits,
so the actual hardware capabilities are not exposed to the users by accident.

### Machine-specific artifacts ### {#security-machine-artifacts}

There are some machine-specific rasterization/precision artifacts and performance differences
that can be observed roughly in the same way as in WebGL. This applies to rasterization coverage
and patterns, interpolation precision of the varyings between shader stages, compute unit scheduling,
and more aspects of execution.

Generally, rasterization and precision fingerprints are identical across most or all
of the devices of each vendor. Performance differences are relatively intractable,
but also relatively low-signal (as with JS execution performance).

Privacy-critical applications and user agents should utilize software implementations to eliminate such artifacts.

### Machine-specific performance ### {#security-machine-performance}

Another factor for differentiating users is measuring the performance of specific
operations on the GPU. Even with low precision timing, repeated execution of an operation
can show if the user's machine is fast at specific workloads.
This is a fairly common vector (present in both WebGL and Javascript),
but it's also low-signal and relatively intractable to truly normalize.

WebGPU compute pipelines expose access to GPU unobstructed by the fixed-function hardware.
This poses an additional risk for unique device fingerprinting. User agents can take steps
to dissociate logical GPU invocations with actual compute units to reduce this risk.

### User Agent State ### {#security-user-agent-state}

This specification doesn't define any additional user-agent state for an origin.
However it is expected that user agents will have compilation caches for the result of expensive
compilation like {{GPUShaderModule}}, {{GPURenderPipeline}} and {{GPUComputePipeline}}.
These caches are important to improve the loading time of WebGPU applications after the first
visit.

For the specification, these caches are indifferentiable from incredibly fast compilation, but
for applications it would be easy to measure how long {{GPUDevice/createComputePipelineAsync()}}
takes to resolve. This can leak information across origins (like "did the user access a site with
this specific shader") so user agents should follow the best practices in
[storage partitioning](https://github.com/privacycg/storage-partitioning).

The system's GPU driver may also have its own cache of compiled shaders and pipelines. User agents
may want to disable these when at all possible, or add per-partition data to shaders in ways that
will make the GPU driver consider them different.

# 基本概念 # {#fundamentals}

## 公约 ## {#api-conventions}

### 点符号语法 ### {#dot-syntax}

在此规范中， `.` ("点符号")语法，通常在编程语言中被使用。短语“`Foo.Bar`”意思是“`Foo`中的 `Bar`成员”。

`?.`（“可选链操作符”）语法，从JavaScript中被采用，也会用到。短语“Foo?.Bar”意思是“如果 `Foo` 为 `null` 或 `undefined` , `undefined`; 否则， `Foo.Bar` ”。

例如， `buffer` 是一个{{GPUBuffer}}对象， `buffer？.[[device]].[[adapter]]` 意思是“如果 `buffer` 为 `null` 或 `undefined` ，则 `undefined` ；否则，`[[adapter]]` 内置在 `[[device]]` 上，内置在buffer上。”

### 内部对象 ### {#webgpu-internal-objects}

<dfn dfn>internal object</dfn>是一个概念性的，未暴露的WebGPU对象。[=Internal objects=]追踪一个API对象的状态并且提供实现基础。如果一个特定[=Internal objects=]的状态可以从多个[=agent=]中并行地改变，那些改变关于所有[=agent=]总是原子的。

Note: 一个 "[=agent=]" 指一个Javascript“线程”（即. 主线程，或Web Worker）。

### WebGPU接口 ### {#webgpu-interfaces}

一个<dfn dfn>WebGPU interface</dfn>是一个包含一个[=internal object=]的暴露出来的接口。[=internal object=]的状态通过它提供的接口进行改变。

作为公约中重要一点，如果一个[=WebGPU interface=]的指向[=invalid=]，这意味着它包含的[=internal object=]是无效的。

所有包含{{GPUObjectBase}}的接口是一个[=WebGPU interface=]。

<script type=idl>
interface mixin GPUObjectBase {
    attribute USVString? label;
};
</script>

{{GPUObjectBase}}有以下属性:

<dl dfn-type=attribute dfn-for=GPUObjectBase>
    : <dfn>label</dfn>
    ::
        label用于开发过程中标记/描述底层[=internal object=]（比如可以用来传递error/warning消息。）label没有特定的格式，可以为空，所以不能被机器解析，开发者可以自由选择是否使用该字段。
</dl>

{{GPUObjectBase}}有以下内部槽位:

<dl dfn-type=attribute dfn-for=GPUObjectBase>
    : <dfn>\[[device]]</dfn>, of type [=device=], readonly
    ::
        一个持有拥有[=internal object=]的[=device=]的内部槽位。
</dl>

### 对象描述符 ### {#object-descriptors}

一个<dfn dfn>object descriptor</dfn>持有创建对象需要的信息，通常是通过{{GPUDevice}}的 `create*` 方法之一创建的。

<script type=idl>
dictionary GPUObjectDescriptorBase {
    USVString label;
};
</script>

{{GPUObjectDescriptorBase}}有以下成员:

<dl dfn-type=dict-member dfn-for=GPUObjectDescriptorBase>
    : <dfn>label</dfn>
    ::
        {{GPUObjectBase/label|GPUObjectBase.label}}的初始值。
</dl>

## 无效内部对象 &amp; 传染无效性 ## {#invalidity}

如果一个对象被成功创建，它在当时是<dfn dfn>valid</dfn>。一个[=internal object=]可以是<dfn dfn>invalid</dfn>。它可以在生命周期内变成[=invalid=]，但是永远不能再重新变回有效的。

问题：考虑将“无效”与“已销毁”分开。这将使有效性保持不变，并且只有涉及设备、缓冲区和纹理的操作（例如提交、映射）才会（明确地）检查这些对象的 `[[已销毁]]` 状态。

<div class=note>
[=invalid=] 对象由多种情况导致，包括：
    - 如果在创建对象时出现错误，则立即无效。例如，如果对象描述符没有描述有效的对象，或者没有足够的内存来分配资源，就会发生这种情况。
    - 如果一个对象被显式销毁（例如 GPUBuffer.destroy()），它就会变得无效。
    - 如果拥有对象的设备丢失，则该对象无效。
</div>

<div>
    要确定给定的{{GPUObjectBase}}对象与|targetObject|一起使用是否有效<dfn abstract-op>valid to use with</dfn>，请运行以下步骤：
        1. 如果不满足以下任一条件，则返回 `false` :
            <div class=validusage>
                - |object|是[=valid=]
                - |object|.{{GPUObjectBase/[[device]]}}是[=valid=].
                - |object|.{{GPUObjectBase/[[device]]}}是|targetObject|.{{GPUObjectBase/[[device]]}}.
            </div>
        2. 返回 `true`.
</div>

## 坐标系 ## {#coordinate-systems}

  - Y轴在标准化设备坐标 (NDC) 中向上：NDC 中的点(-1.0, -1.0)位于NDC的左下角。 此外，NDC中的x和y应介于-1.0和1.0之间（含），而 NDC中的z应介于0.0和1.0之间（含）。NDC中超出此范围的顶点不会引入任何错误，但会被剪裁。
  - Y轴在帧缓冲区坐标、视口坐标和片元/像素坐标中向下：origin(0, 0) 位于这些坐标系中的左上角。
  - 窗口/当前坐标匹配帧缓冲区坐标。
  - 纹理坐标中的origin(0, 0)的UV表示纹理内存中的第一个纹素（最低字节）。

注意：WebGPU的坐标系与图形管道中的DirectX坐标系相匹配。

## 编程模型 ## {#programming-model}

### 时间线 ### {#programming-model-timelines}

*本节是非规范的。*

前端有用户代理、后端有GPU的计算机系统具有并行工作在不同时间线上的组件：

: <dfn dfn>Content timeline</dfn>
:: 与Web 脚本的执行相关联。 它包括调用本规范描述的所有方法。

    <div class=content-timeline>
        在内容时间线上执行的步骤如下所示。
    </div>

: <dfn dfn>Device timeline</dfn>
:: 与用户代理发出的GPU设备操作相关联。它包括创建显卡适配器、设备和 GPU 资源和状态对象，从控制 GPU 的用户代理部分的角度来看，这些操作通常是同步操作，但可以存在于单独的操作系统进程中。

    <div class=device-timeline>
        在设备时间线上执行的步骤如下所示。
    </div>

: <dfn dfn>Queue timeline</dfn>
:: 与在 GPU 的计算单元上执行操作相关。它包括在 GPU 上运行的实际绘制、复制和计算作业。

    <div class=queue-timeline>
        在队列时间线上执行的步骤如下所示。
    </div>

在本规范中，当结果值取决于发生在除[=Content timeline=]以外的任何时间线上的工作时，将使用异步操作。它们由 JavaScript 中的回调和承诺表示。

<div class="example">
{{GPUComputePassEncoder/dispatch(x, y, z)|GPUComputePassEncoder.dispatch()}}:

  1. 用户通过调用发生在内容时间线上的{{GPUComputePassEncoder}}的方法对 `dispatch` 命令进行编码。
  2. 用户发出{{GPUQueue/submit(commandBuffers)|GPUQueue.submit()}}将GPUCommandBuffer移交给用户代理，用户代理通过调用操作系统驱动程序执行低级提交在[=Device timeline=]上处理它。
  3. 提交由GPU调用调度程序分派到实际计算单元上执行，这发生在[=Queue timeline=]上。

</div>
<div class="example">
{{GPUDevice/createBuffer(descriptor)|GPUDevice.createBuffer()}}:

  1. 用户填写一个{{GPUBufferDescriptor}}并用它创建一个{{GPUBuffer}}，这发生在[=Content timeline=]上。
  2. 用户代理在[=Device timeline=]上创建一个低级缓冲区。

</div>
<div class="example">
{{GPUBuffer/mapAsync()|GPUBuffer.mapAsync()}}:

  1. 用户请求在[=Content timeline=]上映射{{GPUBuffer}}并得到一个返回的promise。
  2. 用户代理检查缓冲区当前是否被GPU使用，并在使用结束时提醒自己检查。
  3. 在使用缓冲区完成对队列时间线的GPU操作后，用户代理将其映射到内存并resolves the promise。

</div>

### 内存模型 ### {#programming-model-memory}

*本节不规范。*

一旦在应用程序初始化例程中获得了{{GPUDevice}}，我们可以将WebGPU平台描述为由以下层组成：
Once a {{GPUDevice}} has been obtained during an application initialization routine,
we can describe the <dfn dfn>WebGPU platform</dfn> as consisting of the following layers:
  1. 实现规范的用户代理。
  2. 具有用于此设备的低级本机API驱动程序的操作系统。
  3. 实际的CPU和GPU硬件。

[=WebGPU platform=]的每一层可能有不同的内存类型，用户代理在实现规范时需要考虑：
  - GPU驱动程序通常无法访问脚本拥有的内存，例如脚本创建的{{ArrayBuffer}}。
  - 用户代理可能有不同的进程负责运行内容和与GPU驱动程序的通信。在这种情况下，它使用进程间共享内存来传输数据。
  - 专用 GPU 拥有自己的高带宽内存，而集成 GPU 通常与系统共享内存。

大多数[=physical resources=]分配在对GPU计算或渲染有效的类型的内存中。当用户需要向GPU提供新数据时，数据可能首先需要跨越进程边界才能到达与GPU驱动程序通信的用户代理部分。然后它可能需要对驱动程序可见，这有时需要复制到驱动程序分配的暂存内存中。最后，它可能需要转移到专用GPU内存，从而可能将内部布局更改为对GPU进行操作最有效的布局。

所有这些转换都是由用户代理的WebGPU实现完成的。

注意：这个例子描述了最坏的情况，而在实践中实现可能不需要跨越进程边界，或者可能能够将驱动程序管理的内存通过 `ArrayBuffer` 直接暴露给用户，从而避免任何数据复制。

### 多线程 ### {#programming-model-multi-threading}

### 资源使用 ### {#programming-model-resource-usages}

[=physical resources=]可以在 GPU 上使用，<dfn dfn>internal usage</dfn>:
<dl dfn-type=dfn dfn-for="internal usage">
    : <dfn>input</dfn>
    ::  填入为绘制或调度调用数据的缓冲。保留内容。被缓冲区{{GPUBufferUsage/INDEX}}、缓冲区{{GPUBufferUsage/VERTEX}}或缓冲区{{GPUBufferUsage/INDIRECT}}允许。
    : <dfn>constant</dfn>
    ::  从着色器的角度来看是常量的资源绑定。保留内容。缓冲区{{GPUBufferUsage/UNIFORM}}或纹理{{GPUTextureUsage/TEXTURE_BINDING}}允许。
    : <dfn>storage</dfn>
    ::  可写入存储资源绑定。被缓冲区{{GPUBufferUsage/STORAGE}}或纹理{{GPUTextureUsage/STORAGE_BINDING}}允许。
    : <dfn>storage-read</dfn>
    ::  只读存储资源绑定。保留内容。被缓冲区{{GPUBufferUsage/STORAGE}}允许。
    : <dfn>attachment</dfn>
    :: 在渲染过程中用作输出附件的纹理。被纹理{{GPUTextureUsage/RENDER_ATTACHMENT}}允许。
    : <dfn>attachment-read</dfn>
    :: 在渲染过程中用作只读附件的纹理。被纹理{{GPUTextureUsage/RENDER_ATTACHMENT}}允许。
</dl>

纹理可能由单独的[=mipmap levels=]和[=array layers=]组成，它们可以在任何给定时间以不同的方式被使用。每个这样的<dfn dfn>texture subresource</dfn>都由纹理、[=mipmap levels=]和（仅适用于2d纹理）阵列层和[=aspect=]唯一标识。

我们定义<dfn dfn>subresource</dfn>可以是整个缓冲区，也可以是[=texture subresource=]。

<div>
一些[=internal usages=]与其他用法兼容。[=subresource=]可以处于将多种用途组合在一起的状态。 当（且仅当）满足以下任何规则时，我们认为列表|U|是<dfn dfn>compatible usage list</dfn>：
    - |U|中的每个用法都是[=internal usage/input=]，[=internal usage/constant=]，[=internal usage/storage-read=]，或[=internal usage/attachment-read=]。
    - |U|中的每个用法都是[=internal usage/storage=]。
    - |U|只包含一个元素：[=internal usage/attachment=]。
</div>

强制使用仅组合到兼容的使用列表中，允许API限制在使用内存时可能发生数据争用的时间。该属性使对WebGPU编写的应用程序更有可能在不同平台上运行而无需修改。

通常，当实现以不同于当前使用允许的方式处理使用子资源的操作时，它会安排资源到新状态的转换。 在某些情况下，例如在开放的{{GPURenderPassEncoder}}中，由于硬件限制，这种转换是不可能的。我们将这些地方定义为<dfn dfn>usage scopes</dfn>。

主要的**使用规则**是，对于任何一个[=subresource=]，它在一个[=usage scope=]内的[=internal usages=]列表必须是一个[=compatible usage list=]。

例如，在同一{{GPURenderPassEncoder}}中绑定相同的缓冲区用于[=internal usage/storage=]和[=internal usage/input=]将使编码器以及拥有的{{GPUCommandEncoder}}进入错误状态。这种用法组合不会形成[=compatible usage list=]。

注意：允许在单个[=usage scope=]内出现多个可写存储缓冲区/纹理使用的竞争条件。

提供给{{GPURenderPassColorAttachment/view|GPURenderPassColorAttachment.view}}和{{GPURenderPassColorAttachment/resolveTarget|GPURenderPassColorAttachment.resolveTarget}}的视图中包含的纹理[=subresource=]被视为用作此渲染通道[=usage scope=]的[=internal usage/attachment=]。

[=texture subresource=]的<dfn dfn>physical size</dfn>是[=texture subresource=]在纹素中的维度，包括可能的额外填充以在[=subresource=]中形成完整的[=texel blocks=]。

  - 对于基于像素的{{GPUTextureFormat|GPUTextureFormats}}，物理大小始终等于采样硬件中使用的[=texture subresource=]的大小。
  - 基于块的压缩{{GPUTextureFormat|GPUTextureFormats}}中的纹理始终具有[=mipmap level=] 0，其descriptor.size是纹素块大小的倍数，但较低的[=mipmap level=]可能不是纹素块大小的倍数，并且可以有填充。

<div class="example">
考虑一个BC格式的{{GPUTexture}}，其{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/size}}为{60, 60, 1}，在[=mipmap level=] 2对GPUTexture进行采样时，采样硬件使用{15, 15, 1}作为[=texture subresource=]的大小 ，而其[=physical size=]为 {16, 16, 1}，因为块压缩算法只能在 4x4 纹素块上运行。
</div>

### 同步 ### {#programming-model-synchronization}

对于[=physical resources=]的每个[=subresource=]，在队列时间线上跟踪其[=internal usage=]标识集。

问题：本章节将会被修订以支持多个队列。

在[=Queue timeline=]上，有一个有序的[=usage scope=]序列。 在每个范围的持续时间内，任何给定[=subresource=]的内部使用标志集是恒定的。 [=subresource=]可以在[=usage scope=]之间的边界转换为新的使用。

本规范定义了以下[=usage scope=]：

- 在一个pass之外（在{{GPUCommandEncoder}}中），每个（非状态设置）命令都是一个使用范围（例如{{GPUCommandEncoder/copyBufferToTexture()}}）。
- 在计算过程中，每个调度命令（{{GPUComputePassEncoder/dispatch()}} 或 {{GPUComputePassEncoder/dispatchIndirect()}}）都是一个使用范围。 如果命令可能访问子资源，则在使用范围内“使用”子资源。 在调度中，对于当前{{GPUComputePipeline}}的{{GPUPipelineBase/[[layout]]}}使用的每个绑定组槽，该绑定组引用的每个子资源都在使用范围内“使用”。 状态设置计算传递命令，如{{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)}}，不直接影响使用范围； 他们改为更改在调度命令中检查的状态。
- 一个渲染通道是一个使用范围。如果子资源被任何（状态设置或非状态设置）命令引用，则在使用范围内“使用”子资源。 例如，在{{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)}}中， `bindGroup` 中的每个子资源都在渲染通道的使用范围内“使用”。

问题：上面说的应该是[=GPU commands=]。 但是我们还没有办法引用特定的GPU命令（比如 dispatch）。

<div class=note>
    上述规则意味着以下示例资源使用包含在[=usage scope validation=]中：

    - 在渲染过程中，任何{{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)|setBindGroup()}}调用中使用的子资源，无论当前绑定的管道的着色器或布局实际上依赖于这些绑定，还是绑定组被另一个“set”调用遮蔽。
    - 在任何{{GPURenderEncoderBase/setVertexBuffer()|setVertexBuffer()}}调用中使用的缓冲区，无论是否有任何绘制调用依赖于该缓冲区，或者该缓冲区是否被另一个“set”调用遮蔽。
    - 在任何{{GPURenderEncoderBase/setIndexBuffer()|setIndexBuffer()}}调用中使用的缓冲区，无论是否有任何绘制调用依赖于该缓冲区，或者该缓冲区是否被另一个“set”调用遮蔽。
    - 在{GPURenderPassDescriptor}}中被{{GPUCommandEncoder/beginRenderPass()|beginRenderPass()}}用作颜色附件、解析附件或深度/模板附件的纹理子资源，无论着色器是否实际上依赖于这些附件。
    - 用于可见性为0的绑定组条目的资源，或仅对计算阶段可见但在渲染通道中使用的资源（反之亦然）。
</div>

在命令编码期间，子资源的每次使用都记录在命令缓冲区[=usage scope=]之一中。对于每个[=usage scope=]，实现通过组成使用范围中使用的每个[=subresource=]的所有[=internal usage=]标志的列表来执行<dfn dfn>usage scope validation</dfn>。 如果这些列表中的任何一个不是[=compatible usage list=]，则{{GPUCommandEncoder/finish()|GPUCommandEncoder.finish()}}在当前错误范围内生成{{GPUValidationError}}。

## 核心内部对象 ## {#core-internal-objects}

### 显卡适配器 ### {#adapters}

一个<dfn dfn>adapter</dfn>代表系统上WebGPU的实现。每个显卡适配器都标识浏览器底层平台上的计算/渲染功能实例，以及浏览器在该功能之上的WebGPU实现实例。

如果[=adapter=]变得不可用，则它变得[=invalid=]。 一旦无效，它将永远不再有效。[=adapter=]上的任何[=device=]以及这些设备拥有的[=internal object=]也将变为无效。

注意：[=adapter=]可能是物理显示适配器 (GPU)，但也可能是软件渲染器。 返回的[=adapter=]可以指不同的物理显卡适配器，或指同一物理显卡适配器上的不同浏览器代码路径或系统驱动程序。应用程序可以同时保持多个[=adapter=]（通过{{GPUAdapter}}）（即使有些显卡适配器无效），其中两个可以引用相同物理配置的不同实例（例如，如果GPU被重置或断开连接并重新连接）。

如果[=adapter=]具有显著的性能警告以换取更广泛的兼容性、更可预测的行为或改进的隐私的某种组合，则可以将其视为<dfn>fallback adapter</dfn>。 不需要在每个系统上都有可用的[=fallback adapter=]。

[=adapter=]具有以下内部插槽：
<dl dfn-type=attribute dfn-for=adapter>
    : <dfn>\[[features]]</dfn>, of type [=ordered set=]&lt;{{GPUFeatureName}}&gt;, readonly
    ::
        [=features=] 可以用作创建显卡适配器上的设备。

    : <dfn>\[[limits]]</dfn>, of type [=supported limits=], readonly
    ::
        最好[=limit/better|best=]限制用作创建显卡适配器上的设备。
        每个适配器限制必须与[=supported limits=].中的默认值相同或更好[=limit/better=]。

    : <dfn>\[[current]]</dfn>, of type boolean
    ::
        指此时是否允许显卡适配器出售新设备。它的值可能随时改变。

        它最初在{{GPU/requestAdapter()}}中设置为 `true` 。它在“[=lose the device=]”和“[=mark adapters stale=]”中变为 `false` 。 一旦设置为 `false`，它就不能再次变为 `true` 。

        注意：此机制可确保各种适配器创建场景看起来与应用程序相似，因此它们可以轻松地以较少的测试对更多场景保持健壮：首次初始化，由于未插入适配器而重新初始化，由于测试GPUDevice.destroy()调用而重新初始化 等。它还确保应用程序使用最新的系统状态来决定使用哪个适配器。

    : <dfn>\[[fallback]]</dfn>, of type boolean
    ::
        如果设为 `true`, 则显卡适配器为[=fallback adapter=]。
</dl>

[=adapter=]通过{{GPUAdapter}}暴露出来。

### 设备 ### {#devices}

<dfn dfn>device</dfn>是[=adapter=]的逻辑实例，通过它创建内部对象。它可以在多个代理（例如专用workers）之间共享。

[=device=]是从它创建的所有内部对象的唯一所有者：当[=device=][=lose the device|丢失=]时，它和在其上创建的所有对象（直接，例如 {{GPUDevice/createTexture()}}，或间接，例如{{GPUTexture/createView()}}变得[=invalid=]。

问题：定义“所有权”。

[=device=]有以下内部插槽:

<dl dfn-type=attribute dfn-for=device>
    : <dfn>\[[adapter]]</dfn>, of type [=adapter=], readonly
    ::
        创建此设备的[=adapter=]。

    : <dfn>\[[features]]</dfn>, of type [=ordered set=]&lt;{{GPUFeatureName}}&gt;, readonly
    ::
        可在此设备上使用的功能。不能使用附加功能，即使底层显卡适配器可以支持它们。

    : <dfn>\[[limits]]</dfn>, of type [=supported limits=], readonly
    ::
        可在此设备上使用的限制。 没有更好的限制可以使用，即使底层显卡适配器可以支持它们。
</dl>

<div>
    当使用{{GPUDeviceDescriptor}}描述符从[=adapter=]创建<dfn dfn>a new device</dfn>时：

    - 设置|device|.{{device/[[adapter]]}}为|adapter|.

    - 设置|device|.{{device/[[features]]}}为|descriptor|.{{GPUDeviceDescriptor/requiredFeatures}}中的值[=ordered set|集=]。

    - 让|device|.{{device/[[limits]]}}成为具有默认值的[=supported limits=]对象。对于|descriptor|.{{GPUDeviceDescriptor/requiredLimits}} 中的每个(|key|, |value|) 对，将|device|.{{device/[[limits]]}}中key对应的成员设置为value的[=limit/better=]|值|或支持的limits中的默认值。
</div>

任何时候用户代理需要撤销对设备的访问，它都会调用[=lose the device=]（设备，`undefined`）。

<div>
    <dfn dfn>lose the device</dfn>(|设备|, |原因|):

    1. 设置|device|.{{device/[[adapter]]}}.{{adapter/[[current]]}}为 `false`。
    1. 问题：解释如何从设备得到它再到它“主要的”GPUDevice。
    1. 解决{{GPUDevice/lost|GPUDevice.lost}}返回一个新的{{GPUDeviceLostInfo}}，
        {{GPUDeviceLostInfo/reason}}设置为|reason|
        {{GPUDeviceLostInfo/message}}设置成一个实现定义值。

        注意：{{GPUDeviceLostInfo/message}}不应泄露不必要的用户/系统信息，也不应被应用程序解析。
</div>

[=device=]通过{{GPUDevice}}暴露。

##可选功能## {#optional-capabilities}

WebGPU[=adapter=]和[=device=]具有描述不同实现之间不同的WebGPU功能的<dfn dfn>capabilities</dfn>，通常是由于硬件或系统软件限制。[=capability=]要么是一个特性，要么是一个限制。

### 特性 ### {#features}

<dfn dfn>feature</dfn>是一组可选的WebGPU功能，并非所有实现都支持，通常是由于硬件或系统软件限制。

每个{{GPUAdapter}}暴露一组可用功能。{{GPUAdapter/requestDevice()}}中只能请求这些功能。

仅当在设备创建时请求该功能时，才能使用作为功能一部分的功能。有关每个功能启用的功能的描述，请参阅[[#feature-index|特性索引]]。

### 限制 ### {#limits}

每个<dfn dfn>limit</dfn>都是在设备上使用WebGPU的数字限制。

<dfn dfn>supported limits</dfn>对象对每个定义的限制都有一个值。 每个[=adapter=]都有一组受[=supported limits=]，并且{{GPUDeviceDescriptor/requiredLimits|创建}}的[=device=]具有特定的受支持限制。 无论适配器的限制如何，都会强制执行设备限制。

一个极限值可能比另一个更好<dfn dfn for=limit>better</dfn>。[=limit/better=]的限制值总是会放宽验证，从而使更多的程序有效。 对于每个限制，定义了“更好”。

注意：设置“更好”的限制不一定是可取的，因为它们可能会影响性能。因此，为了提高跨设备和实现的可移植性，应用程序通常应该请求适用于其内容的“最差”限制（理想情况下，默认值）。

每个限制也有一个<dfn dfn for=limit>default</dfn> 。每个[=adapter=]都保证支持默认值或更好的值[=limit/better=]。如果在{{GPUDeviceDescriptor/requiredLimits}}中未明确指定值，则使用默认值。

<table class="data no-colspan-center" dfn-type=attribute dfn-for="supported limits">
    <thead>
        <tr><th>Limit name <th>Type <th>[=limit/Better=] <th>[=limit/Default=]
    </thead>

    <tr><td><dfn>maxTextureDimension1D</dfn>
        <td>{{GPUSize32}} <td>Higher <td>8192
    <tr class=row-continuation><td colspan=4>
        通过{{GPUTextureDescriptor/dimension}} {{GPUTextureDimension/"1d"}}创建的[=texture=]，所允许的{{GPUTextureDescriptor/size}}.[=Extent3D/width=]最大值。

    <tr><td><dfn>maxTextureDimension2D</dfn>
        <td>{{GPUSize32}} <td>Higher <td>8192
    <tr class=row-continuation><td colspan=4>
        通过{{GPUTextureDescriptor/dimension}} {{GPUTextureDimension/"2d"}}创建的[=texture=]所允许的{{GPUTextureDescriptor/size}}.[=Extent3D/width=]和{{GPUTextureDescriptor/size}}.[=Extent3D/height=]最大值。

    <tr><td><dfn>maxTextureDimension3D</dfn>
        <td>{{GPUSize32}} <td>Higher <td>2048
    <tr class=row-continuation><td colspan=4>
        通过{{GPUTextureDescriptor/dimension}} {{GPUTextureDimension/"3d"}}创建的[=texture=]所允许的{{GPUTextureDescriptor/size}}.[=Extent3D/width=], {{GPUTextureDescriptor/size}}.[=Extent3D/height=]和{{GPUTextureDescriptor/size}}.[=Extent3D/depthOrArrayLayers=]最大值。

    <tr><td><dfn>maxTextureArrayLayers</dfn>
        <td>{{GPUSize32}} <td>Higher <td>256
    <tr class=row-continuation><td colspan=4>
        通过{{GPUTextureDescriptor/dimension}} {{GPUTextureDimension/"1d"}}或{{GPUTextureDimension/"2d"}}创建的[=texture=]所允许的{{GPUTextureDescriptor/size}}.[=Extent3D/depthOrArrayLayers=]最大值。

    <tr><td><dfn>maxBindGroups</dfn>
        <td>{{GPUSize32}} <td>Higher <td>4
    <tr class=row-continuation><td colspan=4>
        创建{{GPUPipelineLayout}}时{{GPUPipelineLayoutDescriptor/bindGroupLayouts}}中所允许的{{GPUBindGroupLayout|GPUBindGroupLayouts}}最大值。

    <tr><td><dfn>maxDynamicUniformBuffersPerPipelineLayout</dfn>
        <td>{{GPUSize32}} <td>Higher <td>8
    <tr class=row-continuation><td colspan=4>
        {{GPUPipelineLayout}}中{{GPUBindGroupLayoutEntry}}条目的最大数量，这些条目是具有动态偏移的统一缓冲区。 详见[=Exceeds the binding slot limits=]。

    <tr><td><dfn>maxDynamicStorageBuffersPerPipelineLayout</dfn>
        <td>{{GPUSize32}} <td>Higher <td>4
    <tr class=row-continuation><td colspan=4>
        {{GPUPipelineLayout}}中{{GPUBindGroupLayoutEntry}}条目的最大数量，这些条目是具有动态偏移的存储缓冲区。 详见[=Exceeds the binding slot limits=]。

    <tr><td><dfn>maxSampledTexturesPerShaderStage</dfn>
        <td>{{GPUSize32}} <td>Higher <td>16
    <tr class=row-continuation><td colspan=4>
        对每个可能的{{GPUShaderStage}}`阶段`，{{GPUPipelineLayout}}中作为采样纹理的{{GPUBindGroupLayoutEntry}}条目的最大数量。详见[=Exceeds the binding slot limits=]。

    <tr><td><dfn>maxSamplersPerShaderStage</dfn>
        <td>{{GPUSize32}} <td>Higher <td>16
    <tr class=row-continuation><td colspan=4>
        对每个可能的{{GPUShaderStage}}`阶段`，{{GPUPipelineLayout}}中作为采样器的{{GPUBindGroupLayoutEntry}}条目的最大数量。详见[=Exceeds the binding slot limits=]。

    <tr><td><dfn>maxStorageBuffersPerShaderStage</dfn>
        <td>{{GPUSize32}} <td>Higher <td>8
    <tr class=row-continuation><td colspan=4>
        对每个可能的{{GPUShaderStage}}`阶段`，{{GPUPipelineLayout}}中作为存储缓冲区的{{GPUBindGroupLayoutEntry}}条目的最大数量。详见[=Exceeds the binding slot limits=]。

    <tr><td><dfn>maxStorageTexturesPerShaderStage</dfn>
        <td>{{GPUSize32}} <td>Higher <td>4
    <tr class=row-continuation><td colspan=4>
        对每个可能的{{GPUShaderStage}}`阶段`，{{GPUPipelineLayout}}中作为存储纹理的{{GPUBindGroupLayoutEntry}}条目的最大数量。详见[=Exceeds the binding slot limits=]。

    <tr><td><dfn>maxUniformBuffersPerShaderStage</dfn>
        <td>{{GPUSize32}} <td>Higher <td>12
    <tr class=row-continuation><td colspan=4>
        对每个可能的{{GPUShaderStage}}`阶段`，{{GPUPipelineLayout}}中作为统一缓冲区的{{GPUBindGroupLayoutEntry}}条目的最大数量。详见[=Exceeds the binding slot limits=]。

    <tr><td><dfn>maxUniformBufferBindingSize</dfn>
        <td>{{GPUSize64}} <td>Higher <td>16384
    <tr class=row-continuation><td colspan=4>
        与|entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/type}}为{{GPUBufferBindingType/"uniform"}}的 {{GPUBindGroupLayoutEntry}}|条目|的绑定的最大{{GPUBufferBinding}}.{{GPUBufferBinding/size}}。

    <tr><td><dfn>maxStorageBufferBindingSize</dfn>
        <td>{{GPUSize64}} <td>Higher <td> 134217728 (128 MiB)
    <tr class=row-continuation><td colspan=4>
        与|entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/type}}为{{GPUBufferBindingType/"storage"}}或{{GPUBufferBindingType/"read-only-storage"}}的 {{GPUBindGroupLayoutEntry}}|条目|的绑定的最大{{GPUBufferBinding}}.{{GPUBufferBinding/size}}。

    <tr><td><dfn>minUniformBufferOffsetAlignment</dfn>
        <td>{{GPUSize32}} <td>Lower <td>256
    <tr class=row-continuation><td colspan=4>
        {{GPUBufferBinding}}.{{GPUBufferBinding/offset}}和{{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)|setBindGroup}} |dynamicOffsets| 参数所需的对齐方式，用于与|entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/type}}为{{GPUBufferBindingType/"uniform"}}的{{GPUBindGroupLayoutEntry}} |entry|绑定。

    <tr><td><dfn>minStorageBufferOffsetAlignment</dfn>
        <td>{{GPUSize32}} <td>Lower <td>256
    <tr class=row-continuation><td colspan=4>
        {{GPUBufferBinding}}.{{GPUBufferBinding/offset}}和{{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)|setBindGroup}} |dynamicOffsets| 参数所需的对齐方式，用于与|entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/type}}为{{GPUBufferBindingType/"storage"}}或{{GPUBufferBindingType/"read-only-storage"}}的{{GPUBindGroupLayoutEntry}} |entry|绑定。

    <tr><td><dfn>maxVertexBuffers</dfn>
        <td>{{GPUSize32}} <td>Higher <td>8
    <tr class=row-continuation><td colspan=4>
        创建{{GPURenderPipeline}}时{{GPUVertexState/buffers}}的最大值。

    <tr><td><dfn>maxVertexAttributes</dfn>
        <td>{{GPUSize32}} <td>Higher <td>16
    <tr class=row-continuation><td colspan=4>
        创建{{GPURenderPipeline}}时{{GPUVertexState/buffers}}中{{GPUVertexBufferLayout/attributes}}的最大值。

    <tr><td><dfn>maxVertexBufferArrayStride</dfn>
        <td>{{GPUSize32}} <td>Higher <td>2048
    <tr class=row-continuation><td colspan=4>
        创建{{GPURenderPipeline}}时{{GPUVertexBufferLayout/arrayStride}}所允许的的最大值。

    <tr><td><dfn>maxInterStageShaderComponents</dfn>
        <td>{{GPUSize32}} <td>Higher <td>60
    <tr class=row-continuation><td colspan=4>
        用于内部阶段间通信的输入或输出变量的最大允许组件数（如顶点输出或片段输入）。

    <tr><td><dfn>maxComputeWorkgroupStorageSize</dfn>
        <td>{{GPUSize32}} <td>Higher <td>16352
    <tr class=row-continuation><td colspan=4>
        用于计算阶段{{GPUShaderModule}}入口点的最大字节数。

    <tr><td><dfn>maxComputeInvocationsPerWorkgroup</dfn>
        <td>{{GPUSize32}} <td>Higher <td>256
    <tr class=row-continuation><td colspan=4>
        计算阶段{{GPUShaderModule}}入口点的 `workgroup_size` 维度乘积的最大值。

    <tr><td><dfn>maxComputeWorkgroupSizeX</dfn>
        <td>{{GPUSize32}} <td>Higher <td>256
    <tr class=row-continuation><td colspan=4>
        计算阶段{{GPUShaderModule}}入口点的 `workgroup_size` X维度的最大值。

    <tr><td><dfn>maxComputeWorkgroupSizeY</dfn>
        <td>{{GPUSize32}} <td>Higher <td>256
    <tr class=row-continuation><td colspan=4>
        计算阶段{{GPUShaderModule}}入口点的 `workgroup_size` Y维度的最大值。

    <tr><td><dfn>maxComputeWorkgroupSizeZ</dfn>
        <td>{{GPUSize32}} <td>Higher <td>64
    <tr class=row-continuation><td colspan=4>
        计算阶段{{GPUShaderModule}}入口点的 `workgroup_size` Z维度的最大值。

    <tr><td><dfn>maxComputeWorkgroupsPerDimension</dfn>
        <td>{{GPUSize32}} <td>Higher <td>65535
    <tr class=row-continuation><td colspan=4>
        {{GPUComputePassEncoder/dispatch(x, y, z)}}参数的最大值。

</table>

问题：我们需要有一个最大的每像素渲染目标尺寸吗？

#### <dfn interface>GPUSupportedLimits</dfn> #### {#gpu-supportedlimits}

{{GPUSupportedLimits}}暴露一个显卡适配器或设备支持的[=limits=]。
详见{{GPUAdapter/limits|GPUAdapter.limits}}和{{GPUDevice/limits|GPUDevice.limits}}.

<script type=idl>
[Exposed=(Window, DedicatedWorker)]
interface GPUSupportedLimits {
    readonly attribute unsigned long maxTextureDimension1D;
    readonly attribute unsigned long maxTextureDimension2D;
    readonly attribute unsigned long maxTextureDimension3D;
    readonly attribute unsigned long maxTextureArrayLayers;
    readonly attribute unsigned long maxBindGroups;
    readonly attribute unsigned long maxDynamicUniformBuffersPerPipelineLayout;
    readonly attribute unsigned long maxDynamicStorageBuffersPerPipelineLayout;
    readonly attribute unsigned long maxSampledTexturesPerShaderStage;
    readonly attribute unsigned long maxSamplersPerShaderStage;
    readonly attribute unsigned long maxStorageBuffersPerShaderStage;
    readonly attribute unsigned long maxStorageTexturesPerShaderStage;
    readonly attribute unsigned long maxUniformBuffersPerShaderStage;
    readonly attribute unsigned long long maxUniformBufferBindingSize;
    readonly attribute unsigned long long maxStorageBufferBindingSize;
    readonly attribute unsigned long minUniformBufferOffsetAlignment;
    readonly attribute unsigned long minStorageBufferOffsetAlignment;
    readonly attribute unsigned long maxVertexBuffers;
    readonly attribute unsigned long maxVertexAttributes;
    readonly attribute unsigned long maxVertexBufferArrayStride;
    readonly attribute unsigned long maxInterStageShaderComponents;
    readonly attribute unsigned long maxComputeWorkgroupStorageSize;
    readonly attribute unsigned long maxComputeInvocationsPerWorkgroup;
    readonly attribute unsigned long maxComputeWorkgroupSizeX;
    readonly attribute unsigned long maxComputeWorkgroupSizeY;
    readonly attribute unsigned long maxComputeWorkgroupSizeZ;
    readonly attribute unsigned long maxComputeWorkgroupsPerDimension;
};
</script>

#### <dfn interface>GPUSupportedFeatures</dfn> #### {#gpu-supportedfeatures}

{{GPUSupportedFeatures}}是一个[=setlike=]接口。它的[=set entries=]是一个显卡适配器或设备支持的[=features=]的{{GPUFeatureName}}值。它必须只包含{{GPUFeatureName}}枚举中的字符串。

<script type=idl>
[Exposed=(Window, DedicatedWorker)]
interface GPUSupportedFeatures {
    readonly setlike<DOMString>;
};
</script>

<div class="note">
注意：{{GPUSupportedFeatures}} [=set entries=]的类型是{{DOMString}}以允许用户代理优雅地处理有效的 {{GPUFeatureName}}s，这些{{GPUFeatureName}}s在规范的后续版本中添加，但用户代理尚未更新以识别。 如果设置的条目类型是{{GPUFeatureName}}，以下代码将抛出{{TypeError}}而不是报告 `false`：

<div class="example">
    检查对无法识别的功能的支持：
    <pre highlight="js">
        if (adapter.features.has('unknown-feature')) {
            // Use unknown-feature
        } else {
            console.warn('unknown-feature is not supported by this adapter.');
        }
    </pre>
</div>
</div>

## 源限制 ## {#origin-restrictions}

WebGPU允许访问存储在图像、视频和画布中的图像数据。跨域媒体的使用受到限制，因为着色器可用于间接推断已上传到GPU的纹理内容。

如果图像源<l spec=html>[=is not origin-clean=]</l>，则WebGPU不允许上传图像源。

这也意味着使用WebGPU渲染的画布的[=origin-clean=]标识永远不会设置为 `false`。

有关为图像和视频元素发出CORS请求的更多信息，请参阅：

- [[html#cors-settings-attributes]]
- [[html#the-img-element]] <{img}>
- [[html#media-elements]] {{HTMLMediaElement}}

## 颜色空间和编码 ## {#color-spaces}

WebGPU不提供颜色管理。WebGPU中的所有值（例如纹理元素）都是原始数值，而不是颜色管理的颜色值。

WebGPU有颜色管理的输出（通过{{GPUCanvasConfiguration}}）和输入（通过{{GPUQueue/copyExternalImageToTexture()}}和{GPUDevice/importExternalTexture()}}）接口。必须在WebGPU数值和外部颜色值之间进行颜色转换。每个这样的接口点在本地定义一个编码（颜色空间、传递函数和alpha预乘），在其中解释WebGPU数值。

<script type=idl>
enum GPUPredefinedColorSpace {
    "srgb",
};
</script>

问题：可能用PredefinedColorSpace替换它，但请注意，这样做意味着当项目被添加到上游规范中的枚举时，新的WebGPU 功能会自动添加。

问题(gpuweb/gpuweb#1715):考虑将srgb编码图像上传到线性编码纹理的路径。

<dl dfn-type=enum-value dfn-for=GPUPredefinedColorSpace>
    : <dfn>"srgb"</dfn>
    :: CSS预定义颜色空间<a value for=color()>srgb</a>。
</dl>

# Initialization # {#initialization}

## Examples ## {#initialization-examples}

Issue:
Need a robust example like the one in ErrorHandling.md, which handles all situations.
Possibly also include a simple example with no handling.

## navigator.gpu ## {#navigator-gpu}

A {{GPU}} object is available in the {{Window}} and {{DedicatedWorkerGlobalScope}} contexts through the {{Navigator}}
and {{WorkerNavigator}} interfaces respectively and is exposed via `navigator.gpu`:

<script type=idl>
interface mixin NavigatorGPU {
    [SameObject, SecureContext] readonly attribute GPU gpu;
};
Navigator includes NavigatorGPU;
WorkerNavigator includes NavigatorGPU;
</script>

## GPU ## {#gpu-interface}

<dfn interface>GPU</dfn> is the entry point to WebGPU.

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPU {
    Promise<GPUAdapter?> requestAdapter(optional GPURequestAdapterOptions options = {});
};
</script>

{{GPU}} has the following methods:

<dl dfn-type=method dfn-for=GPU>
    : <dfn>requestAdapter(options)</dfn>
    ::
        Requests an [=adapter=] from the user agent.
        The user agent chooses whether to return an adapter, and, if so,
        chooses according to the provided options.

        <div algorithm=GPU.requestAdapter>
            **Called on:** {{GPU}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPU/requestAdapter(options)">
                |options|: Criteria used to select the adapter.
            </pre>

            **Returns:** {{Promise}}&lt;{{GPUAdapter}}?&gt;

            1. Let |promise| be [=a new promise=].
            1. Issue the following steps on the [=Device timeline=] of |this|:
                <div class=device-timeline>
                    1. If the user agent chooses to return an adapter, it should:
                        1. Create an [=adapter=] |adapter| with {{adapter/[[current]]}} set to
                            `true`, chosen according to the rules in [[#adapter-selection]] and the
                            criteria in |options|.

                        1. If |adapter| meets the criteria of a [=fallback adapter=] set
                            |adapter|.{{adapter/[[fallback]]}} to `true`.

                        1. [=Resolve=] |promise| with a new {{GPUAdapter}} encapsulating |adapter|.

                    1. Otherwise, |promise| [=resolves=] with `null`.
                </div>
            1. Return |promise|.

            <!-- If we add ways to make invalid adapter requests (aside from those
                 that violate IDL rules), specify that they reject the promise. -->
        </div>
</dl>

{{GPU}} has the following internal slots:

<dl dfn-type=attribute dfn-for=GPU>
    : <dfn>\[[previously_returned_adapters]]</dfn>, of type [=ordered set=]&lt;[=adapter=]&gt;
    ::
        The set of [=adapters=] that have been returned via {{GPU/requestAdapter()}}.
        It is used, then cleared, in [=mark adapters stale=].
</dl>

Upon any change in the system's state that could affect the result of any {{GPU/requestAdapter()}}
call, the user agent *should* [=mark adapters stale=]. For example:

- A physical adapter is added/removed (via plug, driver update, TDR, etc.)
- The system's power configuration has changed (laptop unplugged, power settings changed, etc.)

Additionally, [=mark adapters stale=] may by scheduled at any time.
User agents may choose to do this often even when there has been no system state change (e.g.
several seconds after the last call to {{GPUAdapter/requestDevice()}}.
This has no effect on well-formed applications, obfuscates real system state changes, and makes
developers more aware that calling {{GPU/requestAdapter()}} again is always necessary before
calling {{GPUAdapter/requestDevice()}}.

<div>
    To <dfn dfn>mark adapters stale</dfn>:

    1. For each |adapter| in `navigator.gpu.`{{GPU/[[previously_returned_adapters]]}}:
        1. Set |adapter|.{{GPUAdapter/[[adapter]]}}.{{adapter/[[current]]}} to `false`.
    1. [=list/Empty=] `navigator.gpu.`{{GPU/[[previously_returned_adapters]]}}.

    Issue: Update here if an `adaptersadded`/`adapterschanged` event is introduced.
</div>

<div class="example">
    Request a {{GPUAdapter}}:
    <pre highlight="js">
        const adapter = await navigator.gpu.requestAdapter(/* ... */);
        const features = adapter.features;
        // ...
    </pre>
</div>

### Adapter Selection ### {#adapter-selection}

<dfn dictionary>GPURequestAdapterOptions</dfn>
provides hints to the user agent indicating what
configuration is suitable for the application.

<script type=idl>
dictionary GPURequestAdapterOptions {
    GPUPowerPreference powerPreference;
    boolean forceFallbackAdapter = false;
};
</script>

<script type=idl>
enum GPUPowerPreference {
    "low-power",
    "high-performance"
};
</script>

{{GPURequestAdapterOptions}} has the following members:

<dl dfn-type=dict-member dfn-for=GPURequestAdapterOptions>
    : <dfn>powerPreference</dfn>
    ::
        Optionally provides a hint indicating what class of [=adapter=] should be selected from
        the system's available adapters.

        The value of this hint may influence which adapter is chosen, but it must not
        influence whether an adapter is returned or not.

        Note:
        The primary utility of this hint is to influence which GPU is used in a multi-GPU system.
        For instance, some laptops have a low-power integrated GPU and a high-performance
        discrete GPU.

        Note:
        Depending on the exact hardware configuration, such as battery status and attached displays
        or removable GPUs, the user agent may select different [=adapters=] given the same power
        preference.
        Typically, given the same hardware configuration and state and
        `powerPreference`, the user agent is likely to select the same adapter.

        It must be one of the following values:

        <dl dfn-type=enum-value dfn-for=GPUPowerPreference>
            : `undefined` (or not present)
            ::
                Provides no hint to the user agent.

            : <dfn>"low-power"</dfn>
            ::
                Indicates a request to prioritize power savings over performance.

                Note:
                Generally, content should use this if it is unlikely to be constrained by drawing
                performance; for example, if it renders only one frame per second, draws only relatively
                simple geometry with simple shaders, or uses a small HTML canvas element.
                Developers are encouraged to use this value if their content allows, since it may
                significantly improve battery life on portable devices.

            : <dfn>"high-performance"</dfn>
            ::
                Indicates a request to prioritize performance over power consumption.

                Note:
                By choosing this value, developers should be aware that, for [=device=] created on the
                resulting adapter, user agents are more likely to force device loss, in order to save
                power by switching to a lower-power adapter.
                Developers are encouraged to only specify this value if they believe it is absolutely
                necessary, since it may significantly decrease battery life on portable devices.
        </dl>

    : <dfn>forceFallbackAdapter</dfn>
    ::
        When set to `true` indicates that only a [=fallback adapter=] may be returned. If the user
        agent does not support a [=fallback adapter=], will cause {{GPU/requestAdapter()}} to
        resolve to `null`.

        Note:
        {{GPU/requestAdapter()}} may still return a [=fallback adapter=] if
        {{GPURequestAdapterOptions/forceFallbackAdapter}} is set to `false` and either no
        other appropriate [=adapter=] is available or the user agent chooses to return a
        [=fallback adapter=]. Developers that wish to prevent their applications from running on
        [=fallback adapters=] should check the {{GPUAdapter}}.{{GPUAdapter/isFallbackAdapter}}
        attribute prior to requesting a {{GPUDevice}}.
</dl>

## <dfn interface>GPUAdapter</dfn> ## {#gpu-adapter}

A {{GPUAdapter}} encapsulates an [=adapter=],
and describes its capabilities ([=features=] and [=limits=]).

To get a {{GPUAdapter}}, use {{GPU/requestAdapter()}}.

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUAdapter {
    readonly attribute DOMString name;
    [SameObject] readonly attribute GPUSupportedFeatures features;
    [SameObject] readonly attribute GPUSupportedLimits limits;
    readonly attribute boolean isFallbackAdapter;

    Promise<GPUDevice> requestDevice(optional GPUDeviceDescriptor descriptor = {});
};
</script>

{{GPUAdapter}} has the following attributes:

<dl dfn-type=attribute dfn-for=GPUAdapter>
    : <dfn>name</dfn>
    ::
        A human-readable name identifying the adapter.
        The contents are implementation-defined.

    : <dfn>features</dfn>
    ::
        The set of values in `this`.{{GPUAdapter/[[adapter]]}}.{{adapter/[[features]]}}.

    : <dfn>limits</dfn>
    ::
        The limits in `this`.{{GPUAdapter/[[adapter]]}}.{{adapter/[[limits]]}}.

    : <dfn>isFallbackAdapter</dfn>
    ::
        Returns the value of {{GPUAdapter/[[adapter]]}}.{{adapter/[[fallback]]}}.
</dl>

{{GPUAdapter}} has the following internal slots:

<dl dfn-type=attribute dfn-for=GPUAdapter>
    : <dfn>\[[adapter]]</dfn>, of type [=adapter=], readonly
    ::
        The [=adapter=] to which this {{GPUAdapter}} refers.
</dl>

{{GPUAdapter}} has the following methods:

<dl dfn-type=method dfn-for=GPUAdapter>
    : <dfn>requestDevice(descriptor)</dfn>
    ::
        Requests a [=device=] from the [=adapter=].

        <div algorithm=GPUAdapter.requestDevice>
            **Called on:** {{GPUAdapter}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUAdapter/requestDevice(descriptor)">
                |descriptor|: Description of the {{GPUDevice}} to request.
            </pre>

            **Returns:** {{Promise}}&lt;{{GPUDevice}}?&gt;

            1. Let |promise| be [=a new promise=].
            1. Let |adapter| be |this|.{{GPUAdapter/[[adapter]]}}.
            1. Issue the following steps to the [=Device timeline=]:
                <div class=device-timeline>
                    1. If any of the following requirements are unmet,
                        [=reject=] |promise| with a {{TypeError}} and stop.

                        <div class=validusage>
                            - The set of values in |descriptor|.{{GPUDeviceDescriptor/requiredFeatures}}
                                must be a subset of those in |adapter|.{{adapter/[[features]]}}.
                        </div>

                    1. If any of the following requirements are unmet,
                        [=reject=] |promise| with an {{OperationError}} and stop.

                        <div class=validusage>
                            - Each key in |descriptor|.{{GPUDeviceDescriptor/requiredLimits}}
                                must be the name of a member of [=supported limits=].

                            - For each type of limit in [=supported limits=], the value of that
                                limit in |descriptor|.{{GPUDeviceDescriptor/requiredLimits}}
                                must be no [=limit/better=] than the value of that limit in
                                |adapter|.{{adapter/[[limits]]}}.
                        </div>

                    1. If |adapter|.{{adapter/[[current]]}} is `false`,
                        or the user agent otherwise cannot fulfill the request:

                        1. Let |device| be a new [=device=].
                        1. [=Lose the device=](|device|, `undefined`).

                            Note:
                            This makes |adapter|.{{adapter/[[current]]}} `false`, if it wasn't already.

                            Note:
                            User agents should consider issuing developer-visible warnings in
                            most or all cases when this occurs. Applications should perform
                            reinitialization logic starting with {{GPU/requestAdapter()}}.

                        1. [=Resolve=] |promise| with a new {{GPUDevice}} encapsulating |device|,
                            and stop.

                    1. [=Resolve=] |promise| with a new {{GPUDevice}} object encapsulating
                        [=a new device=] with the capabilities described by |descriptor|.
                </div>
            1. Return |promise|.

        </div>
</dl>

### <dfn dictionary>GPUDeviceDescriptor</dfn> ### {#gpudevicedescriptor}

{{GPUDeviceDescriptor}} describes a device request.

<script type=idl>
dictionary GPUDeviceDescriptor : GPUObjectDescriptorBase {
    sequence<GPUFeatureName> requiredFeatures = [];
    record<DOMString, GPUSize64> requiredLimits = {};
};
</script>

{{GPUDeviceDescriptor}} has the following members:

<dl dfn-type=dict-member dfn-for=GPUDeviceDescriptor>
    : <dfn>requiredFeatures</dfn>
    ::
        Specifies the [=features=] that are required by the device request.
        The request will fail if the adapter cannot provide these features.

        Exactly the specified set of features, and no more or less, will be allowed in validation
        of API calls on the resulting device.

    : <dfn>requiredLimits</dfn>
    ::
        Specifies the [=limits=] that are required by the device request.
        The request will fail if the adapter cannot provide these limits.

        Each key must be the name of a member of [=supported limits=].
        Exactly the specified limits, and no [=limit/better=] or worse,
        will be allowed in validation of API calls on the resulting device.

        <!-- If we ever need limit types other than GPUSize32/GPUSize64, we can change the value
        type to `double` or `any` in the future and write out the type conversion explicitly (by
        reference to WebIDL spec). Or change the entire type to `any` and add back a `dictionary
        GPULimits` and define the conversion of the whole object by reference to WebIDL. -->
</dl>

#### <dfn enum>GPUFeatureName</dfn> #### {#gpufeaturename}

Each {{GPUFeatureName}} identifies a set of functionality which, if available,
allows additional usages of WebGPU that would have otherwise been invalid.

<script type=idl>
enum GPUFeatureName {
    "depth-clamping",
    "depth24unorm-stencil8",
    "depth32float-stencil8",
    "pipeline-statistics-query",
    "texture-compression-bc",
    "texture-compression-etc2",
    "texture-compression-astc",
    "timestamp-query",
};
</script>

## <dfn interface>GPUDevice</dfn> ## {#gpu-device}

A {{GPUDevice}} encapsulates a [=device=] and exposes
the functionality of that device.

{{GPUDevice}} is the top-level interface through which [=WebGPU interfaces=] are created.

To get a {{GPUDevice}}, use {{GPUAdapter/requestDevice()}}.

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUDevice : EventTarget {
    [SameObject] readonly attribute GPUSupportedFeatures features;
    [SameObject] readonly attribute GPUSupportedLimits limits;

    [SameObject] readonly attribute GPUQueue queue;

    undefined destroy();

    GPUBuffer createBuffer(GPUBufferDescriptor descriptor);
    GPUTexture createTexture(GPUTextureDescriptor descriptor);
    GPUSampler createSampler(optional GPUSamplerDescriptor descriptor = {});
    GPUExternalTexture importExternalTexture(GPUExternalTextureDescriptor descriptor);

    GPUBindGroupLayout createBindGroupLayout(GPUBindGroupLayoutDescriptor descriptor);
    GPUPipelineLayout createPipelineLayout(GPUPipelineLayoutDescriptor descriptor);
    GPUBindGroup createBindGroup(GPUBindGroupDescriptor descriptor);

    GPUShaderModule createShaderModule(GPUShaderModuleDescriptor descriptor);
    GPUComputePipeline createComputePipeline(GPUComputePipelineDescriptor descriptor);
    GPURenderPipeline createRenderPipeline(GPURenderPipelineDescriptor descriptor);
    Promise<GPUComputePipeline> createComputePipelineAsync(GPUComputePipelineDescriptor descriptor);
    Promise<GPURenderPipeline> createRenderPipelineAsync(GPURenderPipelineDescriptor descriptor);

    GPUCommandEncoder createCommandEncoder(optional GPUCommandEncoderDescriptor descriptor = {});
    GPURenderBundleEncoder createRenderBundleEncoder(GPURenderBundleEncoderDescriptor descriptor);

    GPUQuerySet createQuerySet(GPUQuerySetDescriptor descriptor);
};
GPUDevice includes GPUObjectBase;
</script>

{{GPUDevice}} has the following attributes:

<dl dfn-type=attribute dfn-for=GPUDevice>
    : <dfn>features</dfn>
    ::
        A set containing the {{GPUFeatureName}} values of the features
        supported by the device (i.e. the ones with which it was created).

    : <dfn>limits</dfn>
    ::
        Exposes the limits supported by the device
        (which are exactly the ones with which it was created).

    : <dfn>queue</dfn>
    ::
        The primary {{GPUQueue}} for this device.
</dl>

The {{GPUObjectBase/[[device]]}} for a {{GPUDevice}} is the [=device=] that the {{GPUDevice}} refers
to.

{{GPUDevice}} has the methods listed in its WebIDL definition above.
Those not defined here are defined elsewhere in this document.

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>destroy()</dfn>
    ::
        Destroys the [=device=], preventing further operations on it.
        Outstanding asynchronous operations will fail.

        <div algorithm=GPUDevice.destroy()>
            **Called on:** {{GPUDevice}} |this|.

            1. [=Lose the device=](|this|.{{GPUObjectBase/[[device]]}},
                {{GPUDeviceLostReason/"destroyed"}}).
        </div>

        Note:
        Since no further operations can occur on this device, implementations can free resource
        allocations and abort outstanding asynchronous operations immediately.
</dl>

{{GPUDevice}} objects are [=serializable objects=].

Issue(gpuweb/gpuweb#354): Finish defining multithreading API and add `[Serializable]` back to the interface.

<div>
    <dfn abstract-op>The steps to serialize a GPUDevice object</dfn>,
    given |value|, |serialized|, and |forStorage|, are:
     1. Set |serialized|.agentCluster to be the [=surrounding agent=]'s [=agent cluster=].
     1. If |serialized|.agentCluster's [=cross-origin isolated capability=] is false, throw a "{{DataCloneError}}".
     1. If |forStorage| is `true`, throw a "{{DataCloneError}}".
     1. Set |serialized|.device to the value of |value|.{{GPUObjectBase/[[device]]}}.
</div>

<div>
    <dfn abstract-op>The steps to deserialize a GPUDevice object</dfn>,
    given |serialized| and |value|, are:
     1. If |serialized|.agentCluster is not the [=surrounding agent=]'s [=agent cluster=], throw a "{{DataCloneError}}".
     1. Set |value|.{{GPUObjectBase/[[device]]}} to |serialized|.device.
</div>

Issue: `GPUDevice` doesn't really need the cross-origin policy restriction.
It should be usable from multiple agents regardless. Once we describe the serialization
of buffers, textures, and queues - the COOP+COEP logic should be moved in there.

# 缓冲区 # {#buffers}

## <dfn interface>GPUBuffer</dfn> ## {#buffer-interface}

问题：定义<dfn dfn>buffer</dfn> (内部对象)

{{GPUBuffer}}表示可用于GPU操作的内存块。数据以线性布局存储，这意味着分配的每个字节都可以由其从{{GPUBuffer}}开始的偏移量寻址，受取决于操作的对齐约束限制。一些{{GPUBuffer|GPUBuffers}}可以被映射，这使得内存块可以通过一个{{ArrayBuffer}}访问并调用它的映射。

{{GPUBuffer|GPUBuffers}}是通过{{GPUDevice/createBuffer(descriptor)|GPUDevice.createBuffer(descriptor)}}创建的，
返回一个处于 [=buffer state/mapped=] 或 [=buffer state/unmapped=]状态的新缓冲区。

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUBuffer {
    Promise<undefined> mapAsync(GPUMapModeFlags mode, optional GPUSize64 offset = 0, optional GPUSize64 size);
    ArrayBuffer getMappedRange(optional GPUSize64 offset = 0, optional GPUSize64 size);
    undefined unmap();

    undefined destroy();
};
GPUBuffer includes GPUObjectBase;
</script>

{{GPUBuffer}}有如下内部插槽:

<dl dfn-type=attribute dfn-for="GPUBuffer">
    : <dfn>\[[size]]</dfn> of type {{GPUSize64}}.
    ::
        {{GPUBuffer}}分配的长度（以字节为单位）。

    : <dfn>\[[usage]]</dfn> of type {{GPUBufferUsageFlags}}.
    ::
        此{{GPUBuffer}}被允许的使用。

    : <dfn>\[[state]]</dfn> of type [=buffer state=].
    ::
        {{GPUBuffer}}的当前状态。

    : <dfn>\[[mapping]]</dfn> of type {{ArrayBuffer}} or {{Promise}} or `null`.
    ::
        此{{GPUBuffer}}的映射。{{ArrayBuffer}}不能直接访问，而是通过视图访问它，称为映射范围，存储在{{GPUBuffer/[[mapped_ranges]]}}中。

        在 `DataBlock`方面指定{{GPUBuffer/[[mapping]]}}类似于 `AllocateArrayBuffer`？

    : <dfn>\[[mapping_range]]</dfn> of type [=list=]&lt;{{unsigned long long}}&gt; or `null`.
    ::
        此被映射的{{GPUBuffer}}的范围。

    : <dfn>\[[mapped_ranges]]</dfn> of type [=list=]&lt;{{ArrayBuffer}}&gt; or `null`.
    ::
        {{ArrayBuffer}}s通过{{GPUBuffer/getMappedRange}}返回给应用程序。它们被追踪以便在{{GPUBuffer/unmap}}被调用时可以将其分离。

    : <dfn>\[[map_mode]]</dfn> of type {{GPUMapModeFlags}}.
    ::
        最后一次调用{{GPUBuffer/mapAsync()}}的{{GPUMapModeFlags}}（如果有）。
</dl>

问题：{{GPUBuffer/[[usage]]}}与{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/usage}}的命名不同。我们应该让它保持一致。

每个{{GPUBuffer}}在[=Content timeline=]上都有一个当前的<dfn dfn>buffer state</dfn>，它是以下几项之一：

 - "<dfn dfn for="buffer state">mapped</dfn>" 此时{{GPUBuffer}}中的内容可以被用作CPU操作。
 - "<dfn dfn for="buffer state">mapped at creation</dfn>" 此时{{GPUBuffer}}刚刚被创建并且其中的内容可以被CPU操作。
 - "<dfn dfn for="buffer state">mapping pending</dfn>" 此时{{GPUBuffer}}正在被处理使得它的内容可以被CPU操作。
 - "<dfn dfn for="buffer state">unmapped</dfn>" 此时{{GPUBuffer}}允许GPU操作。
 - "<dfn dfn for="buffer state">destroyed</dfn>" where the {{GPUBuffer}} is
    除了{{GPUBuffer/destroy}}之外不允许任何操作。

注意：一旦创建了{{GPUBuffer}}，{{GPUBuffer/[[size]]}}和{{GPUBuffer/[[usage]]}}是不可变的。

<div class=note>
    注意：{{GPUBuffer}}有一个具有以下状态的状态机。（({{GPUBuffer/[[mapping]]}}, {{GPUBuffer/[[mapping_range]]}},
    和{{GPUBuffer/[[mapped_ranges]]}}在未指定时为空。）

     - [=buffer state/unmapped=]和[=buffer state/destroyed=].
     - 带有类型为{{GPUBuffer/[[mapping]]}}的{{ArrayBuffer}}的[=buffer state/mapped=]或[=buffer state/mapped at creation=]，一个{{GPUBuffer/[[mapping_range]]}}中两个数字连成的串和一串{{GPUBuffer/[[mapped_ranges]]}}中的{{ArrayBuffer}}。
     - [=buffer state/mapping pending=]带有一个类型为{{GPUBuffer/[[mapping]]}}的{{Promise}}。
</div>

{{GPUBuffer}}是可序列化（{{Serializable}}）的。 它是对内部缓冲区对象的引用，而可序列化（{{Serializable}}）意味着可以在领域（线程/工人）之间复制该引用，从而允许多个领域同时访问它。由于{{GPUBuffer}}具有内部状态（已映射、已销毁），因此该状态是内部同步的 - 这些状态更改以原子方式跨领域发生。

问题(gpuweb/gpuweb#354)：完成定义多线程API并将 `[Serializable]`添加回接口。

## 缓冲区创建 ## {#buffer-creation}

### {{GPUBufferDescriptor}} ### {#GPUBufferDescriptor}

它指定创建{{GPUBuffer}}用到的选项。

<script type=idl>
dictionary GPUBufferDescriptor : GPUObjectDescriptorBase {
    required GPUSize64 size;
    required GPUBufferUsageFlags usage;
    boolean mappedAtCreation = false;
};
</script>

<div>
    <dfn abstract-op>校验GPUBufferDescriptor</dfn>(device, descriptor)
        1. 如果设备缺失，返回 `false`.
        2. 如果|descriptor|的{{GPUBufferDescriptor/usage}}任何一个比特位没有表示设备的[[allowed buffer usages]]，返回 `false`。
        3. 如果|descriptor|的{{GPUBufferDescriptor/usage}}的{{GPUBufferUsage/MAP_READ}}和{{GPUBufferUsage/MAP_WRITE}}比特位都设置了值，返回 `false`。
        4. 返回 `true`.
</div>

### 缓冲区使用 ### {#buffer-usage}

<script type=idl>
typedef [EnforceRange] unsigned long GPUBufferUsageFlags;
[Exposed=(Window, DedicatedWorker)]
namespace GPUBufferUsage {
    const GPUFlagsConstant MAP_READ      = 0x0001;
    const GPUFlagsConstant MAP_WRITE     = 0x0002;
    const GPUFlagsConstant COPY_SRC      = 0x0004;
    const GPUFlagsConstant COPY_DST      = 0x0008;
    const GPUFlagsConstant INDEX         = 0x0010;
    const GPUFlagsConstant VERTEX        = 0x0020;
    const GPUFlagsConstant UNIFORM       = 0x0040;
    const GPUFlagsConstant STORAGE       = 0x0080;
    const GPUFlagsConstant INDIRECT      = 0x0100;
    const GPUFlagsConstant QUERY_RESOLVE = 0x0200;
};
</script>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createBuffer(descriptor)</dfn>
    ::
        创建一个{{GPUBuffer}}。

        <div algorithm=GPUDevice.createBuffer>
            **Called on:** {{GPUDevice}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/createBuffer(descriptor)">
                |descriptor|: 要创建的{{GPUBuffer}}的描述。
            </pre>

            **Returns:** {{GPUBuffer}}

            1. 如果以下任何条件没有满足，返回一个错误缓冲并且停止。
                <div class=validusage>
                    - |this|是一个有效的（[=valid=]）{{GPUDevice}}。
                    - |descriptor|.{{GPUBufferDescriptor/usage}}是|this|.[[allowed buffer usages]]的一个子集。
                    - 如果|descriptor|.{{GPUBufferDescriptor/usage}}包含{{GPUBufferUsage/MAP_READ}}:
                        - |descriptor|.{{GPUBufferDescriptor/usage}}除了{{GPUBufferUsage/COPY_DST}}不包含其他标识。
                    - 如果|descriptor|.{{GPUBufferDescriptor/usage}}包含{{GPUBufferUsage/MAP_WRITE}}:
                        - |descriptor|.{{GPUBufferDescriptor/usage}}除了{{GPUBufferUsage/COPY_SRC}}不包含其他标识。
                    - 如果|descriptor|.{{GPUBufferDescriptor/mappedAtCreation}}为 `true`:
                        - |descriptor|.{{GPUBufferDescriptor/size}}是4的倍数。

                    Issue(gpuweb/gpuweb#605): 解释：结果错误缓冲仍然可以在创建时被映射。

                    Issue(gpuweb/gpuweb#605): 解释什么是{{GPUDevice}}的 `[[allowed buffer usages]]`.
                </div>

            2. 使|b|为一个新的{{GPUBuffer}}对象.
            3. 将|b|.{{GPUBuffer/[[size]]}}设置为|descriptor|.{{GPUBufferDescriptor/size}}.
            4. 将|b|.{{GPUBuffer/[[usage]]}}设置为|descriptor|.{{GPUBufferDescriptor/usage}}.
            5. 如果|descriptor|.{{GPUBufferDescriptor/mappedAtCreation}}值为 `true`:

                1. 将|b|.{{GPUBuffer/[[mapping]]}}设置为一个新的大小为|b|.{{GPUBuffer/[[size]]}}的{{ArrayBuffer}}。
                2. 将|b|.{{GPUBuffer/[[mapping_range]]}}设置为 `[0, descriptor.size]`.
                3. 将|b|.{{GPUBuffer/[[mapped_ranges]]}}设置为 `[]`.
                4. 将|b|.{{GPUBuffer/[[state]]}}设置为[=buffer state/mapped at creation=].

                否则:

                1. 将|b|.{{GPUBuffer/[[mapping]]}}设置为 `null`。
                2. 将|b|.{{GPUBuffer/[[mapping_range]]}}设置为 `null`。
                3. 将|b|.{{GPUBuffer/[[mapped_ranges]]}}设置为 `null`。
                4. 将|b|.{{GPUBuffer/[[state]]}}设置为[=buffer state/unmapped=]。

            6. 将|b|分配的每个字节设置为零。
            7. 返回|b|.

            注意：在{{GPUBufferDescriptor/usage}}中没有{{GPUBufferUsage/MAP_READ}}或{{GPUBufferUsage/MAP_WRITE}}的情况下，将{{GPUBufferDescriptor/mappedAtCreation}}设置为 `true`是有效的。这可用于设置缓冲区的初始数据。

        </div>

</dl>

## 缓冲区销毁 ## {#buffer-destruction}

不再需要{{GPUBuffer}}的应用程序可以通过调用{{GPUBuffer/destroy()}}选择在垃圾收集之前失去对它的访问权限。

注意：一旦所有先前提交的使用它的操作完成，这允许用户代理回收与{{GPUBuffer}}关联的GPU内存。

<dl dfn-type=method dfn-for=GPUBuffer>
    : <dfn>destroy()</dfn>
    ::
        销毁{{GPUBuffer}}.

        <div algorithm=GPUBuffer.destroy>
            **Called on:** {{GPUBuffer}} |this|.

            **Returns:** {{undefined}}

            1. 如果|this|.{{GPUBuffer/[[state]]}}为[=buffer state/mapped=]或[=buffer state/mapped at creation=]:
                1. 执行unmap|this|的步骤。

            2. 设置|this|.{{GPUBuffer/[[state]]}}为[=buffer state/destroyed=].

            问题: 一旦我们有了错误单子的描述，就处理错误缓冲区。
        </div>
</dl>

## 缓冲区映射 ## {#buffer-mapping}


应用程序可以请求映射{{GPUBuffer}}，以便他们可以通过代表{{GPUBuffer}}部分分配的ArrayBuffers访问其内容。使用{{GPUBuffer/mapAsync()}}异步请求映射{{GPUBuffer}}，以便用户代理可以确保GPU在应用程序可以访问其内容之前完成使用{{GPUBuffer}}。一旦{{GPUBuffer}} 被映射，应用程序就可以使用{{GPUBuffer/getMappedRange}}同步请求访问其内容范围。已映射的{{GPUBuffer}}不能被GPU使用，并且必须在使用它的work提交到[=Queue timeline=]之前使用{{GPUBuffer/unmap}}取消映射。

问题(gpuweb/gpuweb#605): 添加客户端校验，已映射缓冲区只能在其映射的worker上取消映射和销毁。同样{{GPUBuffer/getMappedRange}}只能在该worker上被调用。

<script type=idl>
typedef [EnforceRange] unsigned long GPUMapModeFlags;
[Exposed=(Window, DedicatedWorker)]
namespace GPUMapMode {
    const GPUFlagsConstant READ  = 0x0001;
    const GPUFlagsConstant WRITE = 0x0002;
};
</script>

<dl dfn-type=method dfn-for=GPUBuffer>
    : <dfn>mapAsync(mode, offset, size)</dfn>
    ::
        映射{{GPUBuffer}}的给定范围，并在{{GPUBuffer}}的内容准备好可以使用{{GPUBuffer/getMappedRange()}}访问时，决议返回的Promise。

        <div algorithm=GPUBuffer.mapAsync>
            **Called on:** {{GPUBuffer}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUBuffer/mapAsync(mode, offset, size)">
                |mode|: 缓冲区是否应当被映射为读取或写入。
                |offset|: 以字节为单位的缓冲区到要映射的范围起始位置的偏移量。
                |size|: 以字节为单位的要映射的范围大小。
            </pre>

            **Returns:** {{Promise}}&lt;{{undefined}}&gt;

            问题(gpuweb/gpuweb#605): 一旦我们有了错误单子，即刻处理错误缓冲区。

            1. 如果|size|字段丢失:
                1. 使|rangeSize|为max(0, |this|.{{GPUBuffer/[[size]]}} - |offset|)。

                否则, 使|rangeSize|为|size|。

            2. 如果以下任何条件未满足:
                <div class=validusage>
                    - |this|为有效的（[=valid=]）{{GPUBuffer}}。
                    - |offset|是8的倍数。
                    - |rangeSize|是4的倍数。
                    - |offset| + |rangeSize|等于或小于|this|.{{GPUBuffer/[[size]]}}。
                    - |this|.{{GPUBuffer/[[state]]}}为[=buffer state/unmapped=]状态。
                    - |mode|明确包含{{GPUMapMode/READ}}或{{GPUMapMode/WRITE}}之一。
                    - 如果|mode|包含{{GPUMapMode/READ}}，则|this|.{{GPUBuffer/[[usage]]}}必须包含{{GPUBufferUsage/MAP_READ}}。
                    - 如果|mode|包含{GPUMapMode/WRITE}}，则|this|.{{GPUBuffer/[[usage]]}}必须包含{{GPUBufferUsage/MAP_WRITE}}.

                    问题: 我们是否需要对仅包含有效标识的|mode|做校验？
                </div>

                接下来:
                1. 记录当前范围内的校验错误。
                2. 返回[=a promise rejected with=]一个[=Device timeline=]上的{{OperationError}}。

            3. 使|p|为一个新的{{Promise}}。
            4. 设置|this|.{{GPUBuffer/[[mapping]]}}为|p|。
            5. 设置|this|.{{GPUBuffer/[[state]]}}为[=buffer state/mapping pending=]。
            6. 设置|this|.{{GPUBuffer/[[map_mode]]}}为|mode|。
            7. 在默认队列上的[=Queue timeline=]对操作进行入队操作，该行为将执行以下操作:
                <div class=queue-timeline>
                    1. 如果|this|.{{GPUBuffer/[[state]]}}为[=buffer state/mapping pending=]状态:

                        1. 使|m|为一个新的大小为|rangeSize|的{{ArrayBuffer}}。
                        2. 将|m|的内容设置为|this|分配的内容，从偏移|offset|开始，为|rangeSize|字节。
                        3. 将|this|.{{GPUBuffer/[[mapping]]}}设置为|m|.
                        4. 将|this|.{{GPUBuffer/[[state]]}}设置为[=buffer state/mapped=].
                        5. 将|this|.{{GPUBuffer/[[mapping_range]]}}设置为<code>[|offset|, |offset| + |rangeSize|]</code>.
                        6. 将|this|.{{GPUBuffer/[[mapped_ranges]]}}设置为 `[]`.

                    2. Resolve |p|.
                </div>
            8. 返回|p|。
        </div>

    : <dfn>getMappedRange(offset, size)</dfn>
    ::
        返回一个带有给定范围内{{GPUBuffer}}内容的{{ArrayBuffer}}。

        <div algorithm=GPUBuffer.getMappedRange>
            **Called on:** {{GPUBuffer}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUBuffer/getMappedRange(offset, size)">
                |offset|: 以字节为单位的缓冲区偏移量，返回缓冲区内容的位置。
                |size|: 以字节为单位的，要返回的{{ArrayBuffer}}大小。
            </pre>

            **Returns:** {{ArrayBuffer}}

            1. 如果|size|缺失:
                1. 使|rangeSize|为max(0, |this|.{{GPUBuffer/[[size]]}} - |offset|)。

                否则, 使|rangeSize|为|size|。

            2. 如果任何以下条件未满足, 抛出一个{{OperationError}}异常并停止。
                <div class=validusage>
                    - |this|.{{GPUBuffer/[[state]]}}为[=buffer state/mapped=] or [=buffer state/mapped at creation=]。
                    - |offset|是8的倍数。
                    - |rangeSize|是4的倍数。
                    - |offset|等于或大于|this|.{{GPUBuffer/[[mapping_range]]}}[0]。
                    - |offset| + |rangeSize|小于或等于|this|.{{GPUBuffer/[[mapping_range]]}}[1].
                    - [|offset|, |offset| + |rangeSize|)不与另一个|this|.{{GPUBuffer/[[mapped_ranges]]}}范围重叠。

                    注意：获取[=buffer state/mapped at creation=]的{{GPUBuffer}}的映射范围总是有效的，即使它是无效的，因为[=Content timeline=]可能不知道它是无效的。

                    问题：考虑将mapAsync偏移量对齐到8以匹配此值。
                </div>

            3. 使|m|为一个新的大小为|rangeSize|的{{ArrayBuffer}}，指向|this|.{{GPUBuffer/[[mapping]]}}的内容偏移量|offset| - |this|.{{GPUBuffer/[[mapping_range]]}}[0]。

            4. 添加([=list/Append=])|m|至|this|.{{GPUBuffer/[[mapped_ranges]]}}。

            5. 返回|m|。
        </div>

    : <dfn>unmap()</dfn>
    ::
        对已映射的{{GPUBuffer}}范围取消映射，并且使得它的内容可以重新被GPU使用。

        <div algorithm=GPUBuffer.unmap>
            **Called on:** {{GPUBuffer}} |this|.

            **Returns:** {{undefined}}

            1. 如果以下任何需求没有满足，产生一个校验错误并停止。
                <div class=validusage>
                    - |this|.{{GPUBuffer/[[state]]}}必须为[=buffer state/mapped at creation=]，
                        [=buffer state/mapping pending=]，或[=buffer state/mapped=].

                    Note: 取消一个状态为[=buffer state/mapped at creation=]的{{GPUBuffer}}[=invalid=]映射是有效的，因为[=Content timeline=]可能不知道它是个错误的{{GPUBuffer}}。
                </div>

            2. 如果|this|.{{GPUBuffer/[[state]]}}为[=buffer state/mapping pending=]:

                1. 拒绝（[=Reject=]）{{GPUBuffer/[[mapping]]}}，以一个{{AbortError}}。
                1. 设置|this|.{{GPUBuffer/[[mapping]]}}为 `null`。

            3. 如果|this|.{{GPUBuffer/[[state]]}}为[=buffer state/mapped=]或[=buffer state/mapped at creation=]:

                1. 如果以下两条件之一成立:

                    - |this|.{{GPUBuffer/[[state]]}}为[=buffer state/mapped at creation=]
                    - |this|.{{GPUBuffer/[[state]]}}为[=buffer state/mapped=]并且|this|.{{GPUBuffer/[[map_mode]]}}包含{{GPUMapMode/WRITE}}

                    则接下来:
                    1. 在默认队列的[=Queue timeline=]上将操作入队，该操作将|this|.{{GPUBuffer/[[mapping_range]]}}的|this|分配更新为 |this|.{{GPUBuffer/[[mapping]]}}的内容。

                2. 将|this|.{{GPUBuffer/[[mapped_ranges]]}}中的每个{{ArrayBuffer}}与其内容分离。
                3. 将|this|.{{GPUBuffer/[[mapping]]}}设置为 `null`.
                4. 将|this|.{{GPUBuffer/[[mapping_range]]}}设置为 `null`.
                5. 将|this|.{{GPUBuffer/[[mapped_ranges]]}}设置为 `null`.

            4. 将|this|.{{GPUBuffer/[[state]]}}设置为[=buffer state/unmapped=].

            注意：当{{GPUBufferUsage/MAP_READ}}缓冲区（目前未在创建时映射）被取消映射时，应用程序对映射范围{{ArrayBuffer}}所做的任何本地修改都将被丢弃，并且不会影响后续映射的内容。
        </div>
</dl>

# Textures and Texture Views # {#textures}

Issue: define <dfn dfn>texture</dfn> (internal object)

Issue: define <dfn dfn>mipmap level</dfn>, <dfn dfn>array layer</dfn>, <dfn dfn>aspect</dfn>, <dfn dfn>slice</dfn> (concepts)

## <dfn interface>GPUTexture</dfn> ## {#texture-interface}

{{GPUTexture|GPUTextures}} are created via
{{GPUDevice/createTexture(descriptor)|GPUDevice.createTexture(descriptor)}}
that returns a new texture.

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUTexture {
    GPUTextureView createView(optional GPUTextureViewDescriptor descriptor = {});

    undefined destroy();
};
GPUTexture includes GPUObjectBase;
</script>

{{GPUTexture}} has the following internal slots:

<dl dfn-type=attribute dfn-for="GPUTexture">
    : <dfn>\[[descriptor]]</dfn>, of type {{GPUTextureDescriptor}}
    ::
        The {{GPUTextureDescriptor}} describing this texture.

        All optional fields of {{GPUTextureDescriptor}} are defined.

    : <dfn>\[[destroyed]]</dfn>, of type `boolean`, initially false
    ::
        If the texture is destroyed, it can no longer be used in any operation,
        and its underlying memory can be freed.
</dl>

<div>
    <dfn abstract-op>compute render extent</dfn>(baseSize, mipLevel)

    **Arguments:**
        - {{GPUExtent3D}} |baseSize|
        - {{GPUSize32}} |mipLevel|

    **Returns:** {{GPUExtent3DDict}}

    1. Let |extent| be a new {{GPUExtent3DDict}} object.
    1. Set |extent|.{{GPUExtent3DDict/width}} to max(1, |baseSize|.[=Extent3D/width=] &Gt; |mipLevel|).
    1. Set |extent|.{{GPUExtent3DDict/height}} to max(1, |baseSize|.[=Extent3D/height=] &Gt; |mipLevel|).
    1. Set |extent|.{{GPUExtent3DDict/depthOrArrayLayers}} to 1.
    1. Return |extent|.
</div>

Issue: share this definition with the part of the specification that describes sampling.

### Texture Creation ### {#texture-creation}

<script type=idl>
dictionary GPUTextureDescriptor : GPUObjectDescriptorBase {
    required GPUExtent3D size;
    GPUIntegerCoordinate mipLevelCount = 1;
    GPUSize32 sampleCount = 1;
    GPUTextureDimension dimension = "2d";
    required GPUTextureFormat format;
    required GPUTextureUsageFlags usage;
};
</script>

<script type=idl>
enum GPUTextureDimension {
    "1d",
    "2d",
    "3d",
};
</script>

<script type=idl>
typedef [EnforceRange] unsigned long GPUTextureUsageFlags;
[Exposed=(Window, DedicatedWorker)]
namespace GPUTextureUsage {
    const GPUFlagsConstant COPY_SRC          = 0x01;
    const GPUFlagsConstant COPY_DST          = 0x02;
    const GPUFlagsConstant TEXTURE_BINDING   = 0x04;
    const GPUFlagsConstant STORAGE_BINDING   = 0x08;
    const GPUFlagsConstant RENDER_ATTACHMENT = 0x10;
};
</script>

<div>
    <dfn abstract-op>maximum mipLevel count</dfn>(dimension, size)
    **Arguments:**
        - {{GPUTextureDescriptor/dimension}} |dimension|
        - {{GPUTextureDescriptor/size}} |size|

    1. Calculate the max dimension value |m|:
        - If |dimension| is:
            <dl class="switch">
                : {{GPUTextureDimension/"1d"}}
                :: Let |m| = |size|.[=Extent3D/width=].

                : {{GPUTextureDimension/"2d"}}
                :: Let |m| = max(|size|.[=Extent3D/width=], |size|.[=Extent3D/height=]).

                : {{GPUTextureDimension/"3d"}}
                :: Let |m| = max(max(|size|.[=Extent3D/width=], |size|.[=Extent3D/height=]), |size|.[=Extent3D/depthOrArrayLayer=]).
            </dl>
    1. Return floor(log<sub>2</sub>(|m|)) + 1.
</div>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createTexture(descriptor)</dfn>
    ::
        Creates a {{GPUTexture}}.

        <div algorithm=GPUDevice.createTexture>
            **Called on:** {{GPUDevice}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/createTexture(descriptor)">
                |descriptor|: Description of the {{GPUTexture}} to create.
            </pre>

            **Returns:** {{GPUTexture}}

            1. Issue the following steps on the [=Device timeline=] of |this|:
                <div class=device-timeline>
                    1. If |descriptor|.{{GPUTextureDescriptor/format}} is a {{GPUTextureFormat}} that requires a feature (see
                        [[#texture-format-caps]]), but |this|.{{GPUObjectBase/[[device]]}}.{{device/[[features]]}} does not
                        [=list/contain=] the feature, throw a {{TypeError}}.
                    1. If any of the following requirements are unmet:
                        <div class=validusage>
                            - |this| must be a [=valid=] {{GPUDevice}}.
                            - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/width=],
                                |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/height=],
                                and |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/depthOrArrayLayers=] must be greater than zero.
                            - |descriptor|.{{GPUTextureDescriptor/mipLevelCount}} must be greater than zero.
                            - |descriptor|.{{GPUTextureDescriptor/sampleCount}} must be either 1 or 4.

                            - If |descriptor|.{{GPUTextureDescriptor/dimension}} is:
                                <dl class="switch">
                                    : {{GPUTextureDimension/"1d"}}
                                    ::
                                        - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/width=] must be less than or equal to
                                            |this|.{{GPUDevice/limits}}.{{GPUSupportedLimits/maxTextureDimension1D}}.
                                        - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/height=] must be 1.
                                        - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/depthOrArrayLayers=] must be 1.
                                        - |descriptor|.{{GPUTextureDescriptor/sampleCount}} must be 1.
                                        - |descriptor|.{{GPUTextureDescriptor/format}} must not be a compressed format or depth/stencil format.

                                    : {{GPUTextureDimension/"2d"}}
                                    ::
                                        - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/width=] must be less than or equal to
                                            |this|.{{GPUDevice/limits}}.{{GPUSupportedLimits/maxTextureDimension2D}}.
                                        - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/height=] must be less than or equal to
                                            |this|.{{GPUDevice/limits}}.{{GPUSupportedLimits/maxTextureDimension2D}}.
                                        - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/depthOrArrayLayers=] must be less than
                                            or equal to |this|.{{GPUDevice/limits}}.{{GPUSupportedLimits/maxTextureArrayLayers}}.

                                    : {{GPUTextureDimension/"3d"}}
                                    ::
                                        - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/width=] must be less than or equal to
                                            |this|.{{GPUDevice/limits}}.{{GPUSupportedLimits/maxTextureDimension3D}}.
                                        - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/height=] must be less than or equal to
                                            |this|.{{GPUDevice/limits}}.{{GPUSupportedLimits/maxTextureDimension3D}}.
                                        - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/depthOrArrayLayers=] must be less than
                                            or equal to |this|.{{GPUDevice/limits}}.{{GPUSupportedLimits/maxTextureDimension3D}}.
                                        - |descriptor|.{{GPUTextureDescriptor/sampleCount}} must be 1.
                                        - |descriptor|.{{GPUTextureDescriptor/format}} must not be a compressed format or depth/stencil format.
                                </dl>
                            - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/width=] must be multiple of [=texel block width=].
                            - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/height=] must be multiple of [=texel block height=].

                            - If |descriptor|.{{GPUTextureDescriptor/sampleCount}} > 1:
                                - |descriptor|.{{GPUTextureDescriptor/mipLevelCount}} must be 1.
                                - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/depthOrArrayLayers=] must be 1.
                                - |descriptor|.{{GPUTextureDescriptor/usage}} must not include the {{GPUTextureUsage/STORAGE_BINDING}} bit.
                                - |descriptor|.{{GPUTextureDescriptor/format}} must be a [=renderable format=].

                            - |descriptor|.{{GPUTextureDescriptor/mipLevelCount}} must be less than or equal to
                                [$maximum mipLevel count$](|descriptor|.{{GPUTextureDescriptor/dimension}}, |descriptor|.{{GPUTextureDescriptor/size}}).

                            - |descriptor|.{{GPUTextureDescriptor/usage}} must be a combination of {{GPUTextureUsage}} values.
                            - If |descriptor|.{{GPUTextureDescriptor/usage}} includes the {{GPUTextureUsage/RENDER_ATTACHMENT}} bit,
                                |descriptor|.{{GPUTextureDescriptor/format}} must be a [=renderable format=].
                            - If |descriptor|.{{GPUTextureDescriptor/usage}} includes the {{GPUTextureUsage/STORAGE_BINDING}} bit,
                                |descriptor|.{{GPUTextureDescriptor/format}} must be listed in [[#plain-color-formats]] table
                                with {{GPUTextureUsage/STORAGE_BINDING}} capability.
                        </div>

                        Then:
                            1. Generate a {{GPUValidationError}} in the current scope with appropriate error message.
                            1. Return a new [=invalid=] {{GPUTexture}}.

                    1. Let |t| be a new {{GPUTexture}} object.
                    1. Set |t|.{{GPUTexture/[[descriptor]]}} to |descriptor|.
                    1. Return |t|.
                </div>
        </div>
</dl>

### Texture Destruction ### {#texture-destruction}

An application that no longer requires a {{GPUTexture}} can choose to lose access to it before
garbage collection by calling {{GPUTexture/destroy()}}.

Note: This allows the user agent to reclaim the GPU memory associated with the {{GPUTexture}} once
all previously submitted operations using it are complete.

<dl dfn-type=method dfn-for=GPUTexture>
    : <dfn>destroy()</dfn>
    ::
        Destroys the {{GPUTexture}}.

        <div algorithm=GPUTexture.destroy>
            **Called on:** {{GPUTexture}} |this|.

            **Returns:** {{undefined}}

            1. Set |this|.{{GPUTexture/[[destroyed]]}} to true.
        </div>
</dl>

## <dfn interface>GPUTextureView</dfn> ## {#gpu-textureview}

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUTextureView {
};
GPUTextureView includes GPUObjectBase;
</script>

{{GPUTextureView}} has the following internal slots:

<dl dfn-type=attribute dfn-for="GPUTextureView">
    : <dfn>\[[texture]]</dfn>
    ::
        The {{GPUTexture}} into which this is a view.

    : <dfn>\[[descriptor]]</dfn>
    ::
        The {{GPUTextureViewDescriptor}} describing this texture view.

        All optional fields of {{GPUTextureViewDescriptor}} are defined.
    : <dfn>\[[renderExtent]]</dfn>
    ::
        For renderable views, this is the effective {{GPUExtent3DDict}} for rendering.

        Note: this extent depends on the {{GPUTextureViewDescriptor/baseMipLevel}}.

</dl>

### Texture View Creation ### {#texture-view-creation}

<script type=idl>
dictionary GPUTextureViewDescriptor : GPUObjectDescriptorBase {
    GPUTextureFormat format;
    GPUTextureViewDimension dimension;
    GPUTextureAspect aspect = "all";
    GPUIntegerCoordinate baseMipLevel = 0;
    GPUIntegerCoordinate mipLevelCount;
    GPUIntegerCoordinate baseArrayLayer = 0;
    GPUIntegerCoordinate arrayLayerCount;
};
</script>

<script type=idl>
enum GPUTextureViewDimension {
    "1d",
    "2d",
    "2d-array",
    "cube",
    "cube-array",
    "3d"
};
</script>

<script type=idl>
enum GPUTextureAspect {
    "all",
    "stencil-only",
    "depth-only"
};
</script>

<dl dfn-type=method dfn-for=GPUTexture>
    : <dfn>createView(descriptor)</dfn>
    ::
        Creates a {{GPUTextureView}}.

        <div algorithm=GPUTexture.createView>
            **Called on:** {{GPUTexture}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUTexture/createView(descriptor)">
                |descriptor|: Description of the {{GPUTextureView}} to create.
            </pre>

            **Returns:** |view|, of type {{GPUTextureView}}.

            1. Set |descriptor| to the result of [$resolving GPUTextureViewDescriptor defaults$] with |descriptor|.
            1. Issue the following steps on the [=Device timeline=] of |this|:
                <div class=device-timeline>
                    1. If any of the following requirements are unmet:
                        <div class=validusage>
                            - |this| is [=valid=]
                            - If the |descriptor|.{{GPUTextureViewDescriptor/aspect}} is
                                <dl class="switch">
                                    : {{GPUTextureAspect/"stencil-only"}}
                                    :: |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/format}} must be a [[#depth-formats|depth-stencil format]]
                                        which contains a stencil aspect.

                                    : {{GPUTextureAspect/"depth-only"}}
                                    :: |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/format}} must be a [[#depth-formats|depth-stencil format]]
                                        which contains a depth aspect.
                                </dl>
                            - |descriptor|.{{GPUTextureViewDescriptor/mipLevelCount}} must be &gt; 0.
                            - |descriptor|.{{GPUTextureViewDescriptor/baseMipLevel}} +
                                |descriptor|.{{GPUTextureViewDescriptor/mipLevelCount}} must be &le;
                                |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/mipLevelCount}}.
                            - |descriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} must be &gt; 0.
                            - |descriptor|.{{GPUTextureViewDescriptor/baseArrayLayer}} +
                                |descriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} must be &le;
                                the [$array layer count$] of |this|.
                            - |descriptor|.{{GPUTextureViewDescriptor/format}} must be |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/format}}.
                                <div class="issue">Allow for creating views with compatible formats as well.</div>
                            - If |descriptor|.{{GPUTextureViewDescriptor/dimension}} is:
                                <dl class="switch">
                                    : {{GPUTextureViewDimension/"1d"}}
                                    :: |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/dimension}} must be {{GPUTextureDimension/"1d"}}.
                                    :: |descriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} must be `1`.

                                    : {{GPUTextureViewDimension/"2d"}}
                                    :: |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/dimension}} must be {{GPUTextureDimension/"2d"}}.
                                    :: |descriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} must be `1`.

                                    : {{GPUTextureViewDimension/"2d-array"}}
                                    :: |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/dimension}} must be {{GPUTextureDimension/"2d"}}.

                                    : {{GPUTextureViewDimension/"cube"}}
                                    :: |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/dimension}} must be {{GPUTextureDimension/"2d"}}.
                                    :: |descriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} must be `6`.
                                    :: |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/size}}.[=Extent3D/width=] must be
                                        |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/size}}.[=Extent3D/height=].

                                    : {{GPUTextureViewDimension/"cube-array"}}
                                    :: |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/dimension}} must be {{GPUTextureDimension/"2d"}}.
                                    :: |descriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} must be a multiple of `6`.
                                    :: |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/size}}.[=Extent3D/width=] must be
                                        |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/size}}.[=Extent3D/height=].

                                    : {{GPUTextureViewDimension/"3d"}}
                                    :: |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/dimension}} must be {{GPUTextureDimension/"3d"}}.
                                    :: |descriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} must be `1`.
                                </dl>
                        </div>

                        Then:
                            1. Generate a {{GPUValidationError}} in the current scope with appropriate error message.
                            1. Return a new [=invalid=] {{GPUTextureView}}.

                    1. Let |view| be a new {{GPUTextureView}} object.
                    1. Set |view|.{{GPUTextureView/[[texture]]}} to |this|.
                    1. Set |view|.{{GPUTextureView/[[descriptor]]}} to |descriptor|.
                    1. If |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/usage}} contains {{GPUTextureUsage/RENDER_ATTACHMENT}}:
                        1. Let |renderExtent| be [$compute render extent$](|this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/size}}, |descriptor|.{{GPUTextureViewDescriptor/baseMipLevel}}).
                        1. Set |view|.{{GPUTextureView/[[renderExtent]]}} to |renderExtent|.
                    1. Return |view|.
                </div>
        </div>
</dl>

<div>
    When <dfn abstract-op>resolving GPUTextureViewDescriptor defaults</dfn> for {{GPUTextureViewDescriptor}}
    |descriptor| run the following steps:

    1. Let |resolved| be a copy of |descriptor|.
    1. If |resolved|.{{GPUTextureViewDescriptor/format}} is `undefined`,
        set |resolved|.{{GPUTextureViewDescriptor/format}} to |texture|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/format}}.
    1. If |resolved|.{{GPUTextureViewDescriptor/mipLevelCount}} is `undefined`,
        set |resolved|.{{GPUTextureViewDescriptor/mipLevelCount}} to |texture|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/mipLevelCount}}
        &minus; {{GPUTextureViewDescriptor/baseMipLevel}}.
    1. If |resolved|.{{GPUTextureViewDescriptor/dimension}} is `undefined` and
        |texture|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/dimension}} is:
        <dl class="switch">
            : {{GPUTextureDimension/"1d"}}
            :: Set |resolved|.{{GPUTextureViewDescriptor/dimension}} to {{GPUTextureViewDimension/"1d"}}.

            : {{GPUTextureDimension/"2d"}}
            :: Set |resolved|.{{GPUTextureViewDescriptor/dimension}} to {{GPUTextureViewDimension/"2d"}}.

            : {{GPUTextureDimension/"3d"}}
            :: Set |resolved|.{{GPUTextureViewDescriptor/dimension}} to {{GPUTextureViewDimension/"3d"}}.
        </dl>
    1. If |resolved|.{{GPUTextureViewDescriptor/arrayLayerCount}} is `undefined` and
        |resolved|.{{GPUTextureViewDescriptor/dimension}} is:
        <dl class="switch">
            : {{GPUTextureViewDimension/"1d"}}, {{GPUTextureViewDimension/"2d"}}, or
                {{GPUTextureViewDimension/"3d"}}
            :: Set |resolved|.{{GPUTextureViewDescriptor/arrayLayerCount}} to `1`.

            : {{GPUTextureViewDimension/"cube"}}
            :: Set |resolved|.{{GPUTextureViewDescriptor/arrayLayerCount}} to `6`.

            : {{GPUTextureViewDimension/"2d-array"}} or {{GPUTextureViewDimension/"cube-array"}}
            :: Set |resolved|.{{GPUTextureViewDescriptor/arrayLayerCount}} to
                |texture|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/size}}.[=Extent3D/depthOrArrayLayers=] &minus;
                {{GPUTextureViewDescriptor/baseArrayLayer}}.
        </dl>

    1. Return |resolved|.
</div>

<div>
    To determine the <dfn abstract-op>array layer count</dfn> of {{GPUTexture}} |texture|, run the
    following steps:

        1. If |texture|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/dimension}} is:
            <dl class="switch">
                : {{GPUTextureDimension/"1d"}} or {{GPUTextureDimension/"3d"}}
                :: Return `1`.

                : {{GPUTextureDimension/"2d"}}
                :: Return |texture|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/size}}.[=Extent3D/depthOrArrayLayers=].
            </dl>
</div>

## Texture Formats ## {#texture-formats}

The name of the format specifies the order of components, bits per component,
and data type for the component.

  * `r`, `g`, `b`, `a` = red, green, blue, alpha
  * `unorm` = unsigned normalized
  * `snorm` = signed normalized
  * `uint` = unsigned int
  * `sint` = signed int
  * `float` = floating point

If the format has the `-srgb` suffix, then sRGB conversions from gamma to linear
and vice versa are applied during the reading and writing of color values in the
shader. Compressed texture formats are provided by [=features=]. Their naming
should follow the convention here, with the texture name as a prefix. e.g.
`etc2-rgba8unorm`.

The <dfn dfn>texel block</dfn> is a single addressable element of the textures in pixel-based {{GPUTextureFormat}}s,
and a single compressed block of the textures in block-based compressed {{GPUTextureFormat}}s.

The <dfn dfn>texel block width</dfn> and <dfn dfn>texel block height</dfn> specifies the dimension of one [=texel block=].
  - For pixel-based {{GPUTextureFormat}}s, the [=texel block width=] and [=texel block height=] are always 1.
  - For block-based compressed {{GPUTextureFormat}}s, the [=texel block width=] is the number of texels in each row of one [=texel block=],
    and the [=texel block height=] is the number of texel rows in one [=texel block=].

The <dfn dfn>texel block size</dfn> of a {{GPUTextureFormat}} is the number of bytes to store one [=texel block=].
The [=texel block size=] of each {{GPUTextureFormat}} is constant except for {{GPUTextureFormat/"stencil8"}}, {{GPUTextureFormat/"depth24plus"}}, and {{GPUTextureFormat/"depth24plus-stencil8"}}.

<script type=idl>
enum GPUTextureFormat {
    // 8-bit formats
    "r8unorm",
    "r8snorm",
    "r8uint",
    "r8sint",

    // 16-bit formats
    "r16uint",
    "r16sint",
    "r16float",
    "rg8unorm",
    "rg8snorm",
    "rg8uint",
    "rg8sint",

    // 32-bit formats
    "r32uint",
    "r32sint",
    "r32float",
    "rg16uint",
    "rg16sint",
    "rg16float",
    "rgba8unorm",
    "rgba8unorm-srgb",
    "rgba8snorm",
    "rgba8uint",
    "rgba8sint",
    "bgra8unorm",
    "bgra8unorm-srgb",
    // Packed 32-bit formats
    "rgb9e5ufloat",
    "rgb10a2unorm",
    "rg11b10ufloat",

    // 64-bit formats
    "rg32uint",
    "rg32sint",
    "rg32float",
    "rgba16uint",
    "rgba16sint",
    "rgba16float",

    // 128-bit formats
    "rgba32uint",
    "rgba32sint",
    "rgba32float",

    // Depth and stencil formats
    "stencil8",
    "depth16unorm",
    "depth24plus",
    "depth24plus-stencil8",
    "depth32float",

    // BC compressed formats usable if "texture-compression-bc" is both
    // supported by the device/user agent and enabled in requestDevice.
    "bc1-rgba-unorm",
    "bc1-rgba-unorm-srgb",
    "bc2-rgba-unorm",
    "bc2-rgba-unorm-srgb",
    "bc3-rgba-unorm",
    "bc3-rgba-unorm-srgb",
    "bc4-r-unorm",
    "bc4-r-snorm",
    "bc5-rg-unorm",
    "bc5-rg-snorm",
    "bc6h-rgb-ufloat",
    "bc6h-rgb-float",
    "bc7-rgba-unorm",
    "bc7-rgba-unorm-srgb",

    // ETC2 compressed formats usable if "texture-compression-etc2" is both
    // supported by the device/user agent and enabled in requestDevice.
    "etc2-rgb8unorm",
    "etc2-rgb8unorm-srgb",
    "etc2-rgb8a1unorm",
    "etc2-rgb8a1unorm-srgb",
    "etc2-rgba8unorm",
    "etc2-rgba8unorm-srgb",
    "eac-r11unorm",
    "eac-r11snorm",
    "eac-rg11unorm",
    "eac-rg11snorm",

    // ASTC compressed formats usable if "texture-compression-astc" is both
    // supported by the device/user agent and enabled in requestDevice.
    "astc-4x4-unorm",
    "astc-4x4-unorm-srgb",
    "astc-5x4-unorm",
    "astc-5x4-unorm-srgb",
    "astc-5x5-unorm",
    "astc-5x5-unorm-srgb",
    "astc-6x5-unorm",
    "astc-6x5-unorm-srgb",
    "astc-6x6-unorm",
    "astc-6x6-unorm-srgb",
    "astc-8x5-unorm",
    "astc-8x5-unorm-srgb",
    "astc-8x6-unorm",
    "astc-8x6-unorm-srgb",
    "astc-8x8-unorm",
    "astc-8x8-unorm-srgb",
    "astc-10x5-unorm",
    "astc-10x5-unorm-srgb",
    "astc-10x6-unorm",
    "astc-10x6-unorm-srgb",
    "astc-10x8-unorm",
    "astc-10x8-unorm-srgb",
    "astc-10x10-unorm",
    "astc-10x10-unorm-srgb",
    "astc-12x10-unorm",
    "astc-12x10-unorm-srgb",
    "astc-12x12-unorm",
    "astc-12x12-unorm-srgb",

    // "depth24unorm-stencil8" feature
    "depth24unorm-stencil8",

    // "depth32float-stencil8" feature
    "depth32float-stencil8",
};
</script>

The depth aspect of the {{GPUTextureFormat/"depth24plus"}}) and {{GPUTextureFormat/"depth24plus-stencil8"}})
formats may be implemented as either a 24-bit unsigned normalized value ("depth24unorm")
or a 32-bit IEEE 754 floating point value ("depth32float").

Issue: add something on GPUAdapter(?) that gives an estimate of the bytes per texel of "stencil8"

The {{GPUTextureFormat/stencil8}} format may be implemented as
either a real "stencil8", or "depth24stencil8", where the depth aspect is
hidden and inaccessible.

Note:
While the precision of depth32float is strictly higher than the precision of
depth24unorm for all values in the representable range (0.0 to 1.0),
note that the set of representable values is not exactly the same:
for depth24unorm, 1 ULP has a constant value of 1 / (2<sup>24</sup> &minus; 1);
for depth32float, 1 ULP has a variable value no greater than 1 / (2<sup>24</sup>).

A <dfn>renderable format</dfn> is either <dfn>color renderable format</dfn>, or <dfn>depth or stencil renderable format</dfn>.
If a format is listed in [[#plain-color-formats]] with {{GPUTextureUsage/RENDER_ATTACHMENT}} capability, it is a
color renderable format. Any other format is not a color renderable format. Any depth/stencil format is a
depth or stencil renderable format. Any other format is not a depth or stencil renderable format.

## <dfn interface>GPUExternalTexture</dfn> ## {#gpu-external-texture}

A {{GPUExternalTexture}} is a sampleable texture wrapping an external video object.
The contents of a {{GPUExternalTexture}} object may not change, either from inside WebGPU
(it is only sampleable) or from outside WebGPU (e.g. due to video frame advancement).

Issue: Update this description with canvas.

They are bound into bind group layouts using the {{GPUBindGroupLayoutEntry/externalTexture}}
bind group layout entry member.
External textures use several binding slots: see [=Exceeds the binding slot limits=].

<div class=note>
    External textures *can* be implemented without creating a copy of the imported source,
    but this depends implementation-defined factors.
    Ownership of the underlying representation may either be exclusive or shared with other
    owners (such as a video decoder), but this is not visible to the application.

    The underlying representation of an external texture is unobservable
    (except for sampling behavior) but typically may include

    - Up to three 2D planes of data (e.g. RGBA, Y+UV, Y+U+V).
    - Metadata for converting coordinates before reading from those planes (crop and rotation).
    - Metadata for converting values into the specified output color space (matrices, gammas, 3D LUT).

    The configuration used may not be stable across time, systems, user agents, media sources,
    or frames within a single video source.
    In order to account for many possible representations,
    the binding conservatively uses the following, for *each* external texture:

    - three sampled texture bindings (for up to 3 planes),
    - one sampled texture binding for a 3D LUT,
    - one sampler binding to sample the 3D LUT, and
    - one uniform buffer binding for metadata.
</div>

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUExternalTexture {
};
GPUExternalTexture includes GPUObjectBase;
</script>

{{GPUExternalTexture}} has the following internal slots:

<dl dfn-type=attribute dfn-for="GPUExternalTexture">
    : <dfn>\[[destroyed]]</dfn>, of type `boolean`
    ::
        Indicates whether the object has been destroyed (can no longer be used).
        Initially set to `false`.

        <!-- Move this to an internal object if GPUExternalTexture becomes Serializable. -->
</dl>

### Importing External Textures ### {#external-texture-creation}

An external texture is created from an external video object
using {{GPUDevice/importExternalTexture()}}.

Issue: Update this description with canvas.

External textures are destroyed automatically, as a microtask,
instead of manually or upon garbage collection like other resources.

<script type=idl>
dictionary GPUExternalTextureDescriptor : GPUObjectDescriptorBase {
    required HTMLVideoElement source;
    GPUPredefinedColorSpace colorSpace = "srgb";
};
</script>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>importExternalTexture(descriptor)</dfn>
    ::
        Creates a {{GPUExternalTexture}} wrapping the provided image source.

        <div algorithm=GPUDevice.importExternalTexture>
            **Called on:** {{GPUDevice}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/importExternalTexture(descriptor)">
                |descriptor|: Provides the external image source object (and any creation options).
            </pre>

            **Returns:** {{GPUExternalTexture}}

            1. Let |source| be |descriptor|.{{GPUExternalTextureDescriptor/source}}.

            1. Let |usability| be the result of
                [=check the usability of the image argument|checking the usability of=] |source|
                (which may throw an exception).

            1. If |usability| is `bad`, throw an {{InvalidStateError}} and stop.

            1. If |source| <l spec=html>[=is not origin-clean=]</l>,
                throw a {{SecurityError}} and stop.

            1. Let |data| be the result of converting the current image contents of |source| into
                the color space |descriptor|.{{GPUExternalTextureDescriptor/colorSpace}}
                with unpremultiplied alpha.

                Note: This is described like a copy, but may be implemented as a reference to
                read-only underlying data plus appropriate metadata to perform conversion later.

                Issue: It is currently undetermined whether the default colorSpace, "srgb", is
                extended-srgb or clamped-srgb.
                This will be determined upstream as the semantics around super-srgb image sources
                get defined. Unfortunately we can't sidestep it for now because video sources
                can go already go outside the srgb range.
                The upstream determination will change whether using the default colorSpace
                option can result in sampling values greater than 1.0 or not.
                If upstream decides to make "srgb" mean clamped-srgb, we also have the option
                of changing our default to `"extended-srgb"`.

            1. Let |result| be a new {{GPUExternalTexture}} object wrapping |data|.

            1. [=Queue a microtask=] to set |result|.{{GPUExternalTexture/[[destroyed]]}} to `true`,
                releasing the underlying resource.

                Issue: Is this too restrictive?

            1. Return |result|.
        </div>
</dl>

### Sampling External Textures ### {#external-texture-sampling}

External textures are represented in WGSL with `texture_external` and may be read using
`textureLoad` and `textureSampleLevel`.

The `sampler` provided to `textureSampleLevel` is used to sample the underlying textures.
The result is in the color space set by {{GPUExternalTextureDescriptor/colorSpace}}.
It is implementation-dependent whether, for any given external texture, the sampler (and filtering)
is applied before or after conversion from underlying values into the specified color space.

Note:
If the internal representation is an RGBA plane, sampling behaves as on a regular 2D texture.
If there are several underlying planes (e.g. Y+UV), the sampler is used to sample each
underlying texture separately, prior to conversion from YUV to the specified color space.


# 采样器 # {#samplers}

## <dfn interface>GPUSampler</dfn> ## {#sampler-interface}

一个{{GPUSampler}}对可在着色器中使用以解释纹理资源数据的变换和过滤信息进行编码。

{{GPUSampler|GPUSamplers}}通过{{GPUDevice/createSampler(descriptor)|GPUDevice.createSampler(optional descriptor)}}被创建，返回一个新的采样器对象。

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUSampler {
};
GPUSampler includes GPUObjectBase;
</script>

{{GPUSampler}}有以下内部插槽:

<dl dfn-type=attribute dfn-for="GPUSampler">
    : <dfn>\[[descriptor]]</dfn>, of type {{GPUSamplerDescriptor}}, readonly
    ::
        用于创建{{GPUSampler}}的{{GPUSamplerDescriptor}}。

    : <dfn>\[[isComparison]]</dfn> of type {{boolean}}.
    ::
        {GPUSampler}}是否被当作比较采样器。

    : <dfn>\[[isFiltering]]</dfn> of type {{boolean}}.
    ::
        {{GPUSampler}}是否对纹理的多个样本进行加权。
</dl>

## 采样器创建 ## {#sampler-creation}

### {{GPUSamplerDescriptor}} ### {#GPUSamplerDescriptor}

{{GPUSamplerDescriptor}}指定用于创建{{GPUSampler}}的选项。

<script type=idl>
dictionary GPUSamplerDescriptor : GPUObjectDescriptorBase {
    GPUAddressMode addressModeU = "clamp-to-edge";
    GPUAddressMode addressModeV = "clamp-to-edge";
    GPUAddressMode addressModeW = "clamp-to-edge";
    GPUFilterMode magFilter = "nearest";
    GPUFilterMode minFilter = "nearest";
    GPUFilterMode mipmapFilter = "nearest";
    float lodMinClamp = 0;
    float lodMaxClamp = 32;
    GPUCompareFunction compare;
    [Clamp] unsigned short maxAnisotropy = 1;
};
</script>

- {{GPUSamplerDescriptor/addressModeV}}、{{GPUSamplerDescriptor/addressModeV}}，和{{GPUSamplerDescriptor/addressModeW}}分别指定纹理宽度、高度和深度坐标的地址模式。
- {{GPUSamplerDescriptor/magFilter}}指定样本足迹小于或等于1纹素时的采样行为。
- {{GPUSamplerDescriptor/magFilter}}指定样本足迹大于1纹素时的采样行为。
- {{GPUSamplerDescriptor/mipmapFilter}}指定在两个mipmap级别之间进行采样的行为。
- {{GPUSamplerDescriptor/lodMinClamp}}和{{GPUSamplerDescriptor/lodMaxClamp}}分别指定了在对纹理进行采样时内部使用的最小和最大细节级别。
- 如果提供了{{GPUSamplerDescriptor/compare}}，则采样器将是具有指定{{GPUCompareFunction}}的比较采样器。
- {{GPUSamplerDescriptor/maxAnisotropy}}指定采样器使用的最大各向异性值限制。

    注意：大多数实现支持范围在1到16之间的{{GPUSamplerDescriptor/maxAnisotropy}}值，包括1和16。

问题：解释LOD是如何计算的，以及平台之间是否存在差异。

问题：解释什么是各向异性采样。

{{GPUAddressMode}}描述了采样器在采样足迹超出采样纹理边界时的行为。

问题：更详细地描述“样本足迹”。

<script type=idl>
enum GPUAddressMode {
    "clamp-to-edge",
    "repeat",
    "mirror-repeat"
};
</script>

<dl dfn-type="enum-value" dfn-for=GPUAddressMode>
    : <dfn>"clamp-to-edge"</dfn>
    ::
        纹理坐标被限制在0.0和1.0之间，包括0.0和1.0。

    : <dfn>"repeat"</dfn>
    ::
        纹理坐标环绕到纹理的另一侧。

    : <dfn>"mirror-repeat"</dfn>
    ::
        纹理坐标换行到纹理的另一侧，但当坐标的整数部分为奇数时，纹理会翻转。
</dl>

{{GPUFilterMode}}描述了采样器在样本足迹与一个纹素不完全匹配时的行为。

<script type=idl>
enum GPUFilterMode {
    "nearest",
    "linear"
};
</script>

<dl dfn-type="enum-value" dfn-for=GPUFilterMode>
    : <dfn>"nearest"</dfn>
    ::
        返回最接近纹理坐标的纹素值。

    : <dfn>"linear"</dfn>
    ::
        在每个维度中选择两个纹素并返回它们值之间的线性插值。
</dl>

{{GPUCompareFunction}}指定比较采样器的行为。如果在着色器中使用比较采样器，则将输入值与采样的纹理值进行比较，并将此比较测试的结果（0.0f表示通过，或1.0f表示失败）用于过滤操作。

问题：描述过滤如何与比较采样相互作用。

<script type=idl>
enum GPUCompareFunction {
    "never",
    "less",
    "equal",
    "less-equal",
    "greater",
    "not-equal",
    "greater-equal",
    "always"
};
</script>

<dl dfn-type="enum-value" dfn-for=GPUCompareFunction>
    : <dfn>"never"</dfn>
    ::
        从不通过比较测试。

    : <dfn>"less"</dfn>
    ::
        如果提供的值小于采样值，则通过比较测试。

    : <dfn>"equal"</dfn>
    ::
        如果提供的值等于采样值，则通过比较测试。

    : <dfn>"less-equal"</dfn>
    ::
        如果提供的值小于等于采样值，则通过比较测试。

    : <dfn>"greater"</dfn>
    ::
        如果提供的值大于采样值，则通过比较测试。
    : <dfn>"not-equal"</dfn>
    ::
        如果提供的值不等于采样值，则通过比较测试。

    : <dfn>"greater-equal"</dfn>
    ::
        如果提供的值大于等于采样值，则通过比较测试。

    : <dfn>"always"</dfn>
    ::
        永远通过比较测试。
</dl>

<div>
    <dfn abstract-op>validating GPUSamplerDescriptor</dfn>(device, descriptor)
    **参数:**
        - {{GPUDevice}} |设备|
        - {{GPUSamplerDescriptor}} |描述符|

    **Returns:** {{boolean}}

    当且仅当满足下列条件时，返回 `true`：
        - |设备|是有效的。
        - |descriptor|.{{GPUSamplerDescriptor/lodMinClamp}}大于等于0.
        - |descriptor|.{{GPUSamplerDescriptor/lodMaxClamp}}大于等于
            |descriptor|.{{GPUSamplerDescriptor/lodMinClamp}}。
        - |descriptor|.{{GPUSamplerDescriptor/maxAnisotropy}}大于等于1。
        - 当|descriptor|.{{GPUSamplerDescriptor/maxAnisotropy}}大于1时，|descriptor|.{{GPUSamplerDescriptor/magFilter}}, |descriptor|.{{GPUSamplerDescriptor/minFilter}}，和|descriptor|.{{GPUSamplerDescriptor/mipmapFilter}}必须等于{{GPUFilterMode/"linear"}}。
</div>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createSampler(descriptor)</dfn>
    ::
        创建一个{{GPUBindGroupLayout}}。

        <div algorithm=GPUDevice.createSampler>
            **Called on:** {{GPUDevice}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/createSampler(descriptor)">
                |descriptor|: 要创建的{{GPUSampler}}的描述。
            </pre>

            **Returns:** {{GPUSampler}}

            1. 使|s|为一个新的{{GPUSampler}}对象。
            2. 将|s|.{{GPUSampler/[[descriptor]]}}设置为|descriptor|.
            3. 如果|s|.{{GPUSampler/[[descriptor]]}}的{{GPUSamplerDescriptor/compare}}属性为 `null`或者undefined，将|s|.{{GPUSampler/[[isComparison]]}}设置为 `false`，否则，设置为 `true`。
            4. 如果{{GPUSamplerDescriptor/minFilter}}，{{GPUSamplerDescriptor/magFilter}}或{{GPUSamplerDescriptor/mipmapFilter}}没有任何其中之一的值为{{GPUFilterMode/"linear"}}，则将|s|.{{GPUSampler/[[isFiltering]]}}设置为 `false`，否则，设置为 `true`。
            5. 返回|s|。

            <div class=validusage dfn-for=GPUDevice.createSampler>
                <dfn abstract-op>有效使用</dfn>
                - 如果|描述符|不是 `null`或undefined：
                    - 如果[$validating GPUSamplerDescriptor$](this, |descriptor|)返回 `false`：
                        1. 在当前范围内生成一个{{GPUValidationError}}并带有恰当的错误消息。
                        2. 返回一个新的[=invalid=]{{GPUSampler}}并且返回结果。
            </div>
        </div>
</dl>


# Resource Binding # {#bindings}

## <dfn interface>GPUBindGroupLayout</dfn> ## {#bind-group-layout}

A {{GPUBindGroupLayout}} defines the interface between a set of resources bound in a {{GPUBindGroup}} and their accessibility in shader stages.

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUBindGroupLayout {
};
GPUBindGroupLayout includes GPUObjectBase;
</script>

{{GPUBindGroupLayout}} has the following internal slots:

<dl dfn-type=attribute dfn-for=GPUBindGroupLayout>
    : <dfn>\[[descriptor]]</dfn>
    ::
</dl>

### Creation ### {#bind-group-layout-creation}

A {{GPUBindGroupLayout}} is created via {{GPUDevice/createBindGroupLayout()|GPUDevice.createBindGroupLayout()}}.

<script type=idl>
dictionary GPUBindGroupLayoutDescriptor : GPUObjectDescriptorBase {
    required sequence<GPUBindGroupLayoutEntry> entries;
};
</script>

A {{GPUBindGroupLayoutEntry}} describes a single shader resource binding to be included in a {{GPUBindGroupLayout}}.

<script type=idl>
typedef [EnforceRange] unsigned long GPUShaderStageFlags;
[Exposed=(Window, DedicatedWorker)]
namespace GPUShaderStage {
    const GPUFlagsConstant VERTEX   = 0x1;
    const GPUFlagsConstant FRAGMENT = 0x2;
    const GPUFlagsConstant COMPUTE  = 0x4;
};

dictionary GPUBindGroupLayoutEntry {
    required GPUIndex32 binding;
    required GPUShaderStageFlags visibility;

    GPUBufferBindingLayout buffer;
    GPUSamplerBindingLayout sampler;
    GPUTextureBindingLayout texture;
    GPUStorageTextureBindingLayout storageTexture;
    GPUExternalTextureBindingLayout externalTexture;
};
</script>

{{GPUBindGroupLayoutEntry}} dictionaries have the following members:

<dl dfn-type=dict-member dfn-for=GPUBindGroupLayoutEntry>
    : <dfn>binding</dfn>
    ::
        A unique identifier for a resource binding within a
        {{GPUBindGroupLayoutEntry}}, a corresponding {{GPUBindGroupEntry}},
        and the {{GPUShaderModule}}s.

    : <dfn>visibility</dfn>
    ::
        A bitset of the members of {{GPUShaderStage}}.
        Each set bit indicates that a {{GPUBindGroupLayoutEntry}}'s resource
        will be accessible from the associated shader stage.

    : <dfn>buffer</dfn>
    ::
        When not `undefined`, indicates the [=binding resource type=] for this {{GPUBindGroupLayoutEntry}}
        is {{GPUBufferBinding}}.

    : <dfn>sampler</dfn>
    ::
        When not `undefined`, indicates the [=binding resource type=] for this {{GPUBindGroupLayoutEntry}}
        is {{GPUSampler}}.

    : <dfn>texture</dfn>
    ::
        When not `undefined`, indicates the [=binding resource type=] for this {{GPUBindGroupLayoutEntry}}
        is {{GPUTextureView}}.

    : <dfn>storageTexture</dfn>
    ::
        When not `undefined`, indicates the [=binding resource type=] for this {{GPUBindGroupLayoutEntry}}
        is {{GPUTextureView}}.

    : <dfn>externalTexture</dfn>
    ::
        When not `undefined`, indicates the [=binding resource type=] for this {{GPUBindGroupLayoutEntry}}
        is {{GPUExternalTexture}}.
</dl>

The [=binding member=] of a {{GPUBindGroupLayoutEntry}} is determined by which member of the
{{GPUBindGroupLayoutEntry}} is defined:
{{GPUBindGroupLayoutEntry/buffer}}, {{GPUBindGroupLayoutEntry/sampler}},
{{GPUBindGroupLayoutEntry/texture}}, {{GPUBindGroupLayoutEntry/storageTexture}}, or
{{GPUBindGroupLayoutEntry/externalTexture}}.
Only one may be defined for any given {{GPUBindGroupLayoutEntry}}.
Each member has an associated {{GPUBindingResource}}
type and each [=binding type=] has an associated [=internal usage=], given by this table:

<table class="data" style="white-space: nowrap">
    <thead>
        <tr>
            <th><dfn dfn>Binding member</dfn>
            <th><dfn dfn lt="Binding Resource Type">Resource type</dfn>
            <th><dfn dfn>Binding type</dfn><br>
            <th><dfn dfn>Binding usage</dfn>
    </thead>
    <tr>
        <td rowspan=3>{{GPUBindGroupLayoutEntry/buffer}}
        <td rowspan=3>{{GPUBufferBinding}}
        <td>{{GPUBufferBindingType/"uniform"}}
        <td>[=internal usage/constant=]
    <tr>
        <td>{{GPUBufferBindingType/"storage"}}
        <td>[=internal usage/storage=]
    <tr>
        <td>{{GPUBufferBindingType/"read-only-storage"}}
        <td>[=internal usage/storage-read=]

    <tr>
        <td rowspan=3>{{GPUBindGroupLayoutEntry/sampler}}
        <td rowspan=3>{{GPUSampler}}
        <td>{{GPUSamplerBindingType/"filtering"}}
        <td rowspan=3>[=internal usage/constant=]
    <tr>
        <td>{{GPUSamplerBindingType/"non-filtering"}}
    <tr>
        <td>{{GPUSamplerBindingType/"comparison"}}

    <tr>
        <td rowspan=5>{{GPUBindGroupLayoutEntry/texture}}
        <td rowspan=5>{{GPUTextureView}}
        <td>{{GPUTextureSampleType/"float"}}
        <td rowspan=5>[=internal usage/constant=]
    <tr>
        <td>{{GPUTextureSampleType/"unfilterable-float"}}
    <tr>
        <td>{{GPUTextureSampleType/"depth"}}
    <tr>
        <td>{{GPUTextureSampleType/"sint"}}
    <tr>
        <td>{{GPUTextureSampleType/"uint"}}

    <tr>
        <td>{{GPUBindGroupLayoutEntry/storageTexture}}
        <td>{{GPUTextureView}}
        <td>{{GPUStorageTextureAccess/"write-only"}}
        <td>[=internal usage/storage=]

    <tr>
        <td>{{GPUBindGroupLayoutEntry/externalTexture}}
        <td>{{GPUExternalTexture}}
        <td>
        <td>[=internal usage/constant=]
</table>

<div>
    The [=list=] of {{GPUBindGroupLayoutEntry}} values |entries|
    <dfn>exceeds the binding slot limits</dfn> of [=supported limits=] |limits|
    if the number of slots used toward a limit exceeds the supported value in |limits|.
    Each entry may use multiple slots toward multiple limits.

    1. For each |entry| in |entries|, if:
        <dl class=switch>
            : |entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/type}}
                is {{GPUBufferBindingType/"uniform"}} and
                |entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/hasDynamicOffset}} is `true`
            :: Consider 1 {{supported limits/maxDynamicUniformBuffersPerPipelineLayout}} slot to be used.
            : |entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/type}}
                is {{GPUBufferBindingType/"storage"}} and
                |entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/hasDynamicOffset}} is `true`
            :: Consider 1 {{supported limits/maxDynamicStorageBuffersPerPipelineLayout}} slot to be used.
        </dl>
    1. For each shader stage |stage| in
        &laquo; {{GPUShaderStage/VERTEX}}, {{GPUShaderStage/FRAGMENT}}, {{GPUShaderStage/COMPUTE}} &raquo;:
        1. For each |entry| in |entries|  for which
            |entry|.{{GPUBindGroupLayoutEntry/visibility}} contains |stage|, if:
            <dl class=switch>
                : |entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/type}}
                    is {{GPUBufferBindingType/"uniform"}}
                :: Consider 1 {{supported limits/maxUniformBuffersPerShaderStage}} slot to be used.
                : |entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/type}}
                    is {{GPUBufferBindingType/"storage"}} or {{GPUBufferBindingType/"read-only-storage"}}
                :: Consider 1 {{supported limits/maxStorageBuffersPerShaderStage}} slot to be used.
                : |entry|.{{GPUBindGroupLayoutEntry/sampler}} is not `undefined`
                :: Consider 1 {{supported limits/maxSamplersPerShaderStage}} slot to be used.
                : |entry|.{{GPUBindGroupLayoutEntry/texture}} is not `undefined`
                :: Consider 1 {{supported limits/maxSampledTexturesPerShaderStage}} slot to be used.
                : |entry|.{{GPUBindGroupLayoutEntry/storageTexture}} is not `undefined`
                :: Consider 1 {{supported limits/maxStorageTexturesPerShaderStage}} slot to be used.
                : |entry|.{{GPUBindGroupLayoutEntry/externalTexture}} is not `undefined`
                :: Consider
                    4 {{supported limits/maxSampledTexturesPerShaderStage}} slot,
                    1 {{supported limits/maxSamplersPerShaderStage}} slot, and
                    1 {{supported limits/maxUniformBuffersPerShaderStage}} slot
                    to be used.
            </dl>
</div>

<script type=idl>
enum GPUBufferBindingType {
    "uniform",
    "storage",
    "read-only-storage",
};

dictionary GPUBufferBindingLayout {
    GPUBufferBindingType type = "uniform";
    boolean hasDynamicOffset = false;
    GPUSize64 minBindingSize = 0;
};
</script>

{{GPUBufferBindingLayout}} dictionaries have the following members:

<dl dfn-type=dict-member dfn-for=GPUBufferBindingLayout>
    : <dfn>type</dfn>
    ::
        Indicates the type required for buffers bound to this bindings.

    : <dfn>hasDynamicOffset</dfn>
    ::
        Indicates whether this binding requires a dynamic offset.

    : <dfn>minBindingSize</dfn>
    ::
        May be used to indicate the minimum buffer binding size.
</dl>

<script type=idl>
enum GPUSamplerBindingType {
    "filtering",
    "non-filtering",
    "comparison",
};

dictionary GPUSamplerBindingLayout {
    GPUSamplerBindingType type = "filtering";
};
</script>

{{GPUSamplerBindingLayout}} dictionaries have the following members:

<dl dfn-type=dict-member dfn-for=GPUSamplerBindingLayout>
    : <dfn>type</dfn>
    ::
        Indicates the required type of a sampler bound to this bindings.
</dl>

<script type=idl>
enum GPUTextureSampleType {
  "float",
  "unfilterable-float",
  "depth",
  "sint",
  "uint",
};

dictionary GPUTextureBindingLayout {
    GPUTextureSampleType sampleType = "float";
    GPUTextureViewDimension viewDimension = "2d";
    boolean multisampled = false;
};
</script>

Issue(https://github.com/gpuweb/gpuweb/issues/851): consider making {{GPUTextureBindingLayout/sampleType}}
truly optional.

{{GPUTextureBindingLayout}} dictionaries have the following members:

<dl dfn-type=dict-member dfn-for=GPUTextureBindingLayout>
    : <dfn>sampleType</dfn>
    ::
        Indicates the type required for texture views bound to this binding.

    : <dfn>viewDimension</dfn>
    ::
        Indicates the required {{GPUTextureViewDescriptor/dimension}} for texture views bound to
        this binding.
        <!-- https://github.com/gpuweb/gpuweb/pull/339 -->

    : <dfn>multisampled</dfn>
    ::
        Inicates whether or not texture views bound to this binding must be multisampled.
</dl>

<script type=idl>
enum GPUStorageTextureAccess {
    "write-only",
};

dictionary GPUStorageTextureBindingLayout {
    GPUStorageTextureAccess access = "write-only";
    required GPUTextureFormat format;
    GPUTextureViewDimension viewDimension = "2d";
};
</script>

Issue(https://github.com/gpuweb/gpuweb/issues/851): consider making {{GPUStorageTextureBindingLayout/format}}
truly optional.

{{GPUStorageTextureBindingLayout}} dictionaries have the following members:

<dl dfn-type=dict-member dfn-for=GPUStorageTextureBindingLayout>
    : <dfn>access</dfn>
    ::
        Indicates whether texture views bound to this binding will be bound for read-only or
        write-only access.

    : <dfn>format</dfn>
    ::
        The required {{GPUTextureViewDescriptor/format}} of texture views bound to this binding.

    : <dfn>viewDimension</dfn>
    ::
        Indicates the required {{GPUTextureViewDescriptor/dimension}} for texture views bound to
        this binding.
        <!-- https://github.com/gpuweb/gpuweb/pull/339 -->
</dl>

<script type=idl>
dictionary GPUExternalTextureBindingLayout {
};
</script>

A {{GPUBindGroupLayout}} object has the following internal slots:

<dl dfn-type=attribute dfn-for="GPUBindGroupLayout">
    : <dfn>\[[entryMap]]</dfn> of type [=ordered map=]&lt;{{GPUSize32}}, {{GPUBindGroupLayoutEntry}}&gt.
    ::
        The map of binding indices pointing to the {{GPUBindGroupLayoutEntry}}s,
        which this {{GPUBindGroupLayout}} describes.

    : <dfn>\[[dynamicOffsetCount]]</dfn> of type {{GPUSize32}}.
    ::
        The number of buffer bindings with dynamic offsets in this {{GPUBindGroupLayout}}.

    : <dfn>\[[exclusivePipeline]]</dfn> of type {{GPUPipelineBase}}?, initially `null`.
    ::
        The pipeline that created this {{GPUBindGroupLayout}}, if it was created as part of a
        [[#default-pipeline-layout|default pipeline layout]]. If not `null`, {{GPUBindGroup}}s
        created with this {{GPUBindGroupLayout}} can only be used with the specified
        {{GPUPipelineBase}}.
</dl>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createBindGroupLayout(descriptor)</dfn>
    ::
        Creates a {{GPUBindGroupLayout}}.

        <div algorithm=GPUDevice.createBindGroupLayout>
            **Called on:** {{GPUDevice}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/createBindGroupLayout(descriptor)">
                |descriptor|: Description of the {{GPUBindGroupLayout}} to create.
            </pre>

            **Returns:** {{GPUBindGroupLayout}}

            1. Let |layout| be a new valid {{GPUBindGroupLayout}} object.
            1. Set |layout|.{{GPUBindGroupLayout/[[descriptor]]}} to |descriptor|.
            1. Issue the following steps on the [=Device timeline=] of |this|:
                <div class=device-timeline>
                    1. If any of the following conditions are unsatisfied:
                        <div class=validusage>
                            - |this| is a [=valid=] {{GPUDevice}}.
                            - The {{GPUBindGroupLayoutEntry/binding}} of each entry in |descriptor| is unique.
                            - |descriptor|.{{GPUBindGroupLayoutDescriptor/entries}} must not
                                [=exceeds the binding slot limits|exceed the binding slot limits=]
                                of |this|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.
                            - For each {{GPUBindGroupLayoutEntry}} |entry| in |descriptor|.{{GPUBindGroupLayoutDescriptor/entries}}:
                                - Let |bufferLayout| be |entry|.{{GPUBindGroupLayoutEntry/buffer}}
                                - Let |samplerLayout| be |entry|.{{GPUBindGroupLayoutEntry/sampler}}
                                - Let |textureLayout| be |entry|.{{GPUBindGroupLayoutEntry/texture}}
                                - Let |storageTextureLayout| be |entry|.{{GPUBindGroupLayoutEntry/storageTexture}}

                                - Exactly one of |bufferLayout|, |samplerLayout|, |textureLayout|,
                                    or |storageTextureLayout| are not `undefined`.

                                - If |entry|.{{GPUBindGroupLayoutEntry/visibility}} includes
                                    {{GPUShaderStage/VERTEX}}:
                                    - |entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/type}}
                                        must not be {{GPUBufferBindingType/"storage"}}.
                                    - |entry|.{{GPUBindGroupLayoutEntry/storageTexture}}?.{{GPUStorageTextureBindingLayout/access}}
                                        must not be {{GPUStorageTextureAccess/"write-only"}}.

                                - If the |textureLayout| is not `undefined` and
                                    |textureLayout|.{{GPUTextureBindingLayout/multisampled}} is `true`:
                                    - |textureLayout|.{{GPUTextureBindingLayout/viewDimension}} is
                                        {{GPUTextureViewDimension/"2d"}}.
                                    - |textureLayout|.{{GPUTextureBindingLayout/sampleType}} is not
                                        {{GPUTextureSampleType/"float"}} or {{GPUTextureSampleType/"depth"}}.

                                - If |storageTextureLayout| is not `undefined`:
                                    - |storageTextureLayout|.{{GPUStorageTextureBindingLayout/viewDimension}} is not
                                        {{GPUTextureViewDimension/"cube"}} or {{GPUTextureViewDimension/"cube-array"}}.
                                    - |storageTextureLayout|.{{GPUStorageTextureBindingLayout/format}} must be a format
                                        which can support storage usage.
                        </div>

                        Then:
                            1. Generate a {{GPUValidationError}} in the current scope with appropriate
                                error message.
                            1. Make |layout| [=invalid=] and return |layout|.

                    1. Set |layout|.{{GPUBindGroupLayout/[[dynamicOffsetCount]]}} to the number of
                        entries in |descriptor| where {{GPUBindGroupLayoutEntry/buffer}} is not `undefined` and
                        {{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/hasDynamicOffset}} is `true`.
                    1. For each {{GPUBindGroupLayoutEntry}} |entry| in
                        |descriptor|.{{GPUBindGroupLayoutDescriptor/entries}}:
                        1. Insert |entry| into |layout|.{{GPUBindGroupLayout/[[entryMap]]}}
                            with the key of |entry|.{{GPUBindGroupLayoutEntry/binding}}.
                </div>
            1. Return |layout|.

        </div>
</dl>

### Compatibility ### {#bind-group-compatibility}

<div>
Two {{GPUBindGroupLayout}} objects |a| and |b| are considered <dfn dfn>group-equivalent</dfn>
if and only if all of the following conditions are satisfied:
    - |a|.{{GPUBindGroupLayout/[[exclusivePipeline]]}} == |b|.{{GPUBindGroupLayout/[[exclusivePipeline]]}}.
    - for any binding number |binding|, one of the following conditions is satisfied:
        - it's missing from both |a|.{{GPUBindGroupLayout/[[entryMap]]}} and |b|.{{GPUBindGroupLayout/[[entryMap]]}}.
        - |a|.{{GPUBindGroupLayout/[[entryMap]]}}[|binding|] == |b|.{{GPUBindGroupLayout/[[entryMap]]}}[|binding|]
</div>

If bind groups layouts are [=group-equivalent=] they can be interchangeably used in all contents.

## <dfn interface>GPUBindGroup</dfn> ## {#gpu-bind-group}

A {{GPUBindGroup}} defines a set of resources to be bound together in a group
    and how the resources are used in shader stages.

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUBindGroup {
};
GPUBindGroup includes GPUObjectBase;
</script>

### Bind Group Creation ### {#bind-group-creation}

A {{GPUBindGroup}} is created via {{GPUDevice/createBindGroup()|GPUDevice.createBindGroup()}}.

<script type=idl>
dictionary GPUBindGroupDescriptor : GPUObjectDescriptorBase {
    required GPUBindGroupLayout layout;
    required sequence<GPUBindGroupEntry> entries;
};
</script>

A {{GPUBindGroupEntry}} describes a single resource to be bound in a {{GPUBindGroup}}.

<script type=idl>
typedef (GPUSampler or GPUTextureView or GPUBufferBinding or GPUExternalTexture) GPUBindingResource;

dictionary GPUBindGroupEntry {
    required GPUIndex32 binding;
    required GPUBindingResource resource;
};
</script>

<script type=idl>
dictionary GPUBufferBinding {
    required GPUBuffer buffer;
    GPUSize64 offset = 0;
    GPUSize64 size;
};
</script>

  * {{GPUBufferBinding/size}}: If undefined, specifies the range starting at
      {{GPUBufferBinding/offset}} and ending at the end of the buffer.

A {{GPUBindGroup}} object has the following internal slots:

<dl dfn-type=attribute dfn-for="GPUBindGroup">
    : <dfn>\[[layout]]</dfn> of type {{GPUBindGroupLayout}}.
    ::
        The {{GPUBindGroupLayout}} associated with this {{GPUBindGroup}}.

    : <dfn>\[[entries]]</dfn> of type sequence<{{GPUBindGroupEntry}}>.
    ::
        The set of {{GPUBindGroupEntry}}s this {{GPUBindGroup}} describes.

    : <dfn>\[[usedResources]]</dfn> of type [=ordered map=]&lt;[=subresource=], [=list=]&lt;[=internal usage=]&gt;&gt;.
    ::
        The set of buffer and texture [=subresource=]s used by this bind group,
        associated with lists of the [=internal usage=] flags.
</dl>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createBindGroup(descriptor)</dfn>
    ::
        Creates a {{GPUBindGroup}}.

        <div algorithm=GPUDevice.createBindGroup>
            **Called on:** {{GPUDevice}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/createBindGroup(descriptor)">
                |descriptor|: Description of the {{GPUBindGroup}} to create.
            </pre>

            **Returns:** {{GPUBindGroup}}

            1. Let |bindGroup| be a new valid {{GPUBindGroup}} object.
            1. Let |limits| be |this|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.
            1. Issue the following steps on the [=Device timeline=] of |this|:
                <div class=device-timeline>
                    1. If any of the following conditions are unsatisfied:
                        <div class=validusage>
                            - |descriptor|.{{GPUBindGroupDescriptor/layout}} is [$valid to use with$] |this|.
                            - The number of {{GPUBindGroupLayoutDescriptor/entries}} of
                                |descriptor|.{{GPUBindGroupDescriptor/layout}} is exactly equal to
                                the number of |descriptor|.{{GPUBindGroupDescriptor/entries}}.

                            For each {{GPUBindGroupEntry}} |bindingDescriptor| in
                                |descriptor|.{{GPUBindGroupDescriptor/entries}}:
                                - Let |resource| be |bindingDescriptor|.{{GPUBindGroupEntry/resource}}.
                                - There is exactly one {{GPUBindGroupLayoutEntry}} |layoutBinding|
                                    in |descriptor|.{{GPUBindGroupDescriptor/layout}}.{{GPUBindGroupLayoutDescriptor/entries}}
                                    such that |layoutBinding|.{{GPUBindGroupLayoutEntry/binding}} equals to
                                    |bindingDescriptor|.{{GPUBindGroupEntry/binding}}.

                                - If the defined [=binding member=] for |layoutBinding| is
                                    <dl class="switch">
                                        : {{GPUBindGroupLayoutEntry/sampler}}
                                        ::
                                            - |resource| is a {{GPUSampler}}.
                                            - |resource| is [$valid to use with$] |this|.
                                            - If |layoutBinding|.{{GPUBindGroupLayoutEntry/sampler}}.{{GPUSamplerBindingLayout/type}} is:
                                                <dl class="switch">
                                                    : {{GPUSamplerBindingType/"filtering"}}
                                                    :: |resource|.{{GPUSampler/[[isComparison]]}} is `false`.

                                                    : {{GPUSamplerBindingType/"non-filtering"}}
                                                    ::
                                                        |resource|.{{GPUSampler/[[isFiltering]]}} is `false`.
                                                        |resource|.{{GPUSampler/[[isComparison]]}} is `false`.

                                                    : {{GPUSamplerBindingType/"comparison"}}
                                                    :: |resource|.{{GPUSampler/[[isComparison]]}} is `true`.
                                                </dl>

                                        : {{GPUBindGroupLayoutEntry/texture}}
                                        ::
                                            - |resource| is a {{GPUTextureView}}.
                                            - |resource| is [$valid to use with$] |this|.
                                            - Let |texture| be |resource|.{{GPUTextureView/[[texture]]}}.
                                            - |layoutBinding|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/viewDimension}}
                                                is equal to |resource|'s {{GPUTextureViewDescriptor/dimension}}.
                                            - |layoutBinding|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/sampleType}}
                                                is [[#texture-format-caps|compatible]] with
                                                |resource|'s {{GPUTextureViewDescriptor/format}}.
                                            - |texture|'s {{GPUTextureDescriptor/usage}} includes {{GPUTextureUsage/TEXTURE_BINDING}}.
                                            - If |layoutBinding|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/multisampled}}
                                                is `true`, |texture|'s {{GPUTextureDescriptor/sampleCount}}
                                                &gt; `1`, Otherwise |texture|'s {{GPUTextureDescriptor/sampleCount}} is `1`.

                                        : {{GPUBindGroupLayoutEntry/storageTexture}}
                                        ::
                                            - |resource| is a {{GPUTextureView}}.
                                            - |resource| is [$valid to use with$] |this|.
                                            - Let |texture| be |resource|.{{GPUTextureView/[[texture]]}}.
                                            - |layoutBinding|.{{GPUBindGroupLayoutEntry/storageTexture}}.{{GPUStorageTextureBindingLayout/viewDimension}}
                                                is equal to |resource|'s {{GPUTextureViewDescriptor/dimension}}.
                                            - |layoutBinding|.{{GPUBindGroupLayoutEntry/storageTexture}}.{{GPUStorageTextureBindingLayout/format}}
                                                is equal to |resource|.{{GPUTextureView/[[descriptor]]}}.{{GPUTextureViewDescriptor/format}}.
                                            - |texture|'s {{GPUTextureDescriptor/usage}} includes {{GPUTextureUsage/STORAGE_BINDING}}.

                                        :  {{GPUBindGroupLayoutEntry/buffer}}
                                        ::
                                            - |resource| is a {{GPUBufferBinding}}.
                                            - |resource|.{{GPUBufferBinding/buffer}} is [$valid to use with$] |this|.
                                            - The bound part designated by |resource|.{{GPUBufferBinding/offset}} and
                                                |resource|.{{GPUBufferBinding/size}} resides inside the buffer.
                                            - The effective binding size, that is either explict in
                                                |resource|.{{GPUBufferBinding/size}} or derived from
                                                |resource|.{{GPUBufferBinding/offset}} and the full
                                                size of the buffer, is greater than or equal to
                                                |layoutBinding|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/minBindingSize}}.

                                            - If |layoutBinding|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/type}} is
                                                <dl class="switch">
                                                    : {{GPUBufferBindingType/"uniform"}}
                                                    :: |resource|.{{GPUBufferBinding/buffer}}.{{GPUBufferDescriptor/usage}}
                                                        includes {{GPUBufferUsage/UNIFORM}}.
                                                    :: |resource|.{{GPUBufferBinding/size}} &le;
                                                        |limits|.{{supported limits/maxUniformBufferBindingSize}}.
                                                    :: |resource|.{{GPUBufferBinding/offset}} is a multiple of
                                                        |limits|.{{supported limits/minUniformBufferOffsetAlignment}}.
                                                    :: Issue: This validation should take into account the default when  {{GPUBufferBinding/size}} is not set.
                                                        Also should {{GPUBufferBinding/size}} default to the `buffer.byteLength - offset` or
                                                        `min(buffer.byteLength - offset, limits.maxUniformBufferBindingSize)`?

                                                    : {{GPUBufferBindingType/"storage"}} or
                                                        {{GPUBufferBindingType/"read-only-storage"}}
                                                    :: |resource|.{{GPUBufferBinding/buffer}}.{{GPUBufferDescriptor/usage}}
                                                        includes {{GPUBufferUsage/STORAGE}}.
                                                    :: |resource|.{{GPUBufferBinding/size}} &le;
                                                        |limits|.{{supported limits/maxStorageBufferBindingSize}}.
                                                    :: |resource|.{{GPUBufferBinding/offset}} is a multiple of
                                                        |limits|.{{supported limits/minStorageBufferOffsetAlignment}}.
                                                </dl>

                                    </dl>

                        </div>

                        Then:
                            1. Generate a {{GPUValidationError}} in the current scope with appropriate
                                error message.
                            1. Make |bindGroup| [=invalid=] and return |bindGroup|.

                    1. Let |bindGroup|.{{GPUBindGroup/[[layout]]}} =
                        |descriptor|.{{GPUBindGroupDescriptor/layout}}.
                    1. Let |bindGroup|.{{GPUBindGroup/[[entries]]}} =
                        |descriptor|.{{GPUBindGroupDescriptor/entries}}.
                    1. Let |bindGroup|.{{GPUBindGroup/[[usedResources]]}} = {}.

                    1. For each {{GPUBindGroupEntry}} |bindingDescriptor| in
                        |descriptor|.{{GPUBindGroupDescriptor/entries}}:
                        1. Let |internalUsage| be the [=binding usage=] for |layoutBinding|.
                        1. Each [=subresource=] seen by |resource| is added to {{GPUBindGroup/[[usedResources]]}} as |internalUsage|.
                </div>
            1. Return |bindGroup|.

            Issue: define the "effective buffer binding size" separately.
        </div>
</dl>

## <dfn interface>GPUPipelineLayout</dfn> ## {#pipeline-layout}

A {{GPUPipelineLayout}} defines the mapping between resources of all {{GPUBindGroup}} objects set up during command encoding in {{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)|setBindGroup}}, and the shaders of the pipeline set by {{GPURenderEncoderBase/setPipeline(pipeline)|GPURenderEncoderBase.setPipeline}} or {{GPUComputePassEncoder/setPipeline(pipeline)|GPUComputePassEncoder.setPipeline}}.

The full binding address of a resource can be defined as a trio of:
  1. shader stage mask, to which the resource is visible
  2. bind group index
  3. binding number

The components of this address can also be seen as the binding space of a pipeline. A {{GPUBindGroup}} (with the corresponding {{GPUBindGroupLayout}}) covers that space for a fixed bind group index. The contained bindings need to be a superset of the resources used by the shader at this bind group index.

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUPipelineLayout {
};
GPUPipelineLayout includes GPUObjectBase;
</script>

{{GPUPipelineLayout}} has the following internal slots:

<dl dfn-type=attribute dfn-for="GPUPipelineLayout">
    : <dfn>\[[bindGroupLayouts]]</dfn> of type [=list=]&lt;{{GPUBindGroupLayout}}&gt;.
    ::
        The {{GPUBindGroupLayout}} objects provided at creation in {{GPUPipelineLayoutDescriptor/bindGroupLayouts|GPUPipelineLayoutDescriptor.bindGroupLayouts}}.
</dl>

Note: using the same {{GPUPipelineLayout}} for many {{GPURenderPipeline}} or {{GPUComputePipeline}} pipelines guarantees that the user agent doesn't need to rebind any resources internally when there is a switch between these pipelines.

<div class="example">
{{GPUComputePipeline}} object X was created with {{GPUPipelineLayout/[[bindGroupLayouts]]|GPUPipelineLayout.bindGroupLayouts}} A, B, C. {{GPUComputePipeline}} object Y was created with {{GPUPipelineLayout/[[bindGroupLayouts]]|GPUPipelineLayout.bindGroupLayouts}} A, D, C. Supposing the command encoding sequence has two dispatches:

  1. {{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)|setBindGroup(0, ...)}}
  1. {{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)|setBindGroup(1, ...)}}
  1. {{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)|setBindGroup(2, ...)}}
  1. {{GPUComputePassEncoder/setPipeline(pipeline)|setPipeline(X)}}
  1. {{GPUComputePassEncoder/dispatch(x, y, z)|dispatch()}}
  1. {{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)|setBindGroup(1, ...)}}
  1. {{GPUComputePassEncoder/setPipeline(pipeline)|setPipeline(Y)}}
  1. {{GPUComputePassEncoder/dispatch(x, y, z)|dispatch()}}

In this scenario, the user agent would have to re-bind the group slot 2 for the second dispatch, even though neither the {{GPUBindGroupLayout}} at index 2 of {{GPUPipelineLayout/[[bindGroupLayouts]]|GPUPipelineLayout.bindGrouplayouts}}, or the {{GPUBindGroup}} at slot 2, change.
</div>

Issue: should this example and the note be moved to some "best practices" document?

Note: the expected usage of the {{GPUPipelineLayout}} is placing the most common and the least frequently changing bind groups at the "bottom" of the layout, meaning lower bind group slot numbers, like 0 or 1. The more frequently a bind group needs to change between draw calls, the higher its index should be. This general guideline allows the user agent to minimize state changes between draw calls, and consequently lower the CPU overhead.

### Creation ### {#pipeline-layout-creation}

A {{GPUPipelineLayout}} is created via {{GPUDevice/createPipelineLayout()|GPUDevice.createPipelineLayout()}}.

<script type=idl>
dictionary GPUPipelineLayoutDescriptor : GPUObjectDescriptorBase {
    required sequence<GPUBindGroupLayout> bindGroupLayouts;
};
</script>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createPipelineLayout(descriptor)</dfn>
    ::
        Creates a {{GPUPipelineLayout}}.

        <div algorithm=GPUDevice.createPipelineLayout>
            **Called on:** {{GPUDevice}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/createPipelineLayout(descriptor)">
                |descriptor|: Description of the {{GPUPipelineLayout}} to create.
            </pre>

            **Returns:** {{GPUPipelineLayout}}

            1. If any of the following requirements are unmet:
                <div class=validusage>
                    Let |limits| be |this|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.

                    Let |allEntries| be the result of concatenating
                        |bgl|.{{GPUBindGroupLayout/[[descriptor]]}}.{{GPUBindGroupLayoutDescriptor/entries}}
                        for all |bgl| in |descriptor|.{{GPUPipelineLayoutDescriptor/bindGroupLayouts}}.

                    - Every {{GPUBindGroupLayout}} in |descriptor|.{{GPUPipelineLayoutDescriptor/bindGroupLayouts}}
                        must be [$valid to use with$] |this| and have a {{GPUBindGroupLayout/[[exclusivePipeline]]}}
                        of `null`.
                    - The [=list/size=] of |descriptor|.{{GPUPipelineLayoutDescriptor/bindGroupLayouts}}
                        must be &le; |limits|.{{supported limits/maxBindGroups}}.
                    - |allEntries| must not [=exceeds the binding slot limits|exceed the binding slot limits=] of |limits|.
                </div>

                Then:
                    1. Generate a {{GPUValidationError}} in the current scope with appropriate error message.
                    1. Create a new [=invalid=] {{GPUPipelineLayout}} and return the result.

            1. Let |pl| be a new {{GPUPipelineLayout}} object.
            1. Set the |pl|.{{GPUPipelineLayout/[[bindGroupLayouts]]}} to
                |descriptor|.{{GPUPipelineLayoutDescriptor/bindGroupLayouts}}.
            1. Return |pl|.
        </div>
</dl>

Note: two {{GPUPipelineLayout}} objects are considered equivalent for any usage
if their internal {{GPUPipelineLayout/[[bindGroupLayouts]]}} sequences contain
{{GPUBindGroupLayout}} objects that are [=group-equivalent=].

# 着色器模块 # {#shader-modules}

## <dfn interface>GPUShaderModule</dfn> ## {#shader-module}

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUShaderModule {
    Promise<GPUCompilationInfo> compilationInfo();
};
GPUShaderModule includes GPUObjectBase;
</script>

{{GPUShaderModule}}是可序列化的。它是对内部着色器模块对象的引用，而{{Serializable}}意味着该引用可以在域（线程/worker）之间复制，从而允许多个域同时访问它。由于{{GPUShaderModule}}是不可变的，因此不存在竞争条件。

问题(gpuweb/gpuweb#354): 完成定义多线程API并将 `[Serializable]` 添加回接口。

### 着色器模块创建 ### {#shader-module-creation}

<script type=idl>
dictionary GPUShaderModuleDescriptor : GPUObjectDescriptorBase {
    required USVString code;
    object sourceMap;
};
</script>

{{GPUShaderModuleDescriptor/sourceMap}}，如果定义，可以解释为source-map-v3格式。Source maps是可选的，但它作为支持开发工具集成（例如源语言调试）的标准化方法。
[[SourceMap]]

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createShaderModule(descriptor)</dfn>
    ::
        创建一个{{GPUShaderModule}}.

        <div algorithm=GPUDevice.createShaderModule>
            **Called on:** {{GPUDevice}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/createShaderModule(descriptor)">
                descriptor: 要创建的{{GPUShaderModule}}的描述。
            </pre>

            **Returns:** {{GPUShaderModule}}

            问题：描述{{GPUDevice/createShaderModule()}}算法步骤。
        </div>
</dl>

### 着色器模块编译信息 ### {#shader-module-compilation-information}

<script type=idl>
enum GPUCompilationMessageType {
    "error",
    "warning",
    "info"
};

[Exposed=(Window, DedicatedWorker), Serializable, SecureContext]
interface GPUCompilationMessage {
    readonly attribute DOMString message;
    readonly attribute GPUCompilationMessageType type;
    readonly attribute unsigned long long lineNum;
    readonly attribute unsigned long long linePos;
    readonly attribute unsigned long long offset;
    readonly attribute unsigned long long length;
};

[Exposed=(Window, DedicatedWorker), Serializable, SecureContext]
interface GPUCompilationInfo {
    readonly attribute FrozenArray<GPUCompilationMessage> messages;
};
</script>

{{GPUCompilationMessage}}是由{{GPUShaderModule}}编译器生成的信息、警告或错误消息。 这些消息旨在让人类可读，以帮助开发人员诊断着色器{{GPUShaderModuleDescriptor/code}}的问题。每个消息可能对应于着色器代码中的单个点、着色器代码的子串，或者可能根本不对应于代码中的任何特定点。

{{GPUCompilationMessage}}具有以下属性：

<dl dfn-type=attribute dfn-for=GPUCompilationMessage>
    : <dfn>message</dfn>
    ::
        一个人类可读的包含着色器编译时产生的消息的字符串。

    : <dfn>type</dfn>
    ::
        消息的重要性级别。

    : <dfn>lineNum</dfn>
    ::
        {{GPUCompilationMessage/message}}对应的着色器代码中的行号。值是one-based，这样lineNum为1表示着色器{{GPUShaderModuleDescriptor/code}}的第一行。

        如果{{GPUCompilationMessage/message}}对应于子字符串，则它指向子字符串开始的行。如果消息不对应着色器代码中的任何特定点，则必须为0。

        问题：在[定义行是什么]时参考WGSL规范(https://gpuweb.github.io/gpuweb/wgsl/#comments)。

    : <dfn>linePos</dfn>
    ::
        从着色器{{GPUShaderModuleDescriptor/code}}的{{GPUCompilationMessage/lineNum}}行的开头到{{GPUCompilationMessage/message}}对应的子字符串的点或开头的偏移量，以UTF-16代码单元为单位。值是one-based，这样{{GPUCompilationMessage/linePos}}为1表示该行的第一个字符。

        如果{{GPUCompilationMessage/message}}对应于子字符串，则它指向子字符串的第一个UTF-16代码单元。如果消息不对应着色器代码中的任何特定点，则必须为0。

    : <dfn>offset</dfn>
    ::
        从UTF-16代码单元中的着色器{{GPUShaderModuleDescriptor/code}}的开头到{{GPUCompilationMessage/message}}对应的子字符串的点或开头的偏移量。必须引用与{{GPUCompilationMessage/lineNum}}和{{GPUCompilationMessage/linePos}}相同的位置。如果{{GPUCompilationMessage/message}}不对应着色器{{GPUShaderModuleDescriptor/code}}中的任何特定点，则必须为0。

    : <dfn>length</dfn>
    ::
        {{GPUCompilationMessage/message}}对应的子字符串中UTF-16代码单元的数量。如果消息与子字符串不对应，则{{GPUCompilationMessage/length}}必须为0。
</dl>

注意：{{GPUCompilationMessage}}.{{GPUCompilationMessage/lineNum}}和
{{GPUCompilationMessage}}.{{GPUCompilationMessage/linePos}}是one-based，因为它们最常见的用途是打印人类可读的消息，这些消息可以与许多文本编辑器中显示的行号和列号相关联。

注意：{{GPUCompilationMessage}}.{{GPUCompilationMessage/offset}}和{{GPUCompilationMessage}}.{{GPUCompilationMessage/length}}适合传递给 `substr()` 以检索{{GPUCompilationMessage/message}}对应的着色器{{GPUShaderModuleDescriptor/code}}的子字符串。

<dl dfn-type=method dfn-for=GPUShaderModule>
    : <dfn>compilationInfo()</dfn>
    ::
        返回{{GPUShaderModule}}编译时产生的任何消息。

        <div algorithm=GPUShaderModule.compilationInfo>
            **Called on:** {{GPUShaderModule}} this.

            **Returns:** {{Promise}}&lt;{{GPUCompilationInfo}}&gt;

            问题：描述{{GPUShaderModule/compilationInfo()}}算法步骤。
        </div>
</dl>

# Pipelines # {#pipelines}

A <dfn dfn>pipeline</dfn>, be it {{GPUComputePipeline}} or {{GPURenderPipeline}},
represents the complete function done by a combination of the GPU hardware, the driver,
and the user agent, that process the input data in the shape of bindings and vertex buffers,
and produces some output, like the colors in the output render targets.

Structurally, the [=pipeline=] consists of a sequence of programmable stages (shaders)
and fixed-function states, such as the blending modes.

Note: Internally, depending on the target platform,
the driver may convert some of the fixed-function states into shader code,
and link it together with the shaders provided by the user.
This linking is one of the reason the object is created as a whole.

This combination state is created as a single object
(by {{GPUDevice/createComputePipeline(descriptor)|GPUDevice.createComputePipeline()}} or {{GPUDevice/createRenderPipeline(descriptor)|GPUDevice.createRenderPipeline()}}),
and switched as one
(by {{GPUComputePassEncoder/setPipeline(pipeline)|GPUComputePassEncoder.setPipeline}} or {{GPURenderEncoderBase/setPipeline(pipeline)|GPURenderEncoderBase.setPipeline}} correspondingly).

## Base pipelines ## {#pipeline-base}

<script type=idl>
dictionary GPUPipelineDescriptorBase : GPUObjectDescriptorBase {
    GPUPipelineLayout layout;
};

interface mixin GPUPipelineBase {
    GPUBindGroupLayout getBindGroupLayout(unsigned long index);
};
</script>

{{GPUPipelineBase}} has the following internal slots:

<dl dfn-type=attribute dfn-for="GPUPipelineBase">
    : <dfn>\[[layout]]</dfn> of type `GPUPipelineLayout`.
    ::
        The definition of the layout of resources which can be used with `this`.
</dl>

{{GPUPipelineBase}} has the following methods:

<dl dfn-type=method dfn-for=GPUPipelineBase>
    : <dfn>getBindGroupLayout(index)</dfn>
    ::
        Gets a {{GPUBindGroupLayout}} that is compatible with the {{GPUPipelineBase}}'s
        {{GPUBindGroupLayout}} at `index`.

        <div algorithm=GPUPipelineBase.getBindGroupLayout>
            **Called on:** {{GPUPipelineBase}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUPipelineBase/getBindGroupLayout(index)">
                |index|: Index into the pipeline layout's {{GPUPipelineLayout/[[bindGroupLayouts]]}}
                    sequence.
            </pre>

            **Returns:** {{GPUBindGroupLayout}}

            1. If |index| &ge;
                |this|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxBindGroups}}:
                1. Throw a {{RangeError}}.

            1. If |this| is not [=valid=]:
                1. Return a new error {{GPUBindGroupLayout}}.

            1. Return a new {{GPUBindGroupLayout}} object that references the same internal object as
                |this|.{{GPUPipelineBase/[[layout]]}}.{{GPUPipelineLayout/[[bindGroupLayouts]]}}[|index|].

            Issue: Specify this more properly once we have internal objects for {{GPUBindGroupLayout}}.
                Alternatively only spec is as a new internal objects that's [=group-equivalent=]

            Note: Only returning new {{GPUBindGroupLayout}} objects ensures no synchronization is necessary
                between the [=Content timeline=] and the [=Device timeline=].
        </div>
</dl>

### Default pipeline layout ### {#default-pipeline-layout}

A {{GPUPipelineBase}} object that was created without a {{GPUPipelineDescriptorBase/layout}}
has a default layout created and used instead.

<div algorithm="default pipeline layout creation">

To create a <dfn abstract-op>default pipeline layout</dfn> for {{GPUPipelineBase}} |pipeline|,
run the following steps:

    1. Let |groupDescs| be a sequence of |device|.{{device/[[limits]]}}.{{supported limits/maxBindGroups}}
        new {{GPUBindGroupLayoutDescriptor}} objects.
    1. For each |groupDesc| in |groupDescs|:

        1. Set |groupDesc|.{{GPUBindGroupLayoutDescriptor/entries}} to an empty sequence.

    1. For each {{GPUProgrammableStage}} |stageDesc| in the descriptor used to create |pipeline|:

        1. Let |stageInfo| be the "reflection information" for |stageDesc|.

            Issue: Define the reflection information concept so that this spec can interface with the WGSL
                spec and get information what the interface is for a {{GPUShaderModule}} for a specific
                entrypoint.

        1. Let |shaderStage| be the {{GPUShaderStageFlags}} for |stageDesc|.{{GPUProgrammableStage/entryPoint}}
            in |stageDesc|.{{GPUProgrammableStage/module}}.
        1. For each resource |resource| in |stageInfo|'s resource interface:

            1. Let |group| be |resource|'s "group" decoration.
            1. Let |binding| be |resource|'s "binding" decoration.
            1. Let |entry| be a new {{GPUBindGroupLayoutEntry}}.
            1. Set |entry|.{{GPUBindGroupLayoutEntry/binding}} to |binding|.
            1. Set |entry|.{{GPUBindGroupLayoutEntry/visibility}} to |shaderStage|.
            1. If |resource| is for a sampler binding:

                1. Let |samplerLayout| be a new {{GPUSamplerBindingLayout}}.
                1. Set |entry|.{{GPUBindGroupLayoutEntry/sampler}} to |samplerLayout|.

            1. If |resource| is for a comparison sampler binding:

                1. Let |samplerLayout| be a new {{GPUSamplerBindingLayout}}.
                1. Set |samplerLayout|.{{GPUSamplerBindingLayout/type}} to {{GPUSamplerBindingType/"comparison"}}.
                1. Set |entry|.{{GPUBindGroupLayoutEntry/sampler}} to |samplerLayout|.

            1. If |resource| is for a buffer binding:

                1. Let |bufferLayout| be a new {{GPUBufferBindingLayout}}.

                1. Set |bufferLayout|.{{GPUBufferBindingLayout/minBindingSize}} to |resource|'s minimum buffer binding size.

                    Issue: link to a definition for "minimum buffer binding size" in the "reflection information".

                1. If |resource| is for a read-only storage buffer:

                    1. Set |bufferLayout|.{{GPUBufferBindingLayout/type}} to {{GPUBufferBindingType/"read-only-storage"}}.

                1. If |resource| is for a storage buffer:

                    1. Set |bufferLayout|.{{GPUBufferBindingLayout/type}} to {{GPUBufferBindingType/"storage"}}.

                1. Set |entry|.{{GPUBindGroupLayoutEntry/buffer}} to |bufferLayout|.

            1. If |resource| is for a sampled texture binding:

                1. Let |textureLayout| be a new {{GPUTextureBindingLayout}}.

                1. If |resource| is a depth texture binding:
                    - Set |textureLayout|.{{GPUTextureBindingLayout/sampleType}} to {{GPUTextureSampleType/"depth"}}

                    Else if the sampled type of |resource| is:

                    -
                        <dl class=switch>
                            : `f32` and |resource| is statically used with a textureSample* builtin in the shader
                            :: Set |textureLayout|.{{GPUTextureBindingLayout/sampleType}} to {{GPUTextureSampleType/"float"}}
                            : `f32` otherwise
                            :: Set |textureLayout|.{{GPUTextureBindingLayout/sampleType}} to {{GPUTextureSampleType/"unfilterable-float"}}
                            : `i32`
                            :: Set |textureLayout|.{{GPUTextureBindingLayout/sampleType}} to {{GPUTextureSampleType/"sint"}}
                            : `u32`
                            :: Set |textureLayout|.{{GPUTextureBindingLayout/sampleType}} to {{GPUTextureSampleType/"uint"}}
                        </dl>

                1. Set |textureLayout|.{{GPUTextureBindingLayout/viewDimension}} to |resource|'s dimension.
                1. If |resource| is for a multisampled texture:

                    1. Set |textureLayout|.{{GPUTextureBindingLayout/multisampled}} to `true`.

                1. Set |entry|.{{GPUBindGroupLayoutEntry/texture}} to |textureLayout|.

            1. If |resource| is for a storage texture binding:

                1. Let |storageTextureLayout| be a new {{GPUStorageTextureBindingLayout}}.
                1. Set |storageTextureLayout|.{{GPUStorageTextureBindingLayout/format}} to |resource|'s format.
                1. Set |storageTextureLayout|.{{GPUStorageTextureBindingLayout/viewDimension}} to |resource|'s dimension.

                1. If |resource| is for a write-only storage texture:

                    1. Set |storageTextureLayout|.{{GPUStorageTextureBindingLayout/access}} to {{GPUStorageTextureAccess/"write-only"}}.

                1. Set |entry|.{{GPUBindGroupLayoutEntry/storageTexture}} to |storageTextureLayout|.

            1. If |groupDescs|[|group|] has an entry |previousEntry| with {{GPUBindGroupLayoutEntry/binding}} equal to |binding|:

                1. If |entry| has different {{GPUBindGroupLayoutEntry/visibility}} than |previousEntry|:

                    1. Add the bits set in |entry|.{{GPUBindGroupLayoutEntry/visibility}} into |previousEntry|.{{GPUBindGroupLayoutEntry/visibility}}

                1. If |resource| is for a buffer binding and |entry| has greater
                    {{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/minBindingSize}}
                    than |previousEntry|:

                    1. Set |previousEntry|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/minBindingSize}}
                        to |entry|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/minBindingSize}}.

                1. If |resource| is a sampled texture binding and |entry| has different
                    {{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/sampleType}} than |previousEntry|
                    and both |entry| and |previousEntry| have {{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/sampleType}}
                    of either {{GPUTextureSampleType/"float"}} or {{GPUTextureSampleType/"unfilterable-float"}}:
                    1. Set |previousEntry|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/sampleType}} to
                        {{GPUTextureSampleType/"float"}}.

                1. If any other property is unequal between |entry| and |previousEntry|:

                    1. Return `null` (which will cause the creation of the pipeline to fail).

            1. Else

                1. Append |entry| to |groupDescs|[|group|].

    1. Let |groupLayouts| be a new sequence.
    1. For each |groupDesc| in |groupDescs|:

        1. Let |bindGroupLayout| be the result of calling |device|.{{GPUDevice/createBindGroupLayout()}}(|groupDesc|).
        1. Set |bindGroupLayout|.{{GPUBindGroupLayout/[[exclusivePipeline]]}} to |pipeline|.
        1. Append |bindGroupLayout| to |groupLayouts|.

    1. Let |desc| be a new {{GPUPipelineLayoutDescriptor}}.
    1. Set |desc|.{{GPUPipelineLayoutDescriptor/bindGroupLayouts}} to |groupLayouts|.
    1. Return |device|.{{GPUDevice/createPipelineLayout()}}(|desc|).

    Issue: This fills the pipeline layout with empty bindgroups. Revisit once the behavior of empty bindgroups is specified.

</div>

### <dfn dictionary>GPUProgrammableStage</dfn> ### {#GPUProgrammableStage}

A {{GPUProgrammableStage}} describes the entry point in the user-provided
{{GPUShaderModule}} that controls one of the programmable stages of a [=pipeline=].

<script type=idl>
dictionary GPUProgrammableStage {
    required GPUShaderModule module;
    required USVString entryPoint;
    record<USVString, GPUPipelineConstantValue> constants;
};

typedef double GPUPipelineConstantValue; // May represent WGSL's bool, f32, i32, u32.
</script>

<dl dfn-for=GPUProgrammableStage dfn-type=dict-member>
    : <dfn>constants</dfn>
    ::
        Specifies the values of [=pipeline-overridable=] constants in the shader module
        {{GPUProgrammableStage/module}}.

        Each such [=pipeline-overridable=] constant is uniquely identified by a single
        [=pipeline-overridable constant identifier string=] (representing the numeric ID of the
        constant, if one is specified, and otherwise the constant's identifier name).

        The key of each key-value pair must equal the identifier string of one such constant.
        When the pipeline is executed, that constant will have the specified value.

        Values are specified as <dfn typedef for=>GPUPipelineConstantValue</dfn>, which is a
        `double` which is converted to the WGSL data type of the corresponding pipeline-overridable
        constant (`bool`, `i32`, `u32`, or `f32`) via [=converted to an IDL value|an IDL value=]
        ({{boolean}}, {{long}}, {{unsigned long}}, or {{float}}).

        <div class=example>
            Pipeline-overridable constants defined in WGSL:

            <pre highlight=rust>
                [[override(0)]]    let has_point_light: bool = true; // Algorithmic control.
                [[override(1200)]] let specular_param: f32 = 2.3;    // Numeric control.
                [[override(1300)]] let gain: f32;                    // Must be overridden.
                [[override]]       let width: f32 = 0.0;             // Specifed at the API level
                                                                     //   using the name "width".
                [[override]]       let depth: f32;                   // Specifed at the API level
                                                                     //   using the name "depth".
                                                                     //   Must be overridden.
            </pre>

            Corresponding JavaScript code, providing only the overrides which are required
            (have no defaults):

            <pre highlight=js>
                {
                    // ...
                    constants: {
                        1300: 2.0,  // "gain"
                        depth: -1,  // "depth"
                    }
                }
            </pre>

            Corresponding JavaScript code, overriding all constants:

            <pre highlight=js>
                {
                    // ...
                    constants: {
                        0: false,   // "has_point_light"
                        1200: 3.0,  // "specular_param"
                        1300: 2.0,  // "gain"
                        width: 20,  // "width"
                        depth: -1,  // "depth"
                    }
                }
            </pre>
        </div>
</dl>

<div>
    <dfn abstract-op>validating GPUProgrammableStage</dfn>(stage, descriptor, layout)

    **Arguments:**
    - {{GPUShaderStage}} |stage|
    - {{GPUProgrammableStage}} |descriptor|
    - {{GPUPipelineLayout}} |layout|

    Return `true` if all of the following conditions are met:

    - |descriptor|.{{GPUProgrammableStage/module}} must be a [=valid=] {{GPUShaderModule}}.
    - |descriptor|.{{GPUProgrammableStage/module}} must contain
        an entry point, for shader stage |stage|,
        named |descriptor|.{{GPUProgrammableStage/entryPoint}}.
    - For each |binding| that is [=statically used=] by the shader entry point:
        - [$validating shader binding$](|binding|, |layout|) must return `true`.
    - For each texture sampling shader call that is [=statically used=] by the entry point:
        1. Let |texture| be the {{GPUBindGroupLayoutEntry}} corresponding to the sampled texture in the call.
        1. Let |sampler| be the {{GPUBindGroupLayoutEntry}} corresponding to the used sampler in the call.
        1. If |sampler|.{{GPUSamplerBindingLayout/type}} is {{GPUSamplerBindingType/"filtering"}},
            then |texture|.{{GPUTextureBindingLayout/sampleType}} must not be
            {{GPUTextureSampleType/"unfilterable-float"}}.
    - For each |key| in [=map/get the keys|the keys=] of
        |descriptor|.{{GPUProgrammableStage/constants}}:
        - |key| must equal the [=pipeline-overridable constant identifier string=] of
            some [=pipeline-overridable=] constant defined in the shader module
            |descriptor|.{{GPUProgrammableStage/module}}.
    - For each [=pipeline-overridable constant identifier string=] |key| which is
        [=statically accessed=] by the shader entry point:
        - If the pipeline-overridable constant identified by |key|
            [=pipeline-overridable constant has a default value|does not have a default value=],
            |descriptor|.{{GPUProgrammableStage/constants}} must [=map/contain=] |key|.
</div>

<div>
    <dfn abstract-op>validating shader binding</dfn>(binding, layout)

    **Arguments:**
        - shader binding declaration |variable|, a module-scope variable declaration reflected from a shader module
        - {{GPUPipelineLayout}} |layout|

    Let |bindGroup| be the bind group index, and |bindIndex| be the binding index,
    of the shader binding declaration |variable|.

    Return `true` if all of the following conditions are satisfied:

        - |layout|.{{GPUPipelineLayout/[[bindGroupLayouts]]}}[|bindGroup|] contains
            a {{GPUBindGroupLayoutEntry}} |entry| whose |entry|.{{GPUBindGroupLayoutEntry/binding}} == |bindIndex|.
        - If the defined [=binding member=] for |entry| is:
            <dl class=switch>
                : {{GPUBindGroupLayoutEntry/buffer}}
                ::
                    If |entry|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/type}} is:
                    <dl class=switch>
                        : {{GPUBufferBindingType/"uniform"}}
                        :: |variable| is declared with the storage class `uniform`.
                        : {{GPUBufferBindingType/"storage"}}
                        :: |variable| is declared with the storage class `storage` and access mode `read_write`.
                        : {{GPUBufferBindingType/"read-only-storage"}}
                        :: |variable| is declared with the storage class `storage` and access mode `read`.
                    </dl>
                ::
                    If |entry|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/minBindingSize}} is not `0`:
                    - If the last field of the corresponding structure defined in the shader has an unbounded array type,
                        then the value of |entry|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/minBindingSize}}
                        must be greater than or equal to the byte offset of that field plus the stride of the unbounded array.
                    - If the corresponding shader structure doesn't end with an unbounded array type,
                        then the value of |entry|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/minBindingSize}}
                        must be greater than or equal to the size of the structure.

                : {{GPUBindGroupLayoutEntry/sampler}}
                ::
                    If |entry|.{{GPUBindGroupLayoutEntry/sampler}}.{{GPUSamplerBindingLayout/type}} is:
                    <dl class=switch>
                        : {{GPUSamplerBindingType/"filtering"}} or {{GPUSamplerBindingType/"non-filtering"}}
                        :: |variable| has type `sampler`.
                        : {{GPUSamplerBindingType/"comparison"}}
                        :: |variable| has type `comparison_sampler`.
                    </dl>

                : {{GPUBindGroupLayoutEntry/texture}}
                ::
                    If, and only if,
                    |entry|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/multisampled}}
                    is `true`, |variable| has type `texture_multisampled_2d<T>` or `texture_depth_multisampled_2d<T>`.
                ::
                    If |entry|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/sampleType}} is:
                    <dl class=switch>
                        : {{GPUTextureSampleType/"float"}}, {{GPUTextureSampleType/"unfilterable-float"}},
                            {{GPUTextureSampleType/"sint"}} or {{GPUTextureSampleType/"uint"}}
                        ::
                            |variable| has type `texture_1d<T>`, `texture_2d<T>`, `texture_2d_array<T>`,
                            `texture_cube<T>`, `texture_cube_array<T>`, `texture_3d<T>`, or
                            `texture_multisampled_2d<T>`.
                        ::
                            If |entry|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/sampleType}} is:
                            <dl class=switch>
                                : {{GPUTextureSampleType/"float"}} or {{GPUTextureSampleType/"unfilterable-float"}}
                                :: The sampled type `T` is `f32`.
                                : {{GPUTextureSampleType/"sint"}}
                                :: The sampled type `T` is `i32`.
                                : {{GPUTextureSampleType/"uint"}}
                                :: The sampled type `T` is `u32`.
                            </dl>

                        : {{GPUTextureSampleType/"depth"}}
                        ::
                            |variable| has type `texture_depth_2d`, `texture_depth_2d_array`,
                            `texture_depth_cube`, `texture_depth_cube_array`, or `texture_depth_multisampled_2d`.
                    </dl>
                ::
                    If |entry|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/viewDimension}} is:
                    <dl class=switch>
                        : {{GPUTextureViewDimension/"1d"}}
                        :: |variable| has type `texture_1d<T>`.
                        : {{GPUTextureViewDimension/"2d"}}
                        :: |variable| has type `texture_2d<T>` or `texture_multisampled_2d<T>`.
                        : {{GPUTextureViewDimension/"2d-array"}}
                        :: |variable| has type `texture_2d_array<T>`.
                        : {{GPUTextureViewDimension/"cube"}}
                        :: |variable| has type `texture_cube<T>`.
                        : {{GPUTextureViewDimension/"cube-array"}}
                        :: |variable| has type `texture_cube_array<T>`.
                        : {{GPUTextureViewDimension/"3d"}}
                        :: |variable| has type `texture_3d<T>`.
                    </dl>

                : {{GPUBindGroupLayoutEntry/storageTexture}}
                ::
                    If |entry|.{{GPUBindGroupLayoutEntry/storageTexture}}.{{GPUStorageTextureBindingLayout/viewDimension}} is:
                    <dl class=switch>
                        : {{GPUTextureViewDimension/"1d"}}
                        :: |variable| has type `texture_storage_1d<T, A>`.
                        : {{GPUTextureViewDimension/"2d"}}
                        :: |variable| has type `texture_storage_2d<T, A>`.
                        : {{GPUTextureViewDimension/"2d-array"}}
                        :: |variable| has type `texture_storage_2d_array<T, A>`.
                        : {{GPUTextureViewDimension/"3d"}}
                        :: |variable| has type `texture_storage_3d<T, A>`.
                    </dl>
                ::
                    If |entry|.{{GPUBindGroupLayoutEntry/storageTexture}}.{{GPUStorageTextureBindingLayout/access}} is:
                    <dl class=switch>
                        : {{GPUStorageTextureAccess/"write-only"}}
                        :: The access mode `A` is `write`.
                    </dl>
                ::
                    The texel format `T` equals
                    |entry|.{{GPUBindGroupLayoutEntry/storageTexture}}.{{GPUStorageTextureBindingLayout/format}}.
            </dl>
</div>

A resource binding is considered to be <dfn dfn>statically used</dfn> by a shader entry point
if and only if it's reachable by the control flow graph of the shader module,
starting at the entry point.

## <dfn interface>GPUComputePipeline</dfn> ## {#compute-pipeline}

A {{GPUComputePipeline}} is a kind of [=pipeline=] that controls the compute shader stage,
and can be used in {{GPUComputePassEncoder}}.

Compute inputs and outputs are all contained in the bindings,
according to the given {{GPUPipelineLayout}}.
The outputs correspond to {{GPUBindGroupLayoutEntry/buffer}} bindings with a type of {{GPUBufferBindingType/"storage"}}
and {{GPUBindGroupLayoutEntry/storageTexture}} bindings with a type of {{GPUStorageTextureAccess/"write-only"}}.

Stages of a compute [=pipeline=]:
  1. Compute shader

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUComputePipeline {
};
GPUComputePipeline includes GPUObjectBase;
GPUComputePipeline includes GPUPipelineBase;
</script>

### Creation ### {#compute-pipeline-creation}

<script type=idl>
dictionary GPUComputePipelineDescriptor : GPUPipelineDescriptorBase {
    required GPUProgrammableStage compute;
};
</script>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createComputePipeline(descriptor)</dfn>
    ::
        Creates a {{GPUComputePipeline}}.

        <div algorithm=GPUDevice.createComputePipeline>
            **Called on:** {{GPUDevice}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/createComputePipeline(descriptor)">
                |descriptor|: Description of the {{GPUComputePipeline}} to create.
            </pre>

            **Returns:** {{GPUComputePipeline}}

            1. Let |pipeline| be a new valid {{GPUComputePipeline}} object.
            1. Issue the following steps on the [=Device timeline=] of |this|:
                <div class=device-timeline>
                    1. If any of the following conditions are unsatisfied:
                        <div class=validusage>
                            - |descriptor|.{{GPUPipelineDescriptorBase/layout}} is [$valid to use with$] |this|.
                            - [$validating GPUProgrammableStage$]({{GPUShaderStage/COMPUTE}},
                                |descriptor|.{{GPUComputePipelineDescriptor/compute}},
                                |descriptor|.{{GPUPipelineDescriptorBase/layout}}) succeeds.
                            - |descriptor|.{{GPUComputePipelineDescriptor/compute}} uses &le;
                                |device|.limits.{{supported limits/maxComputeWorkgroupStorageSize}} bytes of
                                workgroup storage.

                                Issue: Better define using static use, etc.
                            - |descriptor|.{{GPUComputePipelineDescriptor/compute}} uses &le;
                                |device|.limits.{{supported limits/maxComputeInvocationsPerWorkgroup}} per
                                workgroup.

                            - |descriptor|.{{GPUComputePipelineDescriptor/compute}}'s `workgroup_size` attribute
                                has each component &le; the corresponding component in
                                [|device|.limits.{{supported limits/maxComputeWorkgroupSizeX}},
                                |device|.limits.{{supported limits/maxComputeWorkgroupSizeY}},
                                |device|.limits.{{supported limits/maxComputeWorkgroupSizeZ}}].
                        </div>

                        Then:
                            1. Generate a {{GPUValidationError}} in the current scope with appropriate
                                error message.
                            1. Make |pipeline| [=invalid=].

                    1. If |descriptor|.{{GPUPipelineDescriptorBase/layout}} is `undefined`:
                        1. Set |pipeline|.{{GPUPipelineBase/[[layout]]}} to a new [$default pipeline layout$]
                            for |pipeline|.

                        Otherwise set |pipeline|.{{GPUPipelineBase/[[layout]]}} to |descriptor|.{{GPUPipelineDescriptorBase/layout}}.
                </div>
            1. Return |pipeline|.

        </div>

    : <dfn>createComputePipelineAsync(descriptor)</dfn>
    ::
        Creates a {{GPUComputePipeline}}. The returned {{Promise}} resolves when the created pipeline
        is ready to be used without additional delay.

        If pipeline creation fails, the returned {{Promise}} rejects with an {{OperationError}}.

        Note: Use of this method is preferred whenever possible, as it prevents blocking the
        [=queue timeline=] work on pipeline compilation.

        <div algorithm=GPUDevice.createComputePipelineAsync>
            **Called on:** {{GPUDevice}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/createComputePipelineAsync(descriptor)">
                |descriptor|: Description of the {{GPUComputePipeline}} to create.
            </pre>

            **Returns:** {{Promise}}&lt;{{GPUComputePipeline}}&gt;

            1. Let |promise| be [=a new promise=].
            1. Issue the following steps on the [=Device timeline=] of |this|:
                <div class=device-timeline>
                    1. Let |pipeline| be a new {{GPUComputePipeline}} created as if
                        |this|.{{GPUDevice/createComputePipeline()}} was called with |descriptor|;

                    1. When |pipeline| is ready to be used, [=resolve=] |promise| with |pipeline|.
                </div>
            1. Return |promise|.
        </div>
</dl>

## <dfn interface>GPURenderPipeline</dfn> ## {#render-pipeline}

A {{GPURenderPipeline}} is a kind of [=pipeline=] that controls the vertex
and fragment shader stages, and can be used in {{GPURenderPassEncoder}}
as well as {{GPURenderBundleEncoder}}.

Render [=pipeline=] inputs are:
  - bindings, according to the given {{GPUPipelineLayout}}
  - vertex and index buffers, described by {{GPUVertexState}}
  - the color attachments, described by {{GPUColorTargetState}}
  - optionally, the depth-stencil attachment, described by {{GPUDepthStencilState}}

Render [=pipeline=] outputs are:
  - {{GPUBindGroupLayoutEntry/buffer}} bindings with a {{GPUBufferBindingLayout/type}} of {{GPUBufferBindingType/"storage"}}
  - {{GPUBindGroupLayoutEntry/storageTexture}} bindings with a {{GPUStorageTextureBindingLayout/access}} of {{GPUStorageTextureAccess/"write-only"}}
  - the color attachments, described by {{GPUColorTargetState}}
  - optionally, depth-stencil attachment, described by {{GPUDepthStencilState}}

A render [=pipeline=] is comprised of the following <dfn dfn>render stages</dfn>:
  1. Vertex fetch, controlled by {{GPUVertexState/buffers|GPUVertexState.buffers}}
  2. Vertex shader, controlled by {{GPUVertexState}}
  3. Primitive assembly, controlled by {{GPUPrimitiveState}}
  4. Rasterization, controlled by {{GPUPrimitiveState}}, {{GPUDepthStencilState}}, and {{GPUMultisampleState}}
  5. Fragment shader, controlled by {{GPUFragmentState}}
  6. Stencil test and operation, controlled by {{GPUDepthStencilState}}
  7. Depth test and write, controlled by {{GPUDepthStencilState}}
  8. Output merging, controlled by {{GPUFragmentState/targets|GPUFragmentState.targets}}

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPURenderPipeline {
};
GPURenderPipeline includes GPUObjectBase;
GPURenderPipeline includes GPUPipelineBase;
</script>

{{GPURenderPipeline}} has the following internal slots:

<dl dfn-type=attribute dfn-for=GPURenderPipeline>
    : <dfn>\[[descriptor]]</dfn>, of type {{GPURenderPipelineDescriptor}}
    ::
        The {{GPURenderPipelineDescriptor}} describing this pipeline.

        All optional fields of {{GPURenderPipelineDescriptor}} are defined.

    : <dfn>\[[strip_index_format]]</dfn>, of type {{GPUIndexFormat}}?
    ::
        The format index data this pipeline requires if using a strip primitive topology,
        initially `undefined`.

    : <dfn>\[[writesDepth]]</dfn>, of type boolean
    :: True if the pipeline writes to the depth component of the depth/stencil attachment

    : <dfn>\[[writesStencil]]</dfn>, of type boolean
    :: True if the pipeline writes to the stencil component of the depth/stencil attachment
</dl>

### Creation ### {#render-pipeline-creation}

<script type=idl>
dictionary GPURenderPipelineDescriptor : GPUPipelineDescriptorBase {
    required GPUVertexState vertex;
    GPUPrimitiveState primitive = {};
    GPUDepthStencilState depthStencil;
    GPUMultisampleState multisample = {};
    GPUFragmentState fragment;
};
</script>

A {{GPURenderPipelineDescriptor}} describes the state of a render [=pipeline=] by
configuring each of the [=render stages=]. See [[#rendering-operations]] for the
details.

- {{GPURenderPipelineDescriptor/vertex}} describes
    the vertex shader entry point of the [=pipeline=] and its input buffer layouts.
- {{GPURenderPipelineDescriptor/primitive}} describes the
    the primitive-related properties of the [=pipeline=].
- {{GPURenderPipelineDescriptor/depthStencil}} describes
    the optional depth-stencil properties, including the testing, operations, and bias.
- {{GPURenderPipelineDescriptor/multisample}} describes
    the multi-sampling properties of the [=pipeline=].
- {{GPURenderPipelineDescriptor/fragment}} describes
    the fragment shader entry point of the [=pipeline=] and its output colors.
    If it's `null`, the [[#no-color-output]] mode is enabled.

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createRenderPipeline(descriptor)</dfn>
    ::
        Creates a {{GPURenderPipeline}}.

        <div algorithm=GPUDevice.createRenderPipeline>
            **Called on:** {{GPUDevice}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/createRenderPipeline(descriptor)">
                |descriptor|: Description of the {{GPURenderPipeline}} to create.
            </pre>

            **Returns:** {{GPURenderPipeline}}

            1. Let |pipeline| be a new valid {{GPURenderPipeline}} object.
            1. Issue the following steps on the [=Device timeline=] of |this|:
                <div class=device-timeline>
                    1. If any of the following conditions are unsatisfied:
                        <div class=validusage>
                            - |descriptor|.{{GPUPipelineDescriptorBase/layout}} is [$valid to use with$] |this|.
                            - [$validating GPURenderPipelineDescriptor$](|descriptor|, |this|) succeeds.
                        </div>

                        Then:
                            1. Generate a {{GPUValidationError}} in the current scope with appropriate
                                error message.
                            1. Make |pipeline| [=invalid=].

                    1. Set |pipeline|.{{GPURenderPipeline/[[descriptor]]}} to |descriptor|.
                    1. Set |pipeline|.{{GPURenderPipeline/[[strip_index_format]]}} to
                        |descriptor|.{{GPURenderPipelineDescriptor/primitive}}.{{GPUPrimitiveState/stripIndexFormat}}.
                    1. Set |pipeline|.{{GPURenderPipeline/[[writesDepth]]}} to false.
                    1. Set |pipeline|.{{GPURenderPipeline/[[writesStencil]]}} to false.
                    1. Let |depthStencil| be |descriptor|.{{GPURenderPipelineDescriptor/depthStencil}}.
                    1. If |depthStencil| is not null:
                        1. Set |pipeline|.{{GPURenderPipeline/[[writesDepth]]}} to |depthStencil|.{{GPUDepthStencilState/depthWriteEnabled}}.
                        1. If |depthStencil|.{{GPUDepthStencilState/stencilWriteMask}} is not 0:
                            1. Let |stencilFront| be |depthStencil|.{{GPUDepthStencilState/stencilFront}}.
                            1. Let |stencilBack| be |depthStencil|.{{GPUDepthStencilState/stencilBack}}.
                            1. Let |cullMode| be |descriptor|.{{GPURenderPipelineDescriptor/primitive}}.{{GPUPrimitiveState/cullMode}}.
                            1. If |cullMode| is not {{GPUCullMode/"front"}}, and any of |stencilFront|.{{GPUStencilFaceState/passOp}},
                                |stencilFront|.{{GPUStencilFaceState/depthFailOp}}, or |stencilFront|.{{GPUStencilFaceState/failOp}}
                                is not {{GPUStencilOperation/"keep"}}:
                                1. Set |pipeline|.{{GPURenderPipeline/[[writesStencil]]}} to true.
                            1. If |cullMode| is not {{GPUCullMode/"back"}}, and any of |stencilBack|.{{GPUStencilFaceState/passOp}},
                                |stencilBack|.{{GPUStencilFaceState/depthFailOp}}, or |stencilBack|.{{GPUStencilFaceState/failOp}}
                                is not {{GPUStencilOperation/"keep"}}:
                                1. Set |pipeline|.{{GPURenderPipeline/[[writesStencil]]}} to true.
                    1. If |descriptor|.{{GPUPipelineDescriptorBase/layout}} is `undefined`:
                        1. Set |pipeline|.{{GPUPipelineBase/[[layout]]}} to a new [$default pipeline layout$]
                            for |pipeline|.

                        Otherwise set |pipeline|.{{GPUPipelineBase/[[layout]]}} to |descriptor|.{{GPUPipelineDescriptorBase/layout}}.
                </div>
            1. Return |pipeline|.

            Issue: need description of the render states.
        </div>

    : <dfn>createRenderPipelineAsync(descriptor)</dfn>
    ::
        Creates a {{GPURenderPipeline}}. The returned {{Promise}} resolves when the created pipeline
        is ready to be used without additional delay.

        If pipeline creation fails, the returned {{Promise}} rejects with an {{OperationError}}.

        Note: Use of this method is preferred whenever possible, as it prevents blocking the
        [=queue timeline=] work on pipeline compilation.

        <div algorithm=GPUDevice.createRenderPipelineAsync>
            **Called on:** {{GPUDevice}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/createRenderPipelineAsync(descriptor)">
                |descriptor|: Description of the {{GPURenderPipeline}} to create.
            </pre>

            **Returns:** {{Promise}}&lt;{{GPURenderPipeline}}&gt;

            1. Let |promise| be [=a new promise=].
            1. Issue the following steps on the [=Device timeline=] of |this|:
                <div class=device-timeline>
                    1. Let |pipeline| be a new {{GPURenderPipeline}} created as if
                        |this|.{{GPUDevice/createRenderPipeline()}} was called with |descriptor|;

                    1. When |pipeline| is ready to be used, [=resolve=] |promise| with |pipeline|.
                </div>
            1. Return |promise|.
        </div>
</dl>

<div>
    <dfn abstract-op>validating GPURenderPipelineDescriptor</dfn>(descriptor, device)
        **Arguments:**
            - {{GPURenderPipelineDescriptor}} |descriptor|
            - {{GPUDevice}} |device|

        Return `true` if all of the following conditions are satisfied:

            - [$validating GPUProgrammableStage$]({{GPUShaderStage/VERTEX}},
                |descriptor|.{{GPURenderPipelineDescriptor/vertex}},
                |descriptor|.{{GPUPipelineDescriptorBase/layout}}) succeeds.
            - [$validating GPUVertexState$](|device|, |descriptor|.{{GPURenderPipelineDescriptor/vertex}},
                |descriptor|.{{GPURenderPipelineDescriptor/vertex}}) succeeds.
            - If |descriptor|.{{GPURenderPipelineDescriptor/fragment}} is not `null`:
                - [$validating GPUProgrammableStage$]({{GPUShaderStage/FRAGMENT}},
                    |descriptor|.{{GPURenderPipelineDescriptor/fragment}},
                    |descriptor|.{{GPUPipelineDescriptorBase/layout}}) succeeds.
                - [$validating GPUFragmentState$](|descriptor|.{{GPURenderPipelineDescriptor/fragment}}) succeeds.
                - If the "sample_mask" [=builtin=] is a [=pipeline output=] of |descriptor|.{{GPURenderPipelineDescriptor/fragment}}:
                    - |descriptor|.{{GPURenderPipelineDescriptor/multisample}}.{{GPUMultisampleState/alphaToCoverageEnabled}} is `false`.
            - [$validating GPUPrimitiveState$](|descriptor|.{{GPURenderPipelineDescriptor/primitive}}, |device|.{{device/[[features]]}}) succeeds.
            - if |descriptor|.{{GPURenderPipelineDescriptor/depthStencil}} is not `null`:
                - [$validating GPUDepthStencilState$](|descriptor|.{{GPURenderPipelineDescriptor/depthStencil}}) succeeds.
            - [$validating GPUMultisampleState$](|descriptor|.{{GPURenderPipelineDescriptor/multisample}}) succeeds.
            - For each user-defined output of
                |descriptor|.{{GPURenderPipelineDescriptor/vertex}} there must
                be a user-defined input of
                |descriptor|.{{GPURenderPipelineDescriptor/fragment}} that
                matches the
                [=location=],
                type, and
                [=interpolation=]
                of the output.
            - For each user-defined input of
                |descriptor|.{{GPURenderPipelineDescriptor/fragment}} there
                must be a user-defined output of
                |descriptor|.{{GPURenderPipelineDescriptor/vertex}} that
                [=location=],
                type, and
                [=interpolation=]
                of the input.
            - There is less than |device|.limits.{{supported limits/maxInterStageShaderComponents}}
                components of user-defined outputs for |descriptor|.{{GPURenderPipelineDescriptor/vertex}}.
            - There is less than |device|.limits.{{supported limits/maxInterStageShaderComponents}}
                components of user-defined inputs for |descriptor|.{{GPURenderPipelineDescriptor/fragment}}.
</div>

Issue: should we validate that `cullMode` is none for points and lines?

Issue: define what "compatible" means for render target formats.

Issue: need a proper limit for the maximum number of color targets.

### Primitive State ### {#primitive-state}

<script type=idl>
enum GPUPrimitiveTopology {
    "point-list",
    "line-list",
    "line-strip",
    "triangle-list",
    "triangle-strip"
};
</script>

<script type=idl>
dictionary GPUPrimitiveState {
    GPUPrimitiveTopology topology = "triangle-list";
    GPUIndexFormat stripIndexFormat;
    GPUFrontFace frontFace = "ccw";
    GPUCullMode cullMode = "none";

    // Enable depth clamping (requires "depth-clamping" feature)
    boolean clampDepth = false;
};
</script>

<div>
    <dfn abstract-op>validating GPUPrimitiveState</dfn>(|descriptor|, |features|)
        **Arguments:**
            - {{GPUPrimitiveState}} |descriptor|
            - [=list=]&lt;{{GPUFeatureName}}&gt; |features|

        Return `true` if all of the following conditions are satisfied:
            - If |descriptor|.{{GPUPrimitiveState/topology}} is:
                <dl class="switch">
                    : {{GPUPrimitiveTopology/"line-strip"}} or
                        {{GPUPrimitiveTopology/"triangle-strip"}}
                    :: |descriptor|.{{GPUPrimitiveState/stripIndexFormat}} is not `undefined`
                    : Otherwise
                    :: |descriptor|.{{GPUPrimitiveState/stripIndexFormat}} is `undefined`
                </dl>
            - If |descriptor|.{{GPUPrimitiveState/clampDepth}} is `true`:
                - |features| must [=list/contain=] {{GPUFeatureName/"depth-clamping"}}.
</div>

<script type=idl>
enum GPUFrontFace {
    "ccw",
    "cw"
};
</script>

<script type=idl>
enum GPUCullMode {
    "none",
    "front",
    "back"
};
</script>

### Multisample State ### {#multisample-state}

<script type=idl>
dictionary GPUMultisampleState {
    GPUSize32 count = 1;
    GPUSampleMask mask = 0xFFFFFFFF;
    boolean alphaToCoverageEnabled = false;
};
</script>

<div>
    <dfn abstract-op>validating GPUMultisampleState</dfn>(|descriptor|)
        **Arguments:**
            - {{GPUMultisampleState}} |descriptor|

        Return `true` if all of the following conditions are satisfied:
            - If |descriptor|.{{GPUMultisampleState/alphaToCoverageEnabled}} is `true`:
                - |descriptor|.{{GPUMultisampleState/count}} is greater than 1.
</div>

### Fragment State ### {#fragment-state}

<script type=idl>
dictionary GPUFragmentState: GPUProgrammableStage {
    required sequence<GPUColorTargetState> targets;
};
</script>

<div>
    <dfn abstract-op>validating GPUFragmentState</dfn>(|descriptor|)
        Return `true` if all of the following requirements are met:

        - |descriptor|.{{GPUFragmentState/targets}}.length must be &le; 8.
        - For each |colorState| layout descriptor in the list |descriptor|.{{GPUFragmentState/targets}}:
            - |colorState|.{{GPUColorTargetState/format}} must be listed in [[#plain-color-formats]]
                with {{GPUTextureUsage/RENDER_ATTACHMENT}} capability.
            - If |colorState|.{{GPUColorTargetState/blend}} is not `undefined`:
                - The |colorState|.{{GPUColorTargetState/format}} must be filterable
                    according to the [[#plain-color-formats]] table.
                - |colorState|.{{GPUColorTargetState/blend}}.{{GPUBlendState/color}}
                    must be a [=valid GPUBlendComponent=].
                - |colorState|.{{GPUColorTargetState/blend}}.{{GPUBlendState/alpha}}
                    must be a [=valid GPUBlendComponent=].
            - |colorState|.{{GPUColorTargetState/writeMask}} must be &lt; 16.
            - If |descriptor|.{{GPUProgrammableStage/entryPoint}} has a [=pipeline output=] value
                with [=location=] attribute equal to the index of the |colorState|
                in the |descriptor|.{{GPUFragmentState/targets}} list:
                - The [=pipeline output=] type must be compatible with |colorState|.{{GPUColorTargetState/format}}.

                Otherwise:
                - |colorState|.{{GPUColorTargetState/writeMask}} must be 0.
</div>

<div>
    |component| is a <dfn>valid GPUBlendComponent</dfn> if it meets the following requirements:

    - If |component|.{{GPUBlendComponent/operation}} is
        {{GPUBlendOperation/"min"}} or {{GPUBlendOperation/"max"}}:
        - |component|.{{GPUBlendComponent/srcFactor}} and
            |component|.{{GPUBlendComponent/dstFactor}} must both be {{GPUBlendFactor/"one"}}.
</div>

Issue: define the area of reach for "statically used" things of `GPUProgrammableStage`

### Color Target State ### {#color-target-state}

<script type=idl>
dictionary GPUColorTargetState {
    required GPUTextureFormat format;

    GPUBlendState blend;
    GPUColorWriteFlags writeMask = 0xF;  // GPUColorWrite.ALL
};
</script>

<script type=idl>
dictionary GPUBlendState {
    required GPUBlendComponent color;
    required GPUBlendComponent alpha;
};
</script>

<script type=idl>
typedef [EnforceRange] unsigned long GPUColorWriteFlags;
[Exposed=(Window, DedicatedWorker)]
namespace GPUColorWrite {
    const GPUFlagsConstant RED   = 0x1;
    const GPUFlagsConstant GREEN = 0x2;
    const GPUFlagsConstant BLUE  = 0x4;
    const GPUFlagsConstant ALPHA = 0x8;
    const GPUFlagsConstant ALL   = 0xF;
};
</script>

#### Blend State #### {#blend-state}

<script type=idl>
dictionary GPUBlendComponent {
    GPUBlendOperation operation = "add";
    GPUBlendFactor srcFactor = "one";
    GPUBlendFactor dstFactor = "zero";
};
</script>

<script type=idl>
enum GPUBlendFactor {
    "zero",
    "one",
    "src",
    "one-minus-src",
    "src-alpha",
    "one-minus-src-alpha",
    "dst",
    "one-minus-dst",
    "dst-alpha",
    "one-minus-dst-alpha",
    "src-alpha-saturated",
    "constant",
    "one-minus-constant"
};
</script>

<script type=idl>
enum GPUBlendOperation {
    "add",
    "subtract",
    "reverse-subtract",
    "min",
    "max"
};
</script>

### Depth/Stencil State ### {#depth-stencil-state}

<script type=idl>
dictionary GPUDepthStencilState {
    required GPUTextureFormat format;

    boolean depthWriteEnabled = false;
    GPUCompareFunction depthCompare = "always";

    GPUStencilFaceState stencilFront = {};
    GPUStencilFaceState stencilBack = {};

    GPUStencilValue stencilReadMask = 0xFFFFFFFF;
    GPUStencilValue stencilWriteMask = 0xFFFFFFFF;

    GPUDepthBias depthBias = 0;
    float depthBiasSlopeScale = 0;
    float depthBiasClamp = 0;
};
</script>

<script type=idl>
dictionary GPUStencilFaceState {
    GPUCompareFunction compare = "always";
    GPUStencilOperation failOp = "keep";
    GPUStencilOperation depthFailOp = "keep";
    GPUStencilOperation passOp = "keep";
};
</script>

<script type=idl>
enum GPUStencilOperation {
    "keep",
    "zero",
    "replace",
    "invert",
    "increment-clamp",
    "decrement-clamp",
    "increment-wrap",
    "decrement-wrap"
};
</script>

<div>
    <dfn abstract-op>validating GPUDepthStencilState</dfn>(descriptor)
    **Arguments:**
        - {{GPUDepthStencilState}} |descriptor|

    Return `true`, if and only if, all of the following conditions are satisfied:

        - |descriptor|.{{GPUDepthStencilState/format}} is listed in [[#depth-formats]].
        - if |descriptor|.{{GPUDepthStencilState/depthWriteEnabled}} is `true` or
            |descriptor|.{{GPUDepthStencilState/depthCompare}} is not {{GPUCompareFunction/"always"}}:
            - |descriptor|.{{GPUDepthStencilState/format}} must have a depth component.
        - if |descriptor|.{{GPUDepthStencilState/stencilFront}} or
            |descriptor|.{{GPUDepthStencilState/stencilBack}} are not default values:
            - |descriptor|.{{GPUDepthStencilState/format}} must have a stencil component.

    Issue: how can this algorithm support depth/stencil formats that are added in extensions?
</div>

### Vertex State ### {#vertex-state}

<script type=idl>
enum GPUIndexFormat {
    "uint16",
    "uint32"
};
</script>

The index format determines both the data type of index values in a buffer and, when used with
strip primitive topologies ({{GPUPrimitiveTopology/"line-strip"}} or
{{GPUPrimitiveTopology/"triangle-strip"}}) also specifies the primitive restart value. The
<dfn dfn>primitive restart value</dfn> indicates which index value indicates that a new primitive
should be started rather than continuing to construct the triangle strip with the prior indexed
vertices.

{{GPUPrimitiveState}}s that specify a strip primitive topology must specify a
{{GPUPrimitiveState/stripIndexFormat}} so that the [=primitive restart value=] that will be used
is known at pipeline creation time. {{GPUPrimitiveState}}s that specify a list primitive
topology must set {{GPUPrimitiveState/stripIndexFormat}} to `undefined`, and will use the index
format passed to {{GPURenderEncoderBase/setIndexBuffer()}} when rendering.

<table class="data">
  <thead>
    <tr>
      <th>Index format</th>
      <th>Byte size</th>
      <th>Primitive restart value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>{{GPUIndexFormat/"uint16"}}</td>
      <td>2</td>
      <td>0xFFFF</td>
    </tr>
    <tr>
      <td>{{GPUIndexFormat/"uint32"}}</td>
      <td>4</td>
      <td>0xFFFFFFFF</td>
    </tr>
  </tbody>
</table>

#### Vertex Formats #### {#vertex-formats}

The name of the format specifies the order of components, bits per component,
and <dfn dfn>vertex data type</dfn> for the component.

  * `unorm` = unsigned normalized
  * `snorm` = signed normalized
  * `uint` = unsigned int
  * `sint` = signed int
  * `float` = floating point

<script type=idl>
enum GPUVertexFormat {
    "uint8x2",
    "uint8x4",
    "sint8x2",
    "sint8x4",
    "unorm8x2",
    "unorm8x4",
    "snorm8x2",
    "snorm8x4",
    "uint16x2",
    "uint16x4",
    "sint16x2",
    "sint16x4",
    "unorm16x2",
    "unorm16x4",
    "snorm16x2",
    "snorm16x4",
    "float16x2",
    "float16x4",
    "float32",
    "float32x2",
    "float32x3",
    "float32x4",
    "uint32",
    "uint32x2",
    "uint32x3",
    "uint32x4",
    "sint32",
    "sint32x2",
    "sint32x3",
    "sint32x4",
};
</script>

The multi-component formats specify the number of components after "x".
As such, {{GPUVertexFormat/"sint32x3"}} denotes a 3-component vector of `i32` values in the shader.

<script type=idl>
enum GPUVertexStepMode {
    "vertex",
    "instance"
};
</script>

The step mode configures how an address for vertex buffer data is computed, based on the
current vertex or instance index:
<dl class="switch">
    : {{GPUVertexStepMode/"vertex"}}
    :: The address is advanced by {{GPUVertexBufferLayout/arrayStride}} for each vertex,
        and reset between instances.
    : {{GPUVertexStepMode/"instance"}}
    :: The address is advanced by {{GPUVertexBufferLayout/arrayStride}} for each instance.
</dl>

<script type=idl>
dictionary GPUVertexState: GPUProgrammableStage {
    sequence<GPUVertexBufferLayout?> buffers = [];
};
</script>

A <dfn dfn>vertex buffer</dfn> is, conceptually, a view into buffer memory as an *array of structures*.
{{GPUVertexBufferLayout/arrayStride}} is the stride, in bytes, between *elements* of that array.
Each element of a vertex buffer is like a *structure* with a memory layout defined by its
{{GPUVertexBufferLayout/attributes}}, which describe the *members* of the structure.

Each {{GPUVertexAttribute}} describes its
{{GPUVertexAttribute/format}} and its
{{GPUVertexAttribute/offset}}, in bytes, within the structure.

Each attribute appears as a separate input in a vertex shader, each bound by a numeric *location*,
which is specified by {{GPUVertexAttribute/shaderLocation}}.
Every location must be unique within the {{GPUVertexState}}.

<script type=idl>
dictionary GPUVertexBufferLayout {
    required GPUSize64 arrayStride;
    GPUVertexStepMode stepMode = "vertex";
    required sequence<GPUVertexAttribute> attributes;
};
</script>

<script type=idl>
dictionary GPUVertexAttribute {
    required GPUVertexFormat format;
    required GPUSize64 offset;

    required GPUIndex32 shaderLocation;
};
</script>

<div>
    <dfn abstract-op>validating GPUVertexBufferLayout</dfn>(device, descriptor, vertexStage)
    **Arguments:**
        - {{GPUDevice}} |device|
        - {{GPUVertexBufferLayout}} |descriptor|
        - {{GPUProgrammableStage}} |vertexStage|

    Return `true`, if and only if, all of the following conditions are satisfied:

        - |descriptor|.{{GPUVertexBufferLayout/arrayStride}} &le;
            |device|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxVertexBufferArrayStride}}.
        - |descriptor|.{{GPUVertexBufferLayout/arrayStride}} is a multiple of 4.
        - For each attribute |attrib| in the list |descriptor|.{{GPUVertexBufferLayout/attributes}}:
            - If |descriptor|.{{GPUVertexBufferLayout/arrayStride}} is zero:
                - |attrib|.{{GPUVertexAttribute/offset}} + sizeof(|attrib|.{{GPUVertexAttribute/format}}) &le;
                    |device|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxVertexBufferArrayStride}}.

                Otherwise:
                - |attrib|.{{GPUVertexAttribute/offset}} + sizeof(|attrib|.{{GPUVertexAttribute/format}}) &le;
                    |descriptor|.{{GPUVertexBufferLayout/arrayStride}}.
            - |attrib|.{{GPUVertexAttribute/offset}} is a multiple of the minimum of 4 and
                sizeof(|attrib|.{{GPUVertexAttribute/format}}).
            - |attrib|.{{GPUVertexAttribute/shaderLocation}} is less than
                |device|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxVertexAttributes}}.
        - For every vertex attribute in the shader reflection of |vertexStage|.{{GPUProgrammableStage/module}}
            that is a [=pipeline input=] of |vertexStage|.{{GPUProgrammableStage/entryPoint}},
            there is a corresponding |attrib| element of |descriptor|.{{GPUVertexBufferLayout/attributes}} for which
            all of the following are true:
            - The shader format is compatible with |attrib|.{{GPUVertexAttribute/format}}'s [=vertex data type=]:
                <dl class="switch">
                    : "unorm", "snorm", or "float"
                    :: shader format must be `f32` or `vecN<f32>`.
                    : "uint"
                    :: shader format must be `u32` or `vecN<u32>`.
                    : "sint"
                    :: shader format must be `i32` or `vecN<i32>`.
                </dl>
            - The shader location is |attrib|.{{GPUVertexAttribute/shaderLocation}}.
</div>

<div>
    <dfn abstract-op>validating GPUVertexState</dfn>(device, descriptor)
    **Arguments:**
        - {{GPUDevice}} |device|
        - {{GPUVertexState}} |descriptor|

    Return `true`, if and only if, all of the following conditions are satisfied:

        - |descriptor|.{{GPUVertexState/buffers}}.length is less than or equal to
            |device|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxVertexBuffers}}.
        - Each |vertexBuffer| layout descriptor in the list |descriptor|.{{GPUVertexState/buffers}}
            passes [$validating GPUVertexBufferLayout$](|device|, |vertexBuffer|, |descriptor|)
        - The sum of |vertexBuffer|.{{GPUVertexBufferLayout/attributes}}.length,
            over every |vertexBuffer| in |descriptor|.{{GPUVertexState/buffers}},
            is less than or equal to
            |device|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxVertexAttributes}}.
        - Each |attrib| in the union of all {{GPUVertexAttribute}}
            across |descriptor|.{{GPUVertexState/buffers}} has a distinct
            |attrib|.{{GPUVertexAttribute/shaderLocation}} value.
</div>

# 命令缓冲区 # {#command-buffers}

命令缓冲区是预先记录的[=GPU command=]列表，可以提交给{{GPUQueue}}执行。每个<dfn dfn>GPU command</dfn>代表一个要在GPU上执行的任务，例如设置状态、绘图、复制资源等。

## <dfn interface>GPUCommandBuffer</dfn> ## {#command-buffer}

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUCommandBuffer {
    readonly attribute Promise<double> executionTime;
};
GPUCommandBuffer includes GPUObjectBase;
</script>

{{GPUCommandBuffer}}有以下属性:

<dl dfn-type=attribute dfn-for="GPUCommandBuffer">
    : <dfn>executionTime</dfn>
    ::
        GPU执行此命令缓冲所消耗的总时间，以秒为单位。

        注意：如果{{GPUCommandEncoderDescriptor/measureExecutionTime}}为 `true`，这在命令缓冲区执行之后resolves，否则，这会以一个{{OperationError}}rejects。

        <div class=issue>
            指定promise的创建和解决。

            在{{GPUCommandEncoder/finish()}}中，应该指定一个新的promise被创建并存储在这个属性中。如果{{GPUCommandEncoderDescriptor/measureExecutionTime}}为 `false`，则promise开始被拒绝。如果finish()失败，则promise resolves为0。

            在{{GPUQueue/submit()}}中，应该指定（如果设置了{{GPUCommandEncoderDescriptor/measureExecutionTime}}），work被发出以读回执行时间，并且在完成时，promise resolves返回该值。如果submit()失败，则promise resolves为0。
        </div>
</dl>

{{GPUCommandBuffer}}有以下内部插槽:

<dl dfn-type=attribute dfn-for="GPUCommandBuffer">
    : <dfn>\[[command_list]]</dfn> of type [=list=]&lt;[=GPU command=]&gt;.
    ::
        当这个命令缓冲被提交时，一个[=GPU command=]的[=list=]会在[=Queue timeline=]上被执行。
</dl>

### 创建 ### {#command-buffer-creation}

<script type=idl>
dictionary GPUCommandBufferDescriptor : GPUObjectDescriptorBase {
};
</script>


# 命令编码 # {#command-encoding}

## <dfn interface>GPUCommandEncoder</dfn> ## {#command-encoder}

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUCommandEncoder {
    GPURenderPassEncoder beginRenderPass(GPURenderPassDescriptor descriptor);
    GPUComputePassEncoder beginComputePass(optional GPUComputePassDescriptor descriptor = {});

    undefined copyBufferToBuffer(
        GPUBuffer source,
        GPUSize64 sourceOffset,
        GPUBuffer destination,
        GPUSize64 destinationOffset,
        GPUSize64 size);

    undefined copyBufferToTexture(
        GPUImageCopyBuffer source,
        GPUImageCopyTexture destination,
        GPUExtent3D copySize);

    undefined copyTextureToBuffer(
        GPUImageCopyTexture source,
        GPUImageCopyBuffer destination,
        GPUExtent3D copySize);

    undefined copyTextureToTexture(
        GPUImageCopyTexture source,
        GPUImageCopyTexture destination,
        GPUExtent3D copySize);

    undefined pushDebugGroup(USVString groupLabel);
    undefined popDebugGroup();
    undefined insertDebugMarker(USVString markerLabel);

    undefined writeTimestamp(GPUQuerySet querySet, GPUSize32 queryIndex);

    undefined resolveQuerySet(
        GPUQuerySet querySet,
        GPUSize32 firstQuery,
        GPUSize32 queryCount,
        GPUBuffer destination,
        GPUSize64 destinationOffset);

    GPUCommandBuffer finish(optional GPUCommandBufferDescriptor descriptor = {});
};
GPUCommandEncoder includes GPUObjectBase;
</script>

{{GPUCommandEncoder}}有以下内部插槽:

<dl dfn-type=attribute dfn-for="GPUCommandEncoder">
    : <dfn>\[[command_list]]</dfn>，类型为[=list=]&lt;[=GPU command=]&gt;。
    ::
        此编码器生成的{{GPUCommandBuffer}}被提交时，一个[=GPU command=][=list=]在队列时间线上被执行。

    : <dfn>\[[state]]</dfn>，类型为{{encoder state}}。
    ::
        {{GPUCommandEncoder}}的当前状态, 初始时被设置为{{encoder state/open}}。

    : <dfn>\[[debug_group_stack]]</dfn>，类型为[=stack=]&lt;{{USVString}}&gt;。
    ::
        一个激活的调试组标签栈。
</dl>

每个{{GPUCommandEncoder}}在[=Content timeline=]上都有一个当前<dfn dfn-type="enum">encoder state</dfn>，值为以下之一：

<dl dfn-type="enum-value" dfn-for="encoder state">
    : "<dfn>open</dfn>"
    ::
        指{{GPUCommandEncoder}}可用于开始新操作。在{{GPUCommandEncoder}}有效且没有激活的{{GPURenderPassEncoder}}或{{GPUComputePassEncoder}}时，{{GPUCommandEncoder/[[state]]}}处于{{encoder state/open}}状态。

    : "<dfn>encoding a render pass</dfn>"
    ::
        指{{GPUCommandEncoder}}具有激活的{{GPURenderPassEncoder}}。一旦{{GPUCommandEncoder/beginRenderPass()}}被调用成功，{{GPUCommandEncoder/[[state]]}}就变成{{encoder state/encoding a render pass}}状态，直到在返回的{{GPURenderPassEncoder}}上调用{{GPURenderPassEncoder/endPass()}}，此时{{GPUCommandEncoder/[[state]]}}（如果编码器仍然有效）恢复为{{encoder state/open}}状态。

    : "<dfn>encoding a compute pass</dfn>"
    ::
        指{{GPUCommandEncoder}}具有激活的{{GPUComputePassEncoder}}。一旦{{GPUCommandEncoder/beginComputePass()}}被调用成功，{{GPUCommandEncoder/[[state]]}}就变成{{encoder state/encoding a compute pass}}状态，直到在返回的{{GPUComputePassEncoder}}上调用{{GPUComputePassEncoder/endPass()}}，此时{{GPUCommandEncoder/[[state]]}}（如果编码器仍然有效）恢复为{{encoder state/open}}状态。

    : "<dfn>closed</dfn>"
    ::
        指{{GPUCommandEncoder}}已经不可用作任何操作。一旦{{GPUCommandEncoder/finish()}}被调用或{{GPUCommandEncoder}}变无效，{{GPUCommandEncoder/[[state]]}}变为{{encoder state/closed}}状态。
</dl>

### 创建 ### {#command-encoder-creation}

<script type=idl>
dictionary GPUCommandEncoderDescriptor : GPUObjectDescriptorBase {
    boolean measureExecutionTime = false;
};
</script>

<dl dfn-type=dict-member dfn-for=GPUCommandEncoderDescriptor>
    : <dfn>measureExecutionTime</dfn>
    ::
        启用对全部命令缓冲区的GPU执行时间的测量。
</dl>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createCommandEncoder(descriptor)</dfn>
    ::
        创建一个{{GPUCommandEncoder}}。

        <div algorithm=GPUDevice.createCommandEncoder>
            **Called on:** {{GPUDevice}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/createCommandEncoder(descriptor)">
                descriptor: 要创建的{{GPUCommandEncoder}}的描述。
            </pre>

            **Returns:** {{GPUCommandEncoder}}

            问题：描述{{GPUDevice/createCommandEncoder()}}算法步骤。
        </div>
</dl>

## 通道编码 ## {#command-encoder-pass-encoding}

<dl dfn-type=method dfn-for=GPUCommandEncoder>
    : <dfn>beginRenderPass(descriptor)</dfn>
    ::
        Begins encoding a render pass described by |descriptor|.

        <div algorithm=GPUCommandEncoder.beginRenderPass>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/beginRenderPass(descriptor)">
                |descriptor|: 要创建的{{GPURenderPassEncoder}}的描述。
            </pre>

            **Returns:** {{GPURenderPassEncoder}}

            在|this|的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                1. 使|pass|为一个新的{{GPURenderPassEncoder}}对象。
                2. 如果以下任何条件没有满足，产生一个校验错误并停止。
                    <div class=validusage>
                        - |this|.{{GPUCommandEncoder/[[state]]}}为{{encoder state/open}}。
                        - |descriptor|满足[$GPURenderPassDescriptor/Valid Usage$]规则。
                    </div>
                3. 设置|this|.{{GPUCommandEncoder/[[state]]}}为{{encoder state/encoding a render pass}}。
                4. 对每个|descriptor|.{{GPURenderPassDescriptor/colorAttachments}}中的|colorAttachment|:
                    1. |colorAttachment|.{{GPURenderPassColorAttachment/view}}看到的[=texture subresource=]被视为在渲染通道期间用作[=internal usage/attachment=]。
                5. 设置|depthStencilAttachment|为|descriptor|.{{GPURenderPassDescriptor/depthStencilAttachment}}。
                6. 如果|depthStencilAttachment|不是 `null`:
                    1. 设置|depthStencilView|为|depthStencilAttachment|.{{GPURenderPassDepthStencilAttachment/view}}。
                    2. 如果|depthStencilAttachment|.{{GPURenderPassDepthStencilAttachment/depthReadOnly}}和{{GPURenderPassDepthStencilAttachment/stencilReadOnly}}被设置了值：
                        1. |depthStencilView|看到的[=texture subresource=]被视为在渲染通道期间用作[=internal usage/attachment-read=]。
                    3. 否则, |depthStencilView|看到的[=texture subresource=]被视为在渲染通道期间用作[=internal usage/attachment=]。
                    4. 设置|pass|.{{GPURenderEncoderBase/[[depthReadOnly]]}}为|depthStencilAttachment|.{{GPURenderPassDepthStencilAttachment/depthReadOnly}}。
                    5. 设置|pass|.{{GPURenderEncoderBase/[[stencilReadOnly]]}}为|depthStencilAttachment|.{{GPURenderPassDepthStencilAttachment/stencilReadOnly}}。
                7. 设置|pass|.{{GPURenderEncoderBase/[[layout]]}}为[$derive render targets layout from pass$](|descriptor|)。
                8. 返回|pass|。
            </div>

            问题：指定只读深度/模板的行为。
            问题：入队附件负载(with loadOp clear)。
        </div>

    : <dfn>beginComputePass(descriptor)</dfn>
    ::
        开始对|descriptor|描述的compute pass进行编码。

        <div algorithm=GPUCommandEncoder.beginComputePass>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/beginComputePass(descriptor)">
                descriptor:
            </pre>

            **Returns:** {{GPUComputePassEncoder}}

            在|this|的[=Device timeline=]上发起如下步骤：
            <div class=device-timeline>
                1. 如果以下任何条件没有满足，产生一个校验错误并停止。
                    <div class=validusage>
                        - |this|.{{GPUCommandEncoder/[[state]]}}为{{encoder state/open}}。
                    </div>
                2. 设置|this|.{{GPUCommandEncoder/[[state]]}}为{{encoder state/encoding a compute pass}}。
                3. 设置|pass|为一个新的{{GPUComputePassEncoder}}对象。
                4. 返回|pass|。
            </div>
        </div>
</dl>

## 拷贝命令 ## {#copy-commands}

问题：这些字典定义应该在图像副本部分内。

### <dfn dictionary>GPUImageDataLayout</dfn> ### {#gpu-image-data-layout}

<script type=idl>
dictionary GPUImageDataLayout {
    GPUSize64 offset = 0;
    GPUSize32 bytesPerRow;
    GPUSize32 rowsPerImage;
};
</script>

{{GPUImageDataLayout}}是一些线性内存中的图像（<dfn dfn>images</dfn>）布局。它在[=texture=]和[=buffer=]之间复制数据时使用，或者在调度{{GPUQueue}}[=texture=]写入时使用。

  - 对于{{GPUTextureDimension/2d}}纹理，数据在一个或多个毗邻的[=images=]和[=array layers=]之间复制。
  - 对于{{GPUTextureDimension/3d}}纹理，数据在一个或多个毗邻的[=images=]和深度[=slices=]之间复制。

在字节数组和纹理之间复制的操作始终适用于[=texel block=]的行，我们将其称为<dfn dfn>block row</dfn>。不能只更新[=texel block=]的一部分。

问题：更精确地定义图像。特别是，将它们定义为由[=texel block=]组成。

问题：通过参考复制方法共享的通用算法，定义精确的复制语义。

<dl dfn-type=dict-member dfn-for=GPUImageDataLayout>
    : <dfn>bytesPerRow</dfn>
    ::
        每个[=block row=]的开头和后续[=block row=]之间的步幅（以字节为单位）。

        如果有多个[=block row=]则为必须项(即，高度或深度大于一块)。

    : <dfn>rowsPerImage</dfn>
    ::
        每个纹理图像的[=block row=]数。{{GPUImageDataLayout/rowsPerImage}} &times;
        {{GPUImageDataLayout/bytesPerRow}}是每个数据[=images=]的开头和后续[=images=]之间的步幅（以字节为单位）。

        如果有多个[=images=]则为必须项(即，高度大于一)。
</dl>

### <dfn dictionary>GPUImageCopyBuffer</dfn> ### {#gpu-image-copy-buffer}

在图像复制操作中，{{GPUImageCopyBuffer}}定义了一个{{GPUBuffer}}，并与 `copySize` 一起，定义了图像数据在缓冲区内存中如何布局（请参阅 GPUImageDataLayout）。

<script type=idl>
dictionary GPUImageCopyBuffer : GPUImageDataLayout {
    required GPUBuffer buffer;
};
</script>

<div algorithm class=validusage>
<dfn abstract-op>validating GPUImageCopyBuffer</dfn>

  **Arguments:**
    - {{GPUImageCopyBuffer}} |imageCopyBuffer|

  **Returns:** {{boolean}}

  当且仅当所有以下条件都满足时，返回 `true`。
    - |imageCopyBuffer|.{{GPUImageCopyBuffer/buffer}}必须是一个[=valid=]{{GPUBuffer}}。
    - |imageCopyBuffer|.{{GPUImageDataLayout/bytesPerRow}}必须是256的倍数。

</div>

### <dfn dictionary>GPUImageCopyTexture</dfn> ### {#gpu-image-copy-texture}

在图像复制操作中，{{GPUImageCopyTexture}}定义了一个{{GPUTexture}}，并与 `copySize` 一起定义了纹理的子区域（跨越相同 mip-map 级别的一个或多个连续[=texture subresource=]）。

<script type=idl>
dictionary GPUImageCopyTexture {
    required GPUTexture texture;
    GPUIntegerCoordinate mipLevel = 0;
    GPUOrigin3D origin = {};
    GPUTextureAspect aspect = "all";
};
</script>

<dl dfn-type=dict-member dfn-for=GPUImageCopyTexture>
    : <dfn>texture</dfn>
    ::
        要复制到/从的纹理。

    : <dfn>mipLevel</dfn>
    ::
        要复制到/从的{{GPUImageCopyTexture/texture}}的Mip-map级别。

    : <dfn>origin</dfn>
    ::
        定义复制的原点 - 要复制到/从的纹理子区域的最小角。与 `copySize` 一起定义完整复制子区域。

    : <dfn>aspect</dfn>
    ::
        定义要复制到/从纹理的宽高比。
</dl>

<div algorithm class=validusage>
<dfn abstract-op>validating GPUImageCopyTexture</dfn>

  **Arguments:**
    - {{GPUImageCopyTexture}} |imageCopyTexture|
    - {{GPUExtent3D}} |copySize|

  **Returns:** {{boolean}}

  使:
  - |blockWidth|为|imageCopyTexture|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/format}}的[=texel block width=]。
  - |blockHeight|为|imageCopyTexture|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/format}}的[=texel block height=]。

  当且仅当以下所有条件都满足时，返回 `true`：
  - |imageCopyTexture|.{{GPUImageCopyTexture/texture}}必须为一个[=valid=]{{GPUTexture}}.
  - |imageCopyTexture|.{{GPUImageCopyTexture/mipLevel}}必须小于|imageCopyTexture|.{{GPUImageCopyTexture/texture}}的{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/mipLevelCount}}。
  - |imageCopyTexture|.{{GPUImageCopyTexture/origin}}.[=Origin3D/x=]必须是|blockWidth|的倍数。
  - |imageCopyTexture|.{{GPUImageCopyTexture/origin}}.[=Origin3D/y=]必须是|blockHeight|的倍数。
  - 如果满足以下任一条件，则|imageCopyTexture|的[=imageCopyTexture subresource size=]等于|copySize|：
        - |imageCopyTexture|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/format}}是一个depth-stencil格式。
        - |imageCopyTexture|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/sampleCount}}大于1。

</div>

问题(gpuweb/gpuweb#69)：使用{{GPUTextureDimension/1d}}和{{GPUTextureDimension/3d}}纹理定义副本。

### <dfn dictionary>GPUImageCopyTextureTagged</dfn> ### {#gpu-image-copy-texture-tagged}

WebGPU纹理保存原始数字数据，并且没有用描述颜色的语义元数据标记。 但是，{{GPUQueue/copyExternalImageToTexture()}}从描述颜色的来源进行复制。

一个{{GPUImageCopyTextureTagged}}是一个{{GPUImageCopyTexture}}，它额外标记了颜色空间/编码和alpha预乘元数据，以便可以在复制期间保留语义颜色数据。此元数据仅影响{{GPUQueue/copyExternalImageToTexture()}}调用的语义。

<script type=idl>
dictionary GPUImageCopyTextureTagged : GPUImageCopyTexture {
    GPUPredefinedColorSpace colorSpace = "srgb";
    boolean premultipliedAlpha = false;
};
</script>

<dl dfn-type=dict-member dfn-for=GPUImageCopyTextureTagged>
    : <dfn>colorSpace</dfn>
    ::
        描述用于将数据编码到目标纹理中的颜色空间和编码。

        Note:
        注意：如果{{GPUImageCopyTextureTagged/colorSpace}}与源图像匹配，则不会发生转换。 {{ImageBitmap}}颜色空间标记和转换可以通过{{ImageBitmapOptions}}进行控制。

    : <dfn>premultipliedAlpha</dfn>
    ::
        描述写入纹理的数据是否应将其RGB通道预乘以Alpha通道。

        如果此选项设置为 `true`并且{{GPUImageCopyExternalImage/source}}也预乘，则即使源RGB值超过其相应的alpha值，也必须保留它们。

        注意：如果{{GPUImageCopyTextureTagged/premultipliedAlpha}}与源图像匹配，则不会发生转换。2d画布html#premultiplied-alpha-and-the-2d-rendering-context|总是预乘，而WebGL画布可以通过<l spec=html>[=WebGLContextAttributes=]</l>控制。{{ImageBitmap}}预乘可以通过{{ImageBitmapOptions}}控制。
</dl>

问题：将颜色值的编码定义（并测试）为{{GPUQueue/copyExternalImageToTexture()}}允许的各种编码。

### <dfn dictionary>GPUImageCopyExternalImage</dfn> ### {#gpu-image-copy-external-image}

<script type=idl>
dictionary GPUImageCopyExternalImage {
    required (ImageBitmap or HTMLCanvasElement or OffscreenCanvas) source;
    GPUOrigin2D origin = {};
};
</script>

{{GPUImageCopyExternalImage}}有以下成员：

<dl dfn-type=dict-member dfn-for=GPUImageCopyExternalImage>
    : <dfn>source</dfn>
    ::
        图像副本的来源。源数据副本在发出{{GPUQueue/copyExternalImageToTexture()}}时被捕获。

    : <dfn>origin</dfn>
    ::
        定义副本的原点 - 要从中复制的源子区域的最小角。与 `copySize` 一起定义完整子区域副本。
</dl>

### 缓冲区副本 ### {#buffer-copies}

<dl dfn-type=method dfn-for=GPUCommandEncoder>
    : <dfn>copyBufferToBuffer(source, sourceOffset, destination, destinationOffset, size)</dfn>
    ::
        将命令编码到{{GPUCommandEncoder}}中，将数据从{{GPUBuffer}}的子区域复制到另一个{{GPUBuffer}}的子区域。

        <div algorithm=GPUCommandEncoder.copyBufferToBuffer>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/copyBufferToBuffer(source, sourceOffset, destination, destinationOffset, size)">
                |source|: 要复制的{{GPUBuffer}}.
                |sourceOffset|: 到要复制的|source|中的字节偏移量。
                |destination|: 要复制到的{{GPUBuffer}}.
                |destinationOffset|: 到要复制到的的|destination|中的字节偏移量。
                |size|: 要复制的字节大小。
            </pre>

            **Returns:** {{undefined}}

            如果以下任何条件未满足，产生一个校验错误并停止。
            <div class=validusage>
                - |this|.{{GPUCommandEncoder/[[state]]}}为{{encoder state/open}}状态。
                - |source|可以和|this|一起有效使用。
                - |destination|可以和|this|一起有效使用。
                - |source|.{{GPUBuffer/[[usage]]}}包含{{GPUBufferUsage/COPY_SRC}}。
                - |destination|.{{GPUBuffer/[[usage]]}}包含{{GPUBufferUsage/COPY_DST}}。
                - |size|是4的倍数。
                - |sourceOffset|是4的倍数。
                - |destinationOffset|是4的倍数。
                - (|sourceOffset| + |size|)不会溢出{{GPUSize64}}。
                - (|destinationOffset| + |size|)不会溢出{{GPUSize64}}。
                - |source|.{{GPUBuffer/[[size]]}}大于等于(|sourceOffset| + |size|)。
                - |destination|.{{GPUBuffer/[[size]]}}大于等于(|destinationOffset| + |size|)。
                - |source|和|destination|不是同一个{{GPUBuffer}}。
            </div>

            问题(gpuweb/gpuweb#21)：为GPUCommandEncoder定义状态机。

            问题(gpuweb/gpuweb#69)：指出如何处理规范中的溢出。
        </div>
</dl>

### 图像副本 ### {#image-copies}

WebGPU提供{{GPUCommandEncoder/copyBufferToTexture()}}以buffer-to-texture拷贝，以及{{GPUCommandEncoder/copyTextureToBuffer()}} 以texture-to-buffer拷贝。

以下定义和校验规则对{{GPUCommandEncoder/copyBufferToTexture()}}和{{GPUCommandEncoder/copyTextureToBuffer()}}都应用。

[=imageCopyTexture subresource size=]和[=Valid Texture Copy Range=]同样对
{{GPUCommandEncoder/copyTextureToTexture()}}应用。

<div algorithm="imageCopyTexture subresource size">

<dfn dfn>imageCopyTexture subresource size</dfn>

  **Arguments:**
    - {{GPUImageCopyTexture}} |imageCopyTexture|

  **Returns:** {{GPUExtent3D}}

  |imageCopyTexture|的[=imageCopyTexture subresource size=]计算如下:

  它的[=Extent3D/width=], [=Extent3D/height=]和[=Extent3D/depthOrArrayLayers=]分别为=mipmap level=] |imageCopyTexture|.{{GPUImageCopyTexture/mipLevel}}上的|imageCopyTexture|.{{GPUImageCopyTexture/texture}} [=subresource=] [=physical size=]的宽度，高度，和深度。

</div>

问题：将此定义为具有 (texture, mipmapLevel) 参数的算法，并使用调用语法而不是通过标签引用定义。

<div>
    校验线性纹理数据（<dfn abstract-op>validating linear texture data</dfn>(layout, byteSize, format, copyExtent)）

    **Arguments:**
    : {{GPUImageDataLayout}} |layout|
    :: 线性纹理数据的布局。
    : {{GPUSize64}} |byteSize|
    :: 显性数据的总大小，以字节为单位。
    : {{GPUTextureFormat}} |format|
    :: 纹理格式。
    : {{GPUExtent3D}} |copyExtent|
    :: 要复制的纹理的范围。

    1. 使|blockWidth|, |blockHeight|, and |blockSize|为|格式|的[=texel block width=]，[=texel block height|height=]，和[=texel block size|size=]。

    2. 假设|copyExtent|.[=Extent3D/width=]为|blockWidth|的倍数并且|copyExtent|.[=Extent3D/height=]为|blockHeight|的倍数。使:
            - |widthInBlocks|为|copyExtent|.[=Extent3D/width=] &divide; |blockWidth|.
            - |heightInBlocks|为|copyExtent|.[=Extent3D/height=] &divide; |blockHeight|.
            - |bytesInLastRow|为|blockSize| &times; |widthInBlocks|.

    3. 如果以下条件未满足则失败：
        <div class=validusage>
            - 如果|heightInBlocks| &gt; 1，|layout|.{{GPUImageDataLayout/bytesPerRow}}需要被指定。
            - 如果|copyExtent|.[=Extent3D/depthOrArrayLayers=] &gt; 1,
                |layout|.{{GPUImageDataLayout/bytesPerRow}}和|layout|.{{GPUImageDataLayout/rowsPerImage}}需要被指定。
            - 如果被指定，|layout|.{{GPUImageDataLayout/bytesPerRow}}必须大于或等于|bytesInLastRow|。
            - 如果被指定，|layout|.{{GPUImageDataLayout/rowsPerImage}}必须大于或等于|heightInBlocks|。
        </div>

    4. 使|requiredBytesInCopy|为0。

    5. 如果copyExtent|.[=Extent3D/depthOrArrayLayers=] &gt; 1:
        1. 使|bytesPerImage|为
            |layout|.{{GPUImageDataLayout/bytesPerRow}} &times;
            |layout|.{{GPUImageDataLayout/rowsPerImage}}。
        1. 使|bytesBeforeLastImage|为
            |bytesPerImage| &times; (|copyExtent|.[=Extent3D/depthOrArrayLayers=] &minus; 1)。
        1. 将|bytesBeforeLastImage|加至|requiredBytesInCopy|。

    6. 如果|copyExtent|.[=Extent3D/depthOrArrayLayers=] &gt; 0:

        1. 如果|heightInBlocks| &gt; 1, 将
            |layout|.{{GPUImageDataLayout/bytesPerRow}} &times;
            (|heightInBlocks| &minus; 1)
            加至|requiredBytesInCopy|。

        1. 如果|heightInBlocks| &gt; 0, 将
            |bytesInLastRow|加至|requiredBytesInCopy|。

    7. 如果以下条件未满足则失败：
        <div class=validusage>
            - |layout|.{{GPUImageDataLayout/offset}} + |requiredBytesInCopy| &le; |byteSize|。
        </div>
</div>

<div algorithm class=validusage>

<dfn dfn>Valid Texture Copy Range</dfn>

给定一个{{GPUImageCopyTexture}} |imageCopyTexture|和一个{{GPUExtent3D}} |copySize|，使：
  - |blockWidth|为|imageCopyTexture|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/format}}的[=texel block width=]。
  - |blockHeight|为|imageCopyTexture|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/format}}的[=texel block height=]。

以下校验规则应用:

  - 如果|imageCopyTexture|.{{GPUImageCopyTexture/texture}}的{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/dimension}}为{{GPUTextureDimension/1d}}：
    - |copySize|.[=Extent3D/height=]和[=Extent3D/depthOrArrayLayers=]都为1。
  - 如果|imageCopyTexture|.{{GPUImageCopyTexture/texture}}的{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/dimension}}为
    {{GPUTextureDimension/2d}}：
     -  (|imageCopyTexture|.{{GPUImageCopyTexture/origin}}.[=Origin3D/x=] + |copySize|.[=Extent3D/width=])，
        (|imageCopyTexture|.{{GPUImageCopyTexture/origin}}.[=Origin3D/y=] + |copySize|.[=Extent3D/height=])，和
        (|imageCopyTexture|.{{GPUImageCopyTexture/origin}}.[=Origin3D/z=] + |copySize|.[=Extent3D/depthOrArrayLayers=])需要分别小于或等于|imageCopyTexture|[=imageCopyTexture subresource size=]的[=Extent3D/width=]，[=Extent3D/height=]，和[=Extent3D/depthOrArrayLayers=]。
  - |copySize|.[=Extent3D/width=]必须为|blockWidth|的倍数。
  - |copySize|.[=Extent3D/height=]必须为|blockHeight|的倍数。

</div>

问题(gpuweb/gpuweb#69)：使用{{GPUTextureDimension/1d}}和{{GPUTextureDimension/3d}}纹理定义副本。

问题(gpuweb/gpuweb#537)：对rowsPerImage附加的限制，如果需要。

问题(gpuweb/gpuweb#652): 定义{{GPUTextureFormat/"depth24plus"}},
{{GPUTextureFormat/"depth24plus-stencil8"}}, 和{{GPUTextureFormat/"stencil8"}}的副本。

问题: 将“Valid Texture Copy Range”转换成带参数的算法，类似于“validating linear texture data”。

<dl dfn-type=method dfn-for=GPUCommandEncoder>
    : <dfn>copyBufferToTexture(source, destination, copySize)</dfn>
    ::
        将命令编码到{{GPUCommandEncoder}}中，将数据从{{GPUBuffer}}的子区域复制到一个或多个连续[=texture subresource=]的子区域。

        <div algorithm=GPUCommandEncoder.copyBufferToTexture>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/copyBufferToTexture(source, destination, copySize)">
                |source|: 结合|copySize|，定义源缓冲区的区域。
                |destination|: 结合复制大小，定义目标[=texture subresource=]的区域。
                |copySize|:
            </pre>

            **Returns:** {{undefined}}

            如果以下任何条件未满足，则产生一个校验错误并停止。
            <div class=validusage>
                - 使|dstTextureDesc|为|destination|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}。
                - |this|.{{GPUCommandEncoder/[[state]]}}为{{encoder state/open}}。
                - [$validating GPUImageCopyBuffer$](|source|)返回 `true`。
                - |source|.{{GPUImageCopyBuffer/buffer}}.{{GPUBuffer/[[usage]]}}包含{{GPUBufferUsage/COPY_SRC}}。
                - [$validating GPUImageCopyTexture$](|destination|, |copySize|)返回 `true`。
                - |dstTextureDesc|.{{GPUTextureDescriptor/usage}}包含{{GPUTextureUsage/COPY_DST}}。
                - |dstTextureDesc|.{{GPUTextureDescriptor/sampleCount}}为1。
                - 如果|dstTextureDesc|.{{GPUTextureDescriptor/format}}为depth-stencil格式：
                    - |destination|.{{GPUImageCopyTexture/aspect}}必须指向一个|dstTextureDesc|.{{GPUTextureDescriptor/format}}的单个可拷贝宽高比。详见[[#depth-formats|depth-formats]]。
                - 如果|dstTextureDesc|.{{GPUTextureDescriptor/format}}不是depth/stencil格式：
                    - |source|.{{GPUImageDataLayout/offset}}为|dstTextureDesc|.{{GPUTextureDescriptor/format}}的[=texel block size=]的倍数。
                - 如果|dstTextureDesc|.{{GPUTextureDescriptor/format}}是depth/stencil格式：
                    - |source|.{{GPUImageDataLayout/offset}}为4的倍数。
                - [$validating linear texture data$](|source|,
                    |source|.{{GPUImageCopyBuffer/buffer}}.{{GPUBuffer/[[size]]}},
                    |dstTextureDesc|.{{GPUTextureDescriptor/format}},
                    |copySize|)成功。
            </div>
        </div>

    : <dfn>copyTextureToBuffer(source, destination, copySize)</dfn>
    ::
        将命令编码到{{GPUCommandEncoder}}中，将数据从一个或多个连续[=texture subresource=]的子区域复制到{{GPUBuffer}}的子区域。

        <div algorithm=GPUCommandEncoder.copyTextureToBuffer>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/copyTextureToBuffer(source, destination, copySize)">
                |source|: 结合|copySize|，定义源[=texture subresource=]的区域。
                |destination|: 结合|copySize|，定义目标缓冲区的区域。
                |copySize|:
            </pre>

            **Returns:** {{undefined}}

            如果以下任何条件未满足，则产生一个校验错误并停止。
            <div class=validusage>
                - Let |srcTextureDesc|为|source|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}。
                - |this|.{{GPUCommandEncoder/[[state]]}}为{{encoder state/open}}。
                - [$validating GPUImageCopyTexture$](|source|, |copySize|)返回 `true`。
                - |srcTextureDesc|.{{GPUTextureDescriptor/usage}}包含{{GPUTextureUsage/COPY_SRC}}。
                - |srcTextureDesc|.{{GPUTextureDescriptor/sampleCount}}为1。
                - 如果|srcTextureDesc|.{{GPUTextureDescriptor/format}}为depth-stencil格式:
                    - |source|.{{GPUImageCopyTexture/aspect}}必须指向一个|srcTextureDesc|.{{GPUTextureDescriptor/format}}的可拷贝宽高比。详见[[#depth-formats|depth-formats]]。
                - [$validating GPUImageCopyBuffer$](|destination|)返回 `true`。
                - |destination|.{{GPUImageCopyBuffer/buffer}}.{{GPUBuffer/[[usage]]}}包含{{GPUBufferUsage/COPY_DST}}。
                - [=Valid Texture Copy Range=]应用至|source|和|copySize|。
                - 如果|srcTextureDesc|.{{GPUTextureDescriptor/format}}不是depth/stencil格式：
                    - |destination|.{{GPUImageDataLayout/offset}}|srcTextureDesc|.{{GPUTextureDescriptor/format}}的[=texel block size=]的倍数。
                - 如果|srcTextureDesc|.{{GPUTextureDescriptor/format}}是depth/stencil格式：
                    - |destination|.{{GPUImageDataLayout/offset}}是4的倍数。
                - [$validating linear texture data$](|destination|,
                    |destination|.{{GPUImageCopyBuffer/buffer}}.{{GPUBuffer/[[size]]}},
                    |srcTextureDesc|.{{GPUTextureDescriptor/format}},
                    |copySize|)成功。
            </div>
        </div>

    : <dfn>copyTextureToTexture(source, destination, copySize)</dfn>
    ::
        将命令编码到{{GPUCommandEncoder}}中，该命令将数据从一个或多个连续[=texture subresource=]的子区域复制到一个或多个连续[=texture subresource=]的另一个子区域。

        <div algorithm=GPUCommandEncoder.copyTextureToTexture>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/copyTextureToTexture(source, destination, copySize)">
                |source|: 结合|copySize|，定义源[=texture subresource=]的区域。
                |destination|: 结合|copySize|，定义目标[=texture subresource=]的区域。
                |copySize|:
            </pre>

            **Returns:** {{undefined}}

            1. 如果以下任何条件未满足，则产生一个校验错误并停止。
                <div class=validusage>
                    - 使|srcTextureDesc|为|source|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}。
                    - 使|dstTextureDesc|为|destination|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}。
                    - |this|.{{GPUCommandEncoder/[[state]]}}为{{encoder state/open}}。
                    - [$validating GPUImageCopyTexture$](|source|, |copySize|)返回 `true`。
                    - |srcTextureDesc|.{{GPUTextureDescriptor/usage}}包含{{GPUTextureUsage/COPY_SRC}}。
                    - [$validating GPUImageCopyTexture$](|destination|, |copySize|)返回 `true`。
                    - |dstTextureDesc|.{{GPUTextureDescriptor/usage}}包含{{GPUTextureUsage/COPY_DST}}。
                    - |srcTextureDesc|.{{GPUTextureDescriptor/sampleCount}}等于|dstTextureDesc|.{{GPUTextureDescriptor/sampleCount}}。
                    - 如果|srcTextureDesc|.{{GPUTextureDescriptor/format}}不等于|dstTextureDesc|.{{GPUTextureDescriptor/format}}:
                        - [=copies of depth and stencil textures|copy configuration被允许=]
                    - 如果|srcTextureDesc|.{{GPUTextureDescriptor/format}}是depth-stencil格式：
                        - |source|.{{GPUImageCopyTexture/aspect}}和|destination|.{{GPUImageCopyTexture/aspect}}必须都分别指向|srcTextureDesc|.{{GPUTextureDescriptor/format}}和|dstTextureDesc|.{{GPUTextureDescriptor/format}}的全部宽高比。
                    - [=Valid Texture Copy Range=]应用至|source|和|copySize|.
                    - [=Valid Texture Copy Range=]应用至|destination|和|copySize|.
                    - [$set of subresources for texture copy$](|source|, |copySize|)和[$set of subresources for texture copy$](|destination|, |copySize|)是不相交的。
                </div>
        </div>
</dl>

<div>
    The <dfn abstract-op>set of subresources for texture copy</dfn>(|imageCopyTexture|, |copySize|)
    是一个包含如下内容的集合：

      - 如果|imageCopyTexture|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/dimension}}为{{GPUTextureDimension/"2d"}}:
          - 每个|copySize|.[=Extent3D/depthOrArrayLayers=] [=array layers=]的|arrayLayer|从|imageCopyTexture|.{{GPUImageCopyTexture/origin}}.[=Origin3D/z=]开始：
              - |imageCopyTexture|.{{GPUImageCopyTexture/texture}}的The [=subresource=]在[=mipmap level=] |imageCopyTexture|.{{GPUImageCopyTexture/mipLevel}}和[=array layer=] |arrayLayer|处。
      - 否则：
          - |imageCopyTexture|.{{GPUImageCopyTexture/texture}}的[=subresource=]在[=mipmap level=] |imageCopyTexture|.{{GPUImageCopyTexture/mipLevel}}处。
</div>

## 调试标记 ## {#command-encoder-debug-markers}

命令编码器和可编程传递编码器都提供了将调试标签应用于命令组或将单个标签插入命令序列的方法。调试组可以嵌套以创建标记命令的层次结构。 这些标签可能会传递给原生API后端以供工具使用，也可能由用户代理的内部工具使用，或者在此类工具不可用或不适用时可能是空操作。

{{GPUCommandEncoder}}或{{GPUProgrammablePassEncoder}}中的调试组必须为良好嵌套的。

<dl dfn-type=method dfn-for=GPUCommandEncoder>
    : <dfn>pushDebugGroup(groupLabel)</dfn>
    ::
        为{{GPUCommandEncoder}}标记一个命令标签组的起始位置。

        <div algorithm=GPUCommandEncoder.pushDebugGroup>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/pushDebugGroup(groupLabel)">
                |groupLabel|: 命令组的标签。
            </pre>

            **Returns:** {{undefined}}

            在|this|的[=Device timeline=]上发起如下步骤：
            <div class=device-timeline>
                - 如果以下任何条件未满足，使|this|[=invalid=]并停止。
                    <div class=validusage>
                        - |this|.{{GPUCommandEncoder/[[state]]}}为{{encoder state/open}}。
                    </div>
                - 把|groupLabel|[=stack/push=]到|this|.{{GPUCommandEncoder/[[debug_group_stack]]}}上。
            </div>
        </div>

    : <dfn>popDebugGroup()</dfn>
    ::
        为{{GPUCommandEncoder}}标记一个命令标签组的结束位置。

        <div algorithm=GPUCommandEncoder.popDebugGroup>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Returns:** {{undefined}}

            在|this|的[=Device timeline=]上发起如下步骤：
            <div class=device-timeline>
                - 如果以下任何条件未满足，使|this|[=invalid=]并停止。
                    <div class=validusage>
                        - |this|.{{GPUCommandEncoder/[[state]]}}为{{encoder state/open}}。
                        - |this|.{{GPUCommandEncoder/[[debug_group_stack]]}}'s [=stack/size=]大于0。
                    </div>
                - 从|this|.{{GPUCommandEncoder/[[debug_group_stack]]}}中[=stack/pop=]出一项。
            </div>
        </div>

    : <dfn>insertDebugMarker(markerLabel)</dfn>
    ::
        用一个标签字符串标记一个命令流中的点。

        <div algorithm=GPUCommandEncoder.insertDebugMarker>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/insertDebugMarker(markerLabel)">
                markerLabel: 要插入的标签。
            </pre>

            **Returns:** {{undefined}}

            在|this|的[=Device timeline=]上发起如下步骤：
            <div class=device-timeline>
                - 如果以下任何条件未满足，使|this|[=invalid=]并停止。
                    <div class=validusage>
                        - |this|.{{GPUCommandEncoder/[[state]]}}为{{encoder state/open}}。
                    </div>
            </div>
        </div>
</dl>

## 查询 ## {#command-encoder-queries}

<dl dfn-type=method dfn-for=GPUCommandEncoder>
    : <dfn>writeTimestamp(querySet, queryIndex)</dfn>
    ::
        当所有先前命令被全部执行时，向|querySet|写入一个时间戳值。

        <div algorithm=GPUCommandEncoder.writeTimestamp>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/writeTimestamp(querySet, queryIndex)">
                |querySet|: 存放时间戳的查询集合。
                |queryIndex|: 查询集合的查询索引。
            </pre>

            **Returns:** {{undefined}}

            1. 如果|this|.{{GPUObjectBase/[[device]]}}.{{device/[[features]]}}不为[=list/contain=]
                {{GPUFeatureName/"timestamp-query"}}，抛出一个{{TypeError}}。
            2. 如果以下任何条件未满足，产生一个校验错误并停止。
                <div class=validusage>
                    - |this|.{{GPUCommandEncoder/[[state]]}}为{{encoder state/open}}。
                    - |querySet|可以与|this|一起有效使用。
                    - |querySet|.{{GPUQuerySet/[[descriptor]]}}.{{GPUQuerySetDescriptor/type}}为{{GPUQueryType/"timestamp"}}。
                    - |queryIndex| &lt; |querySet|.{{GPUQuerySet/[[descriptor]]}}.{{GPUQuerySetDescriptor/count}}。
                </div>

            问题: 描述{{GPUCommandEncoder/writeTimestamp()}}算法步骤。
        </div>

    : <dfn>resolveQuerySet(querySet, firstQuery, queryCount, destination, destinationOffset)</dfn>
    ::

        <div algorithm=GPUCommandEncoder.resolveQuerySet>
            **Called on:** {{GPUCommandEncoder}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/resolveQuerySet(querySet, firstQuery, queryCount, destination, destinationOffset)">
                querySet:
                firstQuery:
                queryCount:
                destination:
                destinationOffset:
            </pre>

            **Returns:** {{undefined}}

            如果以下任何条件未满足，产生一个{{GPUValidationError}}并停止。
            <div class=validusage>
                - |this|.{{GPUCommandEncoder/[[state]]}}为{{encoder state/open}}。
                - |querySet|为[$valid to use with$] |this|。
                - |destination|为[$valid to use with$] |this|。
                - |destination|.{{GPUBuffer/[[usage]]}}包含{{GPUBufferUsage/QUERY_RESOLVE}}。
                - |firstQuery|小于|querySet|中的查询数量。
                - (|firstQuery| + |queryCount|)小于等于|querySet|中的查询数量。
                - |destinationOffset|是256的倍数。
                - |destinationOffset| + 8 &times; |queryCount| &le; |destination|.{{GPUBuffer/[[size]]}}。
            </div>

            问题: 描述{{GPUCommandEncoder/resolveQuerySet()}}算法步骤。
        </div>
</dl>

## 结尾 ## {#command-encoder-finalization}

可以通过调用{{GPUCommandEncoder/finish()}}来创建包含{{GPUCommandEncoder}}记录的命令的{{GPUCommandBuffer}}。 一旦{{GPUCommandEncoder/finish()}}被调用，命令编码器就不能再使用了。

<dl dfn-type=method dfn-for=GPUCommandEncoder>
    : <dfn>finish(descriptor)</dfn>
    ::
        停止记录命令序列并返回一个对应的{{GPUCommandBuffer}}。

        <div algorithm=GPUCommandEncoder.finish>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/finish(descriptor)">
                descriptor:
            </pre>

            **Returns:** {{GPUCommandBuffer}}

            1. 使|commandBuffer|为一个新的{{GPUCommandBuffer}}。
            2. 在|this|的[=Device timeline=]上发起如下步骤：
                <div class=device-timeline>
                    1. 如果以下任何条件未满足，产生一个校验错误并停止。
                        <div class=validusage>
                            - |this|为[=valid=]的。
                            - |this|.{{GPUCommandEncoder/[[debug_group_stack]]}}'s [=stack/size=]为0。
                            - |this|.{{GPUCommandEncoder/[[state]]}}为{{encoder state/open}}。
                            - 每个包含在|this|中的[=usage scope=]满足[=usage scope validation=]。
                        </div>

                    2. 设置|this|.{{GPUCommandEncoder/[[state]]}}为{{encoder state/closed}}.
                    3. 使|commandBuffer|.{{GPUCommandBuffer/[[command_list]]}}为一个|this|.{{GPUCommandEncoder/[[command_list]]}}的[=list/clone=]。
                </div>

            3. 返回|commandBuffer|。
        </div>
</dl>

# Programmable Passes # {#programmable-passes}

<script type=idl>

interface mixin GPUProgrammablePassEncoder {
    undefined setBindGroup(GPUIndex32 index, GPUBindGroup bindGroup,
                      optional sequence<GPUBufferDynamicOffset> dynamicOffsets = []);

    undefined setBindGroup(GPUIndex32 index, GPUBindGroup bindGroup,
                      Uint32Array dynamicOffsetsData,
                      GPUSize64 dynamicOffsetsDataStart,
                      GPUSize32 dynamicOffsetsDataLength);

    undefined pushDebugGroup(USVString groupLabel);
    undefined popDebugGroup();
    undefined insertDebugMarker(USVString markerLabel);
};
</script>

{{GPUProgrammablePassEncoder}} has the following internal slots:

<dl dfn-type=attribute dfn-for="GPUProgrammablePassEncoder">
    : <dfn>\[[command_encoder]]</dfn> of type {{GPUCommandEncoder}}.
    ::
        The {{GPUCommandEncoder}} that created this programmable pass.

    : <dfn>\[[debug_group_stack]]</dfn> of type [=stack=]&lt;{{USVString}}&gt;.
    ::
        A stack of active debug group labels.

    : <dfn>\[[bind_groups]]</dfn>, of type [=ordered map=]&lt;{{GPUIndex32}}, {{GPUBindGroup}}&gt;
    ::
        The current {{GPUBindGroup}} for each index, initially empty.
</dl>

## Bind Groups ## {#programmable-passes-bind-groups}

<dl dfn-type=method dfn-for=GPUProgrammablePassEncoder>
    : <dfn>setBindGroup(index, bindGroup, dynamicOffsets)</dfn>
    ::
        Sets the current {{GPUBindGroup}} for the given index.

        <div algorithm=GPUProgrammablePassEncoder.setBindGroup>
            **Called on:** {{GPUProgrammablePassEncoder}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)">
                |index|: The index to set the bind group at.
                |bindGroup|: Bind group to use for subsequent render or compute commands.

                <!--The overload appears to be confusing bikeshed, and it ends up expecting this to
                define the arguments for the 5-arg variant of the method, despite the "for"
                explicitly pointing at the 3-arg variant.-->
                <!--|dynamicOffsets|: Array containing buffer offsets in bytes for each entry in
                    |bindGroup| marked as {{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/hasDynamicOffset}}.-->
            </pre>

            Issue: Resolve bikeshed conflict when using `argumentdef` with overloaded functions that prevents us from
                defining |dynamicOffsets|.

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|.{{GPUObjectBase/[[device]]}}:
            <div class=device-timeline>
                1. If any of the following conditions are unsatisfied, make |this| [=invalid=] and stop.
                    <div class=validusage>
                        - |bindGroup| is [$valid to use with$] |this|.
                        - |index| &lt; |this|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxBindGroups}}.
                        - |dynamicOffsets|.length is
                            |bindGroup|.{{GPUBindGroup/[[layout]]}}.{{GPUBindGroupLayout/[[dynamicOffsetCount]]}}.

                        - [$Iterate over each dynamic binding offset$] in |bindGroup| and
                            run the following steps for each |bufferBinding|, |bufferLayout|,
                            and |dynamicOffsetIndex|:

                            - Let |bufferDynamicOffset| be |dynamicOffsets|[|dynamicOffsetIndex|].
                            - |bufferBinding|.{{GPUBufferBinding/offset}} + |bufferDynamicOffset| +
                                |bufferLayout|.{{GPUBufferBindingLayout/minBindingSize}} &le;
                                |bufferBinding|.{{GPUBufferBinding/buffer}}.{{GPUBuffer/[[size]]}}.
                            - if |bufferLayout|.{{GPUBufferBindingLayout/type}} is {{GPUBufferBindingType/"uniform"}}:

                                - |dynamicOffset| is a multiple of {{supported limits/minUniformBufferOffsetAlignment}}.

                            - if |bufferLayout|.{{GPUBufferBindingLayout/type}} is {{GPUBufferBindingType/"storage"}}
                                or {{GPUBufferBindingType/"read-only-storage"}}:

                                - |dynamicOffset| is a multiple of {{supported limits/minStorageBufferOffsetAlignment}}.

                    </div>
                1. Set |this|.{{GPUProgrammablePassEncoder/[[bind_groups]]}}[|index|] to be |bindGroup|.
            </div>
        </div>

    : <dfn>setBindGroup(index, bindGroup, dynamicOffsetsData, dynamicOffsetsDataStart, dynamicOffsetsDataLength)</dfn>
    ::
        Sets the current {{GPUBindGroup}} for the given index, specifying dynamic offsets as a subset
        of a {{Uint32Array}}.

        <div algorithm=GPUProgrammablePassEncoder.setBindGroup2>
            **Called on:** {{GPUProgrammablePassEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsetsData, dynamicOffsetsDataStart, dynamicOffsetsDataLength)">
                |index|: The index to set the bind group at.
                |bindGroup|: Bind group to use for subsequent render or compute commands.
                |dynamicOffsetsData|: Array containing buffer offsets in bytes for each entry in
                    |bindGroup| marked as {{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/hasDynamicOffset}}.
                |dynamicOffsetsDataStart|: Offset in elements into |dynamicOffsetsData| where the
                    buffer offset data begins.
                |dynamicOffsetsDataLength|: Number of buffer offsets to read from |dynamicOffsetsData|.
            </pre>

            **Returns:** {{undefined}}

            1. If any of the following requirements are unmet, throw a {{RangeError}} and stop.
                <div class=validusage>
                    - |dynamicOffsetsDataStart| must be &ge; 0.
                    - |dynamicOffsetsDataStart| + |dynamicOffsetsDataLength| must be &le;
                        |dynamicOffsetsData|.`length`.
                </div>
            1. Let |dynamicOffsets| be a [=list=] containing the range, starting at index
                |dynamicOffsetsDataStart|, of |dynamicOffsetsDataLength| elements of
                [=get a copy of the buffer source|a copy of=] |dynamicOffsetsData|.
            1. Call |this|.{{GPUProgrammablePassEncoder/setBindGroup(index,
                bindGroup, dynamicOffsets)|setBindGroup}}(|index|, |bindGroup|, |dynamicOffsets|).
</dl>

<div>
    To <dfn abstract-op>Iterate over each dynamic binding offset</dfn> in a given {{GPUBindGroup}} |bindGroup|
    with a given list of |steps| to be executed for each dynamic offset:

    1. Let |dynamicOffsetIndex| be `0`.
    1. Let |layout| be |bindGroup|.{{GPUBindGroup/[[layout]]}}.
    1. For each {{GPUBindGroupEntry}} |entry| in |bindGroup|.{{GPUBindGroup/[[entries]]}}:
        1. Let |bindingDescriptor| be the {{GPUBindGroupLayoutEntry}} at
            |layout|.{{GPUBindGroupLayout/[[entryMap]]}}[|entry|.{{GPUBindGroupEntry/binding}}]:
        1. If |bindingDescriptor|.{{GPUBindGroupLayoutEntry/buffer}} is not `undefined` and
            |bindingDescriptor|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/hasDynamicOffset}} is `true`:
            1. Let |bufferBinding| be |entry|.{{GPUBindGroupEntry/resource}}.
            1. Let |bufferLayout| be |bindingDescriptor|.{{GPUBindGroupLayoutEntry/buffer}}.
            1. Call |steps| with |bufferBinding|, |bufferLayout|, and |dynamicOffsetIndex|.
            1. Let |dynamicOffsetIndex| be |dynamicOffsetIndex| + `1`
</div>

<div>
    <dfn abstract-op>Validate encoder bind groups</dfn>(encoder, pipeline)

    **Arguments:**
    : {{GPUProgrammablePassEncoder}} |encoder|
    :: Encoder who's bind groups are being validated.
    : {{GPUPipelineBase}} |pipeline|
    :: Pipline to validate |encoder|s bind groups are compatible with.

    If any of the following conditions are unsatisfied, return `false`:
        <div class=validusage>
            - |pipeline| must not be `null`.
            - For each pair of ({{GPUIndex32}} |index|, {{GPUBindGroupLayout}} |bindGroupLayout|) in
                |pipeline|.{{GPUPipelineBase/[[layout]]}}.{{GPUPipelineLayout/[[bindGroupLayouts]]}}.
                - Let |bindGroup| be |encoder|.{{GPUProgrammablePassEncoder/[[bind_groups]]}}[|index|].
                - |bindGroup| must not be `null`.
                - |bindGroup|.{{GPUBindGroup/[[layout]]}} must be [=group-equivalent=] with |bindGroupLayout|.

            Issue: Check buffer bindings against `minBindingSize` if present.
        </div>

    Otherwise return `true`.
</div>

## Debug Markers ## {#programmable-passes-debug-markers}

Debug marker methods for programmable pass encoders provide the same functionality as
[[#command-encoder-debug-markers|command encoder debug markers]] while recording a programmable
pass.

<dl dfn-type=method dfn-for=GPUProgrammablePassEncoder>
    : <dfn>pushDebugGroup(groupLabel)</dfn>
    ::
        Marks the beginning of a labeled group of commands for the {{GPUProgrammablePassEncoder}}.

        <div algorithm=GPUProgrammablePassEncoder.pushDebugGroup>
            **Called on:** {{GPUProgrammablePassEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUProgrammablePassEncoder/pushDebugGroup(groupLabel)">
                |groupLabel|: The label for the command group.
            </pre>

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|:
            <div class=device-timeline>
                1. [=stack/Push=] |groupLabel| onto |this|.{{GPUProgrammablePassEncoder/[[debug_group_stack]]}}.
            </div>
        </div>

    : <dfn>popDebugGroup()</dfn>
    ::
        Marks the end of a labeled group of commands for the {{GPUProgrammablePassEncoder}}.

        <div algorithm=GPUProgrammablePassEncoder.popDebugGroup>
            **Called on:** {{GPUProgrammablePassEncoder}} |this|.

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|:
            <div class=device-timeline>
                1. If any of the following conditions are unsatisfied, generate a validation
                    error and stop.
                    <div class=validusage>
                        - |this|.{{GPUProgrammablePassEncoder/[[debug_group_stack]]}}'s [=stack/size=] is greater than 0.
                    </div>
                1. [=stack/Pop=] an entry off of |this|.{{GPUProgrammablePassEncoder/[[debug_group_stack]]}}.
            </div>
        </div>

    : <dfn>insertDebugMarker(markerLabel)</dfn>
    ::
        Inserts a single debug marker label into the {{GPUProgrammablePassEncoder}}'s commands sequence.

        <div algorithm=GPUProgrammablePassEncoder.insertDebugMarker>
            **Called on:** {{GPUProgrammablePassEncoder}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUProgrammablePassEncoder/insertDebugMarker(markerLabel)">
                markerLabel: The label to insert.
            </pre>

            **Returns:** {{undefined}}
        </div>
</dl>

# 计算通道 # {#compute-passes}

## <dfn interface>GPUComputePassEncoder</dfn> ## {#compute-pass-encoder}

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUComputePassEncoder {
    undefined setPipeline(GPUComputePipeline pipeline);
    undefined dispatch(GPUSize32 x, optional GPUSize32 y = 1, optional GPUSize32 z = 1);
    undefined dispatchIndirect(GPUBuffer indirectBuffer, GPUSize64 indirectOffset);

    undefined beginPipelineStatisticsQuery(GPUQuerySet querySet, GPUSize32 queryIndex);
    undefined endPipelineStatisticsQuery();

    undefined writeTimestamp(GPUQuerySet querySet, GPUSize32 queryIndex);

    undefined endPass();
};
GPUComputePassEncoder includes GPUObjectBase;
GPUComputePassEncoder includes GPUProgrammablePassEncoder;
</script>

{{GPUComputePassEncoder}}有以下内部插槽：

<dl dfn-type=attribute dfn-for="GPUComputePassEncoder">
    : <dfn>\[[pipeline]]</dfn>, of type {{GPUComputePipeline}}
    ::
        当前{{GPUComputePipeline}}，初始为 `null`。
</dl>

### 创建 ### {#compute-pass-encoder-creation}

<script type=idl>
dictionary GPUComputePassDescriptor : GPUObjectDescriptorBase {
};
</script>

### 调度 ### {#compute-pass-encoder-dispatch}

<dl dfn-type=method dfn-for=GPUComputePassEncoder>
    : <dfn>setPipeline(pipeline)</dfn>
    ::
        设置当前{{GPUComputePipeline}}。

        <div algorithm="GPUComputePassEncoder.setPipeline">
            **Called on:** {{GPUComputePassEncoder}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUComputePassEncoder/setPipeline(pipeline)">
                |pipeline|: 用于后续调度命令的计算管道。
            </pre>

            **Returns:** {{undefined}}

            在|this|.{{GPUObjectBase/[[device]]}}的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                1. 如果以下任何条件未满足，使|this| [=invalid=]并且停止。
                    <div class=validusage>
                        - |pipeline|可以和|this|一起有效使用。
                    </div>
                1. 设置|this|.{{GPUComputePassEncoder/[[pipeline]]}}为|pipeline|。
            </div>
        </div>

    : <dfn>dispatch(x, y, z)</dfn>
    ::
        使用当前{{GPUComputePipeline}}执行的调度工作。有关详细规范，请参阅[[#computing-operations]]。

        <div algorithm="GPUComputePassEncoder.dispatch">
            **Called on:** {{GPUComputePassEncoder}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUComputePassEncoder/dispatch(x, y, z)">
                |x|: 要调度的工作组网格的X维度。
                |y|: 要调度的工作组网格的Y维度。
                |z|: 要调度的工作组网格的Z维度。
            </pre>

            **Returns:** {{undefined}}

            在|this|.{{GPUObjectBase/[[device]]}}的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                1. 如果以下任何条件未满足，使|this| [=invalid=]并停止。
                    <div class=validusage>
                        - [$Validate encoder bind groups$](|this|, |this|.{{GPUComputePassEncoder/[[pipeline]]}})为 `true`。
                        - |x|，|y|，和|z|都小于|this|.device.limits.{{supported limits/maxComputeWorkgroupsPerDimension}}。
                    </div>

                2. [=list/Append=]一个[=GPU command=]至|this|.{{GPUProgrammablePassEncoder/[[command_encoder]]}}.{{GPUCommandEncoder/[[command_list]]}}，它捕获|this|的{{GPUComputePassEncoder}}状态作为|passState|，并在执行时在适当的[=Queue timeline=]上发起以下步骤：
                        1. 使用|passState|.{{GPUComputePassEncoder/[[pipeline]]}}与|passState|.{{GPUProgrammablePassEncoder/[[bind_groups]]}}调度维度为[|x|, |y|, |z|]的工作组网格。
                    </div>
            </div>
        </div>

    : <dfn>dispatchIndirect(indirectBuffer, indirectOffset)</dfn>
    ::
        使用从{{GPUBuffer}}读取的参数调度要与当前{{GPUComputePipeline}一起执行的工作。有关详细规范，请参阅[[#computing-operations]]。

        缓冲区中<dfn dfn for=>indirect dispatch parameters</dfn>必须是三个**32位无符号整数值（共12个字节）**的紧密打包块，以与{{GPUComputePassEncoder/dispatch()}}的参数相同的顺序给出。例如：

        <pre highlight="js">
            let dispatchIndirectParameters = new Uint32Array(3);
            dispatchIndirectParameters[0] = x;
            dispatchIndirectParameters[1] = y;
            dispatchIndirectParameters[2] = z;
        </pre>

        <div algorithm="GPUComputePassEncoder.dispatchIndirect">
            **Called on:** {{GPUComputePassEncoder}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUComputePassEncoder/dispatchIndirect(indirectBuffer, indirectOffset)">
                |indirectBuffer|: Buffer containing the [=indirect dispatch parameters=].
                |indirectOffset|: Offset in bytes into |indirectBuffer| where the dispatch data begins.
            </pre>

            **Returns:** {{undefined}}

            在|this|.{{GPUObjectBase/[[device]]}}的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                1. 如果以下任何条件未满足, 使|this| [=invalid=]并停止。
                    <div class=validusage>
                        - [$Validate encoder bind groups$](|this|, |this|.{{GPUComputePassEncoder/[[pipeline]]}})为 `true`。
                        - |indirectBuffer|为[$valid to use with$] |this|。
                        - |indirectBuffer|.{{GPUBuffer/[[usage]]}}包含{{GPUBufferUsage/INDIRECT}}。
                        - |indirectOffset| + sizeof([=indirect dispatch parameters=]) &le;
                            |indirectBuffer|.{{GPUBuffer/[[size]]}}。
                        - |indirectOffset|是4的倍数。
                    </div>
                1. 使|indirectBuffer|作为{{GPUBufferUsage/INDIRECT}}加至[=usage scope=]。
            </div>

            问题：添加一些与{{supported limits/maxComputeWorkgroupsPerDimension}}有关的校验。
        </div>
</dl>

### 查询 ### {#compute-pass-encoder-queries}

<dl dfn-type=method dfn-for=GPUComputePassEncoder>
    : <dfn>beginPipelineStatisticsQuery(querySet, queryIndex)</dfn>
    ::

        <div algorithm="GPUComputePassEncoder.beginPipelineStatisticsQuery">
            **Called on:** {{GPUComputePassEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUComputePassEncoder/beginPipelineStatisticsQuery(querySet, queryIndex)">
                querySet:
                queryIndex:
            </pre>

            **Returns:** {{undefined}}

            1. 如果this|.{{GPUObjectBase/[[device]]}}.{{device/[[features]]}}未[=list/contain=]
                {{GPUFeatureName/"pipeline-statistics-query"}}，抛出一个{{TypeError}}。

            问题：描述{{GPUComputePassEncoder/beginPipelineStatisticsQuery()}}算法步骤。
        </div>

    : <dfn>endPipelineStatisticsQuery()</dfn>
    ::

        <div algorithm="GPUComputePassEncoder.endPipelineStatisticsQuery">
            **Called on:** {{GPUComputePassEncoder}} |this|.

            **Returns:** {{undefined}}

            1. 如果|this|.{{GPUObjectBase/[[device]]}}.{{device/[[features]]}}未[=list/contain=]
                {{GPUFeatureName/"pipeline-statistics-query"}}，抛出一个{{TypeError}}。

            问题：描述{{GPUComputePassEncoder/endPipelineStatisticsQuery()}}算法步骤。
        </div>

    : <dfn>writeTimestamp(querySet, queryIndex)</dfn>
    ::
        当所有先前命令被全部执行时，在|querySet|中写入一个时间戳。

        <div algorithm="GPUComputePassEncoder.writeTimestamp">
            **Called on:** {{GPUComputePassEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUComputePassEncoder/writeTimestamp(querySet, queryIndex)">
                |querySet|: 存储时间戳值的查询集合。
                |queryIndex|: 查询集合中的查询索引。
            </pre>

            **Returns:** {{undefined}}

            1. 如果|this|.{{GPUObjectBase/[[device]]}}.{{device/[[features]]}}未[=list/contain=]
                {{GPUFeatureName/"timestamp-query"}}, 抛出一个{{TypeError}}。
            2. 如果以下任何条件未满足，产生一个校验错误并停止。
                <div class=validusage>
                    - |querySet|可以和|this|一起有效使用。
                    - |querySet|.{{GPUQuerySet/[[descriptor]]}}.{{GPUQuerySetDescriptor/type}}为{{GPUQueryType/"timestamp"}}。
                    - |queryIndex| &lt; |querySet|.{{GPUQuerySet/[[descriptor]]}}.{{GPUQuerySetDescriptor/count}}。
                </div>

            问题：描述{{GPUComputePassEncoder/writeTimestamp()}}算法步骤。
        </div>
</dl>

### 结尾 ### {#compute-pass-encoder-finalization}

用户完成记录命令后，可以通过调用{{GPUComputePassEncoder/endPass()}}来结束计算通道编码器。一旦{{GPUComputePassEncoder/endPass()}}被调用，计算通道编码器就不能再使用了。

<dl dfn-type=method dfn-for=GPUComputePassEncoder>
    : <dfn>endPass()</dfn>
    ::
        完成计算通道命令序列的记录。

        <div algorithm="GPUComputePassEncoder.endPass">
            **Called on:** {{GPUComputePassEncoder}} |this|.

            **Returns:** {{undefined}}

            在|this|的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                1. 如果以下任何条件未满足，产生一个校验错误并停止。
                    <div class=validusage>
                        - |this|.{{GPUProgrammablePassEncoder/[[debug_group_stack]]}}'s [=stack/size=]为0。

                        问题：添加剩余校验。
                    </div>
            </div>
        </div>
</dl>

# 渲染通道 # {#render-passes}

## <dfn interface>GPURenderPassEncoder</dfn> ## {#render-pass-encoder}

<script type=idl>
interface mixin GPURenderEncoderBase {
    undefined setPipeline(GPURenderPipeline pipeline);

    undefined setIndexBuffer(GPUBuffer buffer, GPUIndexFormat indexFormat, optional GPUSize64 offset = 0, optional GPUSize64 size);
    undefined setVertexBuffer(GPUIndex32 slot, GPUBuffer buffer, optional GPUSize64 offset = 0, optional GPUSize64 size);

    undefined draw(GPUSize32 vertexCount, optional GPUSize32 instanceCount = 1,
              optional GPUSize32 firstVertex = 0, optional GPUSize32 firstInstance = 0);
    undefined drawIndexed(GPUSize32 indexCount, optional GPUSize32 instanceCount = 1,
                     optional GPUSize32 firstIndex = 0,
                     optional GPUSignedOffset32 baseVertex = 0,
                     optional GPUSize32 firstInstance = 0);

    undefined drawIndirect(GPUBuffer indirectBuffer, GPUSize64 indirectOffset);
    undefined drawIndexedIndirect(GPUBuffer indirectBuffer, GPUSize64 indirectOffset);
};

[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPURenderPassEncoder {
    undefined setViewport(float x, float y,
                     float width, float height,
                     float minDepth, float maxDepth);

    undefined setScissorRect(GPUIntegerCoordinate x, GPUIntegerCoordinate y,
                        GPUIntegerCoordinate width, GPUIntegerCoordinate height);

    undefined setBlendConstant(GPUColor color);
    undefined setStencilReference(GPUStencilValue reference);

    undefined beginOcclusionQuery(GPUSize32 queryIndex);
    undefined endOcclusionQuery();

    undefined beginPipelineStatisticsQuery(GPUQuerySet querySet, GPUSize32 queryIndex);
    undefined endPipelineStatisticsQuery();

    undefined writeTimestamp(GPUQuerySet querySet, GPUSize32 queryIndex);

    undefined executeBundles(sequence<GPURenderBundle> bundles);
    undefined endPass();
};
GPURenderPassEncoder includes GPUObjectBase;
GPURenderPassEncoder includes GPUProgrammablePassEncoder;
GPURenderPassEncoder includes GPURenderEncoderBase;
</script>

  * 在间接绘制调用中，基本实例字段（在间接缓冲区数据内）必须设置为零。

{{GPURenderEncoderBase}}有以下内部插槽：

<dl dfn-type=attribute dfn-for="GPURenderEncoderBase">
    : <dfn>\[[layout]]</dfn>, of type {{GPURenderPassLayout}}
    ::
        渲染通道的布局。

    : <dfn>\[[depthReadOnly]]</dfn>, of type boolean?
    ::
        如果存在，该标识表示深度分量未被修改。

    : <dfn>\[[stencilReadOnly]]</dfn>, of type boolean?
    ::
        如果存在，该标识表示模板组件未被修改。

    : <dfn>\[[pipeline]]</dfn>, of type {{GPURenderPipeline}}
    ::
        当前{{GPURenderPipeline}}, 初始为 `null`。

    : <dfn>\[[index_buffer]]</dfn>, of type {{GPUBuffer}}
    ::
        从中读取索引数据的当前缓冲区，初始为 `null`。

    : <dfn>\[[index_format]]</dfn>, of type {{GPUIndexFormat}}
    ::
        {{GPURenderEncoderBase/[[index_buffer]]}}中的索引数据的格式。

    : <dfn>\[[index_buffer_size]]</dfn>, of type {{GPUSize64}}
    ::
        当前设置的{{GPURenderEncoderBase/[[index_buffer]]}}节的字节大小，初始为0。

    : <dfn>\[[vertex_buffers]]</dfn>, of type [=ordered map=]&lt;slot, {{GPUBuffer}}&gt;
    ::
        当前要从每个插槽读取顶点数据的{{GPUBuffer}}s，初始为空。

    : <dfn>\[[vertex_buffer_sizes]]</dfn>, of type [=ordered map=]&lt;slot, {{GPUSize64}}&gt;
    ::
        当前为每个插槽设置的{{GPUBuffer}}部分的大小（以字节为单位），初始为空。
</dl>

{{GPURenderPassEncoder}} has the following internal slots:

<dl dfn-type=attribute dfn-for="GPURenderPassEncoder">
    : <dfn>\[[attachment_size]]</dfn>
    ::
        设置为以下范围：
            - `width, height` = 通道渲染附件的维度。

    : <dfn>\[[occlusion_query_set]]</dfn>, of type {{GPUQuerySet}}.
    ::
        用于存储通道的阻塞查询结果的{{GPUQuerySet}}，在通道创建时使用{{GPURenderPassDescriptor}}.{{GPURenderPassDescriptor/occlusionQuerySet}}进行初始化。

    : <dfn>\[[occlusion_query_active]]</dfn>, of type {{boolean}}.
    ::
        通道的{{GPURenderPassEncoder/[[occlusion_query_set]]}}是否被写入。

    : <dfn>\[[viewport]]</dfn>
    ::  当前视口矩形和深度范围。
</dl>

当{{GPURenderPassEncoder}}被创建，它有以下默认状态：
  * {{GPURenderPassEncoder/[[viewport]]}}:
      * `x, y` = `0.0, 0.0`
      * `width, height` = 通道渲染目标的维度
      * `minDepth, maxDepth` = `0.0, 1.0`
  * 裁剪矩形:
      * `x, y` = `0, 0`
      * `width, height` = 通道渲染目标的维度

### 创建 ### {#render-pass-encoder-creation}

<script type=idl>
dictionary GPURenderPassDescriptor : GPUObjectDescriptorBase {
    required sequence<GPURenderPassColorAttachment> colorAttachments;
    GPURenderPassDepthStencilAttachment depthStencilAttachment;
    GPUQuerySet occlusionQuerySet;
};
</script>

<dl dfn-type=dict-member dfn-for=GPURenderPassDescriptor>
    : <dfn>colorAttachments</dfn>
    ::
        此序列中的{{GPURenderPassColorAttachment}}值集，定义了在执行此渲染通道时将输出到哪些颜色附件。

    : <dfn>depthStencilAttachment</dfn>
    ::
        {{GPURenderPassDepthStencilAttachment}}值，定义了深度/模板附件，在执行此渲染通道时将输出到该附件并对其进行测试。

    : <dfn>occlusionQuerySet</dfn>
    ::
        {{GPUQuerySet}}值，定义了此通道的的阻塞查询结果将存储在哪里。
</dl>

<div class=validusage dfn-for=GPURenderPassDescriptor>
    <dfn abstract-op>Valid Usage</dfn>

    给定一个{{GPURenderPassDescriptor}} |this|，应用以下校验规则：

    1. |this|.{{GPURenderPassDescriptor/colorAttachments}}.length小于或等于8。
    2. |this|.{{GPURenderPassDescriptor/colorAttachments}}.length必须大于 `0` 或|this|.{{GPURenderPassDescriptor/depthStencilAttachment}}必须不为 `null`。
    3. 对每个|this|.{{GPURenderPassDescriptor/colorAttachments}}中的|colorAttachment|：

        1. |colorAttachment|必须满足[$GPURenderPassColorAttachment/GPURenderPassColorAttachment Valid Usage$]规则。

    4. 如果|this|.{{GPURenderPassDescriptor/depthStencilAttachment}}不为 `null`：

        1. |this|.{{GPURenderPassDescriptor/depthStencilAttachment}}必须满足[$GPURenderPassDepthStencilAttachment/GPURenderPassDepthStencilAttachment Valid Usage$]规则。

    5. 所有|this|.{{GPURenderPassDescriptor/colorAttachments}}中的{{GPURenderPassColorAttachment/view}}，以及|this|.{{GPURenderPassDescriptor/depthStencilAttachment}}.{{GPURenderPassDepthStencilAttachment/view}}，
        如果存在，必须有相等的{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/sampleCount}}。

    6. 对每个|this|.{{GPURenderPassDescriptor/colorAttachments}}中的{{GPURenderPassColorAttachment/view}}以及|this|.{{GPURenderPassDescriptor/depthStencilAttachment}}.{{GPURenderPassDepthStencilAttachment/view}}，
        如果存在，{{GPUTextureView/[[renderExtent]]}}必须匹配。

    7. 如果|this|.{{GPURenderPassDescriptor/occlusionQuerySet}}不为 `null`：

        1. |this|.{{GPURenderPassDescriptor/occlusionQuerySet}}.{{GPUQuerySet/[[descriptor]]}}.{{GPUQuerySetDescriptor/type}}必须为{{GPUQueryType/occlusion}}。

    问题(gpuweb/gpuweb#503)：支持无附件。
</div>

<div algorithm="GPURenderPassDescriptor accessors" dfn-for=RenderPassDescriptor>
    对一个给定{{GPURenderPassDescriptor}}值的|descriptor|，句法：

      - |descriptor|.<dfn dfn>renderExtent</dfn>指任何{{GPUTextureView/[[descriptor]]}}中的{{GPUTextureView/[[renderExtent]]}}在|descriptor|.{{GPURenderPassDescriptor/depthStencilAttachment}}.{{GPURenderPassDepthStencilAttachment/view}}或任何|descriptor|.{{GPURenderPassDescriptor/colorAttachments}}中的{{GPURenderPassColorAttachment/view}}中。

    问题：一旦我们从其他地方引用它，就定义它。

    注意：[$GPURenderPassDescriptor/Valid Usage$]保证附件的所有渲染范围都是相同的，因此我们可以采用其中的任何一个，假设描述符是有效的。
</div>

#### 颜色附件 #### {#color-attachments}

<script type=idl>
dictionary GPURenderPassColorAttachment {
    required GPUTextureView view;
    GPUTextureView resolveTarget;

    required (GPULoadOp or GPUColor) loadValue;
    required GPUStoreOp storeOp;
};
</script>

<dl dfn-type=dict-member dfn-for=GPURenderPassColorAttachment>
    : <dfn>view</dfn>
    ::
        {{GPUTextureView}}描述将为此颜色附件输出到的纹理[=subresource=]。

    : <dfn>resolveTarget</dfn>
    ::
        一个{{GPUTextureView}}描述纹理[=subresource=]，如果{{GPURenderPassColorAttachment/view}}是多采样的，它将接收此颜色附件的解析输出。

    : <dfn>loadValue</dfn>
    ::
        如果是{{GPULoadOp}}，则指示在执行渲染通道之前要在{{GPURenderPassColorAttachment/view}}上执行的加载操作。如果是{{GPUColor}}，则指示在执行渲染通道之前清除{{GPURenderPassColorAttachment/view}}的值。

        注意：建议选择clear-value；见{{GPULoadOp/"load"}}。

    : <dfn>storeOp</dfn>
    ::
        执行渲染通道后对{{GPURenderPassColorAttachment/view}}执行的存储操作。
</dl>

<div class=validusage dfn-for=GPURenderPassColorAttachment>
    <dfn abstract-op>GPURenderPassColorAttachment Valid Usage</dfn>

    给定一个{{GPURenderPassColorAttachment}} |this|，应用以下校验规则：

    1. 使|renderTextureDesc|为|this|.{{GPURenderPassColorAttachment/view}}.{{GPUTextureView/[[texture]]}}.{{GPUTexture/[[descriptor]]}}。
    2. 使|resolveTextureDesc|为|this|.{{GPURenderPassColorAttachment/resolveTarget}}.{{GPUTextureView/[[texture]]}}.{{GPUTexture/[[descriptor]]}}。
    3. |this|.{{GPURenderPassColorAttachment/view}}必须有一个[=color renderable format=]。
    4. |renderTextureDesc|.{{GPUTextureDescriptor/usage}必须包含{{GPUTextureUsage/RENDER_ATTACHMENT}}。
    5. |this|.{{GPURenderPassColorAttachment/view}}必须为一个单个[=subresource=]视图。
    6. 如果|this|.{{GPURenderPassColorAttachment/resolveTarget}}不为 `null`：

        1. |this|.{{GPURenderPassColorAttachment/view}}必须为多重采样。
        2. |this|.{{GPURenderPassColorAttachment/resolveTarget}}必须不为多重采样。
        3. |resolveTextureDesc|.{{GPUTextureDescriptor/usage}}必须包含{{GPUTextureUsage/RENDER_ATTACHMENT}}。
        4. |this|.{{GPURenderPassColorAttachment/resolveTarget}}必须为一个单个[=subresource=]视图。

        5. 被|this|.{{GPURenderPassColorAttachment/resolveTarget}}和|this|.{{GPURenderPassColorAttachment/view}}所见的[=subresource=]维度必须匹配。
        6. |resolveTextureDesc|.{{GPUTextureDescriptor/format}}必须匹配|renderTextureDesc|.{{GPUTextureDescriptor/format}}.
        7. 问题：描述任何剩余的resolveTarget校验。

    问题：描述此类型的其余校验规则。
</div>

#### 深度/模板附件 #### {#depth-stencil-attachments}

<script type=idl>
dictionary GPURenderPassDepthStencilAttachment {
    required GPUTextureView view;

    required (GPULoadOp or float) depthLoadValue;
    required GPUStoreOp depthStoreOp;
    boolean depthReadOnly = false;

    required (GPULoadOp or GPUStencilValue) stencilLoadValue;
    required GPUStoreOp stencilStoreOp;
    boolean stencilReadOnly = false;
};
</script>

<dl dfn-type=dict-member dfn-for=GPURenderPassDepthStencilAttachment>
    : <dfn>view</dfn>
    ::
        一个描述纹理[=subresource=]的{{GPUTextureView}}，它将输出至此深度/模板附件，以及从此深度/模板附件中读取。

    : <dfn>depthLoadValue</dfn>
    ::
        如果是{{GPULoadOp}}，则指示在执行渲染通道之前要对视图的深度组件执行的加载操作。如果是 `float`，则表示在执行渲染通道之前清除视图深度组件的值。

        注意：建议选择clear-value；见{{GPULoadOp/"load"}}。

    : <dfn>depthStoreOp</dfn>
    ::
        执行渲染通道后对{{GPURenderPassDepthStencilAttachment/view}}深度组件执行的存储操作。

        注意：建议选择clear-value；见{{GPULoadOp/"load"}}。

    : <dfn>depthReadOnly</dfn>
    ::
        指{{GPURenderPassDepthStencilAttachment/view}}的深度组件，只读。

    : <dfn>stencilLoadValue</dfn>
    ::
        如果是{{GPULoadOp}}，则指在执行渲染通道之前要在{{GPURenderPassDepthStencilAttachment/view}}的模板组件上执行的加载操作。如果是{{GPUStencilValue}}，则指在执行渲染通道之前将{{GPURenderPassDepthStencilAttachment/view}}的模板组件清除到的值。

    : <dfn>stencilStoreOp</dfn>
    ::
        执行渲染通道后在{{GPURenderPassDepthStencilAttachment/view}}的模板组件上执行的存储操作。

    : <dfn>stencilReadOnly</dfn>
    ::
        指{{GPURenderPassDepthStencilAttachment/view}}的模板组件，只读。
</dl>

<div class=validusage dfn-for=GPURenderPassDepthStencilAttachment>
    <dfn abstract-op>GPURenderPassDepthStencilAttachment Valid Usage</dfn>

    给定一个{{GPURenderPassDepthStencilAttachment}} |this|，应用以下校验规则：

    - |this|.{{GPURenderPassDepthStencilAttachment/view}}必须有一个[=depth or stencil renderable
        format=].
    - |this|.{{GPURenderPassDepthStencilAttachment/view}}必须为一个单个[=mipmap level=], single [=array layer=], 和所有纹理中 [=aspects=]的视图。
    - |this|.{{GPURenderPassDepthStencilAttachment/view}}.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/usage}}必须包含{{GPUTextureUsage/RENDER_ATTACHMENT}}。
    - 如果|this|.{{GPURenderPassDepthStencilAttachment/view}}.{{GPUTextureView/[[descriptor]]}}.{{GPUTextureViewDescriptor/format}}既包含深度宽高比又包含模板宽高比（见[[#depth-formats|depth-stencil formats]]）：
        - |this|.{{GPURenderPassDepthStencilAttachment/depthReadOnly}}必须等于|this|.{{GPURenderPassDepthStencilAttachment/stencilReadOnly}}
    - 如果|this|.{{GPURenderPassDepthStencilAttachment/depthReadOnly}}为 `true`：
        - |this|.{{GPURenderPassDepthStencilAttachment/depthLoadValue}}必须为{{GPULoadOp/"load"}}。
        - |this|.{{GPURenderPassDepthStencilAttachment/depthStoreOp}}必须为{{GPUStoreOp/"store"}}。
    - 如果|this|.{{GPURenderPassDepthStencilAttachment/stencilReadOnly}}为 `true`:
        - |this|.{{GPURenderPassDepthStencilAttachment/stencilLoadValue}}必须为{{GPULoadOp/"load"}}。
        - |this|.{{GPURenderPassDepthStencilAttachment/stencilStoreOp}}必须为{{GPUStoreOp/"store"}}。

    问题：描述此类型的其余校验规则。
</div>

#### 加载&amp;存储操作 #### {#load-and-store-ops}

<script type=idl>
enum GPULoadOp {
    "load"
};
</script>

<dl dfn-type=enum-value dfn-for=GPULoadOp>
    : <dfn>"load"</dfn>
    ::
        将此附件的现有值加载到渲染通道中。

        注意：在某些GPU硬件（主要是移动设备）上，提供clear-value的成本要低得多，因为它避免了将数据从主内存加载到tile-local内存中。在其他GPU硬件上，没有显着差异。因此，在初始值无关紧要的情况下（例如，将使用天空盒清除渲染目标），建议使用清除值，而不是{{GPULoadOp/"load"}}。
</dl>

<script type=idl>
enum GPUStoreOp {
    "store",
    "discard"
};
</script>

#### 渲染通道布局 #### {#render-pass-layout}

{{GPURenderPassLayout}}包含当前通道渲染目标的布局，它决定了通道与渲染管线的兼容性。

<script type=idl>
dictionary GPURenderPassLayout: GPUObjectDescriptorBase {
    required sequence<GPUTextureFormat> colorFormats;
    GPUTextureFormat depthStencilFormat;
    GPUSize32 sampleCount = 1;
};
</script>

<div>
    从通道派生渲染目标布局（<dfn abstract-op>derive render targets layout from pass</dfn>）

    **Arguments:**
    - {{GPURenderPassDescriptor}} |descriptor|

    **Returns:** {{GPURenderPassLayout}}

    1. 使|layout|为一个新的{{GPURenderPassLayout}}对象。
    2. 对每个|descriptor|.{{GPURenderPassDescriptor/colorAttachments}}中的|colorAttachment|：
        1. 设置|layout|.{{GPURenderPassLayout/sampleCount}}为|colorAttachment|.{{GPURenderPassColorAttachment/view}}.{{GPUTextureView/[[texture]]}}.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/sampleCount}}。
        2. 将|colorAttachment|.{{GPURenderPassColorAttachment/view}}.{{GPUTextureView/[[descriptor]]}}.{{GPUTextureViewDescriptor/format}}添加至|layout|.{{GPURenderPassLayout/colorFormats}}。
    3. 使|depthStencilAttachment|为|descriptor|.{{GPURenderPassDescriptor/depthStencilAttachment}}.
    4. 如果|depthStencilAttachment|不为 `null`：
        1. 使|view|为|depthStencilAttachment|.{{GPURenderPassDepthStencilAttachment/view}}
        2. 使|layout|.{{GPURenderPassLayout/sampleCount}}为|view|.{{GPUTextureView/[[texture]]}}.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/sampleCount}}。
        3. 使|layout|.{{GPURenderPassLayout/depthStencilFormat}}为|view|.{{GPUTextureView/[[descriptor]]}}.{{GPUTextureViewDescriptor/format}}。
    5. 返回|layout|。

</div>

<div>
    从管线派生渲染目标布局（<dfn abstract-op>derive render targets layout from pipeline</dfn>）

    **Arguments:**
    - {{GPURenderPipelineDescriptor}} |descriptor|

    **Returns:** {{GPURenderPassLayout}}

    1. 使|layout|为一个新的{{GPURenderPassLayout}}对象。
    2. 设置|layout|.{{GPURenderPassLayout/sampleCount}}为|descriptor|.{{GPURenderPipelineDescriptor/multisample}}.{{GPUMultisampleState/count}}。
    3. 如果|descriptor|.{{GPURenderPipelineDescriptor/depthStencil}}不为 `null`：
        1. 设置|layout|.{{GPURenderPassLayout/depthStencilFormat}}为|descriptor|.{{GPURenderPipelineDescriptor/depthStencil}}/{{GPUDepthStencilState/format}}。
    4. 如果|descriptor|.{{GPURenderPipelineDescriptor/fragment}}不为 `null`:
        1. 对每个|descriptor|.{{GPURenderPipelineDescriptor/fragment}}.{{GPUFragmentState/targets}}中的|colorTarget|：
            1. 添加|colorTarget|.{{GPUColorTargetState/format}}至|layout|.{{GPURenderPassLayout/colorFormats}}
    5. 返回|layout|。

</div>

### 绘制 ### {#render-pass-encoder-drawing}

<dl dfn-type=method dfn-for=GPURenderEncoderBase>
    : <dfn>setPipeline(pipeline)</dfn>
    ::
        设置当前{{GPURenderPipeline}}。

        <div algorithm="GPURenderEncoderBase.setPipeline">
            **Called on:** {{GPURenderEncoderBase}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderEncoderBase/setPipeline(pipeline)">
                |pipeline|: 后续绘制命令使用的渲染管线。
            </pre>

            **Returns:** {{undefined}}

            在|this|.{{GPUObjectBase/[[device]]}}的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                1. 使|pipelineTargetsLayout|为[$derive render targets layout from pipeline$](|pipeline|.{{GPURenderPipeline/[[descriptor]]}})。
                2. 如果以下任何条件未满足, 使|this| [=invalid=]并停止。
                    <div class=validusage>
                        - |pipeline|可以同|this|一起有效使用。
                        - |this|.{{GPURenderEncoderBase/[[layout]]}}等于|pipelineTargetsLayout|。
                        - 如果|pipeline|.{{GPURenderPipeline/[[writesDepth]]}}：
                            |this|.{{GPURenderEncoderBase/[[depthReadOnly]]}}必须为 `false`。
                        - If |pipeline|.{{GPURenderPipeline/[[writesStencil]]}}：
                            |this|.{{GPURenderEncoderBase/[[stencilReadOnly]]}}必须为 `false`。
                    </div>
                3. 设置|this|.{{GPURenderEncoderBase/[[pipeline]]}}为|pipeline|。

                问题：定义对于这里的{{GPURenderPassLayout}}"等于"的含义。
            </div>
        </div>

    : <dfn>setIndexBuffer(buffer, indexFormat, offset, size)</dfn>
    ::
        设置当前索引缓冲区。

        <div algorithm="GPURenderEncoderBase.setIndexBuffer">
            **Called on:** {{GPURenderEncoderBase}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderEncoderBase/setIndexBuffer(buffer, indexFormat, offset, size)">
                |buffer|: 包含后续绘制命令所使用的索引数据的缓冲区。
                |indexFormat|: |buffer|中包含的索引数据的格式。
                |offset|: 以字节为单位在索引数据开始的|缓冲区|中的偏移量。默认为 `0`。
                |size|: |缓冲区|中索引数据的大小（以字节为单位）。默认为缓冲区的大小减去偏移量。
            </pre>

            **Returns:** {{undefined}}

            在|this|.{{GPUObjectBase/[[device]]}}的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                1. 如果|size|缺失，设置|size|为|buffer|.{{GPUBuffer/[[size]]}} - |offset|。
                1. 如果以下任何条件未满足，使|this| [=invalid=]并停止。
                    <div class=validusage>
                        - |buffer|可以和|this|一起有效使用。
                        - |buffer|.{{GPUBuffer/[[usage]]}}包含{{GPUBufferUsage/INDEX}}。
                        - |offset|是|indexFormat|字节大小的倍数。
                        - |offset| + |size| &le; |buffer|.{{GPUBuffer/[[size]]}}。
                    </div>
                1. 将|buffer|作为[=internal usage/input=]加至[=usage scope=]。
                1. 设置|this|.{{GPURenderEncoderBase/[[index_buffer]]}}为|buffer|。
                1. 设置|this|.{{GPURenderEncoderBase/[[index_format]]}}为|indexFormat|。
                1. 设置|this|.{{GPURenderEncoderBase/[[index_buffer_size]]}}为|size|。
            </div>
        </div>

    : <dfn>setVertexBuffer(slot, buffer, offset, size)</dfn>
    ::
        设置给定槽的当前顶点缓冲区。

        <div algorithm="GPURenderEncoderBase.setVertexBuffer">
            **Called on:** {{GPURenderEncoderBase}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderEncoderBase/setVertexBuffer(slot, buffer, offset, size)">
                |slot|: 要为其设置顶点缓冲区的顶点缓冲区插槽。
                |buffer|: 包含用于后续绘图命令的顶点数据的缓冲区。
                |offset|: 以字节为单位在顶点数据开始的|缓冲区|中的偏移量。默认为 0。
                |size|: |缓冲区|中顶点数据的大小（以字节为单位）。默认为|缓冲区|的大小减去偏移量。
            </pre>

            **Returns:** {{undefined}}

            在|this|.{{GPUObjectBase/[[device]]}}的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                1. 如果|size|缺失, 设置|size|为|buffer|.{{GPUBuffer/[[size]]}} - |offset|.
                2. 如果以下任何条件未满足，使|this| [=invalid=]并且停止。
                    <div class=validusage>
                        - |buffer|可以和|this|一起有效使用。
                        - |buffer|.{{GPUBuffer/[[usage]]}}包含{{GPUBufferUsage/VERTEX}}。
                        - |slot| &lt; |this|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxVertexBuffers}}。
                        - |offset|是4的倍数。
                        - |offset| + |size| &le; |buffer|.{{GPUBuffer/[[size]]}}。
                    </div>
                3. 将|缓冲区|作为[=internal usage/input=]加至[=usage scope=]。
                4. 设置|this|.{{GPURenderEncoderBase/[[vertex_buffers]]}}[|slot|]为|buffer|。
                5. 设置|this|.{{GPURenderEncoderBase/[[vertex_buffer_sizes]]}}[|slot|]为|size|。
            </div>
        </div>

    : <dfn>draw(vertexCount, instanceCount, firstVertex, firstInstance)</dfn>
    ::
        绘制图元。见[[#rendering-operations]]。

        <div algorithm="GPURenderEncoderBase.draw">
            **Called on:** {{GPURenderEncoderBase}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderEncoderBase/draw(vertexCount, instanceCount, firstVertex, firstInstance)">
                |vertexCount|: 绘制顶点数。
                |instanceCount|: 绘制实例数。
                |firstVertex|: 开始绘制的位置，以定点为单位的定点缓冲区偏移量。
                |firstInstance|: 第一个绘制实例。
            </pre>

            **Returns:** {{undefined}}

            在|this|.{{GPUObjectBase/[[device]]}}的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                如果以下任何条件未满足，使|this| [=invalid=]并停止。
                <div class=validusage>
                    - 可以和|this|一起有效绘制。
                    - 使|buffers|为|this|.{{GPURenderEncoderBase/[[pipeline]]}}.{{GPURenderPipeline/[[descriptor]]}}.{{GPURenderPipelineDescriptor/vertex}}.{{GPUVertexState/buffers}}.
                    - 对每个{{GPUIndex32}} |slot| `0`至|buffers|.length：
                        - 使|bufferSize|为|this|.{{GPURenderEncoderBase/[[vertex_buffer_sizes]]}}[|slot|]。
                        - 使|stride|为|buffers|[|slot|].{{GPUVertexBufferLayout/arrayStride}}。
                        - 如果|stride|为零：
                            - 对每个|this|.{{GPURenderEncoderBase/[[pipeline]]}}.{{GPURenderPipeline/[[descriptor]]}}.{{GPURenderPipelineDescriptor/vertex}}.{{GPUVertexState/buffers}}.{{GPUVertexBufferLayout/attributes}}列表中|attrib|属性：
                                - |attrib|.{{GPUVertexAttribute/offset}} + sizeof(|attrib|.{{GPUVertexAttribute/format}}) &le;
                                    |bufferSize|

                            否则：

                            - 如果|buffers|[|slot|].{{GPUVertexBufferLayout/stepMode}}为：
                                <dl class="switch">
                                    : {{GPUVertexStepMode/"vertex"}}
                                    :: (|firstVertex| + |vertexCount|) * |stride| &le; |bufferSize|.
                                    : {{GPUVertexStepMode/"instance"}}
                                    :: (|firstInstance| + |instanceCount|) * |stride| &le; |bufferSize|.
                                </dl>
                </div>
            </div>
        </div>

    : <dfn>drawIndexed(indexCount, instanceCount, firstIndex, baseVertex, firstInstance)</dfn>
    ::
        绘制索引图元。见[[#rendering-operations]]。

        <div algorithm="GPURenderEncoderBase.drawIndexed">
            **Called on:** {{GPURenderEncoderBase}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderEncoderBase/drawIndexed(indexCount, instanceCount, firstIndex, baseVertex, firstInstance)">
                |indexCount|: 要绘制的索引数。
                |instanceCount|: 要绘制的实例数。
                |firstIndex|: 开始绘制时，在索引缓冲区中的索引偏移量。
                baseVertex: 在索引到顶点缓冲区之前添加到每个索引值。
                |firstInstance|: 第一个绘制实例。
            </pre>

            **Returns:** {{undefined}}

            在|this|.{{GPUObjectBase/[[device]]}}的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                如果以下任何条件未满足，使this| [=invalid=]并停止。
                <div class=validusage>
                    - 可以和|this|一起有效绘制索引。
                    - |firstIndex| + |indexCount| &le; |this|.{{GPURenderEncoderBase/[[index_buffer_size]]}}
                        &div; |this|.{{GPURenderEncoderBase/[[index_format]]}}'s byte size;
                    - 使|buffers|为|this|.{{GPURenderEncoderBase/[[pipeline]]}}.{{GPURenderPipeline/[[descriptor]]}}.{{GPURenderPipelineDescriptor/vertex}}.{{GPUVertexState/buffers}}。
                    - 对每个{{GPUIndex32}} |slot| `0`至|buffers|.length：
                        - 使|bufferSize|为|this|.{{GPURenderEncoderBase/[[vertex_buffer_sizes]]}}[|slot|]。
                        - 使|stride|为|buffers|[|slot|].{{GPUVertexBufferLayout/arrayStride}}。
                        - 如果|stride|为零：
                            - 对每个|this|.{{GPURenderEncoderBase/[[pipeline]]}}.{{GPURenderPipeline/[[descriptor]]}}.{{GPURenderPipelineDescriptor/vertex}}.{{GPUVertexState/buffers}}.{{GPUVertexBufferLayout/attributes}}列表中的|attrib|属性：
                                - |attrib|.{{GPUVertexAttribute/offset}} + sizeof(|attrib|.{{GPUVertexAttribute/format}}) &le;
                                    |bufferSize|

                            否则：

                            - 如果|buffers|[|slot|].{{GPUVertexBufferLayout/stepMode}}为{{GPUVertexStepMode/"instance"}}:
                                - (|firstInstance| + |instanceCount|) * |stride| &le; |bufferSize|.
                </div>
            </div>
        </div>

    : <dfn>drawIndirect(indirectBuffer, indirectOffset)</dfn>
    ::
        使用从{{GPUBuffer}}中读取的参数的绘制图元。见[[#rendering-operations]]。

        缓冲区中编码的<dfn dfn for=>indirect draw parameters</dfn>必须是一个由**四个32位无符号整数值（总共16个字节）**组成的紧密压缩块，以与{{GPURenderEncoderBase/draw()}}的参数相同的顺序给出。比如：

        <pre highlight="js">
            let drawIndirectParameters = new Uint32Array(4);
            drawIndirectParameters[0] = vertexCount;
            drawIndirectParameters[1] = instanceCount;
            drawIndirectParameters[2] = firstVertex;
            drawIndirectParameters[3] = 0; // firstInstance. Must be 0.
        </pre>

        对应 `firstInstance` 的值被保留以备日后使用，并且必须为零。如果它不为零则{{GPURenderEncoderBase/drawIndirect()}}调用被视作一个no-op。
        <div algorithm="GPURenderEncoderBase.drawIndirect">
            **Called on:** {{GPURenderEncoderBase}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderEncoderBase/drawIndirect(indirectBuffer, indirectOffset)">
                |indirectBuffer|: 包含[=indirect draw parameters=]的缓冲区。
                |indirectOffset|: 到绘图数据开始的|indirectBuffer|的以字节为单位的偏移量。
            </pre>

            **Returns:** {{undefined}}

            在|this|.{{GPUObjectBase/[[device]]}}的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                1. 如果以下任何条件未满足，使|this| [=invalid=]并停止。
                    <div class=validusage>
                        - 它可以和|this|一起有效绘制。
                        - |indirectBuffer|可以和|this|一起有效使用。
                        - |indirectBuffer|.{{GPUBuffer/[[usage]]}}包含{{GPUBufferUsage/INDIRECT}}。
                        - |indirectOffset| + sizeof([=indirect draw parameters=]) &le;
                            |indirectBuffer|.{{GPUBuffer/[[size]]}}。
                        - |indirectOffset|是4的倍数。
                    </div>
                2. 将|indirectBuffer|加至[=usage scope=] as [=internal usage/input=]。
            </div>
        </div>

    : <dfn>drawIndexedIndirect(indirectBuffer, indirectOffset)</dfn>
    ::
        使用从{{GPUBuffer}}读取的参数的绘制索引图元。见[[#rendering-operations]]。

        缓冲区中编码的<dfn dfn for=>indirect drawIndexed parameters</dfn>必须是由**五个32位无符号整数值（共 20 个字节）**组成的紧密压缩块，其顺序与{{GPURenderEncoderBase/drawIndexed()}}的参数相同。比如：

        <pre highlight="js">
            let drawIndexedIndirectParameters = new Uint32Array(5);
            drawIndexedIndirectParameters[0] = indexCount;
            drawIndexedIndirectParameters[1] = instanceCount;
            drawIndexedIndirectParameters[2] = firstIndex;
            drawIndexedIndirectParameters[3] = baseVertex;
            drawIndexedIndirectParameters[4] = 0; // firstInstance. Must be 0.
        </pre>

        对应 `firstInstance` 的值被保留以备日后使用并且必须为零。如果它不为零，则{{GPURenderEncoderBase/drawIndexedIndirect()}}调用被视作一个no-op。

        <div algorithm="GPURenderEncoderBase.drawIndexedIndirect">
            **Called on:** {{GPURenderEncoderBase}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderEncoderBase/drawIndexedIndirect(indirectBuffer, indirectOffset)">
                |indirectBuffer|: 包含[=indirect drawIndexed parameters=]的缓冲区。
                |indirectOffset|: 绘制数据开始处|indirectBuffer|中的字节偏移量。
            </pre>

            **Returns:** {{undefined}}

            在|this|.{{GPUObjectBase/[[device]]}}的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                1. 如果以下任何条件未满足，使|this| [=invalid=]并且停止。
                    <div class=validusage>
                        - 可以和|this|一起有效绘制索引。
                        - |indirectBuffer|可以和|this|一起有效使用。
                        - |indirectBuffer|.{{GPUBuffer/[[usage]]}}包含{{GPUBufferUsage/INDIRECT}}.
                        - |indirectOffset| + sizeof([=indirect drawIndexed parameters=]) &le;
                            |indirectBuffer|.{{GPUBuffer/[[size]]}}.
                        - |indirectOffset|是4的倍数。
                    </div>
                2. 将|indirectBuffer|添加至[=usage scope=] as [=internal usage/input=]。
            </div>
        </div>
</dl>

注意：最初禁用为间接绘制调用设置 `firstInstance` 的功能，以扩展支持WebGPU的硬件。它很可能在未来与其他新的间接绘图功能一起作为一个特性添加。

<div>
    要确定使用{{GPURenderEncoderBase}}|编码器|是否<dfn abstract-op>valid to draw</dfn>，运行以下步骤：

    如果以下任何条件未满足，返回 `false`：
        <div class=validusage>
            - [$Validate encoder bind groups$](|encoder|, |encoder|.{{GPURenderEncoderBase/[[pipeline]]}})必须为 `true`。

            - 使|pipelineDescriptor|为|encoder|.{{GPURenderEncoderBase/[[pipeline]]}}.{{GPURenderPipeline/[[descriptor]]}}。
            - 对每个{{GPUIndex32}} |slot| `0`至|pipelineDescriptor|.{{GPURenderPipelineDescriptor/vertex}}.{{GPUVertexState/buffers}}.length:
                - |encoder|.{{GPURenderEncoderBase/[[vertex_buffers]]}}[|slot|]必须不为 `null`。
        </div>

    否则返回 `true`。
</div>

<div>
    要确定使用{{GPURenderEncoderBase}}|编码器|进行索引绘制（<dfn abstract-op>valid to draw indexed</dfn>）是否有效，请运行以下步骤：

    如果以下任何条件未满足, 返回 `false`：
        <div class=validusage>
            - 使用编码器绘制必须有效。

            - |encoder|.{{GPURenderEncoderBase/[[index_buffer]]}}必须不为 `null`。
            - 使|stripIndexFormat|为|encoder|.{{GPURenderEncoderBase/[[pipeline]]}}.{{GPURenderPipeline/[[strip_index_format]]}}。
            - 如果|stripIndexFormat|不是 `undefined`：
                - |encoder|.{{GPURenderEncoderBase/[[index_format]]}}必须为|stripIndexFormat|。
        </div>

    否则返回 `true`。
</div>

### 光栅化状态 ### {#render-pass-encoder-rasterization-state}

{{GPURenderPassEncoder}}有几种方法会影响绘制命令如何光栅化到此编码器使用的附件。

<dl dfn-type=method dfn-for=GPURenderPassEncoder>
    : <dfn>setViewport(x, y, width, height, minDepth, maxDepth)</dfn>
    ::
        将光栅化阶段使用的视口设置为从标准化设备坐标线性映射到视口坐标。

        <div algorithm="GPURenderPassEncoder.setViewport">
            **Called on:** {{GPURenderPassEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPURenderPassEncoder/setViewport(x, y, width, height, minDepth, maxDepth)">
                |x|: 视口最小X像素值。
                |y|: 视口最小Y像素值。
                |width|: 视口宽度像素值。
                |height|: 视口高度像素值。
                |minDepth|: 视口最小深度。
                |maxDepth|: 视口最大深度。
            </pre>

            **Returns:** {{undefined}}

            在|this|的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                1. 如果以下任何条件未满足，产生一个校验错误并停止。
                    <div class=validusage>
                        - |x|大于等于 `0`。
                        - |y|大于等于 `0`。
                        - |width|大于等于 `0`。
                        - |height|大于等于 `0`。
                        - |x| + |width|小于等于|this|.{{GPURenderPassEncoder/[[attachment_size]]}}.width.
                        - |y| + |height|小于等于|this|.{{GPURenderPassEncoder/[[attachment_size]]}}.height.
                        - |minDepth|大于等于 `0.0`，小于等于 `1.0`。
                        - |maxDepth|大于等于 `0.0`，小于等于 `1.0`。
                        - |maxDepth|大于|minDepth|。
                    </div>
                2. 设置|this|.{{GPURenderPassEncoder/[[viewport]]}}为范围|x|, |y|, |width|, |height|, |minDepth|, 和|maxDepth|。
            </div>

            问题：允许GPU使用固定点或环绕视口坐标。
        </div>

    : <dfn>setScissorRect(x, y, width, height)</dfn>
    ::
        设置在光栅化阶段使用的裁剪矩形。转换为视口坐标后，任何落在裁剪矩形之外的片元都将被丢弃。

        <div algorithm="GPURenderPassEncoder.setScissorRect">
            **Called on:** {{GPURenderPassEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPURenderPassEncoder/setScissorRect(x, y, width, height)">
                |x|: 裁剪矩形的最小X值，以像素为单位。
                |y|: 裁剪矩形的最小Y值，以像素为单位。
                |width|: 裁剪矩形的宽度，以像素为单位。
                |height|: 裁剪矩形的高度，以像素为单位。
            </pre>

            **Returns:** {{undefined}}

            在|this|的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                1. 如果以下任何条件未满足，产生一个校验错误并停止。
                    <div class=validusage>
                        - |x|+|width|小于或等于|this|.{{GPURenderPassEncoder/[[attachment_size]]}}.width。
                        - |y|+|height|小于或等于|this|.{{GPURenderPassEncoder/[[attachment_size]]}}.height。
                    </div>
                2. 设置裁剪矩形范围为|x|, |y|, |width|, 和|height|。
            </div>
        </div>

    : <dfn>setBlendConstant(color)</dfn>
    ::
        设置与{{GPUBlendFactor/"constant"}}和“{{GPUBlendFactor/"one-minus-constant"}}”{{GPUBlendFactor}}一起使用的常量混合颜色和alpha值。

        <div algorithm="GPURenderPassEncoder.setBlendConstant">
            **Called on:** {{GPURenderPassEncoder}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderPassEncoder/setBlendConstant(color)">
                color: 混合时所使用的颜色。
            </pre>
        </div>

    : <dfn>setStencilReference(reference)</dfn>
    ::
        使用{{GPUStencilOperation/"replace"}} {{GPUStencilOperation}}设置模板测试期间使用的模板参考值。

        <div algorithm="GPURenderPassEncoder.setStencilReference">
            **Called on:** {{GPURenderPassEncoder}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderPassEncoder/setStencilReference(reference)">
                reference: 模板参考值。
            </pre>
        </div>
</dl>

### 查询 ### {#render-pass-encoder-queries}

<dl dfn-type=method dfn-for=GPURenderPassEncoder>
    : <dfn>beginOcclusionQuery(queryIndex)</dfn>
    ::

        <div algorithm="GPURenderPassEncoder.beginOcclusionQuery">
            **Called on:** {{GPURenderPassEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPURenderPassEncoder/beginOcclusionQuery(queryIndex)">
                |queryIndex|: 查询集合中的查询索引。
            </pre>

            **Returns:** {{undefined}}

            在|this|.{{GPUObjectBase/[[device]]}}的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                1. 如果以下任何条件未满足，产生一个校验错误并停止。
                    <div class=validusage>
                        - |this|.{{GPURenderPassEncoder/[[occlusion_query_set]]}}不为 `null`。
                        - |queryIndex| &lt; |this|.{{GPURenderPassEncoder/[[occlusion_query_set]]}}.{{GPUQuerySet/[[descriptor]]}}.{{GPUQuerySetDescriptor/count}}。
                        - 同一|queryIndex|的查询必须没有被事先写入此通道。
                        - |this|.{{GPURenderPassEncoder/[[occlusion_query_active]]}}为 `false`。
                    </div>

                2. 设置|this|.{{GPURenderPassEncoder/[[occlusion_query_active]]}}为 `true`。
            </div>
        </div>

    : <dfn>endOcclusionQuery()</dfn>
    ::

        <div algorithm="GPURenderPassEncoder.endOcclusionQuery">
            **Called on:** {{GPURenderPassEncoder}} this.

            **Returns:** {{undefined}}

            在|this|.{{GPUObjectBase/[[device]]}}的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                1. 如果以下任何条件未满足，产生一个校验错误并停止。
                    <div class=validusage>
                        - |this|.{{GPURenderPassEncoder/[[occlusion_query_active]]}}为 `true`。
                    </div>

                2. 设置|this|.{{GPURenderPassEncoder/[[occlusion_query_active]]}}为 `false`。
            </div>
        </div>

    : <dfn>beginPipelineStatisticsQuery(querySet, queryIndex)</dfn>
    ::

        <div algorithm="GPURenderPassEncoder.beginPipelineStatisticsQuery">
            **Called on:** {{GPURenderPassEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPURenderPassEncoder/beginPipelineStatisticsQuery(querySet, queryIndex)">
                querySet:
                queryIndex:
            </pre>

            **Returns:** {{undefined}}

            1. 如果|this|.{{GPUObjectBase/[[device]]}}.{{device/[[features]]}}不[=list/contain=]
                {{GPUFeatureName/"pipeline-statistics-query"}}，抛出一个{{TypeError}}。

            问题：描述{{GPURenderPassEncoder/beginPipelineStatisticsQuery()}}算法步骤。
        </div>

    : <dfn>endPipelineStatisticsQuery()</dfn>
    ::

        <div algorithm="GPURenderPassEncoder.endPipelineStatisticsQuery">
            **Called on:** {{GPURenderPassEncoder}} |this|.

            **Returns:** {{undefined}}

            1. 如果|this|.{{GPUObjectBase/[[device]]}}.{{device/[[features]]}}不[=list/contain=]
                {{GPUFeatureName/"pipeline-statistics-query"}}，抛出一个{{TypeError}}。

            问题：描述{{GPURenderPassEncoder/endPipelineStatisticsQuery()}}算法步骤。
        </div>

    : <dfn>writeTimestamp(querySet, queryIndex)</dfn>
    ::
        当所有先前命令全部被执行时，向|querySet|中写入一个时间戳值。

        <div algorithm="GPURenderPassEncoder.writeTimestamp">
            **Called on:** {{GPURenderPassEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPURenderPassEncoder/writeTimestamp(querySet, queryIndex)">
                querySet: 将储存时间戳值的查询集合。
                queryIndex: 查询集合中的查询索引。
            </pre>

            **Returns:** {{undefined}}

            1. 如果|this|.{{GPUObjectBase/[[device]]}}.{{device/[[features]]}}不[=list/contain=]
                {{GPUFeatureName/"timestamp-query"}}，抛出一个{{TypeError}}。
            2. 如果以下任何条件未满足，产生一个校验错误并停止。
                <div class=validusage>
                    - |querySet|可以和|this|一起有效使用。
                    - |querySet|.{{GPUQuerySet/[[descriptor]]}}.{{GPUQuerySetDescriptor/type}}为{{GPUQueryType/"timestamp"}}。
                    - |queryIndex| &lt; |querySet|.{{GPUQuerySet/[[descriptor]]}}.{{GPUQuerySetDescriptor/count}}。
                    - |querySet|中在|queryIndex|位置的查询，在此渲染通道中，之前没有被写入。
                </div>

            问题：描述{{GPURenderPassEncoder/writeTimestamp()}}算法步骤。
        </div>
</dl>

### 捆绑 ### {#render-pass-encoder-bundles}

<dl dfn-type=method dfn-for=GPURenderPassEncoder>
    : <dfn>executeBundles(bundles)</dfn>
    ::
        执行先前记录到给定{{GPURenderBundle}}中的命令，作为此渲染通道的一部分。

        当执行{{GPURenderBundle}}时，它不会继承渲染通道的管线、绑定组或顶点和索引缓冲区。在{{GPURenderBundle}}执行后，渲染通道的管线、绑定组以及顶点和索引缓冲区被清除。

        注意：状态被清除，哪怕当零{{GPURenderBundle|GPURenderBundles}}被执行。

        Note: state is cleared even if zero {{GPURenderBundle|GPURenderBundles}} are executed.

        <div algorithm="GPURenderPassEncoder.executeBundles">
            **Called on:** {{GPURenderPassEncoder}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderPassEncoder/executeBundles(bundles)">
                bundles: 要执行的渲染捆绑列表。
            </pre>

            **Returns:** {{undefined}}

            问题：描述{{GPURenderPassEncoder/executeBundles()}}算法步骤。
        </div>
</dl>

### 结尾 ### {#render-pass-encoder-finalization}

用户完成记录命令后，可以通过调用{{GPURenderPassEncoder/endPass()}}来结束渲染通道编码器。 一旦{{GPURenderPassEncoder/endPass()}}被调用，渲染通道编码器就不能再使用了。

<dl dfn-type=method dfn-for=GPURenderPassEncoder>
    : <dfn>endPass()</dfn>
    ::
        完全记录渲染通道命令序列。

        <div algorithm="GPURenderPassEncoder.endPass">
            **Called on:** {{GPURenderPassEncoder}} |this|.

            **Returns:** {{undefined}}

            在|this|的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                1. 如果以下任何条件未满足，产生一个校验错误并停止。
                    <div class=validusage>
                        - |this|.{{GPUProgrammablePassEncoder/[[debug_group_stack]]}}的[=stack/size=]为0。
                        - |this|.{{GPURenderPassEncoder/[[occlusion_query_active]]}}为 `false`。

                        Issue: Add remaining validation.
                    </div>

                Issue: Enqueue the attachment stores (with storeOp clear).
            </div>
        </div>
</dl>

# Bundles # {#bundles}

## <dfn interface>GPURenderBundle</dfn> ## {#render-bundle}

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPURenderBundle {
};
GPURenderBundle includes GPUObjectBase;
</script>

### Creation ### {#render-bundle-creation}

<script type=idl>
dictionary GPURenderBundleDescriptor : GPUObjectDescriptorBase {
};
</script>

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPURenderBundleEncoder {
    GPURenderBundle finish(optional GPURenderBundleDescriptor descriptor = {});
};
GPURenderBundleEncoder includes GPUObjectBase;
GPURenderBundleEncoder includes GPUProgrammablePassEncoder;
GPURenderBundleEncoder includes GPURenderEncoderBase;
</script>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createRenderBundleEncoder(descriptor)</dfn>
    ::
        Creates a {{GPURenderBundleEncoder}}.

        <div algorithm=GPUDevice.createRenderBundleEncoder>
            **Called on:** {{GPUDevice}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/createRenderBundleEncoder(descriptor)">
                |descriptor|: Description of the {{GPURenderBundleEncoder}} to create.
            </pre>

            **Returns:** {{GPURenderBundleEncoder}}

            Issue the following steps on the [=Device timeline=] of |this|:
            <div class=device-timeline>
                1. If any of the following conditions are unsatisfied, generate a validation
                    error and stop.
                    <div class=validusage>
                        Issue: Add remaining validation.
                    </div>
                1. Let |e| be a new {{GPURenderBundleEncoder}} object.
                1. Set |e|.{{GPURenderEncoderBase/[[layout]]}} to |descriptor|.{{GPURenderPassLayout}}.
                1. Set |e|.{{GPURenderEncoderBase/[[depthReadOnly]]}} to |descriptor|.{{GPURenderBundleEncoderDescriptor/depthReadOnly}}.
                1. Set |e|.{{GPURenderEncoderBase/[[stencilReadOnly]]}} to |descriptor|.{{GPURenderBundleEncoderDescriptor/stencilReadOnly}}.
                1. Return |e|.

                Issue: Describe the reset of the steps for {{GPUDevice/createRenderBundleEncoder()}}.
            </div>
        </div>
</dl>

### Encoding ### {#render-bundle-encoding}

<script type=idl>
dictionary GPURenderBundleEncoderDescriptor : GPURenderPassLayout {
    boolean depthReadOnly = false;
    boolean stencilReadOnly = false;
};
</script>

### Finalization ### {#render-bundle-finalization}

<dl dfn-type=method dfn-for=GPURenderBundleEncoder>
    : <dfn>finish(descriptor)</dfn>
    ::
        Completes recording of the render bundle commands sequence.

        <div algorithm="GPURenderBundleEncoder.finish">
            **Called on:** {{GPURenderBundleEncoder}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderBundleEncoder/finish(descriptor)">
                descriptor:
            </pre>

            **Returns:** {{GPURenderBundle}}

            Issue: Describe {{GPURenderBundleEncoder/finish()}} algorithm steps.
        </div>
</dl>

# Queues # {#queues}

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUQueue {
    undefined submit(sequence<GPUCommandBuffer> commandBuffers);

    Promise<undefined> onSubmittedWorkDone();

    undefined writeBuffer(
        GPUBuffer buffer,
        GPUSize64 bufferOffset,
        [AllowShared] BufferSource data,
        optional GPUSize64 dataOffset = 0,
        optional GPUSize64 size);

    undefined writeTexture(
      GPUImageCopyTexture destination,
      [AllowShared] BufferSource data,
      GPUImageDataLayout dataLayout,
      GPUExtent3D size);

    undefined copyExternalImageToTexture(
        GPUImageCopyExternalImage source,
        GPUImageCopyTextureTagged destination,
        GPUExtent3D copySize);
};
GPUQueue includes GPUObjectBase;
</script>

{{GPUQueue}} has the following methods:

<dl dfn-type=method dfn-for=GPUQueue>
    : <dfn>writeBuffer(buffer, bufferOffset, data, dataOffset, size)</dfn>
    ::
        Issues a write operation of the provided data into a {{GPUBuffer}}.

        <div algorithm=GPUQueue.writeBuffer>
            **Called on:** {{GPUQueue}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUQueue/writeBuffer(buffer, bufferOffset, data, dataOffset, size)">
                |buffer|: The buffer to write to.
                |bufferOffset|: Offset in bytes into |buffer| to begin writing at.
                |data|: Data to write into |buffer|.
                |dataOffset|: Offset in into |data| to begin writing from. Given in elements if
                    |data| is a `TypedArray` and bytes otherwise.
                |size|: Size of content to write from |data| to |buffer|. Given in elements if
                    |data| is a `TypedArray` and bytes otherwise.
            </pre>

            **Returns:** {{undefined}}

            1. If |data| is an {{ArrayBuffer}} or {{DataView}}, let the element type be "byte".
                Otherwise, |data| is a TypedArray; let the element type be the type of the TypedArray.
            1. Let |dataSize| be the size of |data|, in elements.
            1. If |size| is missing,
                let |contentsSize| be |dataSize| &minus; |dataOffset|.
                Otherwise, let |contentsSize| be |size|.
            1. If any of the following conditions are unsatisfied,
                throw {{OperationError}} and stop.
                <!-- Note: it's easiest to write the valid usage rules inline
                     here, because they depend on contentsSize above. -->
                <div class=validusage>
                    - |contentsSize| &ge; 0.
                    - |dataOffset| + |contentsSize| &le; |dataSize|.
                    - |contentsSize|, converted to bytes, is a multiple of 4 bytes.
                </div>
            1. Let |dataContents| be [=get a copy of the buffer source|a copy of the bytes held by the buffer source=].
            1. Let |contents| be the |contentsSize| elements of |dataContents| starting at
                an offset of |dataOffset| elements.
            1. Issue the following steps on the [=Queue timeline=] of |this|:
                <div class=queue-timeline>
                    1. If any of the following conditions are unsatisfied,
                        generate a validation error and stop.
                        <div class=validusage>
                            - |buffer| is [$valid to use with$] |this|.
                            - |buffer|.{{GPUBuffer/[[state]]}} is [=buffer state/unmapped=].
                            - |buffer|.{{GPUBuffer/[[usage]]}} includes {{GPUBufferUsage/COPY_DST}}.
                            - |bufferOffset|, converted to bytes, is a multiple of 4 bytes.
                            - |bufferOffset| + |contentsSize|, converted to bytes, &le; |buffer|.{{GPUBuffer/[[size]]}} bytes.
                        </div>
                    1. Write |contents| into |buffer| starting at |bufferOffset|.
                </div>
        </div>

    : <dfn>writeTexture(destination, data, dataLayout, size)</dfn>
    ::
        Issues a write operation of the provided data into a {{GPUTexture}}.

        <div algorithm=GPUQueue.writeTexture>
            **Called on:** {{GPUQueue}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUQueue/writeTexture(destination, data, dataLayout, size)">
                |destination|: The [=texture subresource=] and origin to write to.
                |data|: Data to write into |destination|.
                |dataLayout|: Layout of the content in |data|.
                |size|: Extents of the content to write from |data| to |destination|.
            </pre>

            **Returns:** {{undefined}}

            1. Let |dataBytes| be [=get a copy of the buffer source|a copy of the bytes held by the buffer source=] |data|.
            1. Let |dataByteSize| be the number of bytes in |dataBytes|.
            1. Let |textureDesc| be |destination|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}.
            1. If any of the following conditions are unsatisfied,
                throw {{OperationError}} and stop.
                <div class=validusage>
                    - [$validating linear texture data$](|dataLayout|,
                        |dataByteSize|,
                        |textureDesc|.{{GPUTextureDescriptor/format}},
                        |size|) succeeds.
                </div>
            1. Let |contents| be the contents of the [=images=] seen by
                viewing |dataBytes| with |dataLayout| and |size|.

                Issue: Specify more formally.
            1. Issue the following steps on the [=Queue timeline=] of |this|:
                <div class=queue-timeline>
                    1. If any of the following conditions are unsatisfied,
                        generate a validation error and stop.
                        <div class=validusage>
                            - [$validating GPUImageCopyTexture$](|destination|, |size|) returns `true`.
                            - |textureDesc|.{{GPUTextureDescriptor/usage}} includes {{GPUTextureUsage/COPY_DST}}.
                            - |textureDesc|.{{GPUTextureDescriptor/sampleCount}} is 1.
                            - [=Valid Texture Copy Range=](|destination|, |size|) is satisfied.
                            - |destination|.{{GPUImageCopyTexture/aspect}} refers to a single copyable aspect
                                of |textureDesc|.{{GPUTextureDescriptor/format}}. See [[#depth-formats|depth-formats]].

                            Note: unlike
                            {{GPUCommandEncoder}}.{{GPUCommandEncoder/copyBufferToTexture()}},
                            there is no alignment requirement on either
                            |dataLayout|.{{GPUImageDataLayout/bytesPerRow}} or |dataLayout|.{{GPUImageDataLayout/offset}}.
                        </div>
                    1. Write |contents| into |destination|.

                        Issue: Specify more formally.
                </div>
        </div>

    : <dfn>copyExternalImageToTexture(source, destination, copySize)</dfn>
    ::
        Issues a copy operation of the contents of a platform image/canvas
        into the destination texture.

        Copying into a `-srgb` texture results in the same texture bytes, not the same decoded
        values, as copying into the corresponding non-`-srgb` format.
        Thus, after a copy operation, sampling the destination texture has
        different results depending on whether its format is `-srgb`, all else unchanged.

        Issue: If an srgb-linear color space is added, explain here how it interacts.

        <div algorithm=GPUQueue.copyExternalImageToTexture>
            **Called on:** {{GPUQueue}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUQueue/copyExternalImageToTexture(source, destination, copySize)">
                |source|: source image and origin to copy to |destination|.
                |destination|: The [=texture subresource=] and origin to write to, and its encoding metadata.
                |copySize|: Extents of the content to write from |source| to |destination|.
            </pre>

            **Returns:** {{undefined}}

            1. Let |sourceImage| be |source|.{{GPUImageCopyExternalImage/source}}
            1. Run [=Check the usability of the image argument=](|sourceImage|).
                If it throws an exception, stop.
                If it does not return `good`, throw an {{InvalidStateError}} and stop.
            1. If |sourceImage| <l spec=html>[=is not origin-clean=]</l>,
                throw a {{SecurityError}} and stop.
            1. If any of the following requirements are unmet, throw an {{OperationError}} and stop.
                <div class=validusage>
                    - If |source|.{{GPUImageCopyExternalImage/source}} is an {{HTMLCanvasElement}}:
                        Its [=canvas context mode=] must be `"2d"`, `"webgl"`, or `"webgl2"`.
                    - If |source|.{{GPUImageCopyExternalImage/source}} is an {{OffscreenCanvas}}:
                        Its [=OffscreenCanvas context mode=] must be `"2d"`, `"webgl"`, or `"webgl2"`.
                    - |source|.|origin|.[=Origin3D/x=] + |copySize|.[=Extent3D/width=]
                        must be &le; the width of |sourceImage|.
                    - |source|.|origin|.[=Origin3D/y=] + |copySize|.[=Extent3D/height=]
                        must be &le; the height of |sourceImage|.
                    - |source|.|origin|.[=Origin3D/z=] + |copySize|.[=Extent3D/depthOrArrayLayers=]
                        must be &le; 1.
                </div>
            1. Issue the following steps on the [=Device timeline=] of |this|:
                <div class=device-timeline>
                    1. Let |textureDesc| be |destination|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}.
                    1. If any of the following requirements are unmet, generate a validation error and stop.
                        <div class=validusage>
                            - |destination|.{{GPUImageCopyTexture/texture}} must be [$valid to use with$] |this|.
                            - [$validating GPUImageCopyTexture$](destination, copySize) must return true.
                            - [=Valid Texture Copy Range=](destination, copySize) must be satisfied.
                            - |textureDesc|.{{GPUTextureDescriptor/usage}} must include both
                                {{GPUTextureUsage/RENDER_ATTACHMENT}} and {{GPUTextureUsage/COPY_DST}}.
                            - |textureDesc|.{{GPUTextureDescriptor/dimension}} must be {{GPUTextureDimension/"2d"}}.
                            - |textureDesc|.{{GPUTextureDescriptor/sampleCount}} must be 1.
                            - |textureDesc|.{{GPUTextureDescriptor/format}} must be one of the following:
                                - {{GPUTextureFormat/"rgba8unorm"}}
                                - {{GPUTextureFormat/"rgba8unorm-srgb"}}
                                - {{GPUTextureFormat/"bgra8unorm"}}
                                - {{GPUTextureFormat/"bgra8unorm-srgb"}}
                                - {{GPUTextureFormat/"rgb10a2unorm"}}
                                - {{GPUTextureFormat/"rg8unorm"}}

                                Issue: Evaluate adding additional formats to this list.
                                Note that any format that represents values outside of 0 to 1
                                has interactions with color space (e.g. clamped-srgb vs extended-srgb).
                        </div>
                    1. Issue: Do the actual copy.
                </div>
        </div>

    : <dfn>submit(commandBuffers)</dfn>
    ::
        Schedules the execution of the command buffers by the GPU on this queue.

        <div algorithm=GPUQueue.submit>
            **Called on:** {{GPUQueue}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUQueue/submit(commandBuffers)">
                |commandBuffers|:
            </pre>

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|:
            <div class=device-timeline>
                1. If any of the following conditions are unsatisfied, generate a validation error and stop.
                    <div class=validusage>
                        - Every {{GPUBuffer}} referenced in any element of |commandBuffers| is in the
                            `"unmapped"` [=buffer state=].
                        - Every {{GPUQuerySet}} referenced in a command in any element of |commandBuffers| is
                            in the [=query set state/available=] state. For occlusion queries,
                            {{GPURenderPassDescriptor/occlusionQuerySet}} in {{GPUCommandEncoder/beginRenderPass()}}
                            does not constitute a reference, while {{GPURenderPassEncoder/beginOcclusionQuery()}}
                            does.
                    </div>

                1. Issue the following steps on the [=Queue timeline=] of |this|:
                    <div class=queue-timeline>
                        1. For each |commandBuffer| in |commandBuffers|:
                            1. Execute each command in |commandBuffer|.{{GPUCommandBuffer/[[command_list]]}}.
                    </div>
            </div>
        </div>

    : <dfn>onSubmittedWorkDone()</dfn>
    ::
        Returns a {{Promise}} that resolves once this queue finishes processing all the work submitted
        up to this moment.

        <div algorithm="GPUQueue.onSubmittedWorkDone">
            **Called on:** {{GPUQueue}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUQueue/onSubmittedWorkDone()">
            </pre>

            **Returns:** {{Promise}}&lt;{{undefined}}&gt;

            Issue: Describe {{GPUQueue/onSubmittedWorkDone()}} algorithm steps.
        </div>
</dl>

Queries {#queries}
================

## <dfn interface>GPUQuerySet</dfn> ## {#queryset}

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUQuerySet {
    undefined destroy();
};
GPUQuerySet includes GPUObjectBase;
</script>

{{GPUQuerySet}} has the following internal slots:

<dl dfn-type=attribute dfn-for="GPUQuerySet">
    : <dfn>\[[descriptor]]</dfn>, of type {{GPUQuerySetDescriptor}}
    ::
        The {{GPUQuerySetDescriptor}} describing this query set.

        All optional fields of {{GPUTextureViewDescriptor}} are defined.

    : <dfn>\[[state]]</dfn> of type [=query set state=].
    ::
        The current state of the {{GPUQuerySet}}.
</dl>

Each {{GPUQuerySet}} has a current <dfn dfn>query set state</dfn> on the [=Device timeline=]
which is one of the following:

 - "<dfn dfn for="query set state">available</dfn>" where the {{GPUQuerySet}} is
     available for GPU operations on its content.
 - "<dfn dfn for="query set state">destroyed</dfn>" where the {{GPUQuerySet}} is
     no longer available for any operations except {{GPUQuerySet/destroy}}.

### QuerySet Creation ### {#queryset-creation}

A {{GPUQuerySetDescriptor}} specifies the options to use in creating a {{GPUQuerySet}}.

<script type=idl>
dictionary GPUQuerySetDescriptor : GPUObjectDescriptorBase {
    required GPUQueryType type;
    required GPUSize32 count;
    sequence<GPUPipelineStatisticName> pipelineStatistics = [];
};
</script>

<dl dfn-type=dict-member dfn-for=GPUQuerySetDescriptor>
    : <dfn>type</dfn>
    ::
        The type of queries managed by {{GPUQuerySet}}.

    : <dfn>count</dfn>
    ::
        The number of queries managed by {{GPUQuerySet}}.

    : <dfn>pipelineStatistics</dfn>
    ::
        The set of {{GPUPipelineStatisticName}} values in this sequence defines which pipeline statistics will be returned in the new query set.
</dl>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createQuerySet(descriptor)</dfn>
    ::
        Creates a {{GPUQuerySet}}.

        <div algorithm=GPUDevice.createQuerySet>
            **Called on:** {{GPUDevice}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/createQuerySet(descriptor)">
                descriptor: Description of the {{GPUQuerySet}} to create.
            </pre>

            **Returns:** {{GPUQuerySet}}

            1. If |descriptor|.{{GPUQuerySetDescriptor/type}} is {{GPUQueryType/"pipeline-statistics"}},
                but |this|.{{GPUObjectBase/[[device]]}}.{{device/[[features]]}} does not [=list/contain=]
                {{GPUFeatureName/"pipeline-statistics-query"}}, throw a {{TypeError}}.
            1. If |descriptor|.{{GPUQuerySetDescriptor/type}} is {{GPUQueryType/"timestamp"}},
                but |this|.{{GPUObjectBase/[[device]]}}.{{device/[[features]]}} does not [=list/contain=]
                {{GPUFeatureName/"timestamp-query"}}, throw a {{TypeError}}.
            1. If any of the following requirements are unmet, return an error query set and stop.
                <div class=validusage>
                    - |this| must be a [=valid=] {{GPUDevice}}.
                    - |descriptor|.{{GPUQuerySetDescriptor/count}} must be &le; 8192.
                    - If |descriptor|.{{GPUQuerySetDescriptor/type}} is
                        {{GPUQueryType/"pipeline-statistics"}}:

                        - |descriptor|.{{GPUQuerySetDescriptor/pipelineStatistics}} must not
                            contain duplicate entries.

                        Otherwise:

                        - |descriptor|.{{GPUQuerySetDescriptor/pipelineStatistics}} must be
                            [=list/empty=].
                </div>
            1. Let |q| be a new {{GPUQuerySet}} object.
            1. Set |q|.{{GPUQuerySet/[[descriptor]]}} to |descriptor|.
            1. Set |q|.{{GPUQuerySet/[[state]]}} to [=query set state/available=].
            1. Return |q|.
        </div>
</dl>

### QuerySet Destruction ### {#queryset-destruction}

An application that no longer requires a {{GPUQuerySet}} can choose to lose access to it before
garbage collection by calling {{GPUQuerySet/destroy()}}.

<dl dfn-type=method dfn-for=GPUQuerySet>
    : <dfn>destroy()</dfn>
    ::
        Destroys the {{GPUQuerySet}}.

        <div algorithm="GPUQuerySet.destroy">
            **Called on:** {{GPUQuerySet}} |this|.

            **Returns:** {{undefined}}

            1. Set |this|.{{GPUQuerySet/[[state]]}} to [=query set state/destroyed=].
        </div>
</dl>

## QueryType ## {#querytype}

<script type=idl>
enum GPUQueryType {
    "occlusion",
    "pipeline-statistics",
    "timestamp"
};
</script>

## Occlusion Query ## {#occlusion}

Occlusion query is only available on render passes, to query the number of fragment samples that pass
all the per-fragment tests for a set of drawing commands, including scissor, sample mask, alpha to
coverage, stencil, and depth tests. Any non-zero result value for the query indicates that at least
one sample passed the tests and reached the output merging stage of the render pipeline, 0 indicates
that no samples passed the tests.

When beginning a render pass, {{GPURenderPassDescriptor}}.{{GPURenderPassDescriptor/occlusionQuerySet}}
must be set to be able to use occlusion queries during the pass. An occlusion query is begun
and ended by calling {{GPURenderPassEncoder/beginOcclusionQuery()}} and
{{GPURenderPassEncoder/endOcclusionQuery()}} in pairs that cannot be nested.

## Pipeline Statistics Query ## {#pipeline-statistics}

<script type=idl>
enum GPUPipelineStatisticName {
    "vertex-shader-invocations",
    "clipper-invocations",
    "clipper-primitives-out",
    "fragment-shader-invocations",
    "compute-shader-invocations"
};
</script>

When resolving pipeline statistics query, each result is written into {{GPUSize64}}, and the number and order of the results written to GPU buffer matches the number and order of {{GPUPipelineStatisticName}} specified in {{GPUQuerySetDescriptor/pipelineStatistics}}.

The {{GPURenderPassEncoder/beginPipelineStatisticsQuery()}} and {{GPURenderPassEncoder/endPipelineStatisticsQuery()}} (on both {{GPUComputePassEncoder}} and {{GPURenderPassEncoder}}) cannot be nested. A pipeline statistics query must be ended before beginning another one.

Pipeline statistics query requires {{GPUFeatureName/"pipeline-statistics-query"}} is available on the device.

## Timestamp Query ## {#timestamp}

Timestamp query allows application to write timestamp values to a {{GPUQuerySet}} by calling {{GPURenderPassEncoder/writeTimestamp()}} on {{GPUComputePassEncoder}} or {{GPURenderPassEncoder}} or {{GPUCommandEncoder}}, and then resolve timestamp values in **nanoseconds** (type of {{GPUSize64}}) to a {{GPUBuffer}} (using {{GPUCommandEncoder/resolveQuerySet()}}).

Timestamp query requires {{GPUFeatureName/"timestamp-query"}} is available on the device.

Note: The timestamp values may be zero if the physical device reset timestamp counter, please ignore it and the following values.

Issue: Write normative text about timestamp value resets.

Issue: Because timestamp query provides high-resolution GPU timestamp, we need to decide what constraints, if any, are on its availability.

# Canvas Rendering # {#canvas-rendering}

## {{HTMLCanvasElement/getContext()|HTMLCanvasElement.getContext()}} ## {#canvas-getcontext}

A {{GPUCanvasContext}} object can be obtained via the {{HTMLCanvasElement/getContext()}}
method of an {{HTMLCanvasElement}} instance by passing the string literal `'webgpu'` as its
`contextType` argument.

<div class="example">
    Get a {{GPUCanvasContext}} from an offscreen {{HTMLCanvasElement}}:
    <pre highlight="js">
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('webgpu');
        context.configure(/* ... */);
        // ...
    </pre>
</div>

## GPUCanvasContext ## {#canvas-context}

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUCanvasContext {
    readonly attribute (HTMLCanvasElement or OffscreenCanvas) canvas;

    undefined configure(GPUCanvasConfiguration configuration);
    undefined unconfigure();

    GPUTextureFormat getPreferredFormat(GPUAdapter adapter);
    GPUTexture getCurrentTexture();
};
</script>

{{GPUCanvasContext}} has the following attributes:

<dl dfn-type=attribute dfn-for=GPUCanvasContext>
    : <dfn>canvas</dfn>
    ::
        The canvas this context was created from.
</dl>

{{GPUCanvasContext}} has the following internal slots:

<dl dfn-type=attribute dfn-for="GPUCanvasContext">
    : <dfn>\[[validConfiguration]]</dfn> of type boolean, initially `false`.
    ::
        Indicates if the context currently has a valid configuration.

    : <dfn>\[[configuration]]</dfn> of type {{GPUCanvasConfiguration}}, initially `null`.
    ::
        The options this context is configured with. `null` if the context has not been configured
        or the configuration has been removed.

    : <dfn>\[[size]]</dfn> of type {{GPUExtent3D}}
    ::
        The size of {{GPUTexture}}s returned from this context.
        [=Extent3D/depthOrArrayLayers=] is always `1`.

    : <dfn>\[[currentTexture]]</dfn> of type {{GPUTexture}}?, initially `null`
    ::
        The current texture that will be returned by the context when calling
        {{GPUCanvasContext/getCurrentTexture()}}, and the next one to be composited to the
        document. Initially set to the result of [$allocating a new context texture$] for this
        context.
</dl>

{{GPUCanvasContext}} has the following methods:

<dl dfn-type=method dfn-for=GPUCanvasContext>
    : <dfn>configure(configuration)</dfn>
    ::
        Configures the context for this canvas. Destroys any textures produced with a previous
        configuration.

        <div algorithm="GPUCanvasContext.configure">
            **Called on:** {{GPUCanvasContext}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCanvasContext/configure(configuration)">
                |configuration|: Desired configuration for the context.
            </pre>

            **Returns:** undefined

            1. Set |this|.{{GPUCanvasContext/[[validConfiguration]]}} to `false`.
            1. Set |this|.{{GPUCanvasContext/[[configuration]]}} to |configuration|.
            1. If |this|.{{GPUCanvasContext/[[currentTexture]]}} is not `null` call
                {{GPUTexture/destroy()}} on |this|.{{GPUCanvasContext/[[currentTexture]]}}.
            1. Set |this|.{{GPUCanvasContext/[[currentTexture]]}} to `null`.
            1. Let |device| be |configuration|.{{GPUCanvasConfiguration/device}}.
            1. Let |canvas| be |this|.{{GPUCanvasContext/canvas}}.
            1. If |configuration|.{{GPUCanvasConfiguration/size}} is `undefined` set
                |this|.{{GPUCanvasContext/[[size]]}} to [|canvas|.width, |canvas|.height, 1],
                otherwise set |this|.{{GPUCanvasContext/[[size]]}} to
                |configuration|.{{GPUCanvasConfiguration/size}}.

            1. Issue the following steps on the [=Device timeline=] of |device|:
                <div class=device-timeline>
                    1. If any of the following conditions are unsatisfied:
                        <div class=validusage>
                            - |device| is a [=valid=] {{GPUDevice}}.
                            - [=Supported context formats=] [=set/contains=]
                                |configuration|.{{GPUCanvasConfiguration/format}}.
                            - |this|.{{GPUCanvasContext/[[size]]}}.[=Extent3D/width=] &gt; 0.
                            - |this|.{{GPUCanvasContext/[[size]]}}.[=Extent3D/width=] &le;
                                |device|.{{GPUDevice/limits}}.{{GPUSupportedLimits/maxTextureDimension2D}}.
                            - |this|.{{GPUCanvasContext/[[size]]}}.[=Extent3D/height=] &gt; 0.
                            - |this|.{{GPUCanvasContext/[[size]]}}.[=Extent3D/height=] &le;
                                |device|.{{GPUDevice/limits}}.{{GPUSupportedLimits/maxTextureDimension2D}}.
                            - |this|.{{GPUCanvasContext/[[size]]}}.[=Extent3D/depthOrArrayLayers=]
                                is 1;
                        </div>

                        Then:
                            1. Generate a {{GPUValidationError}} in the current scope with appropriate
                                error message.
                            1. Return.
                </div>
            1. Set |this|.{{GPUCanvasContext/[[validConfiguration]]}} to `true`.
        </div>

    : <dfn>unconfigure()</dfn>
    ::
        Removes the context configuration. Destroys any textures produced while configured.

        <div algorithm="GPUCanvasContext.unconfigure">
            **Called on:** {{GPUCanvasContext}} |this|.

            **Returns:** undefined

            1. Set |this|.{{GPUCanvasContext/[[validConfiguration]]}} to `false`.
            1. Set |this|.{{GPUCanvasContext/[[configuration]]}} to `null`.
            1. If |this|.{{GPUCanvasContext/[[currentTexture]]}} is not `null` call
                {{GPUTexture/destroy()}} on |this|.{{GPUCanvasContext/[[currentTexture]]}}.
            1. Set |this|.{{GPUCanvasContext/[[currentTexture]]}} to `null`.
        </div>

    : <dfn>getPreferredFormat(adapter)</dfn>
    ::
        Returns an optimal {{GPUTextureFormat}} to use with this context and devices created from
        the given adapter.

        <div algorithm="GPUCanvasContext.getPreferredFormat">
            **Called on:** {{GPUCanvasContext}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUCanvasContext/getPreferredFormat(adapter)">
                |adapter|: Adapter the format should be queried for.
            </pre>

            **Returns:** {{GPUTextureFormat}}

            <div class=content-timeline>
                1. Return an optimal {{GPUTextureFormat}} to use when calling {{GPUCanvasContext/configure()}}
                    with the given |adapter|. Must be one of the [=supported context formats=].
            </div>
        </div>

    : <dfn>getCurrentTexture()</dfn>
    ::
        Get the {{GPUTexture}} that will be composited to the document by the {{GPUCanvasContext}}
        next.

        <div algorithm="GPUCanvasContext.getCurrentTexture">
            **Called on:** {{GPUCanvasContext}} |this|.

            **Returns:** {{GPUTexture}}

            1. If |this|.{{GPUCanvasContext/[[configuration]]}} is `null`:
                1. Throw an {{OperationError}} and stop.
            1. If |this|.{{GPUCanvasContext/[[currentTexture]]}} is `null` or
                |this|.{{GPUCanvasContext/[[currentTexture]]}}.{{GPUTexture/[[destroyed]]}} is true:
                1. Set |this|.{{GPUCanvasContext/[[currentTexture]]}} to the result of [$allocating
                    a new context texture$] for |this|.
            1. Return |this|.{{GPUCanvasContext/[[currentTexture]]}}.
        </div>

        Note: Developers can expect that the same {{GPUTexture}} object will be returned by every
        call to {{GPUCanvasContext/getCurrentTexture()}} made within the same frame (i.e. between
        invocations of [=Update the rendering=]) unless {{GPUCanvasContext/configure()}} is called.
</dl>

<div>
    During the "update the rendering [of the] `Document`" step of the "[=Update the rendering=]"
    HTML processing model, each {{GPUCanvasContext}} |context| must <dfn abstract-op>present the
    context content to the canvas</dfn> by running the following steps:

    1. If |context|.{{GPUCanvasContext/[[currentTexture]]}} is not `null` and
        |context|.{{GPUCanvasContext/[[currentTexture]]}}.{{GPUTexture/[[destroyed]]}} is `false`:
        1. Let |imageContents| be
            [$get a copy of the image contents of a context|a copy of the image contents$]
            of |context|.
        1. Update |context|.{{GPUCanvasContext/canvas}} with |imageContents|.
        1. Call |context|.{{GPUCanvasContext/[[currentTexture]]}}.{{GPUTexture/destroy()}}.
    1. Set |context|.{{GPUCanvasContext/[[currentTexture]]}} to `null`.
</div>

<div algorithm="transferToImageBitmap from WebGPU">
    When {{OffscreenCanvas/transferToImageBitmap()}} is called on a canvas with
    {{GPUCanvasContext}} |context|:

    1. Let |imageContents| be
        [$get a copy of the image contents of a context|a copy of the image contents$]
        of |context|.
    1. If |context|.{{GPUCanvasContext/[[currentTexture]]}} is not `null`:
        1. Call |context|.{{GPUCanvasContext/[[currentTexture]]}}.{{GPUTexture/destroy()}}.
    1. Set |context|.{{GPUCanvasContext/[[currentTexture]]}} to `null`.
    1. Return a new {{ImageBitmap}} containing the |imageContents|.
</div>

<div>
    When WebGPU canvas contents are read using other Web APIs, like
    {{CanvasDrawImage/drawImage()}}, `texImage2D()`, `texSubImage2D()`,
    {{HTMLCanvasElement/toDataURL()}}, {{HTMLCanvasElement/toBlob()}}, and so on,
    they <dfn abstract-op>get a copy of the image contents of a context</dfn>:

    **Arguments:**
    |context|: the {{GPUCanvasContext}}

    **Returns:** image contents

    1. Let |texture| be |context|.{{GPUCanvasContext/[[currentTexture]]}}.
    1. If any of the following requirements is unmet, return a transparent black image of size
        |context|.{{GPUCanvasContext/[[size]]}} and stop.
        <div class=validusage>
            - |texture| must not be `null`.
            - |texture|.{{GPUTexture/[[destroyed]]}} must be false.
            - If |context|.{{GPUCanvasContext/canvas}} is an {{OffscreenCanvas}},
                it must not be linked to a [=placeholder canvas element=].

                Issue: If added, canvas must also not be `desynchronized`.
        </div>
    1. Ensure that all submitted work items (e.g. queue submissions) have
        completed writing to |texture|.
    1. Return the contents of |texture|, tagged as having alpha premultiplied, and with the color space
        |context|.{{GPUCanvasContext/[[configuration]]}}.{{GPUCanvasConfiguration/colorSpace}}.

        Issue(gpuweb/gpuweb#1847): Does compositingAlphaMode=opaque make this return opaque contents?
</div>

<div>
    To <dfn abstract-op lt='allocating a new context texture'>allocate a new context texture</dfn>
    for {{GPUCanvasContext}} |context| run the following steps:

        1. Let |device| be |context|.{{GPUCanvasContext/[[configuration]]}}.{{GPUCanvasConfiguration/device}}.
        1. If |context|.{{GPUCanvasContext/[[validConfiguration]]}} is `false`:
            1. Generate a {{GPUValidationError}} in the current scope of |device| with an appropriate error message.
            1. Return a new [=invalid=] {{GPUTexture}}.
        1. Let |textureDescriptor| be a new {{GPUTextureDescriptor}}.
        1. Set |textureDescriptor|.{{GPUTextureDescriptor/size}} to |context|.{{GPUCanvasContext/[[size]]}}.
        1. Set |textureDescriptor|.{{GPUTextureDescriptor/format}} to
            |context|.{{GPUCanvasContext/[[configuration]]}}.{{GPUCanvasConfiguration/format}}.
        1. Set |textureDescriptor|.{{GPUTextureDescriptor/usage}} to
            |context|.{{GPUCanvasContext/[[configuration]]}}.{{GPUCanvasConfiguration/usage}}.
        1. Let |texture| be a new {{GPUTexture}} created as if |device|.{{GPUDevice/createTexture()}}
            were called with |textureDescriptor|.
            <div class='note'>If a previously presented texture from |context| matches the required criteria,
            its GPU memory may be re-used.</div>
        1. Ensure |texture| is cleared to `(0, 0, 0, 0)`.
        1. Return |texture|.
</div>

## GPUCanvasConfiguration ## {#canvas-configuration}

The <dfn dfn>supported context formats</dfn> are a [=set=] of {{GPUTextureFormat}}s that must be
supported when specified as a {{GPUCanvasConfiguration}}.{{GPUCanvasConfiguration/format}}
regardless of the given {{GPUCanvasConfiguration}}.{{GPUCanvasConfiguration/device}},
initially set to: &laquo;{{GPUTextureFormat/"bgra8unorm"}}, {{GPUTextureFormat/"bgra8unorm-srgb"}},
{{GPUTextureFormat/"rgba8unorm"}}, {{GPUTextureFormat/"rgba8unorm-srgb"}}&raquo;.

<script type=idl>

enum GPUCanvasCompositingAlphaMode {
    "opaque",
    "premultiplied",
};

dictionary GPUCanvasConfiguration {
    required GPUDevice device;
    required GPUTextureFormat format;
    GPUTextureUsageFlags usage = 0x10;  // GPUTextureUsage.RENDER_ATTACHMENT
    GPUPredefinedColorSpace colorSpace = "srgb";
    GPUCanvasCompositingAlphaMode compositingAlphaMode = "opaque";
    GPUExtent3D size;
};
</script>

Issue: For SDR, it doesn't matter whether the default colorSpace of "srgb" means extended-srgb
or clamped-srgb. However, when we add HDR canvas output (representing pixel values > 1),
we need to choose which of those two is the default. Currently the upstream specs haven't worked
out this question just yet.

### Canvas Context sizing ### {#context-sizing}

A {{GPUCanvasContext}}'s {{GPUCanvasContext/[[size]]}} is set by the {{GPUCanvasConfiguration}}
passed to {{GPUCanvasContext/configure()}}, and remains the same until {{GPUCanvasContext/configure()}}
is called again with a new size. If a {{GPUCanvasConfiguration/size}} is not specified then the
width and height attributes of the {{GPUCanvasContext}}.{{GPUCanvasContext/canvas}}
at the time {{GPUCanvasContext/configure()}} is called will be used. If
{{GPUCanvasContext}}.{{GPUCanvasContext/[[size]]}} does not match the dimensions of the canvas
the textures produced by the {{GPUCanvasContext}} will be scaled to fit the canvas element.

<div class="note">
    Note: Unlike `'webgl'` or `'2d'` contexts, `width` and `height` attributes of canvases with a
    `'webgpu'` context only affect:
    - Default layout size, if not overridden by CSS.
    - Default {{GPUCanvasConfiguration}}.{{GPUCanvasConfiguration/size}} when calling
        {{GPUCanvasContext/configure()}}, if not overridden.
</div>

If it is desired to match the dimensions of the canvas after it is resized, the {{GPUCanvasContext}}
must be reconfigured by calling {{GPUCanvasContext/configure()}} again with the new dimensions.

<div class="example">
    Reconfigure a {{GPUCanvasContext}} in response to canvas resize, monitored using
    [ResizeObserver](https://www.w3.org/TR/resize-observer/) to get the exact pixel dimensions of
    the canvas:

    <pre highlight="js">
        const canvas = document.createElement('canvas');
        const context =  canvas.getContext('webgpu');

        const resizeObserver = new ResizeObserver(entries => {
            for (const entry of entries) {
                if (entry != canvas) { continue; }
                context.configure({
                    device: someDevice,
                    format: context.getPreferredFormat(someDevice.adapter),
                    size: {
                        // This reports the size of the canvas element in pixels
                        width: entry.devicePixelContentBoxSize[0].inlineSize,
                        height: entry.devicePixelContentBoxSize[0].blockSize,
                    }
                });
            }
        });
        resizeObserver.observe(canvas);
    </pre>
</div>

## <dfn dfn-type=enum-value dfn-for=GPUCanvasCompositingAlphaMode>GPUCanvasCompositingAlphaMode</dfn> ## {#GPUCanvasCompositingAlphaMode}

This enum selects how the contents of the canvas' context will paint onto the page.

<table class='data'>
    <thead>
        <tr>
            <th>GPUCanvasCompositingAlphaMode
            <th>Description
            <th>dst.rgb
            <th>dst.a
    </thead>
    <tr>
        <td>{{GPUCanvasCompositingAlphaMode/opaque}}
        <td>Paint RGB as opaque and ignore alpha values.
            If the content is not already opaque, implementations may need to clear alpha to opaque during presentation.
        <td>|dst.rgb = src.rgb|
        <td>|dst.a = 1|
    <tr>
        <td>{{GPUCanvasCompositingAlphaMode/premultiplied}}
        <td>Composite assuming color values are premultiplied by their alpha value.
            100% red 50% opaque is [0.5, 0, 0, 0.5].
            Color values must be less than or equal to their alpha value.
            [1.0, 0, 0, 0.5] is "super-luminant" and cannot reliably be displayed.
        <td>|dst.rgb = src.rgb + dst.rgb*(1-src.a)|
        <td>|dst.a = src.a + dst.a*(1-src.a)|
</table>

# Errors &amp; Debugging # {#errors-and-debugging}

## Fatal Errors ## {#fatal-errors}

<script type=idl>
enum GPUDeviceLostReason {
    "destroyed",
};

[Exposed=(Window, DedicatedWorker)]
interface GPUDeviceLostInfo {
    readonly attribute (GPUDeviceLostReason or undefined) reason;
    readonly attribute DOMString message;
};

partial interface GPUDevice {
    readonly attribute Promise<GPUDeviceLostInfo> lost;
};
</script>


## Error Scopes ## {#error-scopes}

<script type=idl>
enum GPUErrorFilter {
    "out-of-memory",
    "validation"
};
</script>

<script type=idl>
[Exposed=(Window, DedicatedWorker)]
interface GPUOutOfMemoryError {
    constructor();
};

[Exposed=(Window, DedicatedWorker)]
interface GPUValidationError {
    constructor(DOMString message);
    readonly attribute DOMString message;
};

typedef (GPUOutOfMemoryError or GPUValidationError) GPUError;
</script>

<script type=idl>
partial interface GPUDevice {
    undefined pushErrorScope(GPUErrorFilter filter);
    Promise<GPUError?> popErrorScope();
};
</script>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>pushErrorScope(filter)</dfn>
    ::
        Issue: Define pushErrorScope.

    : <dfn>popErrorScope()</dfn>
    ::
        Issue: Define popErrorScope.

        Rejects with {{OperationError}} if:

        - The device is lost.
        - There are no error scopes on the stack.
</dl>

## Telemetry ## {#telemetry}

<script type=idl>
[
    Exposed=(Window, DedicatedWorker)
]
interface GPUUncapturedErrorEvent : Event {
    constructor(
        DOMString type,
        GPUUncapturedErrorEventInit gpuUncapturedErrorEventInitDict
    );
    [SameObject] readonly attribute GPUError error;
};

dictionary GPUUncapturedErrorEventInit : EventInit {
    required GPUError error;
};
</script>

<script type=idl>
partial interface GPUDevice {
    [Exposed=(Window, DedicatedWorker)]
    attribute EventHandler onuncapturederror;
};
</script>

# 详细操作 # {#detailed-operations}

本节介绍各种GPU操作的详细信息。

## 转移 ## {#transfer-operations}

问题：描述高级别的转移。

## 计算 ## {#computing-operations}

计算提供对GPU可编程硬件的直接访问的操作。计算没有管线输入或输出的着色器，它们的结果是将数据写入绑定为{{GPUBufferBindingType/"storage"|GPUBufferBindingType."storage"}}和{{GPUStorageTextureBindingLayout}}的存储绑定的副作用。这些操作在{{GPUComputePassEncoder}}中编码为：
  - {{GPUComputePassEncoder/dispatch()}}
  - {{GPUComputePassEncoder/dispatchIndirect()}}

问题：描述计算算法。

## 渲染 ## {#rendering-operations}

渲染由一组GPU操作完成，这些操作在{{GPURenderPassEncoder}}中执行，并导致纹理数据的修改，由渲染通道附件查看。这些操作编码为：
  - {{GPURenderEncoderBase/draw()}}
  - {{GPURenderEncoderBase/drawIndexed()}},
  - {{GPURenderEncoderBase/drawIndirect()}}
  - {{GPURenderEncoderBase/drawIndexedIndirect()}}.

注意：渲染是GPU的传统用途，由硬件中的多个固定功能块支持。

<dfn dfn>RenderState</dfn>是一个在命令编码时表示当前{{GPURenderPassEncoder}}状态的内部对象。[=RenderState=]是以下定义的规范命名空间：
<div algorithm="RenderState accessors" dfn-for=RenderState>
    对一个给定的{{GPURenderPassEncoder}} |pass|，句法：

      - |pass|.<dfn dfn>indexBuffer</dfn>指通过{{GPURenderEncoderBase/setIndexBuffer()}}绑定的索引缓冲区，如果有的话。
      - |pass|.<dfn dfn>vertexBuffers</dfn>指通过{{GPURenderEncoderBase/setVertexBuffer()}}绑定的[=list=]&lt;vertex buffer&gt;。
      - |pass|.<dfn dfn>bindGroups</dfn>指通过{{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)}}绑定的[=list=]&lt;{{GPUBindGroup}}&gt;。
</div>

主渲染算法：

<div>
    <dfn abstract-op>render</dfn>(descriptor, drawCall, state)

        **Arguments:**
            - |descriptor|: 当前{{GPURenderPipeline}}的描述。
            - |drawCall|: 绘制调用参数。
            - |state|: 发出绘制调用的{{GPURenderEncoderBase}}的[=RenderState=]。

        1. **Resolve indices**. 见[[#index-resolution]]。

            使|vertexList|为[$resolve indices$](|drawCall|, |state|)的结果。

        2. **Process vertices**. See [[#vertex-processing]].

            执行[$process vertices$](|vertexList|, |drawCall|, |descriptor|.{{GPURenderPipelineDescriptor/vertex}}, |state|)。

        3. **Assemble primitives**.

            执行assemble primitives(|vertexList|, |drawCall|, |descriptor|.{{GPURenderPipelineDescriptor/primitive}})。

        4. **Clip primitives**.

        5. 光栅化。
        6. 处理片元。
            问题：完成此节。
        7. 处理深度/模板。
            问题：完成此节。
        8. 写入像素。
            问题：完成此节。
</div>

### 索引分辨率 ### {#index-resolution}

在渲染的第一阶段，管道会为每个实例构建一个要处理的顶点列表。
<div>
    <dfn abstract-op>resolve indices</dfn>(drawCall, state)

    **Arguments:**
    - |drawCall|: 绘制调用参数。
    - |state|: 激活的[=RenderState=]。

    **Returns:** 整数索引列表。

    1. 使|vertexIndexList|为一个空的索引列表。
    2. 如果|drawCall|是一个索引绘制调用：
        1. 使用|drawCall|.indexCount整数初始化|vertexIndexList|。
        2. 对0 .. |drawCall|.indexCount (non-inclusive)范围内的|i|：
            1. 使|relativeVertexIndex| be [$fetch index$](|i| + |drawCall|.`firstIndex`,
                |state|.[=RenderState/indexBuffer=])。
            2. 如果|relativeVertexIndex|有 `"out of bounds"` 的具体值，停止并返回空列表。

                注意：当发生这种情况时，实现可能会选择显示警告，特别是当它很容易检测时（如在非间接索引绘制调用中）。
            3. 将|drawCall|.`baseVertex` + |relativeVertexIndex|添加至|vertexIndexList|。
    3. Otherwise:
        1. 使用|drawCall|.vertexCount整数初始化|vertexIndexList|。
        2. 设置每个|vertexIndexList| item |i|为值|drawCall|.firstVertex + |i|。
    4. 返回|vertexIndexList|。

    注意：在间接绘制调用的情况下，从间接缓冲区而不是绘制命令本身读取indexCount、vertexCount 和|drawCall|的其他属性。

    问题：更好地细化间接命令。
</div>

<div>
    <dfn abstract-op>fetch index</dfn>(i, buffer, offset, format)

    **Arguments:**
    - |i|: 要获取的顶点索引的索引。
    - |indexBufferState|: [=RenderState/indexBuffer=] (buffer, format, offset, and size)的值。

    **Returns:** 无符号整数或 `"out of bounds"`

    1. 使|indexSize|被indexBufferState|.`format`定义：
        <dl class="switch">
            : {{GPUIndexFormat/"uint16"}}
            :: 2
            : {{GPUIndexFormat/"uint32"}}
            :: 4
        </dl>
    2. 如果|indexBufferState|.`offset` + |i + 1| &times; |indexSize| &gt; |indexBufferState|.`size`，返回特殊值 `"out of bounds"`。
    3. 将|indexBufferState|.`buffer`中的数据从偏移量|indexBufferState|.`offset` + |i| &times; |indexSize|开始，大小为|indexSize|字节，解释为一个无符号整数并返回它。
</div>

### 顶点处理 ### {#vertex-processing}

顶点处理阶段是渲染[=pipeline=]的一个可编程阶段，它处理顶点属性数据，并为#primitive-clipping生成剪辑空间位置，以及为[[#fragment-processing]]片元处理生成其他数据。

<div>
    <dfn abstract-op>process vertices</dfn>(vertexIndexList, drawCall, desc, state)

    **Arguments:**
    - |vertexIndexList|: 要处理的定点索引列表（可变，通过引用传递）。
    - |desc|: 类型{{GPUVertexState}}的描述符。
    - |state|: 激活的[=RenderState=]。

    每个|vertexIndexList|中的顶点|vertexIndex|，在索引|rawInstanceIndex|的每个实例中，都是独立处理的。|rawInstanceIndex|的范围是从0到|drawCall|.instanceCount - 1，包括这两个值。此处理并行发生，任何副作用，例如写入{{GPUBufferBindingType/"storage"|GPUBufferBindingType."storage"}}绑定，都可能以任何顺序发生。

    1. 使|instanceIndex|为|rawInstanceIndex| + |drawCall|.firstInstance.
    2. 对每个列表|desc|.{{GPUVertexState/buffers}}中的non-`null` |vertexBufferLayout|：
        1. 使|i|为此列表中缓冲区布局的索引值。
        2. 使|vertexBuffer|，|vertexBufferOffset|，和|vertexBufferBindingSize|为buffer，offset，和|state|.[=RenderState/vertexBuffers=]的|i|处大小。
        3. 使|vertexElementIndex|依赖于|vertexBufferLayout|.{{GPUVertexBufferLayout/stepMode}}:
            <dl class="switch">
                : {{GPUVertexStepMode/"vertex"}}
                :: |vertexIndex|
                : {{GPUVertexStepMode/"instance"}}
                :: |instanceIndex|
            </dl>
        4. 对每个|vertexBufferLayout|.{{GPUVertexBufferLayout/attributes}}中的|attributeDesc|：
            1. 使|attributeOffset|为|vertexBufferOffset| +
                |vertexElementIndex| * |vertexBufferLayout|.{{GPUVertexBufferLayout/arrayStride}} +
                |attributeDesc|.{{GPUVertexAttribute/offset}}。
            2. 从|vertexBuffer|偏移量|attributeOffset|开始，加载格式|attributeDesc|.{{GPUVertexAttribute/format}}的属性数据。 组件按 x、y、z、w 的顺序从缓冲区内存中加载。

                如果这导致越界访问，则结果值根据WGSL的[=invalid memory reference=]行为确定。
            3. **Optionally (implementation-defined):**
                如果|attributeOffset| + sizeof(|attributeDesc|.{{GPUVertexAttribute/format}}) &gt;
                |vertexBufferOffset| + |vertexBufferBindingSize|,
                [=list/empty=] |vertexIndexList|并且停止，取消绘制调用。

                注意：这允许实现在发出绘制调用之前检测索引缓冲区中的越界值，而不是使用[=invalid memory reference=]行为。
            4. 根据[=channel formats=]规则，将|数据|转换为着色器可见的格式。
                <div class="example">
                    在WGSL中，{{GPUVertexFormat/"snorm8x2"}}类型的属性和字节值 `[0x70, 0xD0]` 将转换为 `vec2<f32>(0.88, -0.24)`。
                </div>
            5. 调整|数据|大小至着色器类型：
                - 如果都是标量，或者都是相同维度的向量，则不需要调整。
                - 如果|数据|是向量但是着色器类型为标量，则只提取第一个分量。
                - 如果两者都是向量，并且|数据|具有更高的维度，则删除额外的组件。
                    <div class="example">
                        如果需要2-component vector，则类型为{{GPUVertexFormat/"float32x3"}}且值为 `vec3<f32>(1.0, 2.0, 3.0)` 的属性将作为 `vec2<f32>(1.0, 2.0)`暴露给着色器。
                    </div>
                - 如果着色器类型是更高维度的向量，或者|数据|是标量，则以 `vec4<*>(0, 0, 0, 1)` 值填充缺失的组件。
                    <div class="example">
                        如果需要4-component vector，则类型为{{GPUVertexFormat/"sint32"}}且值为5的属性将作为 `vec4<i32>(5, 0, 0, 1)`暴露给着色器。
                    </div>
            6. 将|数据|绑定到顶点着色器输入位置|attributeDesc|.{{GPUVertexAttribute/shaderLocation}}。
    3. 对每个|state|.[=RenderState/bindGroups=]中的{{GPUBindGroup}}组：
        1. 对每个绑定组中的资源{{GPUBindingResource}}：
            1. 使|entry|为此资源对应的{{GPUBindGroupLayoutEntry}}。
            2. 如果|entry|.{{GPUBindGroupLayoutEntry}}.visibility包含{{GPUShaderStage/VERTEX}}:
                - 绑定资源至|索引|组下的着色器并绑定{{GPUBindGroupLayoutEntry/binding|GPUBindGroupLayoutEntry.binding}}.
    4. 设置着色器[=builtins=]:
        - 将vertex_index内置，如果有的话，设置为|vertexIndex|。
        - 将instance_index内置，如果有的话，设置为|instanceIndex|。
    5. 调用由|desc|描述的顶点着色器入口点。

        注意：目标平台缓存顶点着色器调用的结果。不能保证任何重复多次的|vertexIndex|会导致多次调用。同样，不能保证单个|vertexIndex|只会被处理一次。
</div>

### 图元装配 ### {#primitive-assembly}

图元由GPU的固定功能阶段组装。

<div>
    <dfn abstract-op>assemble primitives</dfn>(vertexIndexList, drawCall, desc)

        **Arguments:**
            - |vertexIndexList|: 要处理的顶点索引列表。
            - |drawCall|: 绘制调用参数。
            - |desc|: 类型{{GPUPrimitiveState}}的描述符。

        对于每个实例，图元都是根据|vertexIndexList|从着色器处理过的顶点组装而成的。

        1. 首先，如果|desc|.{{GPUPrimitiveState/stripIndexFormat}}不为null(这意味着图元拓扑是一个strip)，并且|drawCall|已被索引。|vertexIndexList|被拆分为子列表，使用此索引格式的最大值作为分隔符。

            示例：一个类型为{{GPUIndexFormat/"uint16"}}，值为 `[1, 2, 65535, 4, 5, 6]`的|vertexIndexList|将被拆分为子列表：`[1, 2]`和 `[4, 5, 6]`。

        2. 对于每个子列表|vl|，根据|desc|.{{GPUPrimitiveState/topology}}进行图元生成：
            <dl class="switch">
                : {{GPUPrimitiveTopology/"line-list"}}
                ::
                    线图元由(|vl|.0, |vl|.1)，然后(|vl|.2, |vl|.3)，然后(|vl|.4, |vl|.5)等组成。每个后续图元采用2个顶点。

                : {{GPUPrimitiveTopology/"line-strip"}}
                ::
                    线图元由(|vl|.0, |vl|.1)，然后(|vl|.1, |vl|.2)，然后(|vl|.2, |vl|.3)等组成。每个后续图元采用1个顶点。

                : {{GPUPrimitiveTopology/"triangle-list"}}
                ::
                    三角形图元由(|vl|.0, |vl|.1, |vl|.2)，然后(|vl|.3, |vl|.4, |vl|.5)，然后(|vl|.6, |vl|.7, |vl|.8)等组成。每个后续图元采用3个顶点。

                : {{GPUPrimitiveTopology/"triangle-strip"}}
                ::
                    三角形图元由(|vl|.0, |vl|.1, |vl|.2)，然后(|vl|.2, |vl|.1, |vl|.3)，然后(|vl|.2, |vl|.3, |vl|.4)，然后(|vl|.4, |vl|.3, |vl|.5)等组成。每个后续图元采用1个顶点。
            </dl>

            问题：这应该更正式地定义吗？

            未完成的图元被删除。

</div>

### 图元剪裁 ### {#primitive-clipping}

顶点着色器必须创建一个内置的“position”（类型为 vec4<f32>），表示顶点的<dfn dfn>clip position</dfn>。

问题：连接至WGSL内置项。

图元被剪裁到<dfn dfn>clip volume</dfn>，对于图元内的任何剪裁位置p，它由以下不等式定义：
  - &minus;|p|.w &le; |p|.x &le; |p|.w
  - &minus;|p|.w &le; |p|.y &le; |p|.w
  - 0 &le; |p|.z &le; |p|.w (<dfn dfn>depth clipping</dfn>)

如果descriptor|.{{GPURenderPipelineDescriptor/primitive}}.{{GPUPrimitiveState/clampDepth}}为true，则不应用对[=clip volume=]的[=depth clipping=]限制。

如果图元的每条边都完全位于[=clip volume=]内，则图元不变地通过此阶段。如果图元的边与剪辑体积的边界相交，则相交的边将通过位于[=clip volume=]边界的新边重新连接。对于三角形图元（|descriptor|.{{GPURenderPipelineDescriptor/primitive}}.{{GPUPrimitiveState/topology}}是{{GPUPrimitiveTopology/"triangle-list"}}或{{GPUPrimitiveTopology/"triangle-strip"}}），这种重新连接可能会导致在多边形内部引入新的顶点。

如果图元与[=clip volume=]边界的一条边相交，则裁剪的多边形必须包含一个在该边界边上的点。

如果顶点着色器输出其他浮点值（标量和向量），用“透视”插值限定，它们也会被裁剪。与位于裁剪体积内的顶点关联的输出值不受裁剪的影响。然而，如果一个图元被裁剪，分配给裁剪产生的顶点的输出值也会被裁剪。

考虑顶点|a|和|b|之间的边被剪裁，导致顶点|c|，让我们定义|t|为边顶点之间的比率：|c|.p = |t| &times; |a|.p &plus; (1 &minus; |t|) &times; |b|.p，其中|x|.p是顶点|x|的输出[=clip position=]。

对于具有相应片元输入的每个顶点输出值“v”，|a|.v和|b|.v将分别是|a|和|b|顶点的输出。裁剪着色器输出|c|.v是基于插值限定符生成的：
<dl class="switch">
    : "flat"
    ::
        flat插值不受影响，并且基于<dfn dfn>provoking vertex</dfn>，即图元中的第一个顶点。 整个图元的输出值相同，并且与[=provoking vertex=]的顶点输出匹配：|c|.v = [=provoking vertex=].v。

    : "linear"
    ::
        插值率根据[=clip position=]的透视坐标调整，所以的差值结果在屏幕空间中为线性的。

        问题：在这里提供更多细节，如果可能。

    : "perspective"
    ::
        该值在裁剪空间中线性插值，产生透视正确的值：

        |c|.v = |t| &times; |a|.v &plus; (1 &minus; |t|) &times; |b|.v
</dl>

问题：链接到WGSL中的插值限定符。

### 光栅化 ### {#rasterization}

光栅化是硬件处理阶段，将生成的图元映射到<dfn dfn>framebuffer</dfn>的二维渲染区域——当前{{GPURenderPassEncoder}}中的渲染附件集。 该渲染区域被分成均匀的像素网格。

光栅化确定受图元影响的像素集。在多重采样的情况下，每个像素被进一步拆分为|descriptor|.{{GPURenderPipelineDescriptor/multisample}}.{{GPUMultisampleState/count}}个样本。每个像素的样本位置都相同，但在本规范中未定义。

问题：我们需要强制启用Vulkan中的"Standard sample locations"吗？

[=framebuffer=]坐标从渲染目标的左上角开始。 每个单元正好对应一个像素。有关更多信息，请参阅[[#coordinate-systems]]坐标系。

1. 首先，裁剪的顶点被转换为<dfn dfn>NDC</dfn>-归一化设备坐标。给定输出位置|p|，[=NDC=]坐标计算如下：

    ndc(|p|) = vector(|p|.x &divide; |p|.w, |p|.y &divide; |p|.w, |p|.z &divide; |p|.w)

2. 使|viewport|为当前渲染通道的{{GPURenderPassEncoder/[[viewport]]}}。然后根据渲染目标的大小将[=NDC=]坐标|n|转换为[=framebuffer=]坐标：

    framebufferCoords(n) = vector(|viewport|.`x` &plus; 0.5&times;(|n|.x&plus;1)&times;|viewport|.width, |viewport|.y &plus; 0.5&times;(|n|.y&plus;1)&times;|viewport|.height)

3. 具体光栅化算法依赖于{{GPURenderPipelineDescriptor/primitive}}.{{GPUPrimitiveState/topology}}：
    <dl class="switch">
        : {{GPUPrimitiveTopology/"point-list"}}
        :: 点, 如果未被#primitive-clipping过滤, 则进入[[#point-rasterization]]。
        : {{GPUPrimitiveTopology/"line-list"}}或{{GPUPrimitiveTopology/"line-strip"}}
        :: 被#primitive-clipping裁剪的线段，进入[[#line-rasterization]]。
        : {{GPUPrimitiveTopology/"triangle-list"}}或{{GPUPrimitiveTopology/"triangle-strip"}}
        :: #primitive-clipping产生的多边形，进入[[#polygon-rasterization]]。
    </dl>

Issue: 更改"goes into"部分的措辞。

让我们将<dfn dfn>fragment destination</dfn>定义为像素位置与样本索引的组合，以防[[#sample-frequency-shading]]处于激活状态。

光栅化的结果为一个点集，每个点带有以下数据：
  - [=fragment destination=]
  - multisample coverage mask (see [[#sample-masking]])
  - depth, in NDC coordinates.
  - barycentric coordinates

问题：定义barycentric coordinates。
问题：定义深度计算算法。

#### 点光栅化 #### {#point-rasterization}

单个[=fragment destination=]在包含点的framebuffer坐标的像素内被选择。

coverage mask依赖于多重采样模式:
<dl class="switch">
    : sample-frequency
    :: coverageMask = 1 &Lt; `sampleIndex`
    : pixel-frequency multi-sampling
    :: coverageMask = 1 &Lt; |descriptor|.{{GPURenderPipelineDescriptor/multisample}}.{{GPUMultisampleState/count}} &minus; 1
    : no multi-sampling
    :: coverageMask = 1
</dl>

#### 线光栅化 #### {#line-rasterization}

问题：补充本章节。

#### 多边形光栅化 #### {#polygon-rasterization}

令v(i)为对|n|个顶点的光栅化多边形裁剪顶点编号|i|（从1开始）的framebuffer坐标。

注意：本节以术语“多边形”替代“三角形”，由于#primitive-clipping阶段可能介绍了其他顶点。这不会被应用程序发现。

多边形光栅化的第一步是确定多边形是<dfn dfn>front-facing</dfn>还是<dfn dfn>back-facing</dfn>。这取决于framebuffer坐标中多边形所占|区域|的符号：

|area| = 0.5 &times; ((|v|<sub>1</sub>.x &times; |v|<sub>|n|</sub>.y &minus; |v|<sub>|n|</sub>.x &times; |v|<sub>1</sub>.y) &plus; &sum; (|v|<sub>|i|&plus;1</sub>.x &times; |v|<sub>|i|</sub>.y &minus; |v|<sub>|i|</sub>.x &times; |v|<sub>|i|&plus;1</sub>.y))

|区域|的符号是根据{{GPURenderPipelineDescriptor/primitive}}.{{GPUPrimitiveState/frontFace}}解释的：
<dl class="switch">
    : {{GPUFrontFace/"ccw"}}
    :: |area| &gt; 0被当作[=front-facing=], 否则为[=back-facing=]
    : {{GPUFrontFace/"cw"}}
    :: |area| &lt; 0被当作[=front-facing=], 否则为[=back-facing=]
    : "linear"
    ::
</dl>

多边形可以被{{GPURenderPipelineDescriptor/primitive}}.{{GPUPrimitiveState/cullMode}}剔除：
<dl class="switch">
    : {{GPUCullMode/"none"}}
    :: 所有通过此测试的多边形。
    : {{GPUCullMode/"front"}}
    :: [=front-facing=]多边形将被丢弃，并且不会在渲染管线的后期阶段进行处理。
    : {{GPUCullMode/"back"}}
    :: [=back-facing=]多边形将被丢弃。
</dl>

下一步是在帧缓冲区空间中确定多边形内的一组<dfn dfn>fragments</dfn>-这些是为每个片元操作安排的位置。最终确认是基于|descriptor|.{{GPURenderPipelineDescriptor/multisample}}的：
<dl class="switch">
    : disabled
    :: [=Fragment=]与像素中心相关联。也就是说，包含在多边形中的framebuffer空间中坐标为C的所有点（其中fract(|C|) = vector2(0.5, 0.5)）都包括在内。如果像素中心位于多边形的边缘，则是否包含它未定义。

        注意：这成为光栅化器的精度问题。

    : enabled
    :: 每个像素都与|descriptor|.{{GPURenderPipelineDescriptor/multisample}}.{{GPUMultisampleState/count}}位置相关联，这些位置是实现定义的。位置是有序的，并且列表对于framebuffer的每个像素都是相同的。每个位置对应于多采样framebuffer中的一个片元。

       光栅化器构建每个像素内被击中的位置的掩码，并提供作为片元着色器内置的“样本掩码”。

</dl>

### 片元处理 ### {#fragment-processing}

问题：补充此章节。

### 无颜色输出 ### {#no-color-output}

在no-color-output模式下，[=pipeline=]不产生任何颜色附件输出。

[=pipeline=]仍然执行光栅化并根据顶点位置输出生成深度值。深度测试和模板操作仍然可以使用。

### Alpha覆盖 ### {#alpha-to-coverage}

在alpha-to-coverage模式下, 根据{GPURenderPipelineDescriptor/fragment}}.{{GPUFragmentState/targets}}[0]的片元着色器输出|alpha|组件，产生一个另外的MSAA样本的<dfn dfn>alpha-to-coverage mask</dfn>。

生成额外掩码的算法取决于平台，并且可能因不同像素而异。它保证：
  - 如果|alpha|为0.0或更小，结果为0x0。
  - 如果|alpha|为1.0或更大，结果为0xFFFFFFFF。
  - 如果|alpha|比一些其他的|alpha1|更大，则生成的样本掩码设置为1的位数至少和|alpha1|的掩码一样多。
    then the produced sample mask has at least as many bits set to 1 as the mask for |alpha1|

### 采样频率着色 ### {#sample-frequency-shading}

问题：补充此章节。

### 采样遮掩 ### {#sample-masking}

一个像素的<dfn dfn>final sample mask</dfn>计算为：
[=rasterization mask=] & {{GPUMultisampleState/mask}} & [=shader-output mask=]

仅考虑掩码的较低{{GPUMultisampleState/count}}位。

如果[=final sample mask=]的位置|N|处的最低有效位的值为“0”，则丢弃到片段着色器的所有附件的样本颜色输出（对应于样本|N|）。 此外，不会对深度模板附件的相关样本执行深度测试或模板操作。

注意：样本|N|的颜色输出是由片段着色器执行产生的，当前像素的 SV_SampleIndex == |N|。如果片元着色器不使用此语义，则每个像素仅执行一次。

<dfn dfn>rasterization mask</dfn>由光栅化阶段根据光栅化多边形的形状生成。包含在形状中的样本在掩码中获得相关位1。

<dfn dfn>shader-output mask</dfn>采用片元着色器中内置的“sample_mask”的输出值。如果内置函数不是从片元着色器输出的，并且启用了{{GPUMultisampleState/alphaToCoverageEnabled}}，则[=shader-output mask=]将成为[=alpha-to-coverage mask=]。否则，它默认为0xFFFFFFFF。

# 类型定义 # {#type-definitions}

<script type=idl>
typedef [EnforceRange] unsigned long GPUBufferDynamicOffset;
typedef [EnforceRange] unsigned long GPUStencilValue;
typedef [EnforceRange] unsigned long GPUSampleMask;
typedef [EnforceRange] long GPUDepthBias;

typedef [EnforceRange] unsigned long long GPUSize64;
typedef [EnforceRange] unsigned long GPUIntegerCoordinate;
typedef [EnforceRange] unsigned long GPUIndex32;
typedef [EnforceRange] unsigned long GPUSize32;
typedef [EnforceRange] long GPUSignedOffset32;

typedef unsigned long GPUFlagsConstant;
</script>

## 颜色 &amp; 向量 ## {#colors-and-vectors}

<script type=idl>
dictionary GPUColorDict {
    required double r;
    required double g;
    required double b;
    required double a;
};
typedef (sequence<double> or GPUColorDict) GPUColor;
</script>

注意：`double`足够大以精确保存32位有符号/无符号整数和单精度浮点数。

<script type=idl>
dictionary GPUOrigin2DDict {
    GPUIntegerCoordinate x = 0;
    GPUIntegerCoordinate y = 0;
};
typedef (sequence<GPUIntegerCoordinate> or GPUOrigin2DDict) GPUOrigin2D;
</script>

<dfn dfn>Origin2D</dfn>是一个{{GPUOrigin2D}}。
[=Origin2D=]是以下定义的规范命名空间：
<!-- This is silly, but provides convenient syntax for the spec. -->

<div algorithm="GPUOrigin2D accessors" dfn-for=Origin2D>
    对一个给定{{GPUOrigin2D}}值的|origin|，根据其类型，句法：

      - |origin|.<dfn dfn>x</dfn>指{{GPUOrigin2DDict}}.{{GPUOrigin2DDict/x}}或序列的第一项，如果不存在则为0。
      - |origin|.<dfn dfn>y</dfn>指{{GPUOrigin2DDict}}.{{GPUOrigin2DDict/y}}或序列的第二项，如果不存在则为0。
</div>

<script type=idl>
dictionary GPUOrigin3DDict {
    GPUIntegerCoordinate x = 0;
    GPUIntegerCoordinate y = 0;
    GPUIntegerCoordinate z = 0;
};
typedef (sequence<GPUIntegerCoordinate> or GPUOrigin3DDict) GPUOrigin3D;
</script>

<dfn dfn>Origin3D</dfn>是一个{{GPUOrigin3D}}。
[=Origin3D=]是以下定义的规范命名空间：
<!-- This is silly, but provides convenient syntax for the spec. -->

<div algorithm="GPUOrigin3D accessors" dfn-for=Origin3D>
    对于给定{{GPUOrigin3D}}值的|origin|，根据它的类型，句法：

      - |origin|.<dfn dfn>x</dfn>指{{GPUOrigin3DDict}}.{{GPUOrigin3DDict/x}}或序列的第一项，如果不存在则为0。
      - |origin|.<dfn dfn>y</dfn>指{{GPUOrigin3DDict}}.{{GPUOrigin3DDict/y}}或序列的第二项，如果不存在则为0。
      - |origin|.<dfn dfn>z</dfn>指{{GPUOrigin3DDict}}.{{GPUOrigin3DDict/z}}或序列的第三项，如果不存在则为0。
</div>

<script type=idl>
dictionary GPUExtent3DDict {
    required GPUIntegerCoordinate width;
    GPUIntegerCoordinate height = 1;
    GPUIntegerCoordinate depthOrArrayLayers = 1;
};
typedef (sequence<GPUIntegerCoordinate> or GPUExtent3DDict) GPUExtent3D;
</script>

<dfn dfn>Extent3D</dfn>是一个{{GPUExtent3D}}.
[=Extent3D=]为以下定义的规范命名空间：
<!-- This is silly, but provides convenient syntax for the spec. -->

<div algorithm="GPUExtent3D accessors" dfn-for=Extent3D>
    For a given {{GPUExtent3D}} value |extent|, depending on its type, the syntax:

      - |extent|.<dfn dfn>width</dfn>指{{GPUExtent3DDict}}.{{GPUExtent3DDict/width}}或序列的第一项，如果不存在则为1。
      - |extent|.<dfn dfn>height</dfn>指{{GPUExtent3DDict}}.{{GPUExtent3DDict/height}}或序列的第二项，如果不存在则为1。
      - |extent|.<dfn dfn>depthOrArrayLayers</dfn>指{{GPUExtent3DDict}}.{{GPUExtent3DDict/depthOrArrayLayers}}或序列的第三项，如果不存在则为1。
</div>

# 特性索引 # {#feature-index}

## <dfn dfn-type=enum-value dfn-for=GPUFeatureName>"depth-clamping"</dfn> ## {#depth-clamping}

问题：当{{GPUFeatureName/"depth-clamping"}} [=feature=]被启用时定义功能。

**特性字典值**

以下字典值当且仅当{{GPUFeatureName/"depth-clamping"}}
[=feature=]启用时被支持，否则必须设置为它们的默认值：

<dl>
    : {{GPUPrimitiveState}}
    ::
        * {{GPUPrimitiveState/clampDepth}}
</dl>

## <dfn dfn-type=enum-value dfn-for=GPUFeatureName>"depth24unorm-stencil8"</dfn> ## {#depth24unorm-stencil8}

允许明确创建{{GPUTextureFormat/"depth24unorm-stencil8"}}格式的纹理。

**特性枚举**

以下枚举当且仅当{{GPUFeatureName/"depth24unorm-stencil8"}}
[=feature=]启用时被支持：

<dl>
    : {{GPUTextureFormat}}
    ::
        * {{GPUTextureFormat/"depth24unorm-stencil8"}}
</dl>

## <dfn dfn-type=enum-value dfn-for=GPUFeatureName>"depth32float-stencil8"</dfn> ## {#depth32float-stencil8}

允许明确创建{{GPUTextureFormat/"depth32float-stencil8"}}格式的纹理。

**特性枚举**

以下枚举当且仅当{{GPUFeatureName/"depth32float-stencil8"}} [=feature=]启用时被支持。

<dl>
    : {{GPUTextureFormat}}
    ::
        * {{GPUTextureFormat/"depth32float-stencil8"}}
</dl>

## <dfn dfn-type=enum-value dfn-for=GPUFeatureName>"pipeline-statistics-query"</dfn> ## {#pipeline-statistics-query}

问题：当{{GPUFeatureName/"pipeline-statistics-query"}} [=feature=]启用时定义功能。

**特性枚举**

以下枚举当且仅当{{GPUFeatureName/"pipeline-statistics-query"}}
[=feature=]启用时被支持：

<dl>
    : {{GPUQueryType}}
    ::
        * {{GPUQueryType/"pipeline-statistics"}}
</dl>


## <dfn dfn-type=enum-value dfn-for=GPUFeatureName>"texture-compression-bc"</dfn> ## {#texture-compression-bc}

允许明确创建BC压缩格式的纹理。

**特性枚举**

以下枚举当且仅当{{GPUFeatureName/"texture-compression-bc"}}
[=feature=]启用时被支持：

<dl>
    : {{GPUTextureFormat}}
    ::
        * {{GPUTextureFormat/"bc1-rgba-unorm"}}
        * {{GPUTextureFormat/"bc1-rgba-unorm-srgb"}}
        * {{GPUTextureFormat/"bc2-rgba-unorm"}}
        * {{GPUTextureFormat/"bc2-rgba-unorm-srgb"}}
        * {{GPUTextureFormat/"bc3-rgba-unorm"}}
        * {{GPUTextureFormat/"bc3-rgba-unorm-srgb"}}
        * {{GPUTextureFormat/"bc4-r-unorm"}}
        * {{GPUTextureFormat/"bc4-r-snorm"}}
        * {{GPUTextureFormat/"bc5-rg-unorm"}}
        * {{GPUTextureFormat/"bc5-rg-snorm"}}
        * {{GPUTextureFormat/"bc6h-rgb-ufloat"}}
        * {{GPUTextureFormat/"bc6h-rgb-float"}}
        * {{GPUTextureFormat/"bc7-rgba-unorm"}}
        * {{GPUTextureFormat/"bc7-rgba-unorm-srgb"}}
</dl>

## <dfn dfn-type=enum-value dfn-for=GPUFeatureName>"texture-compression-etc2"</dfn> ## {#texture-compression-etc}

允许明确创建ETC2压缩格式的纹理。

**特性枚举**

以下枚举当且仅当{{GPUFeatureName/"texture-compression-etc2"}}
[=feature=]启用时被支持：

<dl>
    : {{GPUTextureFormat}}
    ::
        * {{GPUTextureFormat/"etc2-rgb8unorm"}}
        * {{GPUTextureFormat/"etc2-rgb8unorm-srgb"}}
        * {{GPUTextureFormat/"etc2-rgb8a1unorm"}}
        * {{GPUTextureFormat/"etc2-rgb8a1unorm-srgb"}}
        * {{GPUTextureFormat/"etc2-rgba8unorm"}}
        * {{GPUTextureFormat/"etc2-rgba8unorm-srgb"}}
        * {{GPUTextureFormat/"eac-r11unorm"}}
        * {{GPUTextureFormat/"eac-r11snorm"}}
        * {{GPUTextureFormat/"eac-rg11unorm"}}
        * {{GPUTextureFormat/"eac-rg11snorm"}}
</dl>

## <dfn dfn-type=enum-value dfn-for=GPUFeatureName>"texture-compression-astc"</dfn> ## {#texture-compression-astc}

允许明确创建ASTC压缩格式的纹理。

**特性枚举**

以下枚举当且仅当{{GPUFeatureName/"texture-compression-astc"}}
[=feature=]启用时被支持：

<dl>
    : {{GPUTextureFormat}}
    ::
        * {{GPUTextureFormat/"astc-4x4-unorm"}}
        * {{GPUTextureFormat/"astc-4x4-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-5x4-unorm"}}
        * {{GPUTextureFormat/"astc-5x4-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-5x5-unorm"}}
        * {{GPUTextureFormat/"astc-5x5-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-6x5-unorm"}}
        * {{GPUTextureFormat/"astc-6x5-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-6x6-unorm"}}
        * {{GPUTextureFormat/"astc-6x6-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-8x5-unorm"}}
        * {{GPUTextureFormat/"astc-8x5-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-8x6-unorm"}}
        * {{GPUTextureFormat/"astc-8x6-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-8x8-unorm"}}
        * {{GPUTextureFormat/"astc-8x8-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-10x5-unorm"}}
        * {{GPUTextureFormat/"astc-10x5-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-10x6-unorm"}}
        * {{GPUTextureFormat/"astc-10x6-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-10x8-unorm"}}
        * {{GPUTextureFormat/"astc-10x8-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-10x10-unorm"}}
        * {{GPUTextureFormat/"astc-10x10-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-12x10-unorm"}}
        * {{GPUTextureFormat/"astc-12x10-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-12x12-unorm"}}
        * {{GPUTextureFormat/"astc-12x12-unorm-srgb"}}
</dl>

## <dfn dfn-type=enum-value dfn-for=GPUFeatureName>"timestamp-query"</dfn> ## {#timestamp-query}

问题：当{{GPUFeatureName/"timestamp-query"}} [=feature=]启用时定义功能。

**特性枚举**

以下枚举当且仅当{{GPUFeatureName/"timestamp-query"}}
[=feature=]启用时被支持。

<dl>
    : {{GPUQueryType}}
    ::
        * {{GPUQueryType/"timestamp"}}
</dl>

# 附录 # {#appendices}

## 纹理格式功能 ## {#texture-format-caps}

### 纯色格式 ### {#plain-color-formats}

所有纯色格式支持{{GPUTextureUsage/COPY_SRC}}, {{GPUTextureUsage/COPY_DST}}, 和{{GPUTextureUsage/TEXTURE_BINDING}}用法。

只有具有{{GPUTextureSampleType}} {{GPUTextureSampleType/"float"}}才能被混合。

列{{GPUTextureUsage/RENDER_ATTACHMENT}}和{{GPUTextureUsage/STORAGE_BINDING}}分别指定对{{GPUTextureUsage/RENDER_ATTACHMENT|GPUTextureUsage.RENDER_ATTACHMENT}}和{{GPUTextureUsage/STORAGE_BINDING|GPUTextureUsage.STORAGE_BINDING}}用法的支持。

<table class='data'>
    <thead class=stickyheader>
        <tr>
            <th>Format
            <th>{{GPUTextureSampleType}}
            <th>{{GPUTextureUsage/RENDER_ATTACHMENT}}
            <th>{{GPUTextureUsage/STORAGE_BINDING}}
    </thead>
    <tr><th class=stickyheader>8-bit per component<th><th><th>
    <tr>
        <td>{{GPUTextureFormat/r8unorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/r8snorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>
        <td>
    <tr>
        <td>{{GPUTextureFormat/r8uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/r8sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/rg8unorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/rg8snorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>
        <td>
    <tr>
        <td>{{GPUTextureFormat/rg8uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/rg8sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/rgba8unorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rgba8unorm-srgb}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/rgba8snorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rgba8uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rgba8sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/bgra8unorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/bgra8unorm-srgb}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>
    <tr><th class=stickyheader>16-bit per component<th><th><th>
    <tr>
        <td>{{GPUTextureFormat/r16uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/r16sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/r16float}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/rg16uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/rg16sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/rg16float}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td><!-- Vulkan -->
    <tr>
        <td>{{GPUTextureFormat/rgba16uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rgba16sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rgba16float}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&checkmark;
    <tr><th class=stickyheader>32-bit per component<th><th><th>
    <tr>
        <td>{{GPUTextureFormat/r32uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/r32sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/r32float}}
        <td>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rg32uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rg32sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rg32float}}
        <td>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rgba32uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rgba32sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rgba32float}}
        <td>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&checkmark;
    <tr><th class=stickyheader>mixed component width<th><th><th>
    <tr>
        <td>{{GPUTextureFormat/rgb10a2unorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/rg11b10ufloat}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td><!-- Vulkan -->
        <td>

</table>

### 深度/模板格式 ### {#depth-formats}

所有深度格式都支持{{GPUTextureUsage/COPY_SRC}}，{{GPUTextureUsage/COPY_DST}}，{{GPUTextureUsage/TEXTURE_BINDING}}，和{{GPUTextureUsage/RENDER_ATTACHMENT}}用法。但是，源/目标受格式限制。

没有深度格式可以被过滤。

<table class='data'>
    <thead>
        <tr>
            <th>Format
            <th>Bytes per texel
            <th>Aspect
            <th>{{GPUTextureSampleType}}
            <th>Returned in shaders as...
            <th>Copy aspect from Buffer
            <th>Copy aspect into Buffer
    </thead>
    <tr>
        <td>{{GPUTextureFormat/stencil8}}
        <td>1 &minus; 4
        <td>stencil
        <td>{{GPUTextureSampleType/"uint"}}
        <td>`vec4<u32>(S, X, X, X)`
        <td colspan=2>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/depth16unorm}}
        <td>2
        <td>depth
        <td>{{GPUTextureSampleType/"depth"}}
        <td>`f32(D)`
        <td colspan=2>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/depth24plus}}
        <td>4
        <td>depth
        <td>{{GPUTextureSampleType/"depth"}}
        <td>`f32(D)`
        <td colspan=2>&cross;
    <tr>
        <td rowspan=2 style='white-space:nowrap'>{{GPUTextureFormat/depth24plus-stencil8}}
        <td rowspan=2>4 &minus; 8
        <td>depth
        <td>{{GPUTextureSampleType/"depth"}}
        <td>`f32(D)`
        <td colspan=2>&cross;
    <tr>
        <td>stencil
        <td>{{GPUTextureSampleType/"uint"}}
        <td>`vec4<u32>(S, X, X, X)`
        <td colspan=2>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/depth32float}}
        <td>4
        <td>depth
        <td>{{GPUTextureSampleType/"depth"}}
        <td>`f32(D)`
        <td colspan=1>&cross;
        <td colspan=1>&checkmark;
</table>

模板格式必须采样为 `vec4<u32>(S, X, X, X)`，其中S是模板值，每个X是实现定义的未指定值。作者不能依赖这些.y、.z和.w组件，因为它们的行为是不可移植的。

注意：如果没有添加新的更受约束的模板采样器类型（如深度），实现有效地掩盖模板读取的驱动程序差异是不可行的。由于这不是WebGL的可移植性痛点，因此预计在WebGPU中不会有问题。实际上，根据硬件，需要 `vec4<u32>(S, S, S, S)` 或 `vec4<u32>(S, 0, 0, 1)`。

<dfn dfn>Copies of depth and stencil textures</dfn>只能在以下格式集内发生：
  - {{GPUTextureFormat/stencil8}}, {{GPUTextureFormat/depth24plus-stencil8}} (模板组件), {{GPUTextureFormat/r8uint}}
  - {{GPUTextureFormat/depth16unorm}}, {{GPUTextureFormat/r16uint}}
  - {{GPUTextureFormat/depth24plus}}, {{GPUTextureFormat/depth24plus-stencil8}} (深度宽高比)

另外，{{GPUTextureFormat/depth32float}}纹理可以被拷贝至{{GPUTextureFormat/depth32float}}和{{GPUTextureFormat/r32float}}纹理。

注意：{{GPUTextureFormat/depth32float}}纹素值的范围有限。因此，复制到{{GPUTextureFormat/depth32float}}纹理仅对其他{{GPUTextureFormat/depth32float}}纹理有效。

问题：阐明 `depth24plus-stencil8` 是否可以被复制到所有目标后端API中的 `depth24plus`。

### 打包格式 ### {#packed-formats}

所有打包纹理格式支持{{GPUTextureUsage/COPY_SRC}}, {{GPUTextureUsage/COPY_DST}}, 和{{GPUTextureUsage/TEXTURE_BINDING}}用法。所有这些有{{GPUTextureSampleType/"float"}}类型的格式可以在采样时被过滤。

<table class='data'>
    <thead class=stickyheader>
        <tr>
            <th>Format
            <th>Bytes per block
            <th>{{GPUTextureSampleType}}
            <th>Block Size
            <th>[=Feature=]
    </thead>
    <tr>
        <td>{{GPUTextureFormat/rgb9e5ufloat}}
        <td>4
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>1 &times; 1
        <td>
    <tr>
        <td>{{GPUTextureFormat/bc1-rgba-unorm}}
        <td rowspan=2>8
        <td rowspan=14>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td rowspan=14>4 &times; 4
        <td rowspan=14>{{GPUFeatureName/texture-compression-bc}}
    <tr>
        <td>{{GPUTextureFormat/bc1-rgba-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/bc2-rgba-unorm}}
        <td rowspan=2>16
    <tr>
        <td>{{GPUTextureFormat/bc2-rgba-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/bc3-rgba-unorm}}
        <td rowspan=2>16
    <tr>
        <td>{{GPUTextureFormat/bc3-rgba-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/bc4-r-unorm}}
        <td rowspan=2>8
    <tr>
        <td>{{GPUTextureFormat/bc4-r-snorm}}
    <tr>
        <td>{{GPUTextureFormat/bc5-rg-unorm}}
        <td rowspan=2>16
    <tr>
        <td>{{GPUTextureFormat/bc5-rg-snorm}}
    <tr>
        <td>{{GPUTextureFormat/bc6h-rgb-ufloat}}
        <td rowspan=2>16
    <tr>
        <td>{{GPUTextureFormat/bc6h-rgb-float}}
    <tr>
        <td>{{GPUTextureFormat/bc7-rgba-unorm}}
        <td rowspan=2>16
    <tr>
        <td>{{GPUTextureFormat/bc7-rgba-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/etc2-rgb8unorm}}
        <td rowspan=2>8
        <td rowspan=10>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td rowspan=10>4 &times; 4
        <td rowspan=10>{{GPUFeatureName/texture-compression-etc2}}
    <tr>
        <td>{{GPUTextureFormat/etc2-rgb8unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/etc2-rgb8a1unorm}}
        <td rowspan=2>8
    <tr>
        <td>{{GPUTextureFormat/etc2-rgb8a1unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/etc2-rgba8unorm}}
        <td rowspan=2>16
    <tr>
        <td>{{GPUTextureFormat/etc2-rgba8unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/eac-r11unorm}}
        <td rowspan=2>8
    <tr>
        <td>{{GPUTextureFormat/eac-r11snorm}}
    <tr>
        <td>{{GPUTextureFormat/eac-rg11unorm}}
        <td rowspan=2>16
    <tr>
        <td>{{GPUTextureFormat/eac-rg11snorm}}
    <tr>
        <td>{{GPUTextureFormat/astc-4x4-unorm}}
        <td rowspan=2>16
        <td rowspan=28>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td rowspan=2>4 &times; 4
        <td rowspan=28>{{GPUFeatureName/texture-compression-astc}}
    <tr>
        <td>{{GPUTextureFormat/astc-4x4-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-5x4-unorm}}
        <td rowspan=2>16
        <td rowspan=2>5 &times; 4
    <tr>
        <td>{{GPUTextureFormat/astc-5x4-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-5x5-unorm}}
        <td rowspan=2>16
        <td rowspan=2>5 &times; 5
    <tr>
        <td>{{GPUTextureFormat/astc-5x5-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-6x5-unorm}}
        <td rowspan=2>16
        <td rowspan=2>6 &times; 5
    <tr>
        <td>{{GPUTextureFormat/astc-6x5-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-6x6-unorm}}
        <td rowspan=2>16
        <td rowspan=2>6 &times; 6
    <tr>
        <td>{{GPUTextureFormat/astc-6x6-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-8x5-unorm}}
        <td rowspan=2>16
        <td rowspan=2>8 &times; 5
    <tr>
        <td>{{GPUTextureFormat/astc-8x5-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-8x6-unorm}}
        <td rowspan=2>16
        <td rowspan=2>8 &times; 6
    <tr>
        <td>{{GPUTextureFormat/astc-8x6-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-8x8-unorm}}
        <td rowspan=2>16
        <td rowspan=2>8 &times; 8
    <tr>
        <td>{{GPUTextureFormat/astc-8x8-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-10x5-unorm}}
        <td rowspan=2>16
        <td rowspan=2>10 &times; 5
    <tr>
        <td>{{GPUTextureFormat/astc-10x5-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-10x6-unorm}}
        <td rowspan=2>16
        <td rowspan=2>10 &times; 6
    <tr>
        <td>{{GPUTextureFormat/astc-10x6-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-10x8-unorm}}
        <td rowspan=2>16
        <td rowspan=2>10 &times; 8
    <tr>
        <td>{{GPUTextureFormat/astc-10x8-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-10x10-unorm}}
        <td rowspan=2>16
        <td rowspan=2>10 &times; 10
    <tr>
        <td>{{GPUTextureFormat/astc-10x10-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-12x10-unorm}}
        <td rowspan=2>16
        <td rowspan=2>12 &times; 10
    <tr>
        <td>{{GPUTextureFormat/astc-12x10-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-12x12-unorm}}
        <td rowspan=2>16
        <td rowspan=2>12 &times; 12
    <tr>
        <td>{{GPUTextureFormat/astc-12x12-unorm-srgb}}
</table>

## 非导出dfns的临时使用 ## {#temp-dfn-usages}

[=Origin2D/x=] [=Origin2D/y=]
[=RenderPassDescriptor/renderExtent=]

最终这些将被删除，但目前它们对避免构建此规范文档时的编译警告仍然有用。

[=vertex buffer=]