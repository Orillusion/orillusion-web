<pre class='metadata'>
Title: WebGPU
Shortname: webgpu
Level: None
Status: LD
ED:  
Editor: 赵凌云，lingyun.zhao@orillusion.com
Editor: 薛沛，pei.xue@orillusion.com
Abstract: WebGPU 公开了一个 API，用于在图形处理单元上执行操作，例如渲染和计算。
Markup Shorthands: markdown yes
Markup Shorthands: dfn yes
Markup Shorthands: idl yes
Markup Shorthands: css no
Assume Explicit For: yes
Boilerplate: omit conformance
</pre>

<pre class=biblio>
{
  "WGSL": {
    "authors": [
      "David Neto",
      "Myles C. Maxfield"
    ],
    "href": "https://gpuweb.github.io/gpuweb/wgsl/",
    "title": "WebGPU Shading Language",
    "status": "Editor's Draft",
    "publisher": "W3C",
    "deliveredBy": [
      "https://github.com/gpuweb/gpuweb"
    ]
  },
  "SourceMap": {
    "authors": [
      "John Lenz",
      "Nick Fitzgerald"
    ],
    "href": "https://sourcemaps.info/spec.html",
    "title": "Source Map Revision 3 Proposal"
  }
}
</pre>

<pre class="link-defaults">
spec:html;
    type:interface; text:Navigator
spec:webidl;
    type:interface; text:Promise
</pre>

<pre class='anchors'>
spec: ECMA-262; urlPrefix: https://tc39.es/ecma262/#
    type: dfn
        text: agent; url: agent
        text: surrounding agent; url: surrounding-agent
        text: agent cluster; url: sec-agent-clusters
spec: webidl; urlPrefix: https://heycam.github.io/webidl/#
    type: dfn
        text: resolve; url: resolve
spec: web-apis; urlPrefix: https://html.spec.whatwg.org/multipage/webappapis.html#
    type: dfn
        text: cross-origin isolated capability; url: concept-settings-object-cross-origin-isolated-capability
spec: canvas; urlPrefix: https://html.spec.whatwg.org/multipage/canvas.html#
    type: dfn
        text: origin-clean; url: concept-canvas-origin-clean
        text: placeholder canvas element; url: offscreencanvas-placeholder
        text: canvas context mode; url: concept-canvas-context-mode
        text: OffscreenCanvas context mode; url: offscreencanvas-context-mode
        text: check the usability of the image argument; url: check-the-usability-of-the-image-argument
spec: WGSL; urlPrefix: https://gpuweb.github.io/gpuweb/wgsl/#
    type: dfn
        text: location; url: input-output-locations
        text: interpolation; url: interpolation
        text: pipeline-overridable; url: pipeline-overridable
        text: pipeline-overridable constant identifier string; url: pipeline-overridable-constant-identifier-string
        text: pipeline-overridable constant has a default value; url: pipeline-overridable-constant-has-a-default-value
        text: statically accessed; url: statically-accessed
        text: wgsl-declaration; url: declaration
        text: wgsl-type; url: type
        text: pipeline output; url: pipeline-output
        text: pipeline input; url: pipeline-input
        text: builtin; url: builtin-variables
        text: channel formats; url: channel-formats
        text: invalid memory reference; url: invalid-memory-reference
</pre>

<style>
/* Make <dl> blocks more distinct from their surroundings. */
main dl:not(.switch) {
    border-left: thin solid #f3e48c;
    padding-left: .5em;
}

/** In switches, make multiple consecutive <dd> entries distinguishable. */
dl.switch > dd {
    display: list-item;
}

/* <p> by default has these margins. Update ul/ol/dl to match,
 * since they are also put in places where paragraphs go. */
p, ul, ol, dl {
    margin: 1em 0;
}

/* Box for Valid Usage requirements. */
div.validusage {
    padding: .5em;
    border: thin solid #88e !important;
    border-radius: .5em;
}
/*
 * If the Valid Usage requirements are the first child of a *-timeline block give it a larger top
 * margin to prevent the block labels from overlapping.
 */
.content-timeline>.validusage:first-child,
.device-timeline>.validusage:first-child,
.queue-timeline>.validusage:first-child {
    margin-top: 1.5em;
}

/*
 * Boxes for steps that occur on a particular timeline.
 */
div.content-timeline, div.device-timeline, div.queue-timeline {
    padding: .5em;
    border-radius: .5em;
}
.content-timeline {
    background: rgba(0, 255, 0, 0.05);
    background: var(--tint-green);
}
.device-timeline {
    background: rgba(255, 0, 0, 0.05);
    background: var(--tint-red);
}
.queue-timeline {
    background: rgba(255, 0, 255, 0.05);
    background: var(--tint-purple);
}

/*
 * Stylistic labels, for clarity of presentation of these blocks.
 *
 * NOTE: This text is non-accessible and non-selectable; surrounding
 * text must also explain the context.
 */
.validusage, .content-timeline, .device-timeline, .queue-timeline {
    position: relative;
}
.validusage::before,
.content-timeline::before,
.device-timeline::before,
.queue-timeline::before {
    font-weight: bold;
    font-style: italic;
    font-size: 130%;
    color: rgba(0, 0, 0, 0.15);
    color: var(--watermark-text);
    position: absolute;
    right: .3em;
    top: -.1em;
}
.validusage::before {
    content: "Valid Usage";
}
.content-timeline::before {
    content: "Content Timeline";
}
.device-timeline::before {
    content: "Device Timeline";
}
.queue-timeline::before {
    content: "Queue Timeline";
}

/*
 * Ensure that argumentdef blocks don't overflow algorithm section borders. This is made far harder
 * than it needs to be because the top-level W3C stylesheet has several @media + min-width variants
 * that mark themselves as !important and then proceed to do the wrong thing.
 */
@media screen and (min-width: 78em) {
    body:not(.toc-inline) .algorithm .overlarge {
        margin-right: auto !important;
    }
}
@media screen and (min-width: 90em) {
    body:not(.toc-inline) .algorithm .overlarge {
        margin-right: auto !important;
    }
}
.algorithm .overlarge {
    margin-right: auto !important;
}

/*
 * The default algorithm style has a caption that doesn't suit this spec's
 * formatting particularly well. Hide it.
 */
.algorithm .argumentdef {
    margin-top: 0;
}
.algorithm .argumentdef>caption {
    display: none;
}

/*
 * Add vertical lines to demarcate multi-column cells.
 */
table.data td[colspan] {
    border-left-style: dotted;
    border-right-style: dotted;
}

table.data.no-colspan-center td[colspan],
table.data.no-colspan-center th[colspan] {
    text-align: unset;
}

table.data tr.row-continuation td,
table.data tr.row-continuation th {
    border-top: none;
}

/*
 * Sticky table headers.
 */
.overlarge {
    /* position: sticky doesn't work inside scrollable elements. */
    overflow-x: unset;
}
thead.stickyheader th, th.stickyheader {
    position: sticky;
    top: 0;
    background: #f8f8f8;
    background: var(--stickyheader-background);
}

/*
 * Darkmode colors
 */
:root {
    --watermark-text: rgba(0, 0, 0, 15%);
    --stickyheader-background: #f8f8f8;
    --tint-red: rgba(255, 0, 0, 6%);
    --tint-green: rgba(0, 255, 0, 10%);
    --tint-blue: rgba(0, 0, 255, 5%);
    --tint-purple: rgba(255, 0, 255, 5%);
}
@media (prefers-color-scheme:dark) {
    :root {
        --watermark-text: rgba(255, 255, 255, 25%);
        --stickyheader-background: #181818;
        --tint-red: rgba(255, 0, 0, 20%);
        --tint-green: rgba(0, 255, 0, 18%);
        --tint-blue: rgba(0, 130, 255, 24%);
        --tint-purple: rgba(255, 0, 255, 22%);
    }
}

</style>

# 介绍 # {#intro}

*本节内容非官方*

[图形处理单元](https://en.wikipedia.org/wiki/Graphics_processing_unit)，简称GPU，
对于在个人计算中实现丰富的渲染和计算应用程序至关重要。
WebGPU 是一个 API，它为 Web 公开 GPU 硬件的功能。
该API 旨在有效地映射到（2014 年后）原生 GPU API。
WebGPU 与 [WebGL](https://www.khronos.org/webgl/) 并不相关，也没有明确针对 OpenGL ES。

WebGPU 将物理 GPU 硬件视为 {{GPUAdapter}}。 它通过以下方式提供与适配器的连接
{{GPUDevice}} 管理资源，设备的 {{GPUQueue}} 执行命令。
{{GPUDevice}} 可能有自己的内存，可以高速访问处理单元。
{{GPUBuffer}} 和 {{GPUTexture}} 是由 GPU 内存支持的<dfn dfn>physical resources</dfn>。
{{GPUCommandBuffer}} 和 {{GPURenderBundle}} 是用户记录命令的容器。
{{GPUShaderModule}} 包含 [=shader=] 代码。 其他资源，
例如 {{GPUSampler}} 或 {{GPUBindGroup}}，配置 GPU 使用 [=physical resources=] 的方式。

GPU 通过 [=pipeline=] 提供数据来执行 {{GPUCommandBuffer}} 中编码的命令，
这是固定功能和可编程阶段的混合。 可编程阶段执行
<dfn dfn>shaders</dfn>，它们是专为在 GPU 硬件上运行而设计的特殊程序。
[=pipeline=] 的大部分状态定义为
{{GPURenderPipeline}} 或 {{GPUComputePipeline}} 对象。 不包括的状态
在这些 [=pipeline=] 对象中，是在使用命令进行编码时设置的，
例如 {{GPUCommandEncoder/beginRenderPass()}} 或 {{GPURenderPassEncoder/setBlendConstant()}}。


# 恶意使用注意事项 # {#malicious-use}

*本节内容非官方* 本节描述了与在 Web 上公开此 API 相关的风险

## 安全性 ## {#security}

WebGPU 的安全要求与 Web 的以往相同，同样不容商量。
一般方法是在所有命令到达 GPU 之前对其进行严格验证，
确保页面只能使用自己的数据。

### 基于 CPU 的未定义行为 ### {#security-cpu-ub}

WebGPU 实现将用户发出的工作负载转换为特定的 API 命令
到目标平台。 原生 API 指定了命令的有效用法
（例如，参见 [vkCreateDescriptorSetLayout](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/vkCreateDescriptorSetLayout.html)）
如果不遵守有效的使用规则，通常不保证任何结果。
这称为“未定义行为”，黑客可以利用它来访问他们不拥有的内存
或强制驱动程序执行任意代码。

为了禁止不安全的使用，为任何输入定义了允许的 WebGPU 行为范围。
一个实现必须验证来自用户的所有输入并且只有有效的工作负载才能到达驱动程序。 本文档规定了所有错误条件和处理语义。
例如，在“源”和“目标”中指定具有交叉范围的相同缓冲区
{{GPUCommandEncoder/copyBufferToBuffer()}} 的结果是 {{GPUCommandEncoder}}
产生错误，并且没有其他操作发生。

请查看 [[#errors-and-debugging]] 有关报错处理的更多信息。

## 基于 GPU 的未定义行为 ## {#security-gpu-ub}

WebGPU [=shader=]s 由 GPU 硬件内部的计算单元执行。 在原生 API 中，
某些着色器指令可能会导致 GPU 上出现未定义的行为。
为了解决这个问题，着色器指令集及其定义的行为都是
由 WebGPU 严格定义的。 当着色器提供给 {{GPUDevice/createShaderModule()}} 时，
WebGPU 实现必须在进行任何转换（到特定于平台的着色器）或转换过程之前对其进行验证。

## 未初始化的数据 ## {#security-uninitialized}

通常，分配新内存可能会暴露系统上运行的其他应用程序的剩余数据。
为了解决这个问题，WebGPU 在概念上将所有资源初始化为零，尽管在实践中
如果看到开发人员手动初始化内容，则实现可能会跳过此步骤。
这包括着色器内的变量和共享工作组内存。

清除工作组内存的精确机制可能因平台而异。
如果原生 API 不提供清除它的工具，WebGPU 实现将转换计算
着色器首先清除所有调用，同步它们，然后继续执行开发人员的代码。

## 着色器中的越界访问 ## {#security-shader}

[=Shader=]s 可以直接访问 [=physical resource=]
（例如，作为 {{GPUBufferBindingType/"uniform"}} {{GPUBufferBinding}}），或通过 <dfn dfn>texture unit</dfn>，
处理纹理坐标转换的固定功能硬件块。
API 端的验证只能保证提供着色器的所有输入并且
他们有正确的用法和类型。
如果不涉及 [=texture unit=]，主机API端不能保证数据在边界内访问。

问题: 定义与着色器 API 不同的主机 API

为了防止着色器访问应用程序不拥有的 GPU 内存，
WebGPU 实现可能会在驱动程序中启用特殊模式（称为“稳健缓冲区访问”）
这保证访问仅限于缓冲区边界。

或者，实现可以通过插入手动边界检查来转换着色器代码。
当采用此路径时，越界检查仅适用于数组索引。 他们不需要对着色器结构的普通字段访问
因为 {{GPUBufferBindingLayout/minBindingSize}}
在主机端验证。

如果着色器尝试 [=physical resource=] 边界之外加载数据，
以下允许实施：
  1. 在资源边界内的不同位置返回一个值
  2. 返回带有任意“X”的“(0, 0, 0, X)”的值向量
  3. 部分丢弃绘制 或 调度调用

如果着色器尝试 [=physical resource=] 边界之外写入数据，
以下允许实施：
  1. 将值写入资源边界内的不同位置
  2. 丢弃写操作
  3. 部分丢弃绘制 或 调度调用

## 无效数据 ## {#security-invalid-data}

将 [floating-point](https://en.wikipedia.org/wiki/IEEE_754) 数据从 CPU 上传到 GPU 时，
或者在 GPU 上生成它，我们最终可能会得到一个不对应的二进制表示
到有效数字，例如无穷大或 NaN（非数字）。 这种情况下的 GPU 行为是
受制于 IEEE-754 标准的 GPU 硬件实现的准确性。
WebGPU 保证引入无效的浮点数只会影响结果
算术计算，不会有其他副作用。

### 驱动程序错误 ### {#security-driver-bugs}

GPU 驱动程序像任何其他软件一样容易出现错误。 如果发生错误，黑客
可能会利用驱动程序的错误行为来访问非特权数据。
为了降低风险，WebGPU 工作组将与 GPU 厂商进行协调
将 WebGPU 一致性测试套件 (CTS) 作为其驱动程序测试过程的一部分进行集成，
就像为 WebGL 所做的那样。
WebGPU 可以实现将为一些已发现的错误提供解决方法，
并在存在无法解决的已知错误的驱动程序上禁用 WebGPU。

### 定时攻击 ### {#security-timing}

WebGPU 设计用于通过 Web Workers 进行多线程使用。 因此，它被设计为对
用户开放现代的高精度的定时攻击。 一些对象，
像 {{GPUBuffer}} 或 {{GPUQueue}} 一样，具有可以同时访问的共享状态。
这允许发生竞争条件，类似于访问来自多个 Web Workers的“SharedArrayBuffer”，这使得线程调度是可观察的。

WebGPU 通过只对[=agent cluster=] 中的 [=agents=]限制反序列化（或共享）对象的能力来解决这个问题
，并且仅当[跨域隔离](https://web.dev/coop-coep/) 政策已经到位。
此限制符合 [缓解措施](https://hacks.mozilla.org/2020/07/safely-reviving-shared-memory/)
对抗恶意的“SharedArrayBuffer”使用。 同样，用户代理也可以
序列化 [=agents=] 共享任何句柄以完全防止任何并发。

最终，WebGPU 中共享状态竞争的攻击面将是
`SharedArrayBuffer` 攻击的一小部分。

WebGPU 还指定了 {{GPUFeatureName/"timestamp-query"}} 功能，其中
提供 GPU 操作的高精度计时。 该功能是可选的，一个 WebGPU
实施可能会将其暴露限制在那些受信任的场景中。 或者，
计时查询结果可以由计算着色器处理并对齐到较低的精度。

### 行锤攻击 ### {#security-rowhammer}

[行锤](https://en.wikipedia.org/wiki/Row_hammer) 是一类利用
DRAM 单元中的状态泄漏。 它可以用于 [在 GPU 上](https://www.vusec.net/projects/glitch/)。
WebGPU 没有任何特定的缓解措施，并且依赖于平台级解决方案，
例如减少内存刷新间隔。

## 拒绝服务 ## {#security-dos}

WebGPU 应用程序可以访问 GPU 内存和计算单元。 WebGPU 实现可能会限制
应用程序的可用 GPU 内存，以保持其他应用程序的响应。
对于 GPU 处理时间，WebGPU 实现可能会设置“看门狗”计时器，以确保
应用程序不会导致 GPU 无响应超过几秒钟。
这些措施类似于 WebGL 中使用的措施。

## 工作负载识别 ## {#security-workload-identification}

WebGPU 提供对不同程序之间共享的受限全局资源的访问
（和网页）在同一台机器上运行。 基于这些共享资源的使用模式，应用程序可以尝试间接探测
这些全局资源是如何受限的，以便推断由其他打开的网页执行的工作负载。
这些问题通常类似于 Javascript 的问题，
例如系统内存和 CPU 执行吞吐量。 WebGPU 不提供任何额外的
对此的缓解措施。

### 内存资源 ### {#security-memory-resources}

WebGPU 暴露了机器全局内存堆（例如 VRAM）中的错误分配。
这允许探测系统剩余可用内存的大小
（对于给定的堆类型）通过尝试分配和监视分配失败。

GPU 内部有一个或多个（通常只有两个）内存堆
由所有正在运行的应用程序共享。 当堆耗尽时，WebGPU 将无法创建资源。
这是可观察到的，这可能允许恶意应用程序猜测哪些堆是
被其他应用程序使用，以及它们从中分配了多少。

### 计算资源 ### {#security-computation-resources}

如果一个站点与另一个站点同时使用 WebGPU，它可能会观察到增加
及时处理一些工作。 例如，如果一个站点不断提交
计算工作负载并跟踪队列上工作的完成情况，
它可能会观察到其他东西也开始使用 GPU。

GPU 有许多可以独立测试的部分，例如算术单元、
纹理采样单元、原子单元等。恶意应用程序可能会感知到
其中一些单元受到压力，并试图猜测另一个单元的工作量
通过分析应力模式来应用。 这与实际情况相似
Javascript 的 CPU 执行。

## 隐私 ## {#security-privacy}

### 机器特定限制 ### {#security-machine-limits}

WebGPU 可以公开许多关于底层 GPU 架构和设备几何结构的细节。
这包括可用的物理适配器、对 GPU 和 CPU 可以使用的资源的许多限制
（例如最大纹理大小），以及任何可选的特定于硬件的
可用的能力。

用户代理没有义务暴露真正的硬件限制，他们完全控制暴露了多少机器细节。 减少指纹识别的一种策略是分箱
将所有目标平台放入几个 bin 中。 一般来说，暴露硬件限制的隐私影响与 WebGL 相匹配。

[=limit/default=] 限制也特意设置得足够高，
以允许大多数应用程序在不请求更高限制的情况下工作。
API的所有使用都根据请求的限制进行验证，
所以实际的硬件功能不会偶然暴露给用户。

### 特定于机器的工件 ### {#security-machine-artifacts}

存在一些特定于机器的光栅化/精度伪像和性能差异
与 WebGL 大致相同。 这适用于光栅化覆盖
和模式，着色器阶段之间变化的插值精度，计算单元调度，
以及执行的更多方面。

通常，光栅化和精确指纹在大多数或所有
每个供应商的设备。 性能差异比较棘手，
但信号也相对较低（与 JS 执行性能一样）。

隐私关键应用程序和用户代理应利用软件实现来消除此类工件。

### 机器特定性能 ### {#security-machine-performance}

区分用户的另一个因素是衡量 GPU 上特定操作的性能。
即使计时精度较低，重复执行操作也可以显示用户的机器在特定工作负载下的速度是否很快。
这是一个相当常见的向量（存在于 WebGL 和 Javascript 中），
但它也是低信号且相对难以真正标准化的。

WebGPU 计算管道公开了对 GPU 的访问，不受固定功能硬件的阻碍。
这给唯一设备指纹带来了额外的风险。 用户代理可以采取措施
将逻辑 GPU 调用与实际计算单元分离以降低这种风险。

### 用户代理状态 ### {#security-user-agent-state}

本规范没有定义任何额外的用户代理状态。
但是，由于昂贵的结果，预计用户代理将具有编译缓存
编译如 {{GPUShaderModule}}、{{GPURenderPipeline}} 和 {{GPUComputePipeline}}。
这些缓存对于提高 WebGPU 应用程序在第一次访问加载后的加载时间很重要。

对于规范来说，这些缓存与难以置信的快速编译没有区别，但是
对于应用程序，很容易衡量 {{GPUDevice/createComputePipelineAsync()}} 需要多长时间来解决。
这可能会跨源泄漏信息（例如“用户是否使用此特定着色器访问了站点”），
因此用户代理应遵循 [存储分区](https://github.com/privacycg/storage-partitioning) 中的最佳实践。

系统的 GPU 驱动程序也可能有自己的编译着色器和管道缓存。 用户代理
可能希望尽可能禁用这些，或者以如下方式将每个分区的数据添加到着色器
将使 GPU 驱动程序认为它们不同。


# 基本概念 # {#fundamentals}

## 公约 ## {#api-conventions}

### 点符号语法 ### {#dot-syntax}

在此规范中， `.` ("点符号")语法，通常在编程语言中被使用。短语“`Foo.Bar`”意思是“`Foo`中的 `Bar`成员”。

`?.`（“可选链操作符”）语法，从JavaScript中被采用，也会用到。短语“Foo?.Bar”意思是“如果 `Foo` 为 `null` 或 `undefined` , `undefined`; 否则， `Foo.Bar` ”。

例如， `buffer` 是一个{{GPUBuffer}}对象， `buffer？.[[device]].[[adapter]]` 意思是“如果 `buffer` 为 `null` 或 `undefined` ，则 `undefined` ；否则，`[[adapter]]` 内置在 `[[device]]` 上，内置在buffer上。”

### 内部对象 ### {#webgpu-internal-objects}

<dfn dfn>internal object</dfn>是一个概念性的，未暴露的WebGPU对象。[=Internal objects=]追踪一个API对象的状态并且提供实现基础。如果一个特定[=Internal objects=]的状态可以从多个[=agent=]中并行地改变，那些改变关于所有[=agent=]总是原子的。

Note: 一个 "[=agent=]" 指一个Javascript“线程”（即. 主线程，或Web Worker）。

### WebGPU接口 ### {#webgpu-interfaces}

一个<dfn dfn>WebGPU interface</dfn>是一个包含一个[=internal object=]的暴露出来的接口。[=internal object=]的状态通过它提供的接口进行改变。

作为公约中重要一点，如果一个[=WebGPU interface=]的指向[=invalid=]，这意味着它包含的[=internal object=]是无效的。

所有包含{{GPUObjectBase}}的接口是一个[=WebGPU interface=]。

<script type=idl>
interface mixin GPUObjectBase {
    attribute USVString? label;
};
</script>

{{GPUObjectBase}}有以下属性:

<dl dfn-type=attribute dfn-for=GPUObjectBase>
    : <dfn>label</dfn>
    ::
        label用于开发过程中标记/描述底层[=internal object=]（比如可以用来传递error/warning消息。）label没有特定的格式，可以为空，所以不能被机器解析，开发者可以自由选择是否使用该字段。
</dl>

{{GPUObjectBase}}有以下内部槽位:

<dl dfn-type=attribute dfn-for=GPUObjectBase>
    : <dfn>\[[device]]</dfn>, of type [=device=], readonly
    ::
        一个持有拥有[=internal object=]的[=device=]的内部槽位。
</dl>

### 对象描述符 ### {#object-descriptors}

一个<dfn dfn>object descriptor</dfn>持有创建对象需要的信息，通常是通过{{GPUDevice}}的 `create*` 方法之一创建的。

<script type=idl>
dictionary GPUObjectDescriptorBase {
    USVString label;
};
</script>

{{GPUObjectDescriptorBase}}有以下成员:

<dl dfn-type=dict-member dfn-for=GPUObjectDescriptorBase>
    : <dfn>label</dfn>
    ::
        {{GPUObjectBase/label|GPUObjectBase.label}}的初始值。
</dl>

## 无效内部对象 &amp; 传染无效性 ## {#invalidity}

如果一个对象被成功创建，它在当时是<dfn dfn>valid</dfn>。一个[=internal object=]可以是<dfn dfn>invalid</dfn>。它可以在生命周期内变成[=invalid=]，但是永远不能再重新变回有效的。

问题：考虑将“无效”与“已销毁”分开。这将使有效性保持不变，并且只有涉及设备、缓冲区和纹理的操作（例如提交、映射）才会（明确地）检查这些对象的 `[[已销毁]]` 状态。

<div class=note>
[=invalid=] 对象由多种情况导致，包括：
    - 如果在创建对象时出现错误，则立即无效。例如，如果对象描述符没有描述有效的对象，或者没有足够的内存来分配资源，就会发生这种情况。
    - 如果一个对象被显式销毁（例如 GPUBuffer.destroy()），它就会变得无效。
    - 如果拥有对象的设备丢失，则该对象无效。
</div>

<div>
    要确定给定的{{GPUObjectBase}}对象与|targetObject|一起使用是否有效<dfn abstract-op>valid to use with</dfn>，请运行以下步骤：
        1. 如果不满足以下任一条件，则返回 `false` :
            <div class=validusage>
                - |object|是[=valid=]
                - |object|.{{GPUObjectBase/[[device]]}}是[=valid=].
                - |object|.{{GPUObjectBase/[[device]]}}是|targetObject|.{{GPUObjectBase/[[device]]}}.
            </div>
        2. 返回 `true`.
</div>

## 坐标系 ## {#coordinate-systems}

  - Y轴在标准化设备坐标 (NDC) 中向上：NDC 中的点(-1.0, -1.0)位于NDC的左下角。 此外，NDC中的x和y应介于-1.0和1.0之间（含），而 NDC中的z应介于0.0和1.0之间（含）。NDC中超出此范围的顶点不会引入任何错误，但会被剪裁。
  - Y轴在帧缓冲区坐标、视口坐标和片元/像素坐标中向下：origin(0, 0) 位于这些坐标系中的左上角。
  - 窗口/当前坐标匹配帧缓冲区坐标。
  - 纹理坐标中的origin(0, 0)的UV表示纹理内存中的第一个纹素（最低字节）。

注意：WebGPU的坐标系与图形管道中的DirectX坐标系相匹配。

## 编程模型 ## {#programming-model}

### 时间线 ### {#programming-model-timelines}

*本节是非规范的。*

前端有用户代理、后端有GPU的计算机系统具有并行工作在不同时间线上的组件：

: <dfn dfn>Content timeline</dfn>
:: 与Web 脚本的执行相关联。 它包括调用本规范描述的所有方法。

    <div class=content-timeline>
        在内容时间线上执行的步骤如下所示。
    </div>

: <dfn dfn>Device timeline</dfn>
:: 与用户代理发出的GPU设备操作相关联。它包括创建显卡适配器、设备和 GPU 资源和状态对象，从控制 GPU 的用户代理部分的角度来看，这些操作通常是同步操作，但可以存在于单独的操作系统进程中。

    <div class=device-timeline>
        在设备时间线上执行的步骤如下所示。
    </div>

: <dfn dfn>Queue timeline</dfn>
:: 与在 GPU 的计算单元上执行操作相关。它包括在 GPU 上运行的实际绘制、复制和计算作业。

    <div class=queue-timeline>
        在队列时间线上执行的步骤如下所示。
    </div>

在本规范中，当结果值取决于发生在除[=Content timeline=]以外的任何时间线上的工作时，将使用异步操作。它们由 JavaScript 中的回调和承诺表示。

<div class="example">
{{GPUComputePassEncoder/dispatch(x, y, z)|GPUComputePassEncoder.dispatch()}}:

  1. 用户通过调用发生在内容时间线上的{{GPUComputePassEncoder}}的方法对 `dispatch` 命令进行编码。
  2. 用户发出{{GPUQueue/submit(commandBuffers)|GPUQueue.submit()}}将GPUCommandBuffer移交给用户代理，用户代理通过调用操作系统驱动程序执行低级提交在[=Device timeline=]上处理它。
  3. 提交由GPU调用调度程序分派到实际计算单元上执行，这发生在[=Queue timeline=]上。

</div>
<div class="example">
{{GPUDevice/createBuffer(descriptor)|GPUDevice.createBuffer()}}:

  1. 用户填写一个{{GPUBufferDescriptor}}并用它创建一个{{GPUBuffer}}，这发生在[=Content timeline=]上。
  2. 用户代理在[=Device timeline=]上创建一个低级缓冲区。

</div>
<div class="example">
{{GPUBuffer/mapAsync()|GPUBuffer.mapAsync()}}:

  1. 用户请求在[=Content timeline=]上映射{{GPUBuffer}}并得到一个返回的promise。
  2. 用户代理检查缓冲区当前是否被GPU使用，并在使用结束时提醒自己检查。
  3. 在使用缓冲区完成对队列时间线的GPU操作后，用户代理将其映射到内存并resolves the promise。

</div>

### 内存模型 ### {#programming-model-memory}

*本节不规范。*

一旦在应用程序初始化例程中获得了{{GPUDevice}}，我们可以将WebGPU平台描述为由以下层组成：
Once a {{GPUDevice}} has been obtained during an application initialization routine,
we can describe the <dfn dfn>WebGPU platform</dfn> as consisting of the following layers:
  1. 实现规范的用户代理。
  2. 具有用于此设备的低级本机API驱动程序的操作系统。
  3. 实际的CPU和GPU硬件。

[=WebGPU platform=]的每一层可能有不同的内存类型，用户代理在实现规范时需要考虑：
  - GPU驱动程序通常无法访问脚本拥有的内存，例如脚本创建的{{ArrayBuffer}}。
  - 用户代理可能有不同的进程负责运行内容和与GPU驱动程序的通信。在这种情况下，它使用进程间共享内存来传输数据。
  - 专用 GPU 拥有自己的高带宽内存，而集成 GPU 通常与系统共享内存。

大多数[=physical resources=]分配在对GPU计算或渲染有效的类型的内存中。当用户需要向GPU提供新数据时，数据可能首先需要跨越进程边界才能到达与GPU驱动程序通信的用户代理部分。然后它可能需要对驱动程序可见，这有时需要复制到驱动程序分配的暂存内存中。最后，它可能需要转移到专用GPU内存，从而可能将内部布局更改为对GPU进行操作最有效的布局。

所有这些转换都是由用户代理的WebGPU实现完成的。

注意：这个例子描述了最坏的情况，而在实践中实现可能不需要跨越进程边界，或者可能能够将驱动程序管理的内存通过 `ArrayBuffer` 直接暴露给用户，从而避免任何数据复制。

### 多线程 ### {#programming-model-multi-threading}

### 资源使用 ### {#programming-model-resource-usages}

[=physical resources=]可以在 GPU 上使用，<dfn dfn>internal usage</dfn>:
<dl dfn-type=dfn dfn-for="internal usage">
    : <dfn>input</dfn>
    ::  填入为绘制或调度调用数据的缓冲。保留内容。被缓冲区{{GPUBufferUsage/INDEX}}、缓冲区{{GPUBufferUsage/VERTEX}}或缓冲区{{GPUBufferUsage/INDIRECT}}允许。
    : <dfn>constant</dfn>
    ::  从着色器的角度来看是常量的资源绑定。保留内容。缓冲区{{GPUBufferUsage/UNIFORM}}或纹理{{GPUTextureUsage/TEXTURE_BINDING}}允许。
    : <dfn>storage</dfn>
    ::  可写入存储资源绑定。被缓冲区{{GPUBufferUsage/STORAGE}}或纹理{{GPUTextureUsage/STORAGE_BINDING}}允许。
    : <dfn>storage-read</dfn>
    ::  只读存储资源绑定。保留内容。被缓冲区{{GPUBufferUsage/STORAGE}}允许。
    : <dfn>attachment</dfn>
    :: 在渲染过程中用作输出附件的纹理。被纹理{{GPUTextureUsage/RENDER_ATTACHMENT}}允许。
    : <dfn>attachment-read</dfn>
    :: 在渲染过程中用作只读附件的纹理。被纹理{{GPUTextureUsage/RENDER_ATTACHMENT}}允许。
</dl>

纹理可能由单独的[=mipmap levels=]和[=array layers=]组成，它们可以在任何给定时间以不同的方式被使用。每个这样的<dfn dfn>texture subresource</dfn>都由纹理、[=mipmap levels=]和（仅适用于2d纹理）阵列层和[=aspect=]唯一标识。

我们定义<dfn dfn>subresource</dfn>可以是整个缓冲区，也可以是[=texture subresource=]。

<div>
一些[=internal usages=]与其他用法兼容。[=subresource=]可以处于将多种用途组合在一起的状态。 当（且仅当）满足以下任何规则时，我们认为列表|U|是<dfn dfn>compatible usage list</dfn>：
    - |U|中的每个用法都是[=internal usage/input=]，[=internal usage/constant=]，[=internal usage/storage-read=]，或[=internal usage/attachment-read=]。
    - |U|中的每个用法都是[=internal usage/storage=]。
    - |U|只包含一个元素：[=internal usage/attachment=]。
</div>

强制使用仅组合到兼容的使用列表中，允许API限制在使用内存时可能发生数据争用的时间。该属性使对WebGPU编写的应用程序更有可能在不同平台上运行而无需修改。

通常，当实现以不同于当前使用允许的方式处理使用子资源的操作时，它会安排资源到新状态的转换。 在某些情况下，例如在开放的{{GPURenderPassEncoder}}中，由于硬件限制，这种转换是不可能的。我们将这些地方定义为<dfn dfn>usage scopes</dfn>。

主要的**使用规则**是，对于任何一个[=subresource=]，它在一个[=usage scope=]内的[=internal usages=]列表必须是一个[=compatible usage list=]。

例如，在同一{{GPURenderPassEncoder}}中绑定相同的缓冲区用于[=internal usage/storage=]和[=internal usage/input=]将使编码器以及拥有的{{GPUCommandEncoder}}进入错误状态。这种用法组合不会形成[=compatible usage list=]。

注意：允许在单个[=usage scope=]内出现多个可写存储缓冲区/纹理使用的竞争条件。

提供给{{GPURenderPassColorAttachment/view|GPURenderPassColorAttachment.view}}和{{GPURenderPassColorAttachment/resolveTarget|GPURenderPassColorAttachment.resolveTarget}}的视图中包含的纹理[=subresource=]被视为用作此渲染通道[=usage scope=]的[=internal usage/attachment=]。

[=texture subresource=]的<dfn dfn>physical size</dfn>是[=texture subresource=]在纹素中的维度，包括可能的额外填充以在[=subresource=]中形成完整的[=texel blocks=]。

  - 对于基于像素的{{GPUTextureFormat|GPUTextureFormats}}，物理大小始终等于采样硬件中使用的[=texture subresource=]的大小。
  - 基于块的压缩{{GPUTextureFormat|GPUTextureFormats}}中的纹理始终具有[=mipmap level=] 0，其descriptor.size是纹素块大小的倍数，但较低的[=mipmap level=]可能不是纹素块大小的倍数，并且可以有填充。

<div class="example">
考虑一个BC格式的{{GPUTexture}}，其{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/size}}为{60, 60, 1}，在[=mipmap level=] 2对GPUTexture进行采样时，采样硬件使用{15, 15, 1}作为[=texture subresource=]的大小 ，而其[=physical size=]为 {16, 16, 1}，因为块压缩算法只能在 4x4 纹素块上运行。
</div>

### 同步 ### {#programming-model-synchronization}

对于[=physical resources=]的每个[=subresource=]，在队列时间线上跟踪其[=internal usage=]标识集。

问题：本章节将会被修订以支持多个队列。

在[=Queue timeline=]上，有一个有序的[=usage scope=]序列。 在每个范围的持续时间内，任何给定[=subresource=]的内部使用标志集是恒定的。 [=subresource=]可以在[=usage scope=]之间的边界转换为新的使用。

本规范定义了以下[=usage scope=]：

- 在一个pass之外（在{{GPUCommandEncoder}}中），每个（非状态设置）命令都是一个使用范围（例如{{GPUCommandEncoder/copyBufferToTexture()}}）。
- 在计算过程中，每个调度命令（{{GPUComputePassEncoder/dispatch()}} 或 {{GPUComputePassEncoder/dispatchIndirect()}}）都是一个使用范围。 如果命令可能访问子资源，则在使用范围内“使用”子资源。 在调度中，对于当前{{GPUComputePipeline}}的{{GPUPipelineBase/[[layout]]}}使用的每个绑定组槽，该绑定组引用的每个子资源都在使用范围内“使用”。 状态设置计算传递命令，如{{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)}}，不直接影响使用范围； 他们改为更改在调度命令中检查的状态。
- 一个渲染通道是一个使用范围。如果子资源被任何（状态设置或非状态设置）命令引用，则在使用范围内“使用”子资源。 例如，在{{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)}}中， `bindGroup` 中的每个子资源都在渲染通道的使用范围内“使用”。

问题：上面说的应该是[=GPU commands=]。 但是我们还没有办法引用特定的GPU命令（比如 dispatch）。

<div class=note>
    上述规则意味着以下示例资源使用包含在[=usage scope validation=]中：

    - 在渲染过程中，任何{{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)|setBindGroup()}}调用中使用的子资源，无论当前绑定的管道的着色器或布局实际上依赖于这些绑定，还是绑定组被另一个“set”调用遮蔽。
    - 在任何{{GPURenderEncoderBase/setVertexBuffer()|setVertexBuffer()}}调用中使用的缓冲区，无论是否有任何绘制调用依赖于该缓冲区，或者该缓冲区是否被另一个“set”调用遮蔽。
    - 在任何{{GPURenderEncoderBase/setIndexBuffer()|setIndexBuffer()}}调用中使用的缓冲区，无论是否有任何绘制调用依赖于该缓冲区，或者该缓冲区是否被另一个“set”调用遮蔽。
    - 在{GPURenderPassDescriptor}}中被{{GPUCommandEncoder/beginRenderPass()|beginRenderPass()}}用作颜色附件、解析附件或深度/模板附件的纹理子资源，无论着色器是否实际上依赖于这些附件。
    - 用于可见性为0的绑定组条目的资源，或仅对计算阶段可见但在渲染通道中使用的资源（反之亦然）。
</div>

在命令编码期间，子资源的每次使用都记录在命令缓冲区[=usage scope=]之一中。对于每个[=usage scope=]，实现通过组成使用范围中使用的每个[=subresource=]的所有[=internal usage=]标志的列表来执行<dfn dfn>usage scope validation</dfn>。 如果这些列表中的任何一个不是[=compatible usage list=]，则{{GPUCommandEncoder/finish()|GPUCommandEncoder.finish()}}在当前错误范围内生成{{GPUValidationError}}。

## 核心内部对象 ## {#core-internal-objects}

### 显卡适配器 ### {#adapters}

一个<dfn dfn>adapter</dfn>代表系统上WebGPU的实现。每个显卡适配器都标识浏览器底层平台上的计算/渲染功能实例，以及浏览器在该功能之上的WebGPU实现实例。

如果[=adapter=]变得不可用，则它变得[=invalid=]。 一旦无效，它将永远不再有效。[=adapter=]上的任何[=device=]以及这些设备拥有的[=internal object=]也将变为无效。

注意：[=adapter=]可能是物理显示适配器 (GPU)，但也可能是软件渲染器。 返回的[=adapter=]可以指不同的物理显卡适配器，或指同一物理显卡适配器上的不同浏览器代码路径或系统驱动程序。应用程序可以同时保持多个[=adapter=]（通过{{GPUAdapter}}）（即使有些显卡适配器无效），其中两个可以引用相同物理配置的不同实例（例如，如果GPU被重置或断开连接并重新连接）。

如果[=adapter=]具有显著的性能警告以换取更广泛的兼容性、更可预测的行为或改进的隐私的某种组合，则可以将其视为<dfn>fallback adapter</dfn>。 不需要在每个系统上都有可用的[=fallback adapter=]。

[=adapter=]具有以下内部插槽：
<dl dfn-type=attribute dfn-for=adapter>
    : <dfn>\[[features]]</dfn>, of type [=ordered set=]&lt;{{GPUFeatureName}}&gt;, readonly
    ::
        [=features=] 可以用作创建显卡适配器上的设备。

    : <dfn>\[[limits]]</dfn>, of type [=supported limits=], readonly
    ::
        最好[=limit/better|best=]限制用作创建显卡适配器上的设备。
        每个适配器限制必须与[=supported limits=].中的默认值相同或更好[=limit/better=]。

    : <dfn>\[[current]]</dfn>, of type boolean
    ::
        指此时是否允许显卡适配器出售新设备。它的值可能随时改变。

        它最初在{{GPU/requestAdapter()}}中设置为 `true` 。它在“[=lose the device=]”和“[=mark adapters stale=]”中变为 `false` 。 一旦设置为 `false`，它就不能再次变为 `true` 。

        注意：此机制可确保各种适配器创建场景看起来与应用程序相似，因此它们可以轻松地以较少的测试对更多场景保持健壮：首次初始化，由于未插入适配器而重新初始化，由于测试GPUDevice.destroy()调用而重新初始化 等。它还确保应用程序使用最新的系统状态来决定使用哪个适配器。

    : <dfn>\[[fallback]]</dfn>, of type boolean
    ::
        如果设为 `true`, 则显卡适配器为[=fallback adapter=]。
</dl>

[=adapter=]通过{{GPUAdapter}}暴露出来。

### 设备 ### {#devices}

<dfn dfn>device</dfn>是[=adapter=]的逻辑实例，通过它创建内部对象。它可以在多个代理（例如专用workers）之间共享。

[=device=]是从它创建的所有内部对象的唯一所有者：当[=device=][=lose the device|丢失=]时，它和在其上创建的所有对象（直接，例如 {{GPUDevice/createTexture()}}，或间接，例如{{GPUTexture/createView()}}变得[=invalid=]。

问题：定义“所有权”。

[=device=]有以下内部插槽:

<dl dfn-type=attribute dfn-for=device>
    : <dfn>\[[adapter]]</dfn>, of type [=adapter=], readonly
    ::
        创建此设备的[=adapter=]。

    : <dfn>\[[features]]</dfn>, of type [=ordered set=]&lt;{{GPUFeatureName}}&gt;, readonly
    ::
        可在此设备上使用的功能。不能使用附加功能，即使底层显卡适配器可以支持它们。

    : <dfn>\[[limits]]</dfn>, of type [=supported limits=], readonly
    ::
        可在此设备上使用的限制。 没有更好的限制可以使用，即使底层显卡适配器可以支持它们。
</dl>

<div>
    当使用{{GPUDeviceDescriptor}}描述符从[=adapter=]创建<dfn dfn>a new device</dfn>时：

    - 设置|device|.{{device/[[adapter]]}}为|adapter|.

    - 设置|device|.{{device/[[features]]}}为|descriptor|.{{GPUDeviceDescriptor/requiredFeatures}}中的值[=ordered set|集=]。

    - 让|device|.{{device/[[limits]]}}成为具有默认值的[=supported limits=]对象。对于|descriptor|.{{GPUDeviceDescriptor/requiredLimits}} 中的每个(|key|, |value|) 对，将|device|.{{device/[[limits]]}}中key对应的成员设置为value的[=limit/better=]|值|或支持的limits中的默认值。
</div>

任何时候用户代理需要撤销对设备的访问，它都会调用[=lose the device=]（设备，`undefined`）。

<div>
    <dfn dfn>lose the device</dfn>(|设备|, |原因|):

    1. 设置|device|.{{device/[[adapter]]}}.{{adapter/[[current]]}}为 `false`。
    1. 问题：解释如何从设备得到它再到它“主要的”GPUDevice。
    1. 解决{{GPUDevice/lost|GPUDevice.lost}}返回一个新的{{GPUDeviceLostInfo}}，
        {{GPUDeviceLostInfo/reason}}设置为|reason|
        {{GPUDeviceLostInfo/message}}设置成一个实现定义值。

        注意：{{GPUDeviceLostInfo/message}}不应泄露不必要的用户/系统信息，也不应被应用程序解析。
</div>

[=device=]通过{{GPUDevice}}暴露。

##可选功能## {#optional-capabilities}

WebGPU[=adapter=]和[=device=]具有描述不同实现之间不同的WebGPU功能的<dfn dfn>capabilities</dfn>，通常是由于硬件或系统软件限制。[=capability=]要么是一个特性，要么是一个限制。

### 特性 ### {#features}

<dfn dfn>feature</dfn>是一组可选的WebGPU功能，并非所有实现都支持，通常是由于硬件或系统软件限制。

每个{{GPUAdapter}}暴露一组可用功能。{{GPUAdapter/requestDevice()}}中只能请求这些功能。

仅当在设备创建时请求该功能时，才能使用作为功能一部分的功能。有关每个功能启用的功能的描述，请参阅[[#feature-index|特性索引]]。

### 限制 ### {#limits}

每个<dfn dfn>limit</dfn>都是在设备上使用WebGPU的数字限制。

<dfn dfn>supported limits</dfn>对象对每个定义的限制都有一个值。 每个[=adapter=]都有一组受[=supported limits=]，并且{{GPUDeviceDescriptor/requiredLimits|创建}}的[=device=]具有特定的受支持限制。 无论适配器的限制如何，都会强制执行设备限制。

一个极限值可能比另一个更好<dfn dfn for=limit>better</dfn>。[=limit/better=]的限制值总是会放宽验证，从而使更多的程序有效。 对于每个限制，定义了“更好”。

注意：设置“更好”的限制不一定是可取的，因为它们可能会影响性能。因此，为了提高跨设备和实现的可移植性，应用程序通常应该请求适用于其内容的“最差”限制（理想情况下，默认值）。

每个限制也有一个<dfn dfn for=limit>default</dfn> 。每个[=adapter=]都保证支持默认值或更好的值[=limit/better=]。如果在{{GPUDeviceDescriptor/requiredLimits}}中未明确指定值，则使用默认值。

<table class="data no-colspan-center" dfn-type=attribute dfn-for="supported limits">
    <thead>
        <tr><th>Limit name <th>Type <th>[=limit/Better=] <th>[=limit/Default=]
    </thead>

    <tr><td><dfn>maxTextureDimension1D</dfn>
        <td>{{GPUSize32}} <td>Higher <td>8192
    <tr class=row-continuation><td colspan=4>
        通过{{GPUTextureDescriptor/dimension}} {{GPUTextureDimension/"1d"}}创建的[=texture=]，所允许的{{GPUTextureDescriptor/size}}.[=Extent3D/width=]最大值。

    <tr><td><dfn>maxTextureDimension2D</dfn>
        <td>{{GPUSize32}} <td>Higher <td>8192
    <tr class=row-continuation><td colspan=4>
        通过{{GPUTextureDescriptor/dimension}} {{GPUTextureDimension/"2d"}}创建的[=texture=]所允许的{{GPUTextureDescriptor/size}}.[=Extent3D/width=]和{{GPUTextureDescriptor/size}}.[=Extent3D/height=]最大值。

    <tr><td><dfn>maxTextureDimension3D</dfn>
        <td>{{GPUSize32}} <td>Higher <td>2048
    <tr class=row-continuation><td colspan=4>
        通过{{GPUTextureDescriptor/dimension}} {{GPUTextureDimension/"3d"}}创建的[=texture=]所允许的{{GPUTextureDescriptor/size}}.[=Extent3D/width=], {{GPUTextureDescriptor/size}}.[=Extent3D/height=]和{{GPUTextureDescriptor/size}}.[=Extent3D/depthOrArrayLayers=]最大值。

    <tr><td><dfn>maxTextureArrayLayers</dfn>
        <td>{{GPUSize32}} <td>Higher <td>256
    <tr class=row-continuation><td colspan=4>
        通过{{GPUTextureDescriptor/dimension}} {{GPUTextureDimension/"1d"}}或{{GPUTextureDimension/"2d"}}创建的[=texture=]所允许的{{GPUTextureDescriptor/size}}.[=Extent3D/depthOrArrayLayers=]最大值。

    <tr><td><dfn>maxBindGroups</dfn>
        <td>{{GPUSize32}} <td>Higher <td>4
    <tr class=row-continuation><td colspan=4>
        创建{{GPUPipelineLayout}}时{{GPUPipelineLayoutDescriptor/bindGroupLayouts}}中所允许的{{GPUBindGroupLayout|GPUBindGroupLayouts}}最大值。

    <tr><td><dfn>maxDynamicUniformBuffersPerPipelineLayout</dfn>
        <td>{{GPUSize32}} <td>Higher <td>8
    <tr class=row-continuation><td colspan=4>
        {{GPUPipelineLayout}}中{{GPUBindGroupLayoutEntry}}条目的最大数量，这些条目是具有动态偏移的统一缓冲区。 详见[=Exceeds the binding slot limits=]。

    <tr><td><dfn>maxDynamicStorageBuffersPerPipelineLayout</dfn>
        <td>{{GPUSize32}} <td>Higher <td>4
    <tr class=row-continuation><td colspan=4>
        {{GPUPipelineLayout}}中{{GPUBindGroupLayoutEntry}}条目的最大数量，这些条目是具有动态偏移的存储缓冲区。 详见[=Exceeds the binding slot limits=]。

    <tr><td><dfn>maxSampledTexturesPerShaderStage</dfn>
        <td>{{GPUSize32}} <td>Higher <td>16
    <tr class=row-continuation><td colspan=4>
        对每个可能的{{GPUShaderStage}}`阶段`，{{GPUPipelineLayout}}中作为采样纹理的{{GPUBindGroupLayoutEntry}}条目的最大数量。详见[=Exceeds the binding slot limits=]。

    <tr><td><dfn>maxSamplersPerShaderStage</dfn>
        <td>{{GPUSize32}} <td>Higher <td>16
    <tr class=row-continuation><td colspan=4>
        对每个可能的{{GPUShaderStage}}`阶段`，{{GPUPipelineLayout}}中作为采样器的{{GPUBindGroupLayoutEntry}}条目的最大数量。详见[=Exceeds the binding slot limits=]。

    <tr><td><dfn>maxStorageBuffersPerShaderStage</dfn>
        <td>{{GPUSize32}} <td>Higher <td>8
    <tr class=row-continuation><td colspan=4>
        对每个可能的{{GPUShaderStage}}`阶段`，{{GPUPipelineLayout}}中作为存储缓冲区的{{GPUBindGroupLayoutEntry}}条目的最大数量。详见[=Exceeds the binding slot limits=]。

    <tr><td><dfn>maxStorageTexturesPerShaderStage</dfn>
        <td>{{GPUSize32}} <td>Higher <td>4
    <tr class=row-continuation><td colspan=4>
        对每个可能的{{GPUShaderStage}}`阶段`，{{GPUPipelineLayout}}中作为存储纹理的{{GPUBindGroupLayoutEntry}}条目的最大数量。详见[=Exceeds the binding slot limits=]。

    <tr><td><dfn>maxUniformBuffersPerShaderStage</dfn>
        <td>{{GPUSize32}} <td>Higher <td>12
    <tr class=row-continuation><td colspan=4>
        对每个可能的{{GPUShaderStage}}`阶段`，{{GPUPipelineLayout}}中作为统一缓冲区的{{GPUBindGroupLayoutEntry}}条目的最大数量。详见[=Exceeds the binding slot limits=]。

    <tr><td><dfn>maxUniformBufferBindingSize</dfn>
        <td>{{GPUSize64}} <td>Higher <td>16384
    <tr class=row-continuation><td colspan=4>
        与|entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/type}}为{{GPUBufferBindingType/"uniform"}}的 {{GPUBindGroupLayoutEntry}}|条目|的绑定的最大{{GPUBufferBinding}}.{{GPUBufferBinding/size}}。

    <tr><td><dfn>maxStorageBufferBindingSize</dfn>
        <td>{{GPUSize64}} <td>Higher <td> 134217728 (128 MiB)
    <tr class=row-continuation><td colspan=4>
        与|entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/type}}为{{GPUBufferBindingType/"storage"}}或{{GPUBufferBindingType/"read-only-storage"}}的 {{GPUBindGroupLayoutEntry}}|条目|的绑定的最大{{GPUBufferBinding}}.{{GPUBufferBinding/size}}。

    <tr><td><dfn>minUniformBufferOffsetAlignment</dfn>
        <td>{{GPUSize32}} <td>Lower <td>256
    <tr class=row-continuation><td colspan=4>
        {{GPUBufferBinding}}.{{GPUBufferBinding/offset}}和{{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)|setBindGroup}} |dynamicOffsets| 参数所需的对齐方式，用于与|entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/type}}为{{GPUBufferBindingType/"uniform"}}的{{GPUBindGroupLayoutEntry}} |entry|绑定。

    <tr><td><dfn>minStorageBufferOffsetAlignment</dfn>
        <td>{{GPUSize32}} <td>Lower <td>256
    <tr class=row-continuation><td colspan=4>
        {{GPUBufferBinding}}.{{GPUBufferBinding/offset}}和{{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)|setBindGroup}} |dynamicOffsets| 参数所需的对齐方式，用于与|entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/type}}为{{GPUBufferBindingType/"storage"}}或{{GPUBufferBindingType/"read-only-storage"}}的{{GPUBindGroupLayoutEntry}} |entry|绑定。

    <tr><td><dfn>maxVertexBuffers</dfn>
        <td>{{GPUSize32}} <td>Higher <td>8
    <tr class=row-continuation><td colspan=4>
        创建{{GPURenderPipeline}}时{{GPUVertexState/buffers}}的最大值。

    <tr><td><dfn>maxVertexAttributes</dfn>
        <td>{{GPUSize32}} <td>Higher <td>16
    <tr class=row-continuation><td colspan=4>
        创建{{GPURenderPipeline}}时{{GPUVertexState/buffers}}中{{GPUVertexBufferLayout/attributes}}的最大值。

    <tr><td><dfn>maxVertexBufferArrayStride</dfn>
        <td>{{GPUSize32}} <td>Higher <td>2048
    <tr class=row-continuation><td colspan=4>
        创建{{GPURenderPipeline}}时{{GPUVertexBufferLayout/arrayStride}}所允许的的最大值。

    <tr><td><dfn>maxInterStageShaderComponents</dfn>
        <td>{{GPUSize32}} <td>Higher <td>60
    <tr class=row-continuation><td colspan=4>
        用于内部阶段间通信的输入或输出变量的最大允许组件数（如顶点输出或片段输入）。

    <tr><td><dfn>maxComputeWorkgroupStorageSize</dfn>
        <td>{{GPUSize32}} <td>Higher <td>16352
    <tr class=row-continuation><td colspan=4>
        用于计算阶段{{GPUShaderModule}}入口点的最大字节数。

    <tr><td><dfn>maxComputeInvocationsPerWorkgroup</dfn>
        <td>{{GPUSize32}} <td>Higher <td>256
    <tr class=row-continuation><td colspan=4>
        计算阶段{{GPUShaderModule}}入口点的 `workgroup_size` 维度乘积的最大值。

    <tr><td><dfn>maxComputeWorkgroupSizeX</dfn>
        <td>{{GPUSize32}} <td>Higher <td>256
    <tr class=row-continuation><td colspan=4>
        计算阶段{{GPUShaderModule}}入口点的 `workgroup_size` X维度的最大值。

    <tr><td><dfn>maxComputeWorkgroupSizeY</dfn>
        <td>{{GPUSize32}} <td>Higher <td>256
    <tr class=row-continuation><td colspan=4>
        计算阶段{{GPUShaderModule}}入口点的 `workgroup_size` Y维度的最大值。

    <tr><td><dfn>maxComputeWorkgroupSizeZ</dfn>
        <td>{{GPUSize32}} <td>Higher <td>64
    <tr class=row-continuation><td colspan=4>
        计算阶段{{GPUShaderModule}}入口点的 `workgroup_size` Z维度的最大值。

    <tr><td><dfn>maxComputeWorkgroupsPerDimension</dfn>
        <td>{{GPUSize32}} <td>Higher <td>65535
    <tr class=row-continuation><td colspan=4>
        {{GPUComputePassEncoder/dispatch(x, y, z)}}参数的最大值。

</table>

问题：我们需要有一个最大的每像素渲染目标尺寸吗？

#### <dfn interface>GPUSupportedLimits</dfn> #### {#gpu-supportedlimits}

{{GPUSupportedLimits}}暴露一个显卡适配器或设备支持的[=limits=]。
详见{{GPUAdapter/limits|GPUAdapter.limits}}和{{GPUDevice/limits|GPUDevice.limits}}.

<script type=idl>
[Exposed=(Window, DedicatedWorker)]
interface GPUSupportedLimits {
    readonly attribute unsigned long maxTextureDimension1D;
    readonly attribute unsigned long maxTextureDimension2D;
    readonly attribute unsigned long maxTextureDimension3D;
    readonly attribute unsigned long maxTextureArrayLayers;
    readonly attribute unsigned long maxBindGroups;
    readonly attribute unsigned long maxDynamicUniformBuffersPerPipelineLayout;
    readonly attribute unsigned long maxDynamicStorageBuffersPerPipelineLayout;
    readonly attribute unsigned long maxSampledTexturesPerShaderStage;
    readonly attribute unsigned long maxSamplersPerShaderStage;
    readonly attribute unsigned long maxStorageBuffersPerShaderStage;
    readonly attribute unsigned long maxStorageTexturesPerShaderStage;
    readonly attribute unsigned long maxUniformBuffersPerShaderStage;
    readonly attribute unsigned long long maxUniformBufferBindingSize;
    readonly attribute unsigned long long maxStorageBufferBindingSize;
    readonly attribute unsigned long minUniformBufferOffsetAlignment;
    readonly attribute unsigned long minStorageBufferOffsetAlignment;
    readonly attribute unsigned long maxVertexBuffers;
    readonly attribute unsigned long maxVertexAttributes;
    readonly attribute unsigned long maxVertexBufferArrayStride;
    readonly attribute unsigned long maxInterStageShaderComponents;
    readonly attribute unsigned long maxComputeWorkgroupStorageSize;
    readonly attribute unsigned long maxComputeInvocationsPerWorkgroup;
    readonly attribute unsigned long maxComputeWorkgroupSizeX;
    readonly attribute unsigned long maxComputeWorkgroupSizeY;
    readonly attribute unsigned long maxComputeWorkgroupSizeZ;
    readonly attribute unsigned long maxComputeWorkgroupsPerDimension;
};
</script>

#### <dfn interface>GPUSupportedFeatures</dfn> #### {#gpu-supportedfeatures}

{{GPUSupportedFeatures}}是一个[=setlike=]接口。它的[=set entries=]是一个显卡适配器或设备支持的[=features=]的{{GPUFeatureName}}值。它必须只包含{{GPUFeatureName}}枚举中的字符串。

<script type=idl>
[Exposed=(Window, DedicatedWorker)]
interface GPUSupportedFeatures {
    readonly setlike<DOMString>;
};
</script>

<div class="note">
注意：{{GPUSupportedFeatures}} [=set entries=]的类型是{{DOMString}}以允许用户代理优雅地处理有效的 {{GPUFeatureName}}s，这些{{GPUFeatureName}}s在规范的后续版本中添加，但用户代理尚未更新以识别。 如果设置的条目类型是{{GPUFeatureName}}，以下代码将抛出{{TypeError}}而不是报告 `false`：

<div class="example">
    检查对无法识别的功能的支持：
    <pre highlight="js">
        if (adapter.features.has('unknown-feature')) {
            // Use unknown-feature
        } else {
            console.warn('unknown-feature is not supported by this adapter.');
        }
    </pre>
</div>
</div>

## 源限制 ## {#origin-restrictions}

WebGPU允许访问存储在图像、视频和画布中的图像数据。跨域媒体的使用受到限制，因为着色器可用于间接推断已上传到GPU的纹理内容。

如果图像源<l spec=html>[=is not origin-clean=]</l>，则WebGPU不允许上传图像源。

这也意味着使用WebGPU渲染的画布的[=origin-clean=]标识永远不会设置为 `false`。

有关为图像和视频元素发出CORS请求的更多信息，请参阅：

- [[html#cors-settings-attributes]]
- [[html#the-img-element]] <{img}>
- [[html#media-elements]] {{HTMLMediaElement}}

## 颜色空间和编码 ## {#color-spaces}

WebGPU不提供颜色管理。WebGPU中的所有值（例如纹理元素）都是原始数值，而不是颜色管理的颜色值。

WebGPU有颜色管理的输出（通过{{GPUCanvasConfiguration}}）和输入（通过{{GPUQueue/copyExternalImageToTexture()}}和{GPUDevice/importExternalTexture()}}）接口。必须在WebGPU数值和外部颜色值之间进行颜色转换。每个这样的接口点在本地定义一个编码（颜色空间、传递函数和alpha预乘），在其中解释WebGPU数值。

<script type=idl>
enum GPUPredefinedColorSpace {
    "srgb",
};
</script>

问题：可能用PredefinedColorSpace替换它，但请注意，这样做意味着当项目被添加到上游规范中的枚举时，新的WebGPU 功能会自动添加。

问题(gpuweb/gpuweb#1715):考虑将srgb编码图像上传到线性编码纹理的路径。

<dl dfn-type=enum-value dfn-for=GPUPredefinedColorSpace>
    : <dfn>"srgb"</dfn>
    :: CSS预定义颜色空间<a value for=color()>srgb</a>。
</dl>


# 初始化 # {#initialization}

## 举例 ## {#initialization-examples}

问题:
需要一个像 ErrorHandling.md 中的强大示例，它可以处理所有情况。
可能还包括一个没有处理的简单示例。

## navigator.gpu ## {#navigator-gpu}

{{GPU}} 对象分别通过 {{Navigator}} 和 {{WorkerNavigator}} 接口在 {{Window}} 和 {{DedicatedWorkerGlobalScope}} 上下文中可用，
并通过 `navigator.gpu` 公开：

<script type=idl>
interface mixin NavigatorGPU {
    [SameObject, SecureContext] readonly attribute GPU gpu;
};
Navigator includes NavigatorGPU;
WorkerNavigator includes NavigatorGPU;
</script>

## GPU ## {#gpu-interface}

<dfn interface>GPU</dfn> is the entry point to WebGPU.

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPU {
    Promise<GPUAdapter?> requestAdapter(optional GPURequestAdapterOptions options = {});
};
</script>

{{GPU}} has the following methods:

<dl dfn-type=method dfn-for=GPU>
    : <dfn>requestAdapter(options)</dfn>
    ::
         从用户代理请求 [=adapter=]。
         用户代理选择是否返回适配器，如果返回，
         根据提供的选项进行选择。

        <div algorithm=GPU.requestAdapter>
            **Called on:** {{GPU}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPU/requestAdapter(options)">
                |options|: Criteria used to select the adapter.
            </pre>

            **Returns:** {{Promise}}&lt;{{GPUAdapter}}?&gt;

            1. 让 |promise| 成为一个 [=a new promise=].
            1. 在|this|的[=Device timeline=] 上发出以下步骤 :
                <div class=device-timeline>
                    1. 如果用户代理选择返回一个适配器，它应该:
                        1. 创建一个 [=adapter=] |adapter|， 其中 {{adapter/[[current]]}} 设置为
                            `true`, 根据 [[#adapter-selection]] 中的规则和 |options| 中的标准.

                        1. 如果 |adapter| 满足 [=fallback adapter=] 设定
                            |adapter| 的标准.{{adapter/[[fallback]]}} 为 `true`.

                        1. [=Resolve=] |promise| 使用新的 {{GPUAdapter}} 封装 |adapter|.

                    1. 否则, |promise| [=resolves=] with `null`.
                </div>
            1. 返回 |promise|.

            <!-- 如果我们添加方法来发出无效的适配器请求（除了那些
                                   违反 IDL 规则），指定他们拒绝承诺。 -->
        </div>
</dl>

{{GPU}} 有以下内部插槽:

<dl dfn-type=attribute dfn-for=GPU>
    : <dfn>\[[previously_returned_adapters]]</dfn>, of type [=ordered set=]&lt;[=adapter=]&gt;
    ::
         通过 {{GPU/requestAdapter()}} 返回的 [=adapters=] 集。
         它在 [=mark adapters stale=] 中使用，然后清除。
</dl>

当系统状态发生任何可能影响任何 {{GPU/requestAdapter()}} 调用结果的变化时，用户代理*应该* [=mark adapters stale=]。 例如：

- 添加/移除物理适配器（通过插头、驱动程序更新、TDR 等）
- 系统的电源配置已更改（笔记本电脑已拔下电源，电源设置已更改等）

此外，[=mark adapters stale=] 可以随时安排。
即使没有系统状态改变（例如
最后一次调用 {{GPUAdapter/requestDevice()}} 后几秒。
这对格式良好的应用程序没有影响，混淆了真实的系统状态变化，并使
开发人员更清楚在调用 {{GPUAdapter/requestDevice()}} 之前总是需要再次调用 {{GPU/requestAdapter()}}。

<div algorithm>
    To <dfn dfn>mark adapters stale</dfn>:

    1. 在 `navigator.gpu.`{{GPU/[[previously_returned_adapters]]}} 中每一个|adapter|:
        1. 设定 |adapter|.{{GPUAdapter/[[adapter]]}}.{{adapter/[[current]]}} 为 `false`.
    1. [=list/empty=] `navigator.gpu.`{{GPU/[[previously_returned_adapters]]}}.

    问题：如果引入了 `adaptersAdded`/`adapterschanged` 事件，请在此处更新。</div>

<div class="example">
    Request a {{GPUAdapter}}:
    <pre highlight="js">
        const adapter = await navigator.gpu.requestAdapter(/* ... */);
        const features = adapter.features;
        // ...
    </pre>
</div>

### 适配器选择 ### {#adapter-selection}

<dfn dictionary>GPURequestAdapterOptions</dfn>
向用户代理提供提示，指示什么
配置适合应用程序。

<script type=idl>
dictionary GPURequestAdapterOptions {
    GPUPowerPreference powerPreference;
    boolean forceFallbackAdapter = false;
};
</script>

<script type=idl>
enum GPUPowerPreference {
    "low-power",
    "high-performance"
};
</script>

{{GPURequestAdapterOptions}} 有以下选择:

<dl dfn-type=dict-member dfn-for=GPURequestAdapterOptions>
    : <dfn>powerPreference</dfn>
    ::
        （可选）提供一个提示，指示应从系统的可用适配器中选择什么类的 [=adapter=]。

        这个提示的值可能会影响选择哪个适配器，但它不能影响是否返回适配器。

        注意：
        此提示的主要用途是影响多 GPU 系统中使用的 GPU。
        例如，一些笔记本电脑有一个低功耗的集成 GPU 和一个高性能的独立 GPU。

        注意：
        根据确切的硬件配置，例如电池状态和连接的显示器或可移动 GPU，用户代理可能会选择不同的 [=adapter=] 给定相同的电源首选项。
        通常，给定相同的硬件配置和状态以及“powerPreference”，用户代理可能会选择相同的适配器。

        必须是以下值之一:

        <dl dfn-type=enum-value dfn-for=GPUPowerPreference>
            : `undefined` (or not present)
            ::
                不提供任何提示给用户代理.

            : <dfn>"low-power"</dfn>
            ::
                指示将节能优先于性能的请求。

                注意:
                通常，如果内容不太可能受到绘图性能的限制，则应使用它； 例如，如果它每秒只渲染一帧，使用简单的着色器只绘制相对简单的几何图形，或者使用小的 HTML 画布元素。
                如果内容允许，鼓励开发人员使用此值，因为它可以显着提高便携式设备的电池寿命。

            : <dfn>"high-performance"</dfn>
            ::
                指示将性能优先于功耗的请求。

                注意:
                通过选择这个值，开发人员应该意识到，对于在生成的适配器上创建的 [=devices=]，用户代理更有可能强制设备丢失，以便通过切换到低功率适配器来节省功率。
                仅在他们认为绝对必要时鼓励开发人员指定此值，因为它可能会显着缩短便携式设备的电池寿命。
        </dl>

    : <dfn>forceFallbackAdapter</dfn>
    ::
        当设置为 `true` 时表示只能返回 [=fallback adapter=]。 如果用户
        代理不支持 [=fallback adapter=]，会导致 {{GPU/requestAdapter()}}
        解析为 `null`。

        注意:
        如果 {{GPURequestAdapterOptions/forceFallbackAdapter}} 设置为 `false` 并且没有其他合适的 [=adapter=] 可用或用户代理选择 返回一个 [=fallback adapter=]，
        {{GPU/requestAdapter()}} 仍可能返回 [=fallback adapter=]。
        希望阻止其应用程序在 [=fallback adapters=] 上运行的开发人员应在请求 {{GPUDevice}} 之前检查 {{GPUAdapter}}.{{GPUAdapter/isFallbackAdapter}} 属性。
</dl>

## <dfn interface>GPUAdapter</dfn> ## {#gpu-adapter}

一个 {{GPUAdapter}} 封装了一个 [=adapter=]，
并描述其功能（[=features=] 和 [=limits=]）。

使用 {{GPU/requestAdapter()}} 来获取 {{GPUAdapter}}。

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUAdapter {
    readonly attribute DOMString name;
    [SameObject] readonly attribute GPUSupportedFeatures features;
    [SameObject] readonly attribute GPUSupportedLimits limits;
    readonly attribute boolean isFallbackAdapter;

    Promise<GPUDevice> requestDevice(optional GPUDeviceDescriptor descriptor = {});
};
</script>

{{GPUAdapter}} has the following attributes:

<dl dfn-type=attribute dfn-for=GPUAdapter>
    : <dfn>name</dfn>
    ::
        标识适配器的可读名称。
        内容是实现定义的。

    : <dfn>features</dfn>
    ::
        `this` 中值的集合.{{GPUAdapter/[[adapter]]}}.{{adapter/[[features]]}}.

    : <dfn>limits</dfn>
    ::
        `this` 中的限值.{{GPUAdapter/[[adapter]]}}.{{adapter/[[limits]]}}.

    : <dfn>isFallbackAdapter</dfn>
    ::
        返回 {{GPUAdapter/[[adapter]]}} 的值.{{adapter/[[fallback]]}}.
</dl>

{{GPUAdapter}} 有以下内部插槽:

<dl dfn-type=attribute dfn-for=GPUAdapter>
    : <dfn>\[[adapter]]</dfn>, 属于 [=adapter=] 类别, 只读
    ::
        此 {{GPUAdapter}} 所指的 [=adapter=].
</dl>

{{GPUAdapter}} 有以下方法:

<dl dfn-type=method dfn-for=GPUAdapter>
    : <dfn>requestDevice(descriptor)</dfn>
    ::
        向 [=adapter=] 请求一个 [=device=].

        <div algorithm=GPUAdapter.requestDevice>
            **调用:** {{GPUAdapter}} |this|.

            **参数:**
            <pre class=argumentdef for="GPUAdapter/requestDevice(descriptor)">
                |descriptor|: 要请求的 {{GPUDevice}} 的描述。
            </pre>

            **返回:** {{Promise}}&lt;{{GPUDevice}}?&gt;

            1. 让 |promise| 成为一个 [=a new promise=].
            1. 让 |adapter| 作为 |this|.{{GPUAdapter/[[adapter]]}}.
            1. 发布下列指令给 [=Device timeline=]:
                <div class=device-timeline>
                    1. 如果以下任意条件没有满足,
                        [=reject=] |promise| 带有 {{TypeError}} 然后停止运行。

                        <div class=validusage>
                            - |descriptor| 中的值的集合.{{GPUDeviceDescriptor/requiredFeatures}}
                                必须是 |adapter| 中的值的子及.{{adapter/[[features]]}}.
                        </div>

                    1. 如果以下任意条件没有满足,
                        [=reject=] |promise| 带有 {{OperationError}} 然后停止运行。

                        <div class=validusage>
                            - |descriptor| 中的每一个key.{{GPUDeviceDescriptor/requiredLimits}}
                                必须是 [=supported limits=] 中的成员的一个.

                            - 对于 [=supported limits=] 中的每种类型的限制，|descriptor|.{{GPUDeviceDescriptor/requiredLimits}}
                                中该限制的值必须不是 [=limit/better=] 比 |adapter|.{{adapter/[[limits]]}} 中该限制的值。
                        </div>

                    1. 如果 |adapter|.{{adapter/[[current]]}} 是 `false`,
                        或者用户代理无法满足请求：

                        1. 让 |device|成为一个新的 [=device=].
                        1. [=Lose the device=](|device|, `undefined`).

                            注意:
                            这将是 |adapter|.{{adapter/[[current]]}} 为 `false`, 如果之前不是 `false`。

                            注意:
                            发生这种情况时，用户代理应考虑在大多数或所有情况下发出开发人员可见的警告。
                            应用程序应该从 {{GPU/requestAdapter()}} 开始执行重新初始化逻辑。

                        1. [=Resolve=] |promise| 用一个新的 {{GPUDevice}} 来封装 |device|,
                            然后停止运行。

                    1. [=Resolve=] |promise| 用一个新的 {{GPUDevice}} 对象封装
                        [a new device=] 其有 |descriptor| 描述的功能。
                </div>
            1. 返回 |promise|.

        </div>
</dl>

### <dfn dictionary>GPUDeviceDescriptor</dfn> ### {#gpudevicedescriptor}

{{GPUDeviceDescriptor}} 描述一个设备请求。

<script type=idl>
dictionary GPUDeviceDescriptor : GPUObjectDescriptorBase {
    sequence<GPUFeatureName> requiredFeatures = [];
    record<DOMString, GPUSize64> requiredLimits = {};
};
</script>

{{GPUDeviceDescriptor}} 有以下成员:

<dl dfn-type=dict-member dfn-for=GPUDeviceDescriptor>
    : <dfn>requiredFeatures</dfn>
    ::
        指定设备请求所需的 [=features=]。
        如果适配器无法提供这些功能，则请求将失败。

        在生成的设备上的 API 调用验证中，将允许完全指定的一组功能，不多也不少。

    : <dfn>requiredLimits</dfn>
    ::
        指定设备请求所需的 [=limits=]。
        如果适配器无法提供这些限制，则请求将失败。

        每个key必须是 [=supported limits=] 成员的名称。
        正如指定的限制，没有 [=limit/better=] 或更糟，
        才会被允许验证结果设备上的 API 调用。

        <!-- 如果我们需要 GPUSize32/GPUSize64 以外的限制类型，我们可以在将来将值类型更改为 `double` 或 `any`，
        并明确写出类型转换（参考 WebIDL 规范）。
        或者将整个类型更改为 `any` 并添加回一个 `dictionary GPULimits` 并通过引用 WebIDL 定义整个对象的转换。 -->
</dl>

#### <dfn enum>GPUFeatureName</dfn> #### {#gpufeaturename}

每个 {{GPUFeatureName}} 标识一组功能，如果可用，则允许额外使用否则无效的 WebGPU。

<script type=idl>
enum GPUFeatureName {
    "depth-clamping",
    "depth24unorm-stencil8",
    "depth32float-stencil8",
    "pipeline-statistics-query",
    "texture-compression-bc",
    "timestamp-query",
};
</script>

## <dfn interface>GPUDevice</dfn> ## {#gpu-device}

一个 {{GPUDevice}} 封装了一个 [=device=] 并暴露了
该设备的功能。

{{GPUDevice}} 是创建 [=WebGPU interfaces=] 的顶级接口。

要获得 {{GPUDevice}}，请使用 {{GPUAdapter/requestDevice()}}。

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUDevice : EventTarget {
    [SameObject] readonly attribute GPUSupportedFeatures features;
    [SameObject] readonly attribute GPUSupportedLimits limits;

    [SameObject] readonly attribute GPUQueue queue;

    undefined destroy();

    GPUBuffer createBuffer(GPUBufferDescriptor descriptor);
    GPUTexture createTexture(GPUTextureDescriptor descriptor);
    GPUSampler createSampler(optional GPUSamplerDescriptor descriptor = {});
    GPUExternalTexture importExternalTexture(GPUExternalTextureDescriptor descriptor);

    GPUBindGroupLayout createBindGroupLayout(GPUBindGroupLayoutDescriptor descriptor);
    GPUPipelineLayout createPipelineLayout(GPUPipelineLayoutDescriptor descriptor);
    GPUBindGroup createBindGroup(GPUBindGroupDescriptor descriptor);

    GPUShaderModule createShaderModule(GPUShaderModuleDescriptor descriptor);
    GPUComputePipeline createComputePipeline(GPUComputePipelineDescriptor descriptor);
    GPURenderPipeline createRenderPipeline(GPURenderPipelineDescriptor descriptor);
    Promise<GPUComputePipeline> createComputePipelineAsync(GPUComputePipelineDescriptor descriptor);
    Promise<GPURenderPipeline> createRenderPipelineAsync(GPURenderPipelineDescriptor descriptor);

    GPUCommandEncoder createCommandEncoder(optional GPUCommandEncoderDescriptor descriptor = {});
    GPURenderBundleEncoder createRenderBundleEncoder(GPURenderBundleEncoderDescriptor descriptor);

    GPUQuerySet createQuerySet(GPUQuerySetDescriptor descriptor);
};
GPUDevice includes GPUObjectBase;
</script>

{{GPUDevice}} has the following attributes:

<dl dfn-type=attribute dfn-for=GPUDevice>
    : <dfn>features</dfn>
    ::
        包含设备支持的功能（即创建它的功能）的 {{GPUFeatureName}} 值的集合。

    : <dfn>limits</dfn>
    ::
        公开设备支持的限制
        （这正是创建它的那些）。

    : <dfn>queue</dfn>
    ::
        此设备的主要 {{GPUQueue}}。
</dl>

{{GPUDevice}} 的 {{GPUObjectBase/[[device]]}} 是 {{GPUDevice}} 引用的 [=device=]
到。

{{GPUDevice}} 具有上面的 WebIDL 定义中列出的方法。
此处未定义的内容在本文档的其他地方进行了定义。

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>destroy()</dfn>
    ::
        销毁 [=device=]，防止对其进行进一步操作。
        未完成的异步操作将失败。

        <div algorithm=GPUDevice.destroy()>
            **Called on:** {{GPUDevice}} |this|.

            1. [=Lose the device=](|this|.{{GPUObjectBase/[[device]]}},
                {{GPUDeviceLostReason/"destroyed"}}).
        </div>

        注意:
        由于此设备上不能发生进一步的操作，因此实现可以释放资源分配并立即中止未完成的异步操作。
</dl>

{{GPUDevice}} 对象是 [=serializable objects=]。

问题(gpuweb/gpuweb#354): 完成定义多线程 API 并将“[Serializable]”添加回接口。

<div algorithm>
    <dfn abstract-op>序列化 GPUDevice 对象的步骤</dfn>,
    给定 |value|, |serialized|, 和 |forStorage|:
     1. 设置|serialized|.agentCluster 为[=surrounding agent=] 的[=agent cluster=]。
     1. 如果|serialized|.agentCluster 的[=cross-origin isolated capability=] 为false，则抛出“{{DataCloneError}}”。
     1. 如果 |forStorage| 是 `true`，抛出“{{DataCloneError}}”。
     1. 将 |serialized|.device 设置为 |value|.{{GPUObjectBase/[[device]]}} 的值。
</div>

<div algorithm>
    <dfn abstract-op> 反序列化 GPUDevice 对象的步骤</dfn>,
    给定 |serialized| and |value|:
     1. 如果|serialized|.agentCluster 不是[=surrounding agent=] 的[=agent cluster=]，则抛出“{{DataCloneError}}”。
     1. 将 |value|.{{GPUObjectBase/[[device]]}} 设置为 |serialized|.device。
</div>

问题: `GPUDevice` 并不真正需要跨域策略限制。
无论如何，它应该可以从多个代理使用。 一旦我们描述了缓冲区、纹理和队列的序列化 - COOP+COEP 逻辑应该被移到那里。


# 缓冲区 # {#buffers}

## <dfn interface>GPUBuffer</dfn> ## {#buffer-interface}

问题：定义<dfn dfn>buffer</dfn> (内部对象)

{{GPUBuffer}}表示可用于GPU操作的内存块。数据以线性布局存储，这意味着分配的每个字节都可以由其从{{GPUBuffer}}开始的偏移量寻址，受取决于操作的对齐约束限制。一些{{GPUBuffer|GPUBuffers}}可以被映射，这使得内存块可以通过一个{{ArrayBuffer}}访问并调用它的映射。

{{GPUBuffer|GPUBuffers}}是通过{{GPUDevice/createBuffer(descriptor)|GPUDevice.createBuffer(descriptor)}}创建的，
返回一个处于 [=buffer state/mapped=] 或 [=buffer state/unmapped=]状态的新缓冲区。

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUBuffer {
    Promise<undefined> mapAsync(GPUMapModeFlags mode, optional GPUSize64 offset = 0, optional GPUSize64 size);
    ArrayBuffer getMappedRange(optional GPUSize64 offset = 0, optional GPUSize64 size);
    undefined unmap();

    undefined destroy();
};
GPUBuffer includes GPUObjectBase;
</script>

{{GPUBuffer}}有如下内部插槽:

<dl dfn-type=attribute dfn-for="GPUBuffer">
    : <dfn>\[[size]]</dfn> of type {{GPUSize64}}.
    ::
        {{GPUBuffer}}分配的长度（以字节为单位）。

    : <dfn>\[[usage]]</dfn> of type {{GPUBufferUsageFlags}}.
    ::
        此{{GPUBuffer}}被允许的使用。

    : <dfn>\[[state]]</dfn> of type [=buffer state=].
    ::
        {{GPUBuffer}}的当前状态。

    : <dfn>\[[mapping]]</dfn> of type {{ArrayBuffer}} or {{Promise}} or `null`.
    ::
        此{{GPUBuffer}}的映射。{{ArrayBuffer}}不能直接访问，而是通过视图访问它，称为映射范围，存储在{{GPUBuffer/[[mapped_ranges]]}}中。

        在 `DataBlock`方面指定{{GPUBuffer/[[mapping]]}}类似于 `AllocateArrayBuffer`？

    : <dfn>\[[mapping_range]]</dfn> of type [=list=]&lt;{{unsigned long long}}&gt; or `null`.
    ::
        此被映射的{{GPUBuffer}}的范围。

    : <dfn>\[[mapped_ranges]]</dfn> of type [=list=]&lt;{{ArrayBuffer}}&gt; or `null`.
    ::
        {{ArrayBuffer}}s通过{{GPUBuffer/getMappedRange}}返回给应用程序。它们被追踪以便在{{GPUBuffer/unmap}}被调用时可以将其分离。

    : <dfn>\[[map_mode]]</dfn> of type {{GPUMapModeFlags}}.
    ::
        最后一次调用{{GPUBuffer/mapAsync()}}的{{GPUMapModeFlags}}（如果有）。
</dl>

问题：{{GPUBuffer/[[usage]]}}与{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/usage}}的命名不同。我们应该让它保持一致。

每个{{GPUBuffer}}在[=Content timeline=]上都有一个当前的<dfn dfn>buffer state</dfn>，它是以下几项之一：

 - "<dfn dfn for="buffer state">mapped</dfn>" 此时{{GPUBuffer}}中的内容可以被用作CPU操作。
 - "<dfn dfn for="buffer state">mapped at creation</dfn>" 此时{{GPUBuffer}}刚刚被创建并且其中的内容可以被CPU操作。
 - "<dfn dfn for="buffer state">mapping pending</dfn>" 此时{{GPUBuffer}}正在被处理使得它的内容可以被CPU操作。
 - "<dfn dfn for="buffer state">unmapped</dfn>" 此时{{GPUBuffer}}允许GPU操作。
 - "<dfn dfn for="buffer state">destroyed</dfn>" where the {{GPUBuffer}} is
    除了{{GPUBuffer/destroy}}之外不允许任何操作。

注意：一旦创建了{{GPUBuffer}}，{{GPUBuffer/[[size]]}}和{{GPUBuffer/[[usage]]}}是不可变的。

<div class=note>
    注意：{{GPUBuffer}}有一个具有以下状态的状态机。（({{GPUBuffer/[[mapping]]}}, {{GPUBuffer/[[mapping_range]]}},
    和{{GPUBuffer/[[mapped_ranges]]}}在未指定时为空。）

     - [=buffer state/unmapped=]和[=buffer state/destroyed=].
     - 带有类型为{{GPUBuffer/[[mapping]]}}的{{ArrayBuffer}}的[=buffer state/mapped=]或[=buffer state/mapped at creation=]，一个{{GPUBuffer/[[mapping_range]]}}中两个数字连成的串和一串{{GPUBuffer/[[mapped_ranges]]}}中的{{ArrayBuffer}}。
     - [=buffer state/mapping pending=]带有一个类型为{{GPUBuffer/[[mapping]]}}的{{Promise}}。
</div>

{{GPUBuffer}}是可序列化（{{Serializable}}）的。 它是对内部缓冲区对象的引用，而可序列化（{{Serializable}}）意味着可以在领域（线程/工人）之间复制该引用，从而允许多个领域同时访问它。由于{{GPUBuffer}}具有内部状态（已映射、已销毁），因此该状态是内部同步的 - 这些状态更改以原子方式跨领域发生。

问题(gpuweb/gpuweb#354)：完成定义多线程API并将 `[Serializable]`添加回接口。

## 缓冲区创建 ## {#buffer-creation}

### {{GPUBufferDescriptor}} ### {#GPUBufferDescriptor}

它指定创建{{GPUBuffer}}用到的选项。

<script type=idl>
dictionary GPUBufferDescriptor : GPUObjectDescriptorBase {
    required GPUSize64 size;
    required GPUBufferUsageFlags usage;
    boolean mappedAtCreation = false;
};
</script>

<div>
    <dfn abstract-op>校验GPUBufferDescriptor</dfn>(device, descriptor)
        1. 如果设备缺失，返回 `false`.
        2. 如果|descriptor|的{{GPUBufferDescriptor/usage}}任何一个比特位没有表示设备的[[allowed buffer usages]]，返回 `false`。
        3. 如果|descriptor|的{{GPUBufferDescriptor/usage}}的{{GPUBufferUsage/MAP_READ}}和{{GPUBufferUsage/MAP_WRITE}}比特位都设置了值，返回 `false`。
        4. 返回 `true`.
</div>

### 缓冲区使用 ### {#buffer-usage}

<script type=idl>
typedef [EnforceRange] unsigned long GPUBufferUsageFlags;
[Exposed=(Window, DedicatedWorker)]
namespace GPUBufferUsage {
    const GPUFlagsConstant MAP_READ      = 0x0001;
    const GPUFlagsConstant MAP_WRITE     = 0x0002;
    const GPUFlagsConstant COPY_SRC      = 0x0004;
    const GPUFlagsConstant COPY_DST      = 0x0008;
    const GPUFlagsConstant INDEX         = 0x0010;
    const GPUFlagsConstant VERTEX        = 0x0020;
    const GPUFlagsConstant UNIFORM       = 0x0040;
    const GPUFlagsConstant STORAGE       = 0x0080;
    const GPUFlagsConstant INDIRECT      = 0x0100;
    const GPUFlagsConstant QUERY_RESOLVE = 0x0200;
};
</script>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createBuffer(descriptor)</dfn>
    ::
        创建一个{{GPUBuffer}}。

        <div algorithm=GPUDevice.createBuffer>
            **Called on:** {{GPUDevice}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/createBuffer(descriptor)">
                |descriptor|: 要创建的{{GPUBuffer}}的描述。
            </pre>

            **Returns:** {{GPUBuffer}}

            1. 如果以下任何条件没有满足，返回一个错误缓冲并且停止。
                <div class=validusage>
                    - |this|是一个有效的（[=valid=]）{{GPUDevice}}。
                    - |descriptor|.{{GPUBufferDescriptor/usage}}是|this|.[[allowed buffer usages]]的一个子集。
                    - 如果|descriptor|.{{GPUBufferDescriptor/usage}}包含{{GPUBufferUsage/MAP_READ}}:
                        - |descriptor|.{{GPUBufferDescriptor/usage}}除了{{GPUBufferUsage/COPY_DST}}不包含其他标识。
                    - 如果|descriptor|.{{GPUBufferDescriptor/usage}}包含{{GPUBufferUsage/MAP_WRITE}}:
                        - |descriptor|.{{GPUBufferDescriptor/usage}}除了{{GPUBufferUsage/COPY_SRC}}不包含其他标识。
                    - 如果|descriptor|.{{GPUBufferDescriptor/mappedAtCreation}}为 `true`:
                        - |descriptor|.{{GPUBufferDescriptor/size}}是4的倍数。

                    Issue(gpuweb/gpuweb#605): 解释：结果错误缓冲仍然可以在创建时被映射。

                    Issue(gpuweb/gpuweb#605): 解释什么是{{GPUDevice}}的 `[[allowed buffer usages]]`.
                </div>

            2. 使|b|为一个新的{{GPUBuffer}}对象.
            3. 将|b|.{{GPUBuffer/[[size]]}}设置为|descriptor|.{{GPUBufferDescriptor/size}}.
            4. 将|b|.{{GPUBuffer/[[usage]]}}设置为|descriptor|.{{GPUBufferDescriptor/usage}}.
            5. 如果|descriptor|.{{GPUBufferDescriptor/mappedAtCreation}}值为 `true`:

                1. 将|b|.{{GPUBuffer/[[mapping]]}}设置为一个新的大小为|b|.{{GPUBuffer/[[size]]}}的{{ArrayBuffer}}。
                2. 将|b|.{{GPUBuffer/[[mapping_range]]}}设置为 `[0, descriptor.size]`.
                3. 将|b|.{{GPUBuffer/[[mapped_ranges]]}}设置为 `[]`.
                4. 将|b|.{{GPUBuffer/[[state]]}}设置为[=buffer state/mapped at creation=].

                否则:

                1. 将|b|.{{GPUBuffer/[[mapping]]}}设置为 `null`。
                2. 将|b|.{{GPUBuffer/[[mapping_range]]}}设置为 `null`。
                3. 将|b|.{{GPUBuffer/[[mapped_ranges]]}}设置为 `null`。
                4. 将|b|.{{GPUBuffer/[[state]]}}设置为[=buffer state/unmapped=]。

            6. 将|b|分配的每个字节设置为零。
            7. 返回|b|.

            注意：在{{GPUBufferDescriptor/usage}}中没有{{GPUBufferUsage/MAP_READ}}或{{GPUBufferUsage/MAP_WRITE}}的情况下，将{{GPUBufferDescriptor/mappedAtCreation}}设置为 `true`是有效的。这可用于设置缓冲区的初始数据。

        </div>

</dl>

## 缓冲区销毁 ## {#buffer-destruction}

不再需要{{GPUBuffer}}的应用程序可以通过调用{{GPUBuffer/destroy()}}选择在垃圾收集之前失去对它的访问权限。

注意：一旦所有先前提交的使用它的操作完成，这允许用户代理回收与{{GPUBuffer}}关联的GPU内存。

<dl dfn-type=method dfn-for=GPUBuffer>
    : <dfn>destroy()</dfn>
    ::
        销毁{{GPUBuffer}}.

        <div algorithm=GPUBuffer.destroy>
            **Called on:** {{GPUBuffer}} |this|.

            **Returns:** {{undefined}}

            1. 如果|this|.{{GPUBuffer/[[state]]}}为[=buffer state/mapped=]或[=buffer state/mapped at creation=]:
                1. 执行unmap|this|的步骤。

            2. 设置|this|.{{GPUBuffer/[[state]]}}为[=buffer state/destroyed=].

            问题: 一旦我们有了错误单子的描述，就处理错误缓冲区。
        </div>
</dl>

## 缓冲区映射 ## {#buffer-mapping}


应用程序可以请求映射{{GPUBuffer}}，以便他们可以通过代表{{GPUBuffer}}部分分配的ArrayBuffers访问其内容。使用{{GPUBuffer/mapAsync()}}异步请求映射{{GPUBuffer}}，以便用户代理可以确保GPU在应用程序可以访问其内容之前完成使用{{GPUBuffer}}。一旦{{GPUBuffer}} 被映射，应用程序就可以使用{{GPUBuffer/getMappedRange}}同步请求访问其内容范围。已映射的{{GPUBuffer}}不能被GPU使用，并且必须在使用它的work提交到[=Queue timeline=]之前使用{{GPUBuffer/unmap}}取消映射。

问题(gpuweb/gpuweb#605): 添加客户端校验，已映射缓冲区只能在其映射的worker上取消映射和销毁。同样{{GPUBuffer/getMappedRange}}只能在该worker上被调用。

<script type=idl>
typedef [EnforceRange] unsigned long GPUMapModeFlags;
[Exposed=(Window, DedicatedWorker)]
namespace GPUMapMode {
    const GPUFlagsConstant READ  = 0x0001;
    const GPUFlagsConstant WRITE = 0x0002;
};
</script>

<dl dfn-type=method dfn-for=GPUBuffer>
    : <dfn>mapAsync(mode, offset, size)</dfn>
    ::
        映射{{GPUBuffer}}的给定范围，并在{{GPUBuffer}}的内容准备好可以使用{{GPUBuffer/getMappedRange()}}访问时，决议返回的Promise。

        <div algorithm=GPUBuffer.mapAsync>
            **Called on:** {{GPUBuffer}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUBuffer/mapAsync(mode, offset, size)">
                |mode|: 缓冲区是否应当被映射为读取或写入。
                |offset|: 以字节为单位的缓冲区到要映射的范围起始位置的偏移量。
                |size|: 以字节为单位的要映射的范围大小。
            </pre>

            **Returns:** {{Promise}}&lt;{{undefined}}&gt;

            问题(gpuweb/gpuweb#605): 一旦我们有了错误单子，即刻处理错误缓冲区。

            1. 如果|size|字段丢失:
                1. 使|rangeSize|为max(0, |this|.{{GPUBuffer/[[size]]}} - |offset|)。

                否则, 使|rangeSize|为|size|。

            2. 如果以下任何条件未满足:
                <div class=validusage>
                    - |this|为有效的（[=valid=]）{{GPUBuffer}}。
                    - |offset|是8的倍数。
                    - |rangeSize|是4的倍数。
                    - |offset| + |rangeSize|等于或小于|this|.{{GPUBuffer/[[size]]}}。
                    - |this|.{{GPUBuffer/[[state]]}}为[=buffer state/unmapped=]状态。
                    - |mode|明确包含{{GPUMapMode/READ}}或{{GPUMapMode/WRITE}}之一。
                    - 如果|mode|包含{{GPUMapMode/READ}}，则|this|.{{GPUBuffer/[[usage]]}}必须包含{{GPUBufferUsage/MAP_READ}}。
                    - 如果|mode|包含{GPUMapMode/WRITE}}，则|this|.{{GPUBuffer/[[usage]]}}必须包含{{GPUBufferUsage/MAP_WRITE}}.

                    问题: 我们是否需要对仅包含有效标识的|mode|做校验？
                </div>

                接下来:
                1. 记录当前范围内的校验错误。
                2. 返回[=a promise rejected with=]一个[=Device timeline=]上的{{OperationError}}。

            3. 使|p|为一个新的{{Promise}}。
            4. 设置|this|.{{GPUBuffer/[[mapping]]}}为|p|。
            5. 设置|this|.{{GPUBuffer/[[state]]}}为[=buffer state/mapping pending=]。
            6. 设置|this|.{{GPUBuffer/[[map_mode]]}}为|mode|。
            7. 在默认队列上的[=Queue timeline=]对操作进行入队操作，该行为将执行以下操作:
                <div class=queue-timeline>
                    1. 如果|this|.{{GPUBuffer/[[state]]}}为[=buffer state/mapping pending=]状态:

                        1. 使|m|为一个新的大小为|rangeSize|的{{ArrayBuffer}}。
                        2. 将|m|的内容设置为|this|分配的内容，从偏移|offset|开始，为|rangeSize|字节。
                        3. 将|this|.{{GPUBuffer/[[mapping]]}}设置为|m|.
                        4. 将|this|.{{GPUBuffer/[[state]]}}设置为[=buffer state/mapped=].
                        5. 将|this|.{{GPUBuffer/[[mapping_range]]}}设置为<code>[|offset|, |offset| + |rangeSize|]</code>.
                        6. 将|this|.{{GPUBuffer/[[mapped_ranges]]}}设置为 `[]`.

                    2. Resolve |p|.
                </div>
            8. 返回|p|。
        </div>

    : <dfn>getMappedRange(offset, size)</dfn>
    ::
        返回一个带有给定范围内{{GPUBuffer}}内容的{{ArrayBuffer}}。

        <div algorithm=GPUBuffer.getMappedRange>
            **Called on:** {{GPUBuffer}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUBuffer/getMappedRange(offset, size)">
                |offset|: 以字节为单位的缓冲区偏移量，返回缓冲区内容的位置。
                |size|: 以字节为单位的，要返回的{{ArrayBuffer}}大小。
            </pre>

            **Returns:** {{ArrayBuffer}}

            1. 如果|size|缺失:
                1. 使|rangeSize|为max(0, |this|.{{GPUBuffer/[[size]]}} - |offset|)。

                否则, 使|rangeSize|为|size|。

            2. 如果任何以下条件未满足, 抛出一个{{OperationError}}异常并停止。
                <div class=validusage>
                    - |this|.{{GPUBuffer/[[state]]}}为[=buffer state/mapped=] or [=buffer state/mapped at creation=]。
                    - |offset|是8的倍数。
                    - |rangeSize|是4的倍数。
                    - |offset|等于或大于|this|.{{GPUBuffer/[[mapping_range]]}}[0]。
                    - |offset| + |rangeSize|小于或等于|this|.{{GPUBuffer/[[mapping_range]]}}[1].
                    - [|offset|, |offset| + |rangeSize|)不与另一个|this|.{{GPUBuffer/[[mapped_ranges]]}}范围重叠。

                    注意：获取[=buffer state/mapped at creation=]的{{GPUBuffer}}的映射范围总是有效的，即使它是无效的，因为[=Content timeline=]可能不知道它是无效的。

                    问题：考虑将mapAsync偏移量对齐到8以匹配此值。
                </div>

            3. 使|m|为一个新的大小为|rangeSize|的{{ArrayBuffer}}，指向|this|.{{GPUBuffer/[[mapping]]}}的内容偏移量|offset| - |this|.{{GPUBuffer/[[mapping_range]]}}[0]。

            4. 添加([=list/Append=])|m|至|this|.{{GPUBuffer/[[mapped_ranges]]}}。

            5. 返回|m|。
        </div>

    : <dfn>unmap()</dfn>
    ::
        对已映射的{{GPUBuffer}}范围取消映射，并且使得它的内容可以重新被GPU使用。

        <div algorithm=GPUBuffer.unmap>
            **Called on:** {{GPUBuffer}} |this|.

            **Returns:** {{undefined}}

            1. 如果以下任何需求没有满足，产生一个校验错误并停止。
                <div class=validusage>
                    - |this|.{{GPUBuffer/[[state]]}}必须为[=buffer state/mapped at creation=]，
                        [=buffer state/mapping pending=]，或[=buffer state/mapped=].

                    Note: 取消一个状态为[=buffer state/mapped at creation=]的{{GPUBuffer}}[=invalid=]映射是有效的，因为[=Content timeline=]可能不知道它是个错误的{{GPUBuffer}}。
                </div>

            2. 如果|this|.{{GPUBuffer/[[state]]}}为[=buffer state/mapping pending=]:

                1. 拒绝（[=Reject=]）{{GPUBuffer/[[mapping]]}}，以一个{{AbortError}}。
                1. 设置|this|.{{GPUBuffer/[[mapping]]}}为 `null`。

            3. 如果|this|.{{GPUBuffer/[[state]]}}为[=buffer state/mapped=]或[=buffer state/mapped at creation=]:

                1. 如果以下两条件之一成立:

                    - |this|.{{GPUBuffer/[[state]]}}为[=buffer state/mapped at creation=]
                    - |this|.{{GPUBuffer/[[state]]}}为[=buffer state/mapped=]并且|this|.{{GPUBuffer/[[map_mode]]}}包含{{GPUMapMode/WRITE}}

                    则接下来:
                    1. 在默认队列的[=Queue timeline=]上将操作入队，该操作将|this|.{{GPUBuffer/[[mapping_range]]}}的|this|分配更新为 |this|.{{GPUBuffer/[[mapping]]}}的内容。

                2. 将|this|.{{GPUBuffer/[[mapped_ranges]]}}中的每个{{ArrayBuffer}}与其内容分离。
                3. 将|this|.{{GPUBuffer/[[mapping]]}}设置为 `null`.
                4. 将|this|.{{GPUBuffer/[[mapping_range]]}}设置为 `null`.
                5. 将|this|.{{GPUBuffer/[[mapped_ranges]]}}设置为 `null`.

            4. 将|this|.{{GPUBuffer/[[state]]}}设置为[=buffer state/unmapped=].

            注意：当{{GPUBufferUsage/MAP_READ}}缓冲区（目前未在创建时映射）被取消映射时，应用程序对映射范围{{ArrayBuffer}}所做的任何本地修改都将被丢弃，并且不会影响后续映射的内容。
        </div>
</dl>


# 纹理和纹理视图 # {#textures}

Issue: define <dfn dfn>texture</dfn> (internal object)

Issue: define <dfn dfn>mipmap level</dfn>, <dfn dfn>array layer</dfn>, <dfn dfn>aspect</dfn>, <dfn dfn>slice</dfn> (concepts)

## <dfn interface>GPUTexture</dfn> ## {#texture-interface}

{{GPUTexture|GPUTextures}} 是通过创建
{{GPUDevice/createTexture(descriptor)|GPUDevice.createTexture(descriptor)}} 返回的一个新的纹理。

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUTexture {
    GPUTextureView createView(optional GPUTextureViewDescriptor descriptor = {});

    undefined destroy();
};
GPUTexture includes GPUObjectBase;
</script>

{{GPUTexture}} 有以下内部插槽:

<dl dfn-type=attribute dfn-for="GPUTexture">
    : <dfn>\[[descriptor]]</dfn>, {{GPUTextureDescriptor}} 类型
    ::
        {{GPUTextureDescriptor}} 描述这个纹理.

        {{GPUTextureDescriptor}} 的所有可选字段都已定义。

    : <dfn>\[[destroyed]]</dfn>, `boolean` 类型, 初始设定为 false
    ::
        如果纹理被破坏，它就不能再用于任何操作，
        并且它的底层内存可以被释放。
</dl>

<div algorithm>
    <dfn abstract-op>compute render extent</dfn>(baseSize, mipLevel)

    **参数:**
        - {{GPUExtent3D}} |baseSize|
        - {{GPUSize32}} |mipLevel|

    **返回:** {{GPUExtent3DDict}}

    1. 让 |extent| 成为一个新的 {{GPUExtent3DDict}} 对象。
    1. 设置 |extent|.{{GPUExtent3DDict/width}} 为 max(1, |baseSize|.[=Extent3D/width=] &Gt; |mipLevel|).
    1. 设置 |extent|.{{GPUExtent3DDict/height}} 为 max(1, |baseSize|.[=Extent3D/height=] &Gt; |mipLevel|).
    1. 设置 |extent|.{{GPUExtent3DDict/depthOrArrayLayers}} 为 1.
    1. 返回 |extent|.
</div>

问题: 与描述抽样的规范部分共享此定义。

### 纹理创建 ### {#texture-creation}

<script type=idl>
dictionary GPUTextureDescriptor : GPUObjectDescriptorBase {
    required GPUExtent3D size;
    GPUIntegerCoordinate mipLevelCount = 1;
    GPUSize32 sampleCount = 1;
    GPUTextureDimension dimension = "2d";
    required GPUTextureFormat format;
    required GPUTextureUsageFlags usage;
};
</script>

<script type=idl>
enum GPUTextureDimension {
    "1d",
    "2d",
    "3d",
};
</script>

<script type=idl>
typedef [EnforceRange] unsigned long GPUTextureUsageFlags;
[Exposed=(Window, DedicatedWorker)]
namespace GPUTextureUsage {
    const GPUFlagsConstant COPY_SRC          = 0x01;
    const GPUFlagsConstant COPY_DST          = 0x02;
    const GPUFlagsConstant TEXTURE_BINDING   = 0x04;
    const GPUFlagsConstant STORAGE_BINDING   = 0x08;
    const GPUFlagsConstant RENDER_ATTACHMENT = 0x10;
};
</script>

<div algorithm>
    <dfn abstract-op>maximum mipLevel count</dfn>(dimension, size)
    **参数:**
        - {{GPUTextureDescriptor/dimension}} |dimension|
        - {{GPUTextureDescriptor/size}} |size|

    1. 计算最大维度值 |m|:
        - 如果 |dimension| 是:
            <dl class="switch">
                : {{GPUTextureDimension/"1d"}}
                :: 设定 |m| = |size|.[=Extent3D/width=].

                : {{GPUTextureDimension/"2d"}}
                :: 设定 |m| = max(|size|.[=Extent3D/width=], |size|.[=Extent3D/height=]).

                : {{GPUTextureDimension/"3d"}}
                :: 设定 |m| = max(max(|size|.[=Extent3D/width=], |size|.[=Extent3D/height=]), |size|.[=Extent3D/depthOrArrayLayer=]).
            </dl>
    1. 返回 floor(log<sub>2</sub>(|m|)) + 1.
</div>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createTexture(descriptor)</dfn>
    ::
        创建一个 {{GPUTexture}}.

        <div algorithm=GPUDevice.createTexture>
            **调用:** {{GPUDevice}} this.

            **参数:**
            <pre class=argumentdef for="GPUDevice/createTexture(descriptor)">
                |descriptor|: 针对要创建的 {{GPUTexture}} 的描述。
            </pre>

            **返回:** {{GPUTexture}}

            1. 在 |this| 的 [=Device timeline=] 上发布一下指令:
                <div class=device-timeline>
                    1. 如果 |descriptor|.{{GPUTextureDescriptor/format}} 是一个需要特征的 {{GPUTextureFormat}}（参见
                        [[#texture-format-caps]])，但 |this|.{{GPUObjectBase/[[device]]}}.{{device/[[features]]}} 没有
                        [=list/contain=] 功能，抛出 {{TypeError}}。
                    1. 如果不满足以下任何要求:
                        <div class=validusage>
                            - |this| 必须是 [=valid=] {{GPUDevice}}.
                            - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/width=],
                                |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/height=],
                                和 |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/depthOrArrayLayers=] 必须大于零。
                            - |descriptor|.{{GPUTextureDescriptor/mipLevelCount}} 必须大于零。
                            - |descriptor|.{{GPUTextureDescriptor/sampleCount}} 必须为 1 或 4。

                            - 如果 |descriptor|.{{GPUTextureDescriptor/dimension}} 是:
                                <dl class="switch">
                                    : {{GPUTextureDimension/"1d"}}
                                    ::
                                        - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/width=] 必须小于或等于
                                            |this|.{{GPUDevice/limits}}.{{GPUSupportedLimits/maxTextureDimension1D}}。
                                        - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/height=] 必须为 1。
                                        - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/depthOrArrayLayers=] 必须为 1。
                                        - |descriptor|.{{GPUTextureDescriptor/sampleCount}} 必须为 1。
                                        - |descriptor|.{{GPUTextureDescriptor/format}} 不得是压缩格式或深度/模板格式。

                                    : {{GPUTextureDimension/"2d"}}
                                    ::
                                        - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/width=] 必须小于或等于
                                            |this|.{{GPUDevice/limits}}.{{GPUSupportedLimits/maxTextureDimension2D}}。
                                        - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/height=] 必须小于或等于
                                            |this|.{{GPUDevice/limits}}.{{GPUSupportedLimits/maxTextureDimension2D}}。
                                        - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/depthOrArrayLayers=] 必须小于或等于
                                            |this|.{{GPUDevice/limits}}.{{GPUSupportedLimits/maxTextureArrayLayers}}。

                                    : {{GPUTextureDimension/"3d"}}
                                    ::
                                        - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/width=] 必须小于或等于
                                            |this|.{{GPUDevice/limits}}.{{GPUSupportedLimits/maxTextureDimension3D}}.
                                        - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/height=] 必须小于或等于
                                            |this|.{{GPUDevice/limits}}.{{GPUSupportedLimits/maxTextureDimension3D}}.
                                        - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/depthOrArrayLayers=] 必须小于或等于
                                            |this|.{{GPUDevice/limits}}.{{GPUSupportedLimits/maxTextureDimension3D}}.
                                        - |descriptor|.{{GPUTextureDescriptor/sampleCount}} 必须为 1。
                                        - |descriptor|.{{GPUTextureDescriptor/format}} 不得是压缩格式或深度/模板格式。
                                </dl>
                            - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/width=] 必须是 [=texel block width=] 的倍数。
                            - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/height=] 必须是 [=texel block height=] 的倍数。

                            - 如果 |descriptor|.{{GPUTextureDescriptor/sampleCount}} > 1:
                                - |descriptor|.{{GPUTextureDescriptor/mipLevelCount}} 必须为 1。
                                - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/depthOrArrayLayers=] 必须为 1。
                                - |descriptor|.{{GPUTextureDescriptor/usage}} 必须不包含 {{GPUTextureUsage/STORAGE_BINDING}} 位.
                                - |descriptor|.{{GPUTextureDescriptor/format}} 必须为 [=renderable format=].

                            - |descriptor|.{{GPUTextureDescriptor/mipLevelCount}} 必须小于或等于
                                [$maximum mipLevel count$](|descriptor|.{{GPUTextureDescriptor/dimension}}, |descriptor|.{{GPUTextureDescriptor/size}}).

                            - |descriptor|.{{GPUTextureDescriptor/usage}} 必须为 {{GPUTextureUsage}} 的值的组合。
                            - If |descriptor|.{{GPUTextureDescriptor/usage}} 包含 {{GPUTextureUsage/RENDER_ATTACHMENT}} 位,
                                |descriptor|.{{GPUTextureDescriptor/format}} 必须为 [=renderable format=].
                            - If |descriptor|.{{GPUTextureDescriptor/usage}} 包含 {{GPUTextureUsage/STORAGE_BINDING}} 位,
                                |descriptor|.{{GPUTextureDescriptor/format}} 必须在 带有 {{GPUTextureUsage/STORAGE_BINDING}} 的功能的
                                [[#plain-color-formats]] 表格中列出。

                        </div>

                        Then:
                            1. 在当前范围内生成带有相应错误消息的 {{GPUValidationError}}。
                            1. 返回一个新的[=invalid=] {{GPUTexture}}。

                    1. 让 |t| 成为一个新的 {{GPUTexture}} 对象.
                    1. 设定 |t|.{{GPUTexture/[[descriptor]]}} 为 |descriptor|.
                    1. 返回 |t|.
                </div>
        </div>
</dl>

### 纹理破坏 ### {#texture-destruction}

不再需要 {{GPUTexture}} 的应用程序可以通过调用 {{GPUTexture/destroy()}} 选择在垃圾收集之前失去对它的访问权限。

注意: 这允许用户代理在所有先前提交的使用它的操作完成后回收与 {{GPUTexture}} 关联的 GPU 内存。

<dl dfn-type=method dfn-for=GPUTexture>
    : <dfn>destroy()</dfn>
    ::
        摧毁 {{GPUTexture}}.

        <div algorithm=GPUTexture.destroy>
            **调用:** {{GPUTexture}} |this|.

            **返回:** {{undefined}}

            1. 设置 |this|.{{GPUTexture/[[destroyed]]}} 为 true.
        </div>
</dl>

## <dfn interface>GPUTextureView</dfn> ## {#gpu-textureview}

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUTextureView {
};
GPUTextureView includes GPUObjectBase;
</script>

{{GPUTextureView}} 有以下内部插槽:

<dl dfn-type=attribute dfn-for="GPUTextureView">
    : <dfn>\[[texture]]</dfn>
    ::
        这是视图所在的 {{GPUTexture}}。

    : <dfn>\[[descriptor]]</dfn>
    ::
        {{GPUTextureViewDescriptor}} 描绘这个纹理视图.

        {{GPUTextureViewDescriptor}} 的所有可选字段都已定义。
    : <dfn>\[[renderExtent]]</dfn>
    ::
        对于可渲染视图，这是用于渲染的有效 {{GPUExtent3DDict}}。

        注意: 这个程度取决于 {{GPUTextureViewDescriptor/baseMipLevel}}.

</dl>

### 纹理视图创建 ### {#texture-view-creation}

<script type=idl>
dictionary GPUTextureViewDescriptor : GPUObjectDescriptorBase {
    GPUTextureFormat format;
    GPUTextureViewDimension dimension;
    GPUTextureAspect aspect = "all";
    GPUIntegerCoordinate baseMipLevel = 0;
    GPUIntegerCoordinate mipLevelCount;
    GPUIntegerCoordinate baseArrayLayer = 0;
    GPUIntegerCoordinate arrayLayerCount;
};
</script>

<script type=idl>
enum GPUTextureViewDimension {
    "1d",
    "2d",
    "2d-array",
    "cube",
    "cube-array",
    "3d"
};
</script>

<script type=idl>
enum GPUTextureAspect {
    "all",
    "stencil-only",
    "depth-only"
};
</script>

<dl dfn-type=method dfn-for=GPUTexture>
    : <dfn>createView(descriptor)</dfn>
    ::
        创建一个 {{GPUTextureView}}.

        <div algorithm=GPUTexture.createView>
            **调用:** {{GPUTexture}} |this|.

            **参数:**
            <pre class=argumentdef for="GPUTexture/createView(descriptor)">
                |descriptor|: 描述要创建的 {{GPUTextureView}}。
            </pre>

            **返回:** |view|, {{GPUTextureView}}类型。

            1. 设置 |descriptor| 为带有|descriptor| 的 [$resolving GPUTextureViewDescriptor defaults$] 返回值。
            1. 在 |this| 的 [=Device timeline=] 上发布以下指令:
                <div class=device-timeline>
                    1. 如果不满足以下任何要求:
                        <div class=validusage>
                            - |this| 是 [=valid=]
                            - 如果 |descriptor|.{{GPUTextureViewDescriptor/aspect}} 是
                                <dl class="switch">
                                    : {{GPUTextureAspect/"stencil-only"}}
                                    :: |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/format}} 必须是带有模板方面的
                                        [[#depth-formats|depth-stencil format]]。

                                    : {{GPUTextureAspect/"depth-only"}}
                                    :: |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/format}} 必须是带有深度方面的
                                        [[#depth-formats|depth-stencil format]]。

                                </dl>
                            - |descriptor|.{{GPUTextureViewDescriptor/mipLevelCount}} 必须 &gt; 0.
                            - |descriptor|.{{GPUTextureViewDescriptor/baseMipLevel}} +
                                |descriptor|.{{GPUTextureViewDescriptor/mipLevelCount}} 必须 &le;
                                |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/mipLevelCount}}.
                            - |descriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} 必须 &gt; 0.
                            - |descriptor|.{{GPUTextureViewDescriptor/baseArrayLayer}} +
                                |descriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} 必须 &le;
                                the [$array layer count$] of |this|.
                            - |descriptor|.{{GPUTextureViewDescriptor/format}} 必须是 |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/format}}.
                                <div class="issue">也允许创建具有兼容格式的视图。</div>
                            - 如果 |descriptor|.{{GPUTextureViewDescriptor/dimension}} 是:
                                <dl class="switch">
                                    : {{GPUTextureViewDimension/"1d"}}
                                    :: |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/dimension}} 必须是 {{GPUTextureDimension/"1d"}}.
                                    :: |descriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} 必须是 `1`.

                                    : {{GPUTextureViewDimension/"2d"}}
                                    :: |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/dimension}} 必须是 {{GPUTextureDimension/"2d"}}.
                                    :: |descriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} 必须是 `1`.

                                    : {{GPUTextureViewDimension/"2d-array"}}
                                    :: |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/dimension}} 必须是 {{GPUTextureDimension/"2d"}}.

                                    : {{GPUTextureViewDimension/"cube"}}
                                    :: |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/dimension}} 必须是 {{GPUTextureDimension/"2d"}}.
                                    :: |descriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} 必须是 `6`.
                                    :: |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/size}}.[=Extent3D/width=] 必须是
                                        |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/size}}.[=Extent3D/height=].

                                    : {{GPUTextureViewDimension/"cube-array"}}
                                    :: |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/dimension}} 必须是 {{GPUTextureDimension/"2d"}}.
                                    :: |descriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} 必须是 `6` 的倍数。
                                    :: |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/size}}.[=Extent3D/width=] 必须是
                                        |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/size}}.[=Extent3D/height=].

                                    : {{GPUTextureViewDimension/"3d"}}
                                    :: |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/dimension}} 必须是 {{GPUTextureDimension/"3d"}}.
                                    :: |descriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} 必须是 `1`.
                                </dl>
                        </div>

                        Then:
                            1. 在当前范围内生成一个 {{GPUValidationError}} 并带有适当的错误消息。
                            1. 返回一个新的 [=invalid=] {{GPUTextureView}}。

                    1. 让 |view| 成为一个新的 {{GPUTextureView}} 对象。
                    1. 设置 |view|.{{GPUTextureView/[[texture]]}} 为 |this|。
                    1. 设置 |view|.{{GPUTextureView/[[descriptor]]}} 为 |descriptor|.
                    1. 如果 |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/usage}} 包含 {{GPUTextureUsage/RENDER_ATTACHMENT}}:
                        1. 让 |renderExtent| 为 [$compute render extent$](|this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/size}}, |descriptor|.{{GPUTextureViewDescriptor/baseMipLevel}}).
                        1. 设置 |view|.{{GPUTextureView/[[renderExtent]]}} 为 |renderExtent|.
                    1. 返回 |view|.
                </div>
        </div>
</dl>

<div algorithm>
    When <dfn abstract-op>resolving GPUTextureViewDescriptor defaults</dfn> for {{GPUTextureViewDescriptor}}
    |descriptor| 运行一下步骤：

    1. 让 |resolved| 成为一个 |descriptor| 的副本。
    1. 如果 |resolved|.{{GPUTextureViewDescriptor/format}} 是 `undefined`,
        设置 |resolved|.{{GPUTextureViewDescriptor/format}} 为 |texture|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/format}}.
    1. 如果 |resolved|.{{GPUTextureViewDescriptor/mipLevelCount}} 是 `undefined`,
        设置 |resolved|.{{GPUTextureViewDescriptor/mipLevelCount}} 为 |texture|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/mipLevelCount}}
        &minus; {{GPUTextureViewDescriptor/baseMipLevel}}.
    1. 如果 |resolved|.{{GPUTextureViewDescriptor/dimension}} 是 `undefined` 并且
        |texture|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/dimension}} 是:
        <dl class="switch">
            : {{GPUTextureDimension/"1d"}}
            :: 设置 |resolved|.{{GPUTextureViewDescriptor/dimension}} 为 {{GPUTextureViewDimension/"1d"}}.

            : {{GPUTextureDimension/"2d"}}
            :: 设置 |resolved|.{{GPUTextureViewDescriptor/dimension}} 为 {{GPUTextureViewDimension/"2d"}}.

            : {{GPUTextureDimension/"3d"}}
            :: 设置 |resolved|.{{GPUTextureViewDescriptor/dimension}} 为 {{GPUTextureViewDimension/"3d"}}.
        </dl>
    1. 如果 |resolved|.{{GPUTextureViewDescriptor/arrayLayerCount}} 为 `undefined` 并且
        |resolved|.{{GPUTextureViewDescriptor/dimension}} 是:
        <dl class="switch">
            : {{GPUTextureViewDimension/"1d"}}, {{GPUTextureViewDimension/"2d"}}, or
                {{GPUTextureViewDimension/"3d"}}
            :: 设置 |resolved|.{{GPUTextureViewDescriptor/arrayLayerCount}} 为 `1`.

            : {{GPUTextureViewDimension/"cube"}}
            :: 设置 |resolved|.{{GPUTextureViewDescriptor/arrayLayerCount}} 为 `6`.

            : {{GPUTextureViewDimension/"2d-array"}} 或者 {{GPUTextureViewDimension/"cube-array"}}
            :: 设置 |resolved|.{{GPUTextureViewDescriptor/arrayLayerCount}} 为
                |texture|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/size}}.[=Extent3D/depthOrArrayLayers=] &minus;
                {{GPUTextureViewDescriptor/baseArrayLayer}}.
        </dl>

    1. 返回 |resolved|.
</div>

<div algorithm>
    要确定 {{GPUTexture}} |texture| 的 <dfn abstract-op>array layer count</dfn>，请运行
    以下步骤：

        1. 如果 |texture|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/dimension}} 是:
            <dl class="switch">
                : {{GPUTextureDimension/"1d"}} 或者 {{GPUTextureDimension/"3d"}}
                :: 返回 `1`.

                : {{GPUTextureDimension/"2d"}}
                :: 返回 |texture|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/size}}.[=Extent3D/depthOrArrayLayers=].
            </dl>
</div>

## 纹理格式 ## {#texture-formats}

格式的名称指定了组件的顺序、每个组件的位数、
和组件的数据类型。

  * `r`, `g`, `b`, `a` = red, green, blue, alpha
  * `unorm` = unsigned normalized
  * `snorm` = signed normalized
  * `uint` = unsigned int
  * `sint` = signed int
  * `float` = floating point

如果格式具有“-srgb”后缀，则在着色器中读取和写入颜色值期间应用从伽马到线性的 sRGB 转换，反之亦然。 压缩纹理格式由 [=features=] 提供。
它们的命名应遵循此处的约定，以纹理名称作为前缀。 例如 `etc2-rgba8unorm`。

<dfn dfn>texel block</dfn> 是基于像素的 {{GPUTextureFormat}} 中纹理的单个可寻址元素，以及基于块的压缩 {{GPUTextureFormat}} 中纹理的单个压缩块。

<dfn dfn>texel block width</dfn> 和 <dfn dfn>texel block height</dfn> 指定了一个 [=texel block=] 的尺寸。
   - 对于基于像素的 {{GPUTextureFormat}}s，[=texel block width=] 和 [=texel block height=] 始终为 1。
   - 对于基于块的压缩{{GPUTextureFormat}}s，[=texel block width=]是一个[=texel block=]的每一行的texel数量，[=texel block height=]是数量 一个 [=texel block=] 中的 texel 行。

{{GPUTextureFormat}} 的 <dfn dfn>texel block size</dfn> 是存储一个 [=texel block=] 的字节数。
除了 {{GPUTextureFormat/"stencil8"}}、{{GPUTextureFormat/"depth24plus"}} 和 {{GPUTextureFormat/"depth24plus-stencil8"} 之外，
每个 {{GPUTextureFormat}} 的 [=texel block size=] 是恒定的 }。

<script type=idl>
enum GPUTextureFormat {
    // 8-bit 格式
    "r8unorm",
    "r8snorm",
    "r8uint",
    "r8sint",

    // 16-bit 格式
    "r16uint",
    "r16sint",
    "r16float",
    "rg8unorm",
    "rg8snorm",
    "rg8uint",
    "rg8sint",

    // 32-bit 格式
    "r32uint",
    "r32sint",
    "r32float",
    "rg16uint",
    "rg16sint",
    "rg16float",
    "rgba8unorm",
    "rgba8unorm-srgb",
    "rgba8snorm",
    "rgba8uint",
    "rgba8sint",
    "bgra8unorm",
    "bgra8unorm-srgb",
    // Packed 32-bit formats
    "rgb9e5ufloat",
    "rgb10a2unorm",
    "rg11b10ufloat",

    // 64-bit 格式
    "rg32uint",
    "rg32sint",
    "rg32float",
    "rgba16uint",
    "rgba16sint",
    "rgba16float",

    // 128-bit 格式
    "rgba32uint",
    "rgba32sint",
    "rgba32float",

    // 深度和模板格式
    "stencil8",
    "depth16unorm",
    "depth24plus",
    "depth24plus-stencil8",
    "depth32float",

    // BC 压缩模式非常有用，如果设备和用户代理同时支持"texture-compression-bc"
    // 并且在 RequestDevice 中被开启。
    "bc1-rgba-unorm",
    "bc1-rgba-unorm-srgb",
    "bc2-rgba-unorm",
    "bc2-rgba-unorm-srgb",
    "bc3-rgba-unorm",
    "bc3-rgba-unorm-srgb",
    "bc4-r-unorm",
    "bc4-r-snorm",
    "bc5-rg-unorm",
    "bc5-rg-snorm",
    "bc6h-rgb-ufloat",
    "bc6h-rgb-float",
    "bc7-rgba-unorm",
    "bc7-rgba-unorm-srgb",

    // "depth24unorm-stencil8" 特性
    "depth24unorm-stencil8",

    // "depth32float-stencil8" 特性
    "depth32float-stencil8",
};
</script>

{{GPUTextureFormat/"depth24plus"}}) 和 {{GPUTextureFormat/"depth24plus-stencil8"}}) 的深度方面
格式可以实现为 24 位无符号归一化值（“depth24unorm”）
或 32 位 IEEE 754 浮点值（“depth32float”）。

问题：在 GPUAdapter(?) 上添加一些内容，以估算“stencil8”的每纹素字节数。

{{GPUTextureFormat/stencil8}} 格式可以实现为
一个真正的“stencil8”或“depth24stencil8”，其中深度方面是
隐藏且无法访问。

注意:
虽然对于可表示范围（0.0 到 1.0）中的所有值，depth32float 的精度严格高于 depth24unorm 的精度，但请注意，可表示值的集合并不完全相同：
对于depth24unorm，1 ULP 的常数值为1 / (2<sup>24</sup> &minus; 1);
对于depth32float，1 ULP 的变量值不大于1 / (2<sup>24</sup>)。

<dfn>renderable format</dfn> 要么是 <dfn>color renderable format</dfn>, 要么是  <dfn>depth or stencil renderable format</dfn>。
如果在 [[#plain-color-formats]] 中列出了具有 {{GPUTextureUsage/RENDER_ATTACHMENT}} 功能的格式，则它是可渲染颜色的格式。
任何其他格式都不是可呈现颜色的格式。 任何深度/模板格式都是深度或模板可渲染格式。 任何其他格式都不是深度或模板可渲染格式。

## <dfn interface>GPUExternalTexture</dfn> ## {#gpu-external-texture}

{{GPUExternalTexture}} 是包装外部视频对象的可采样纹理。
{{GPUExternalTexture}} 对象的内容可能不会改变，无论是从 WebGPU 内部（仅可采样）还是从 WebGPU 外部（例如由于视频帧推进）。

问题：使用画布更新此描述。

它们使用 {{GPUBindGroupLayoutEntry/externalTexture}} 绑定组布局条目成员绑定到绑定组布局。
外部纹理使用多个绑定槽：参见 [=Exceeds the binding slot limits=]。

<div class=note>
    外部纹理*可以*在不创建导入源的副本的情况下实现，但这取决于实现定义的因素。
    底层表示的所有权可能是独占的，也可能与其他所有者（例如视频解码器）共享，但这对应用程序不可见。

    外部纹理的底层表示是不可观察的（采样行为除外），但通常可能包括

    - 最多三个 2D 数据平面（例如 RGBA、Y+UV、Y+U+V）。
    - 在从这些平面（裁剪和旋转）读取之前转换坐标的元数据。
    - 用于将值转换为指定输出颜色空间（矩阵、伽马、3D LUT）的元数据。

    使用的配置可能在时间、系统、用户代理、媒体源、
    或单个视频源中的帧。
    为了解释许多可能的表示，
    对于*每个*外部纹理，绑定保守地使用以下内容：

    - 三个采样纹理绑定（最多 3 个平面），
    - 一个用于 3D LUT 的采样纹理绑定，
    - 一个采样器绑定来采样 3D LUT，以及
    - 一种统一的元数据缓冲区绑定。
</div>

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUExternalTexture {
};
GPUExternalTexture includes GPUObjectBase;
</script>

{{GPUExternalTexture}} 有以下内部插槽:

<dl dfn-type=attribute dfn-for="GPUExternalTexture">
    : <dfn>\[[destroyed]]</dfn>, `boolean` 格式
    ::
        表示对象是否被摧毁 (不能被使用).
        初始被设定为 `false`.

        <!-- 如果 GPUExternalTexture 变成 Serializable，则把其移动到内部对象 -->
</dl>

### 导入外部纹理 ### {#external-texture-creation}

外部纹理是从外部视频对象创建的
使用 {{GPUDevice/importExternalTexture()}}。

问题：使用画布更新此描述。

外部纹理被自动销毁，作为一个微任务，
而不是像其他资源一样手动或垃圾收集。

<script type=idl>
dictionary GPUExternalTextureDescriptor : GPUObjectDescriptorBase {
    required HTMLVideoElement source;
    GPUPredefinedColorSpace colorSpace = "srgb";
};
</script>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>importExternalTexture(descriptor)</dfn>
    ::
        创建一个 {{GPUExternalTexture}} 包装提供的图像源。

        <div algorithm=GPUDevice.importExternalTexture>
            **调用:** {{GPUDevice}} this.

            **参数:**
            <pre class=argumentdef for="GPUDevice/importExternalTexture(descriptor)">
                |descriptor|: 提供外部图像源对象（和任何创建选项）。
            </pre>

            **返回:** {{GPUExternalTexture}}

            1. 让 |source| 成为 |descriptor|.{{GPUExternalTextureDescriptor/source}}.

            1. 让 |usability| 是 检查图像参数的可用性|检查 |source| 的可用性的结果 （这可能会引发异常）。

            1. 如果 |usability| 是 `bad`, 抛出一个 {{InvalidStateError}} 并停止运行。

            1. 如果 |source| <l spec=html>[=is not origin-clean=]</l>,
                抛出一个 {{SecurityError}} 并停止运行。

            1. 让 |data| 是 |source| 的当前图像内容转换的结果 进入未预乘 alpha颜色空间
                |descriptor|.{{GPUExternalTextureDescriptor/colorSpace}} 。

                注意：这被描述为一个副本，但可以作为对只读基础数据的引用以及稍后执行转换的适当元数据来实现。

                问题：目前不确定默认颜色空间“srgb”是否为
                扩展 srgb 或钳位 srgb。
                这将在上游确定，因为围绕超级 srgb 图像源的语义得到定义。 不幸的是，我们现在不能回避它，因为视频源可能已经超出了 srgb 范围。
                上游决定将改变使用默认 colorSpace 选项是否会导致采样值大于 1.0。
                如果上游决定使“srgb”表示clamped-srgb，我们还可以选择将默认值更改为“extended-srgb”。

            1. 让 |result| 是一个新的 {{GPUExternalTexture}} 对象包装 |data|。

            1. [=Queue a microtask=] 将 |result|.{{GPUExternalTexture/[[destroyed]]}} 设置为 `true`，
                释放底层资源。

                问题：这是否过于严格？

            1. 返回 |result|.
        </div>
</dl>

### 采样外部纹理 ### {#external-texture-sampling}

外部纹理在 WGSL 中用 `texture_external` 表示，可以使用
`textureLoad` 和 `textureSampleLevel`。

提供给 `textureSampleLevel` 的 `sampler` 用于对底层纹理进行采样。
结果在 {{GPUExternalTextureDescriptor/colorSpace}} 设置的颜色空间中。
对于任何给定的外部纹理，采样器（和过滤）是在从底层值转换到指定颜色空间之前还是之后应用，这取决于实现。

注意：
如果内部表示是 RGBA 平面，则采样的行为与常规 2D 纹理相同。
如果有多个底层平面（例如 Y+UV），则在从 YUV 转换到指定颜色空间之前，使用采样器分别对每个底层纹理进行采样。


# 采样器 # {#samplers}

## <dfn interface>GPUSampler</dfn> ## {#sampler-interface}

一个{{GPUSampler}}对可在着色器中使用以解释纹理资源数据的变换和过滤信息进行编码。

{{GPUSampler|GPUSamplers}}通过{{GPUDevice/createSampler(descriptor)|GPUDevice.createSampler(optional descriptor)}}被创建，返回一个新的采样器对象。

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUSampler {
};
GPUSampler includes GPUObjectBase;
</script>

{{GPUSampler}}有以下内部插槽:

<dl dfn-type=attribute dfn-for="GPUSampler">
    : <dfn>\[[descriptor]]</dfn>, of type {{GPUSamplerDescriptor}}, readonly
    ::
        用于创建{{GPUSampler}}的{{GPUSamplerDescriptor}}。

    : <dfn>\[[isComparison]]</dfn> of type {{boolean}}.
    ::
        {GPUSampler}}是否被当作比较采样器。

    : <dfn>\[[isFiltering]]</dfn> of type {{boolean}}.
    ::
        {{GPUSampler}}是否对纹理的多个样本进行加权。
</dl>

## 采样器创建 ## {#sampler-creation}

### {{GPUSamplerDescriptor}} ### {#GPUSamplerDescriptor}

{{GPUSamplerDescriptor}}指定用于创建{{GPUSampler}}的选项。

<script type=idl>
dictionary GPUSamplerDescriptor : GPUObjectDescriptorBase {
    GPUAddressMode addressModeU = "clamp-to-edge";
    GPUAddressMode addressModeV = "clamp-to-edge";
    GPUAddressMode addressModeW = "clamp-to-edge";
    GPUFilterMode magFilter = "nearest";
    GPUFilterMode minFilter = "nearest";
    GPUFilterMode mipmapFilter = "nearest";
    float lodMinClamp = 0;
    float lodMaxClamp = 32;
    GPUCompareFunction compare;
    [Clamp] unsigned short maxAnisotropy = 1;
};
</script>

- {{GPUSamplerDescriptor/addressModeV}}、{{GPUSamplerDescriptor/addressModeV}}，和{{GPUSamplerDescriptor/addressModeW}}分别指定纹理宽度、高度和深度坐标的地址模式。
- {{GPUSamplerDescriptor/magFilter}}指定样本足迹小于或等于1纹素时的采样行为。
- {{GPUSamplerDescriptor/magFilter}}指定样本足迹大于1纹素时的采样行为。
- {{GPUSamplerDescriptor/mipmapFilter}}指定在两个mipmap级别之间进行采样的行为。
- {{GPUSamplerDescriptor/lodMinClamp}}和{{GPUSamplerDescriptor/lodMaxClamp}}分别指定了在对纹理进行采样时内部使用的最小和最大细节级别。
- 如果提供了{{GPUSamplerDescriptor/compare}}，则采样器将是具有指定{{GPUCompareFunction}}的比较采样器。
- {{GPUSamplerDescriptor/maxAnisotropy}}指定采样器使用的最大各向异性值限制。

    注意：大多数实现支持范围在1到16之间的{{GPUSamplerDescriptor/maxAnisotropy}}值，包括1和16。

问题：解释LOD是如何计算的，以及平台之间是否存在差异。

问题：解释什么是各向异性采样。

{{GPUAddressMode}}描述了采样器在采样足迹超出采样纹理边界时的行为。

问题：更详细地描述“样本足迹”。

<script type=idl>
enum GPUAddressMode {
    "clamp-to-edge",
    "repeat",
    "mirror-repeat"
};
</script>

<dl dfn-type="enum-value" dfn-for=GPUAddressMode>
    : <dfn>"clamp-to-edge"</dfn>
    ::
        纹理坐标被限制在0.0和1.0之间，包括0.0和1.0。

    : <dfn>"repeat"</dfn>
    ::
        纹理坐标环绕到纹理的另一侧。

    : <dfn>"mirror-repeat"</dfn>
    ::
        纹理坐标换行到纹理的另一侧，但当坐标的整数部分为奇数时，纹理会翻转。
</dl>

{{GPUFilterMode}}描述了采样器在样本足迹与一个纹素不完全匹配时的行为。

<script type=idl>
enum GPUFilterMode {
    "nearest",
    "linear"
};
</script>

<dl dfn-type="enum-value" dfn-for=GPUFilterMode>
    : <dfn>"nearest"</dfn>
    ::
        返回最接近纹理坐标的纹素值。

    : <dfn>"linear"</dfn>
    ::
        在每个维度中选择两个纹素并返回它们值之间的线性插值。
</dl>

{{GPUCompareFunction}}指定比较采样器的行为。如果在着色器中使用比较采样器，则将输入值与采样的纹理值进行比较，并将此比较测试的结果（0.0f表示通过，或1.0f表示失败）用于过滤操作。

问题：描述过滤如何与比较采样相互作用。

<script type=idl>
enum GPUCompareFunction {
    "never",
    "less",
    "equal",
    "less-equal",
    "greater",
    "not-equal",
    "greater-equal",
    "always"
};
</script>

<dl dfn-type="enum-value" dfn-for=GPUCompareFunction>
    : <dfn>"never"</dfn>
    ::
        从不通过比较测试。

    : <dfn>"less"</dfn>
    ::
        如果提供的值小于采样值，则通过比较测试。

    : <dfn>"equal"</dfn>
    ::
        如果提供的值等于采样值，则通过比较测试。

    : <dfn>"less-equal"</dfn>
    ::
        如果提供的值小于等于采样值，则通过比较测试。

    : <dfn>"greater"</dfn>
    ::
        如果提供的值大于采样值，则通过比较测试。
    : <dfn>"not-equal"</dfn>
    ::
        如果提供的值不等于采样值，则通过比较测试。

    : <dfn>"greater-equal"</dfn>
    ::
        如果提供的值大于等于采样值，则通过比较测试。

    : <dfn>"always"</dfn>
    ::
        永远通过比较测试。
</dl>

<div>
    <dfn abstract-op>validating GPUSamplerDescriptor</dfn>(device, descriptor)
    **参数:**
        - {{GPUDevice}} |设备|
        - {{GPUSamplerDescriptor}} |描述符|

    **Returns:** {{boolean}}

    当且仅当满足下列条件时，返回 `true`：
        - |设备|是有效的。
        - |descriptor|.{{GPUSamplerDescriptor/lodMinClamp}}大于等于0.
        - |descriptor|.{{GPUSamplerDescriptor/lodMaxClamp}}大于等于
            |descriptor|.{{GPUSamplerDescriptor/lodMinClamp}}。
        - |descriptor|.{{GPUSamplerDescriptor/maxAnisotropy}}大于等于1。
        - 当|descriptor|.{{GPUSamplerDescriptor/maxAnisotropy}}大于1时，|descriptor|.{{GPUSamplerDescriptor/magFilter}}, |descriptor|.{{GPUSamplerDescriptor/minFilter}}，和|descriptor|.{{GPUSamplerDescriptor/mipmapFilter}}必须等于{{GPUFilterMode/"linear"}}。
</div>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createSampler(descriptor)</dfn>
    ::
        创建一个{{GPUBindGroupLayout}}。

        <div algorithm=GPUDevice.createSampler>
            **Called on:** {{GPUDevice}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/createSampler(descriptor)">
                |descriptor|: 要创建的{{GPUSampler}}的描述。
            </pre>

            **Returns:** {{GPUSampler}}

            1. 使|s|为一个新的{{GPUSampler}}对象。
            2. 将|s|.{{GPUSampler/[[descriptor]]}}设置为|descriptor|.
            3. 如果|s|.{{GPUSampler/[[descriptor]]}}的{{GPUSamplerDescriptor/compare}}属性为 `null`或者undefined，将|s|.{{GPUSampler/[[isComparison]]}}设置为 `false`，否则，设置为 `true`。
            4. 如果{{GPUSamplerDescriptor/minFilter}}，{{GPUSamplerDescriptor/magFilter}}或{{GPUSamplerDescriptor/mipmapFilter}}没有任何其中之一的值为{{GPUFilterMode/"linear"}}，则将|s|.{{GPUSampler/[[isFiltering]]}}设置为 `false`，否则，设置为 `true`。
            5. 返回|s|。

            <div class=validusage dfn-for=GPUDevice.createSampler>
                <dfn abstract-op>有效使用</dfn>
                - 如果|描述符|不是 `null`或undefined：
                    - 如果[$validating GPUSamplerDescriptor$](this, |descriptor|)返回 `false`：
                        1. 在当前范围内生成一个{{GPUValidationError}}并带有恰当的错误消息。
                        2. 返回一个新的[=invalid=]{{GPUSampler}}并且返回结果。
            </div>
        </div>
</dl>


# 资源绑定 # {#bindings}

## <dfn interface>GPUBindGroupLayout</dfn> ## {#bind-group-layout}

{{GPUBindGroupLayout}} 定义了绑定在 {{GPUBindGroup}} 中的一组资源与其在着色器阶段的可访问性之间的接口。

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUBindGroupLayout {
};
GPUBindGroupLayout includes GPUObjectBase;
</script>

{{GPUBindGroupLayout}} 有以下内部插槽:

<dl dfn-type=attribute dfn-for=GPUBindGroupLayout>
    : <dfn>\[[descriptor]]</dfn>
    ::
</dl>

### 创建 ### {#bind-group-layout-creation}

{{GPUBindGroupLayout}} 是通过 {{GPUDevice/createBindGroupLayout()|GPUDevice.createBindGroupLayout()}} 创建的。

<script type=idl>
dictionary GPUBindGroupLayoutDescriptor : GPUObjectDescriptorBase {
    required sequence<GPUBindGroupLayoutEntry> entries;
};
</script>

{{GPUBindGroupLayoutEntry}} 描述了要包含在 {{GPUBindGroupLayout}} 中的单个着色器资源绑定。

<script type=idl>
typedef [EnforceRange] unsigned long GPUShaderStageFlags;
[Exposed=(Window, DedicatedWorker)]
namespace GPUShaderStage {
    const GPUFlagsConstant VERTEX   = 0x1;
    const GPUFlagsConstant FRAGMENT = 0x2;
    const GPUFlagsConstant COMPUTE  = 0x4;
};

dictionary GPUBindGroupLayoutEntry {
    required GPUIndex32 binding;
    required GPUShaderStageFlags visibility;

    GPUBufferBindingLayout buffer;
    GPUSamplerBindingLayout sampler;
    GPUTextureBindingLayout texture;
    GPUStorageTextureBindingLayout storageTexture;
    GPUExternalTextureBindingLayout externalTexture;
};
</script>

{{GPUBindGroupLayoutEntry}} 词典有以下成员：

<dl dfn-type=dict-member dfn-for=GPUBindGroupLayoutEntry>
    : <dfn>binding</dfn>
    ::
        {{GPUBindGroupLayoutEntry}} 中资源绑定的唯一标识符、相应的 {{GPUBindGroupEntry}} 和 {{GPUShaderModule}}。

    : <dfn>visibility</dfn>
    ::
        {{GPUShaderStage}} 成员的比特集。
        每个设置位表示 {{GPUBindGroupLayoutEntry}} 的资源
        可以从关联的着色器阶段访问。

    : <dfn>buffer</dfn>
    ::
        当不是 `undefined` 时，表示这个 {{GPUBindGroupLayoutEntry}} 的 [=binding resource type=]
        是 {{GPUBufferBinding}}。

    : <dfn>sampler</dfn>
    ::
        当不是 `undefined` 时，表示这个 {{GPUBindGroupLayoutEntry}} 的 [=binding resource type=]
        是 {{GPUSampler}}。

    : <dfn>texture</dfn>
    ::
        当不是 `undefined` 时，表示这个 {{GPUBindGroupLayoutEntry}} 的 [=binding resource type=]
        是 {{GPUTextureView}}。

    : <dfn>storageTexture</dfn>
    ::
        当不是 `undefined` 时，表示这个 {{GPUBindGroupLayoutEntry}} 的 [=binding resource type=]
        是 {{GPUTextureView}}。

    : <dfn>externalTexture</dfn>
    ::
        当不是 `undefined` 时，表示这个 {{GPUBindGroupLayoutEntry}} 的 [=binding resource type=]
        是 {{GPUExternalTexture}}。
</dl>

{{GPUBindGroupLayoutEntry}} 的 [=binding member=] 由定义了 {{GPUBindGroupLayoutEntry}} 的哪个成员决定：
{{GPUBindGroupLayoutEntry/buffer}}、{{GPUBindGroupLayoutEntry/sampler}}、
{{GPUBindGroupLayoutEntry/texture}}、{{GPUBindGroupLayoutEntry/storageTexture}} 或
{{GPUBindGroupLayoutEntry/externalTexture}}。
对于任何给定的 {{GPUBindGroupLayoutEntry}}，只能定义一个。
每个成员都有一个关联的 {{GPUBindingResource}} 类型，每个 [=binding type=] 都有一个关联的 [=internal usage=]，如下表所示：

<table class="data" style="white-space: nowrap">
    <thead>
        <tr>
            <th><dfn dfn>Binding member</dfn>
            <th><dfn dfn lt="Binding Resource Type">Resource type</dfn>
            <th><dfn dfn>Binding type</dfn><br>
            <th><dfn dfn>Binding usage/dfn>
    </thead>
    <tr>
        <td rowspan=3>{{GPUBindGroupLayoutEntry/buffer}}
        <td rowspan=3>{{GPUBufferBinding}}
        <td>{{GPUBufferBindingType/"uniform"}}
        <td>[=internal usage/constant=]
    <tr>
        <td>{{GPUBufferBindingType/"storage"}}
        <td>[=internal usage/storage=]
    <tr>
        <td>{{GPUBufferBindingType/"read-only-storage"}}
        <td>[=internal usage/storage-read=]

    <tr>
        <td rowspan=3>{{GPUBindGroupLayoutEntry/sampler}}
        <td rowspan=3>{{GPUSampler}}
        <td>{{GPUSamplerBindingType/"filtering"}}
        <td rowspan=3>[=internal usage/constant=]
    <tr>
        <td>{{GPUSamplerBindingType/"non-filtering"}}
    <tr>
        <td>{{GPUSamplerBindingType/"comparison"}}

    <tr>
        <td rowspan=5>{{GPUBindGroupLayoutEntry/texture}}
        <td rowspan=5>{{GPUTextureView}}
        <td>{{GPUTextureSampleType/"float"}}
        <td rowspan=5>[=internal usage/constant=]
    <tr>
        <td>{{GPUTextureSampleType/"unfilterable-float"}}
    <tr>
        <td>{{GPUTextureSampleType/"depth"}}
    <tr>
        <td>{{GPUTextureSampleType/"sint"}}
    <tr>
        <td>{{GPUTextureSampleType/"uint"}}

    <tr>
        <td>{{GPUBindGroupLayoutEntry/storageTexture}}
        <td>{{GPUTextureView}}
        <td>{{GPUStorageTextureAccess/"write-only"}}
        <td>[=internal usage/storage=]

    <tr>
        <td>{{GPUBindGroupLayoutEntry/externalTexture}}
        <td>{{GPUExternalTexture}}
        <td>
        <td>[=internal usage/constant=]
</table>

<div algorithm>
    如果用于限制的插槽数超过 |limits| 中支持的值，
    {{GPUBindGroupLayoutEntry}} 值的 [=list=] |entries| <dfn>exceeds the binding slot limits</dfn>xi [=supported limits=] |limits|。
    每个条目可以使用多个槽来实现多个限制。

    1. 对于每个 在 |entries| 中的 |entry| , 如果:
        <dl class=switch>
            : |entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/type}}
                是 {{GPUBufferBindingType/"uniform"}} 和
                |entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/hasDynamicOffset}} 是 `true`
            ::  1 {{supported limits/maxDynamicUniformBuffersPerPipelineLayout}} 槽会被使用。
            : |entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/type}}
                是 {{GPUBufferBindingType/"storage"}} 和
                |entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/hasDynamicOffset}} 是 `true`
            ::  1 {{supported limits/maxDynamicStorageBuffersPerPipelineLayout}} 槽会被使用。
        </dl>
    1. 对于每个着色器阶段 |stage| 在
        &laquo; {{GPUShaderStage/VERTEX}}, {{GPUShaderStage/FRAGMENT}}, {{GPUShaderStage/COMPUTE}} &raquo;:
        1. 对于每个 在 |entries| 中的 |entry| , 如果:
            |entry|.{{GPUBindGroupLayoutEntry/visibility}} 包含 |stage|, 如果:
            <dl class=switch>
                : |entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/type}}
                    是 {{GPUBufferBindingType/"uniform"}}
                ::  1 {{supported limits/maxUniformBuffersPerShaderStage}} 槽会被使用。
                : |entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/type}}
                    是 {{GPUBufferBindingType/"storage"}} 或者 {{GPUBufferBindingType/"read-only-storage"}}
                ::  1 {{supported limits/maxStorageBuffersPerShaderStage}} 槽会被使用。
                : |entry|.{{GPUBindGroupLayoutEntry/sampler}} 不是 `undefined`
                ::  1 {{supported limits/maxSamplersPerShaderStage}} 槽会被使用。
                : |entry|.{{GPUBindGroupLayoutEntry/texture}} 不是 `undefined`
                :: Consider 1 {{supported limits/maxSampledTexturesPerShaderStage}} 槽会被使用。
                : |entry|.{{GPUBindGroupLayoutEntry/storageTexture}} 不是 `undefined`
                :: Consider 1 {{supported limits/maxStorageTexturesPerShaderStage}} 槽会被使用。
                : |entry|.{{GPUBindGroupLayoutEntry/externalTexture}} 不是 `undefined`
                ::
                    4 {{supported limits/maxSampledTexturesPerShaderStage}} 槽，
                    1 {{supported limits/maxSamplersPerShaderStage}} 槽， 和
                    1 {{supported limits/maxUniformBuffersPerShaderStage}} 槽会被使用。
            </dl>
</div>

<script type=idl>
enum GPUBufferBindingType {
    "uniform",
    "storage",
    "read-only-storage",
};

dictionary GPUBufferBindingLayout {
    GPUBufferBindingType type = "uniform";
    boolean hasDynamicOffset = false;
    GPUSize64 minBindingSize = 0;
};
</script>

{{GPUBufferBindingLayout}} 词典有以下成员:

<dl dfn-type=dict-member dfn-for=GPUBufferBindingLayout>
    : <dfn>type</dfn>
    ::
        指示绑定到此绑定的缓冲区所需的类型。

    : <dfn>hasDynamicOffset</dfn>
    ::
        指示此绑定是否需要动态偏移量。

    : <dfn>minBindingSize</dfn>
    ::
        可用于指示最小缓冲区绑定大小。
</dl>

<script type=idl>
enum GPUSamplerBindingType {
    "filtering",
    "non-filtering",
    "comparison",
};

dictionary GPUSamplerBindingLayout {
    GPUSamplerBindingType type = "filtering";
};
</script>

{{GPUSamplerBindingLayout}} 词典有以下成员:

<dl dfn-type=dict-member dfn-for=GPUSamplerBindingLayout>
    : <dfn>type</dfn>
    ::
        指示绑定到此绑定的采样器的所需类型。
</dl>

<script type=idl>
enum GPUTextureSampleType {
  "float",
  "unfilterable-float",
  "depth",
  "sint",
  "uint",
};

dictionary GPUTextureBindingLayout {
    GPUTextureSampleType sampleType = "float";
    GPUTextureViewDimension viewDimension = "2d";
    boolean multisampled = false;
};
</script>

问题(https://github.com/gpuweb/gpuweb/issues/851): 如何使 {{GPUTextureBindingLayout/sampleType}} 真正可选。

{{GPUTextureBindingLayout}} 词典有以下成员:

<dl dfn-type=dict-member dfn-for=GPUTextureBindingLayout>
    : <dfn>sampleType</dfn>
    ::
        指示绑定到此绑定的纹理视图所需的类型。
    : <dfn>viewDimension</dfn>
    ::
        指示绑定到此绑定的纹理视图所需的 {{GPUTextureViewDescriptor/dimension}}。
        <!-- https://github.com/gpuweb/gpuweb/pull/339 -->

    : <dfn>multisampled</dfn>
    ::
        指示绑定到此绑定的纹理视图是否必须进行多重采样。
</dl>

<script type=idl>
enum GPUStorageTextureAccess {
    "write-only",
};

dictionary GPUStorageTextureBindingLayout {
    GPUStorageTextureAccess access = "write-only";
    required GPUTextureFormat format;
    GPUTextureViewDimension viewDimension = "2d";
};
</script>

问题(https://github.com/gpuweb/gpuweb/issues/851): 考虑时 {{GPUStorageTextureBindingLayout/format}} 真正可选。

{{GPUStorageTextureBindingLayout}} 词典有以下成员:

<dl dfn-type=dict-member dfn-for=GPUStorageTextureBindingLayout>
    : <dfn>access</dfn>
    ::
        指示绑定到此绑定的纹理视图是否将绑定为只读或
        只写访问。

    : <dfn>format</dfn>
    ::
        绑定到此绑定的纹理视图所需的 {{GPUTextureViewDescriptor/format}}。
    : <dfn>viewDimension</dfn>
    ::
        指示绑定到此绑定的纹理视图所需的 {{GPUTextureViewDescriptor/dimension}}。
        <!-- https://github.com/gpuweb/gpuweb/pull/339 -->
</dl>

<script type=idl>
dictionary GPUExternalTextureBindingLayout {
};
</script>

{{GPUBindGroupLayout}} 对象有以下内部插槽:

<dl dfn-type=attribute dfn-for="GPUBindGroupLayout">
    : <dfn>\[[entryMap]]</dfn> 是 [=ordered map=]&lt;{{GPUSize32}}, {{GPUBindGroupLayoutEntry}}&gt 类型。
    ::
        指向 {{GPUBindGroupLayoutEntry}} 的绑定索引映射，此 {{GPUBindGroupLayout}} 描述了该映射。

    : <dfn>\[[dynamicOffsetCount]]</dfn> 是 {{GPUSize32}} 类型。
    ::
        此 {{GPUBindGroupLayout}} 中具有动态偏移量的缓冲区绑定数。
    : <dfn>\[[exclusivePipeline]]</dfn>  {{GPUPipelineBase}} 类型?， 初始设定为 `null`。
    ::
        创建此 {{GPUBindGroupLayout}} 的管道，如果它是作为 [[#default-pipeline-layout|default pipeline layout]] 的一部分创建的。
        如果不是 `null`，则使用此 {{GPUBindGroupLayout}} 创建的 {{GPUBindGroup}} 只能与指定的 {{GPUPipelineBase}} 一起使用。
</dl>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createBindGroupLayout(descriptor)</dfn>
    ::
        创建一个 {{GPUBindGroupLayout}}。

        <div algorithm=GPUDevice.createBindGroupLayout>
            **调用:** {{GPUDevice}} |this|.

            **参数:**
            <pre class=argumentdef for="GPUDevice/createBindGroupLayout(descriptor)">
                |descriptor|: 要创建的 {{GPUBindGroupLayout}} 的描述。
            </pre>

            **返回:** {{GPUBindGroupLayout}}

            1. 让 |layout| 是一个新的有效 {{GPUBindGroupLayout}} 对象。
            1. 设置 |layout|.{{GPUBindGroupLayout/[[descriptor]]}} 为 |descriptor|.
            1. 在 |this| 的 [=Device timeline=] 上发出以下步骤:
                <div class=device-timeline>
                    1. 如果一下任一条件没有被满足:
                        <div class=validusage>
                            - |this| 是一个 [=valid=] {{GPUDevice}}.
                            - 在 |descriptor| 中每一个条目的 {{GPUBindGroupLayoutEntry/binding}} 是唯一的。
                            - |descriptor|.{{GPUBindGroupLayoutDescriptor/entries}} 必须不能
                                超过绑定槽限制|超过 |this|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}的绑定槽限制。
                            - |descriptor|.{{GPUBindGroupLayoutDescriptor/entries}} 中每一个条目的 {{GPUBindGroupLayoutEntry}}:
                                - 设定 |bufferLayout| 为 |entry|.{{GPUBindGroupLayoutEntry/buffer}}
                                - 设定 |samplerLayout| 为 |entry|.{{GPUBindGroupLayoutEntry/sampler}}
                                - 设定 |textureLayout| 为 |entry|.{{GPUBindGroupLayoutEntry/texture}}
                                - 设定 |storageTextureLayout| 为 |entry|.{{GPUBindGroupLayoutEntry/storageTexture}}

                                - |bufferLayout|， |samplerLayout|， |textureLayout|，
                                    或 |storageTextureLayout| 其中一个不是 `undefined`。

                                - 如果 |entry|.{{GPUBindGroupLayoutEntry/visibility}} 包含
                                    {{GPUShaderStage/VERTEX}}:
                                    - |entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/type}}
                                        必须不能是 {{GPUBufferBindingType/"storage"}}.
                                    - |entry|.{{GPUBindGroupLayoutEntry/storageTexture}}?.{{GPUStorageTextureBindingLayout/access}}
                                        必须不能是 {{GPUStorageTextureAccess/"write-only"}}.

                                - 如果 |textureLayout| 不是 `undefined` 并且
                                    |textureLayout|.{{GPUTextureBindingLayout/multisampled}} 是 `true`:
                                    - |textureLayout|.{{GPUTextureBindingLayout/viewDimension}} 是
                                        {{GPUTextureViewDimension/"2d"}}.
                                    - |textureLayout|.{{GPUTextureBindingLayout/sampleType}} 不是
                                        {{GPUTextureSampleType/"float"}} 或者 {{GPUTextureSampleType/"depth"}}.

                                - 如果 |storageTextureLayout| 不是 `undefined`:
                                    - |storageTextureLayout|.{{GPUStorageTextureBindingLayout/viewDimension}} 不是
                                        {{GPUTextureViewDimension/"cube"}} 或 {{GPUTextureViewDimension/"cube-array"}}.
                                    - |storageTextureLayout|.{{GPUStorageTextureBindingLayout/format}}
                                        必须是可以支持存储使用的格式。
                        </div>

                        Then:
                            1. 在当前范围内生成带有适当错误消息的 {{GPUValidationError}}。
                            1. 使 |layout| [=invalid=] 并且返回 |layout|。

                    1. Set |layout|.{{GPUBindGroupLayout/[[dynamicOffsetCount]]}} to the number of
                        entries in |descriptor| where {{GPUBindGroupLayoutEntry/buffer}} is not `undefined` and
                        {{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/hasDynamicOffset}} is `true`.
                    1. For each {{GPUBindGroupLayoutEntry}} |entry| in
                        |descriptor|.{{GPUBindGroupLayoutDescriptor/entries}}:
                        1. Insert |entry| into |layout|.{{GPUBindGroupLayout/[[entryMap]]}}
                            with the key of |entry|.{{GPUBindGroupLayoutEntry/binding}}.
                </div>
            1. 返回 |layout|.

        </div>
</dl>

### 兼容性 ### {#bind-group-compatibility}

<div algorithm>
两个 {{GPUBindGroupLayout}} 对象 |a| 和 |b| 是 <dfn dfn>group-equivalent</dfn>
当且仅当满足以下所有条件：
    - |a|.{{GPUBindGroupLayout/[[exclusivePipeline]]}} == |b|.{{GPUBindGroupLayout/[[exclusivePipeline]]}}.
    - 对于任何绑定编号|binding|，满足以下条件之一：
        - 编号在 |a|.{{GPUBindGroupLayout/[[entryMap]]}} 和 |b|.{{GPUBindGroupLayout/[[entryMap]]}} 中都丢失了。
        - |a|.{{GPUBindGroupLayout/[[entryMap]]}}[|binding|] == |b|.{{GPUBindGroupLayout/[[entryMap]]}}[|binding|]
</div>

如果绑定组布局是 [=group-equivalent=]，它们可以在所有内容中互换使用。

## <dfn interface>GPUBindGroup</dfn> ## {#gpu-bind-group}

{{GPUBindGroup}} 定义了一组要绑定到一个组中的资源
     以及如何在着色器阶段使用资源。

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUBindGroup {
};
GPUBindGroup includes GPUObjectBase;
</script>

### 绑定组创建 ### {#bind-group-creation}

一个 {{GPUBindGroup}} 通过 {{GPUDevice/createBindGroup()|GPUDevice.createBindGroup()}} 被创建。

<script type=idl>
dictionary GPUBindGroupDescriptor : GPUObjectDescriptorBase {
    required GPUBindGroupLayout layout;
    required sequence<GPUBindGroupEntry> entries;
};
</script>

{{GPUBindGroupEntry}} 描述了要绑定在 {{GPUBindGroup}} 中的单个资源。

<script type=idl>
typedef (GPUSampler or GPUTextureView or GPUBufferBinding or GPUExternalTexture) GPUBindingResource;

dictionary GPUBindGroupEntry {
    required GPUIndex32 binding;
    required GPUBindingResource resource;
};
</script>

<script type=idl>
dictionary GPUBufferBinding {
    required GPUBuffer buffer;
    GPUSize64 offset = 0;
    GPUSize64 size;
};
</script>

  * {{GPUBufferBinding/size}}: 如果未定义，则指定范围从
    {{GPUBufferBinding/offset}} 并在缓冲区末尾结束。

一个 {{GPUBindGroup}} 对象有以下内部插槽:

<dl dfn-type=attribute dfn-for="GPUBindGroup">
    : <dfn>\[[layout]]</dfn> {{GPUBindGroupLayout}} 类型。
    ::
        与此 {{GPUBindGroup}} 关联的 {{GPUBindGroupLayout}}。

    : <dfn>\[[entries]]</dfn> 是类型序列 <{{GPUBindGroupEntry}}>.
    ::
        此 {{GPUBindGroup}} 描述的 {{GPUBindGroupEntry}} 集。

    : <dfn>\[[usedResources]]</dfn> 是 [=ordered map=]&lt;[=subresource=], [=list=]&lt;[=internal usage=]&gt;&gt; 类型。
    ::
        此绑定组使用的缓冲区和纹理集 [=subresource=]，
        与 [=internal usage=] 标志的列表相关联。
</dl>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createBindGroup(descriptor)</dfn>
    ::
        创建一个 {{GPUBindGroup}}.

        <div algorithm=GPUDevice.createBindGroup>
            **调用:** {{GPUDevice}} |this|.

            **参数:**
            <pre class=argumentdef for="GPUDevice/createBindGroup(descriptor)">
                |descriptor|: Description of the {{GPUBindGroup}} to create.
            </pre>

            **返回:** {{GPUBindGroup}}

            1. 设定 |bindGroup| 为一个新的有效的 {{GPUBindGroup}} 对象。
            1. 设定 |limits| 为 |this|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}。
            1. 在 |this| 的 [=Device timeline=] 发布一下步骤:
                <div class=device-timeline>
                    1. 如果以下任一条件没有被满足：
                        <div class=validusage>
                            - |descriptor|.{{GPUBindGroupDescriptor/layout}} 与 |this| 一起使用是有效的。
                            - |descriptor|.{{GPUBindGroupDescriptor/layout}} 的 {{GPUBindGroupLayoutDescriptor/entries}}
                                的数量和 |descriptor|.{{GPUBindGroupDescriptor/entries}} 的数量完全相等。

                            对于每一个 |descriptor|.{{GPUBindGroupDescriptor/entries}} 中的
                                {{GPUBindGroupEntry}} |bindingDescriptor|:
                                - 设定 |resource| 为 |bindingDescriptor|.{{GPUBindGroupEntry/resource}}。
                                - 在 |descriptor|.{{GPUBindGroupDescriptor/layout}}.{{GPUBindGroupLayoutDescriptor/entries}} 中，
                                    只有一个 {{GPUBindGroupLayoutEntry}} |layoutBinding|
                                    使得 |layoutBinding|.{{GPUBindGroupLayoutEntry/binding}} 等于
                                    |bindingDescriptor|.{{GPUBindGroupEntry/binding}}。

                                - 如果为 |layoutBinding| 定义了 [=binding member=] 是
                                    <dl class="switch">
                                        : {{GPUBindGroupLayoutEntry/sampler}}
                                        ::
                                            - |resource| 是一个 {{GPUSampler}}.
                                            - |resource| 与 |this| 一起使用是有效的。
                                            - 如果 |layoutBinding|.{{GPUBindGroupLayoutEntry/sampler}}.{{GPUSamplerBindingLayout/type}} 是:
                                                <dl class="switch">
                                                    : {{GPUSamplerBindingType/"filtering"}}
                                                    :: |resource|.{{GPUSampler/[[isComparison]]}} 是 `false`.

                                                    : {{GPUSamplerBindingType/"non-filtering"}}
                                                    ::
                                                        |resource|.{{GPUSampler/[[isFiltering]]}} 是 `false`.
                                                        |resource|.{{GPUSampler/[[isComparison]]}} 是 `false`.

                                                    : {{GPUSamplerBindingType/"comparison"}}
                                                    :: |resource|.{{GPUSampler/[[isComparison]]}} 是 `true`.
                                                </dl>

                                        : {{GPUBindGroupLayoutEntry/texture}}
                                        ::
                                            - |resource| 是一个 {{GPUTextureView}}。
                                            - |resource| 与 |this| 一起使用是有效的。
                                            - 设置 |texture| 为 |resource|.{{GPUTextureView/[[texture]]}}.
                                            - |layoutBinding|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/viewDimension}}
                                                与 |resource| 的 {{GPUTextureViewDescriptor/dimension}} 相等。
                                            - |layoutBinding|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/sampleType}}
                                                是与 |resource| 的 {{GPUTextureViewDescriptor/format}}
                                                [[#texture-format-caps|兼容的]]。
                                            - |texture| 的 {{GPUTextureDescriptor/usage}} 包含 {{GPUTextureUsage/TEXTURE_BINDING}}.
                                            - 如果 |layoutBinding|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/multisampled}}
                                                是 `true`, |texture| 的 {{GPUTextureDescriptor/sampleCount}}
                                                &gt; `1`, 否则 |texture| 的 {{GPUTextureDescriptor/sampleCount}} 为 `1`.

                                        : {{GPUBindGroupLayoutEntry/storageTexture}}
                                        ::
                                            - |resource| 是一个 {{GPUTextureView}}。
                                            - |resource| 与 |this| 一起使用是有效的。
                                            - 设置 |texture| 为 |resource|.{{GPUTextureView/[[texture]]}}.
                                            - |layoutBinding|.{{GPUBindGroupLayoutEntry/storageTexture}}.{{GPUStorageTextureBindingLayout/viewDimension}}
                                                与 |resource| 的 {{GPUTextureViewDescriptor/dimension}} 相同。
                                            - |layoutBinding|.{{GPUBindGroupLayoutEntry/storageTexture}}.{{GPUStorageTextureBindingLayout/format}}
                                                与 |resource|.{{GPUTextureView/[[descriptor]]}}.{{GPUTextureViewDescriptor/format}} 相等。
                                            - |texture| 的 {{GPUTextureDescriptor/usage}} 包含 {{GPUTextureUsage/STORAGE_BINDING}}。

                                        :  {{GPUBindGroupLayoutEntry/buffer}}
                                        ::
                                            - |resource| 是一个 {{GPUBufferBinding}}.
                                            - |resource|.{{GPUBufferBinding/buffer}} 与 |this| 一起使用是有效的。
                                            - |resource|.{{GPUBufferBinding/offset}} 指定的绑定部分和
                                                |resource|.{{GPUBufferBinding/size}} 驻留在缓冲区内。
                                            - 有效绑定大小，即在
                                                |resource|.{{GPUBufferBinding/size}} 或派生自
                                                |resource|.{{GPUBufferBinding/offset}} 和完整的
                                                缓冲区的大小，大于或等于
                                                |layoutBinding|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/minBindingSize}}.

                                            - 如果 |layoutBinding|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/type}} 是
                                                <dl class="switch">
                                                    : {{GPUBufferBindingType/"uniform"}}
                                                    :: |resource|.{{GPUBufferBinding/buffer}}.{{GPUBufferDescriptor/usage}}
                                                        包含 {{GPUBufferUsage/UNIFORM}}。
                                                    :: |resource|.{{GPUBufferBinding/size}} &le;
                                                        |limits|.{{supported limits/maxUniformBufferBindingSize}}。
                                                    :: |resource|.{{GPUBufferBinding/offset}} 是
                                                        |limits|.{{supported limits/minUniformBufferOffsetAlignment}} 的倍数。
                                                    :: 问题：当 {{GPUBufferBinding/size}} 未设置时，此验证应考虑默认值。
                                                        还应该 {{GPUBufferBinding/size}} 默认为 `buffer.byteLength - offset` 或
                                                        `min(buffer.byteLength - offset, limits.maxUniformBufferBindingSize)`？

                                                    : {{GPUBufferBindingType/"storage"}} 或者
                                                        {{GPUBufferBindingType/"read-only-storage"}}
                                                    :: |resource|.{{GPUBufferBinding/buffer}}.{{GPUBufferDescriptor/usage}}
                                                        包含 {{GPUBufferUsage/STORAGE}}。
                                                    :: |resource|.{{GPUBufferBinding/size}} &le;
                                                        |limits|.{{supported limits/maxStorageBufferBindingSize}}.
                                                    :: |resource|.{{GPUBufferBinding/offset}} 是
                                                        |limits|.{{supported limits/minStorageBufferOffsetAlignment}} 的倍数。
                                                </dl>

                                    </dl>

                        </div>

                        Then:
                            1. 在当前范围内生成带有适当错误消息的 {{GPUValidationError}}。
                            1. 使 |bindGroup| [=invalid=] 并返回 |bindGroup|.

                    1. 设置 |bindGroup|.{{GPUBindGroup/[[layout]]}} =
                        |descriptor|.{{GPUBindGroupDescriptor/layout}}.
                    1. 设置 |bindGroup|.{{GPUBindGroup/[[entries]]}} =
                        |descriptor|.{{GPUBindGroupDescriptor/entries}}.
                    1. 设置 |bindGroup|.{{GPUBindGroup/[[usedResources]]}} = {}.

                    1. |descriptor|.{{GPUBindGroupDescriptor/entries}} 中的每一个 {{GPUBindGroupEntry}} |bindingDescriptor|:
                        1. 设定 |internalUsage| 为 [=binding usage=] 为了 |layoutBinding|。
                        1. |resource| 看到的每个 [=subresource=] 添加到 {{GPUBindGroup/[[usedResources]]}} 作为 |internalUsage|。
                </div>
            1. 返回 |bindGroup|.

            问题：单独定义“有效缓冲区绑定大小”。
        </div>
</dl>

## <dfn interface>GPUPipelineLayout</dfn> ## {#pipeline-layout}

{{GPUPipelineLayout}} 定义了在 {{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)|setBindGroup}}
中的命令编码期间设置的所有 {{GPUBindGroup}} 对象的资源和由设置的管道着色器之间的映射
{{GPURenderEncoderBase/setPipeline(pipeline)|GPURenderEncoderBase.setPipeline}} 或 {{GPUComputePassEncoder/setPipeline(pipeline)|GPUComputePassEncoder.setPipeline}}。

资源的完整绑定地址可以定义为以下三项：
   1. 着色器阶段蒙版，资源可见
   2. 绑定组索引
   3. 绑定号码

这个地址的组成部分也可以看作是一个管道的绑定空间。 {{GPUBindGroup}}（带有相应的 {{GPUBindGroupLayout}}）覆盖了固定绑定组索引的空间。 包含的绑定需要是着色器在此绑定组索引处使用的资源的超集。

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUPipelineLayout {
};
GPUPipelineLayout includes GPUObjectBase;
</script>

{{GPUPipelineLayout}} 有以下内部插槽：

<dl dfn-type=attribute dfn-for="GPUPipelineLayout">
    : <dfn>\[[bindGroupLayouts]]</dfn> [=list=]&lt;{{GPUBindGroupLayout}}&gt; 类型。
    ::
        在 {{GPUPipelineLayoutDescriptor/bindGroupLayouts|GPUPipelineLayoutDescriptor.bindGroupLayouts}} 中创建时提供的 {{GPUBindGroupLayout}} 对象。
</dl>

注意：对许多 {{GPURenderPipeline}} 或 {{GPUComputePipeline}} 管道使用相同的 {{GPUPipelineLayout}} 可以保证用户代理在这些管道之间切换时不需要在内部重新绑定任何资源。

<div class="example">
{{GPUComputePipeline}} 对象 X 是由 {{GPUPipelineLayout/[[bindGroupLayouts]]|GPUPipelineLayout.bindGroupLayouts}} A, B, C 创建。
{{GPUComputePipeline}} 对象 Y 是由 {{GPUPipelineLayout/[[bindGroupLayouts]]|GPUPipelineLayout.bindGroupLayouts}} A, D, C 创建。
假设命令编码序列有两个调度：

  1. {{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)|setBindGroup(0, ...)}}
  1. {{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)|setBindGroup(1, ...)}}
  1. {{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)|setBindGroup(2, ...)}}
  1. {{GPUComputePassEncoder/setPipeline(pipeline)|setPipeline(X)}}
  1. {{GPUComputePassEncoder/dispatch(x, y, z)|dispatch()}}
  1. {{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)|setBindGroup(1, ...)}}
  1. {{GPUComputePassEncoder/setPipeline(pipeline)|setPipeline(Y)}}
  1. {{GPUComputePassEncoder/dispatch(x, y, z)|dispatch()}}

在这种情况下，用户代理将不得不重新绑定组插槽 2 以进行第二次调度，
即使 {{GPUPipelineLayout/[[bindGroupLayouts]]|GPUPipelineLayout.bindGrouplayouts}} 的索引 2 处的 {{GPUBindGroupLayout}}，
或插槽 2 处的 {{GPUBindGroup}} 更改。
</div>

问题：是否应将此示例和注释移至某些“最佳实践”文档？

注意：{{GPUPipelineLayout}} 的预期用途是将最常见和最不频繁更改的绑定组放置在布局的“底部”，这意味着较低的绑定组插槽编号，例如 0 或 1。
绑定越频繁 group 需要在 draw call 之间改变，它的索引应该越高。
这个通用指南允许用户代理最小化绘制调用之间的状态变化，从而降低 CPU 开销。

### 创建 ### {#pipeline-layout-creation}

{{GPUPipelineLayout}} 是通过 {GPUDevice/createPipelineLayout()|GPUDevice.createPipelineLayout()}} 创建的。

<script type=idl>
dictionary GPUPipelineLayoutDescriptor : GPUObjectDescriptorBase {
    required sequence<GPUBindGroupLayout> bindGroupLayouts;
};
</script>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createPipelineLayout(descriptor)</dfn>
    ::
        创建一个 {{GPUPipelineLayout}}。

        <div algorithm=GPUDevice.createPipelineLayout>
            **调用:** {{GPUDevice}} |this|。

            **参数:**
            <pre class=argumentdef for="GPUDevice/createPipelineLayout(descriptor)">
                |descriptor|: 要创建的 {{GPUPipelineLayout}} 的描述。
            </pre>

            **返回:** {{GPUPipelineLayout}}

            1. 如果以下任一条件为满足：
                <div class=validusage>
                    设定 |limits| 为 |this|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}。

                    让 |allEntries| 是连接
                    |descriptor|.{{GPUPipelineLayoutDescriptor/bindGroupLayouts}} 中所有 |bgl| 的
                    |bgl|.{{GPUBindGroupLayout/[[descriptor]]}}.{{GPUBindGroupLayoutDescriptor/entries}} 的结果。

                    - |descriptor|.{{GPUPipelineLayoutDescriptor/bindGroupLayouts}} 中的每个 {{GPUBindGroupLayout}}
                        必须与 |this| 一起使用是有效的， 并且 {{GPUBindGroupLayout/[[exclusivePipeline]]}}
                        为 `null`。
                    - |descriptor|.{{GPUPipelineLayoutDescriptor/bindGroupLayouts}} 的 [=list/size=]
                        必须 &le; |limits|.{{supported limits/maxBindGroups}}。
                    - |allEntries| 必须不能超过绑定槽限制|超过绑定槽限制 |limits|。
                </div>

                Then:
                    1. 在当前范围内生成带有适当错误消息的 {{GPUValidationError}}。
                    1. 创建一个新的 [=invalid=] {{GPUPipelineLayout}} 并返回结果。

            1. 设定 |pl| 为一个新的 {{GPUPipelineLayout}} 对象。
            1. 设定 |pl|.{{GPUPipelineLayout/[[bindGroupLayouts]]}} 为
                |descriptor|.{{GPUPipelineLayoutDescriptor/bindGroupLayouts}}。
            1. 返回 |pl|。
        </div>
</dl>

注意：两个 {{GPUPipelineLayout}} 对象对于任何用法都被认为是等效的
如果它们的内部 {{GPUPipelineLayout/[[bindGroupLayouts]]}} 序列包含
{{GPUBindGroupLayout}} 对象是 [=group-equivalent=]。


# 着色器模块 # {#shader-modules}

## <dfn interface>GPUShaderModule</dfn> ## {#shader-module}

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUShaderModule {
    Promise<GPUCompilationInfo> compilationInfo();
};
GPUShaderModule includes GPUObjectBase;
</script>

{{GPUShaderModule}}是可序列化的。它是对内部着色器模块对象的引用，而{{Serializable}}意味着该引用可以在域（线程/worker）之间复制，从而允许多个域同时访问它。由于{{GPUShaderModule}}是不可变的，因此不存在竞争条件。

问题(gpuweb/gpuweb#354): 完成定义多线程API并将 `[Serializable]` 添加回接口。

### 着色器模块创建 ### {#shader-module-creation}

<script type=idl>
dictionary GPUShaderModuleDescriptor : GPUObjectDescriptorBase {
    required USVString code;
    object sourceMap;
};
</script>

{{GPUShaderModuleDescriptor/sourceMap}}，如果定义，可以解释为source-map-v3格式。Source maps是可选的，但它作为支持开发工具集成（例如源语言调试）的标准化方法。
[[SourceMap]]

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createShaderModule(descriptor)</dfn>
    ::
        创建一个{{GPUShaderModule}}.

        <div algorithm=GPUDevice.createShaderModule>
            **Called on:** {{GPUDevice}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/createShaderModule(descriptor)">
                descriptor: 要创建的{{GPUShaderModule}}的描述。
            </pre>

            **Returns:** {{GPUShaderModule}}

            问题：描述{{GPUDevice/createShaderModule()}}算法步骤。
        </div>
</dl>

### 着色器模块编译信息 ### {#shader-module-compilation-information}

<script type=idl>
enum GPUCompilationMessageType {
    "error",
    "warning",
    "info"
};

[Exposed=(Window, DedicatedWorker), Serializable, SecureContext]
interface GPUCompilationMessage {
    readonly attribute DOMString message;
    readonly attribute GPUCompilationMessageType type;
    readonly attribute unsigned long long lineNum;
    readonly attribute unsigned long long linePos;
    readonly attribute unsigned long long offset;
    readonly attribute unsigned long long length;
};

[Exposed=(Window, DedicatedWorker), Serializable, SecureContext]
interface GPUCompilationInfo {
    readonly attribute FrozenArray<GPUCompilationMessage> messages;
};
</script>

{{GPUCompilationMessage}}是由{{GPUShaderModule}}编译器生成的信息、警告或错误消息。 这些消息旨在让人类可读，以帮助开发人员诊断着色器{{GPUShaderModuleDescriptor/code}}的问题。每个消息可能对应于着色器代码中的单个点、着色器代码的子串，或者可能根本不对应于代码中的任何特定点。

{{GPUCompilationMessage}}具有以下属性：

<dl dfn-type=attribute dfn-for=GPUCompilationMessage>
    : <dfn>message</dfn>
    ::
        一个人类可读的包含着色器编译时产生的消息的字符串。

    : <dfn>type</dfn>
    ::
        消息的重要性级别。

    : <dfn>lineNum</dfn>
    ::
        {{GPUCompilationMessage/message}}对应的着色器代码中的行号。值是one-based，这样lineNum为1表示着色器{{GPUShaderModuleDescriptor/code}}的第一行。

        如果{{GPUCompilationMessage/message}}对应于子字符串，则它指向子字符串开始的行。如果消息不对应着色器代码中的任何特定点，则必须为0。

        问题：在[定义行是什么]时参考WGSL规范(https://gpuweb.github.io/gpuweb/wgsl/#comments)。

    : <dfn>linePos</dfn>
    ::
        从着色器{{GPUShaderModuleDescriptor/code}}的{{GPUCompilationMessage/lineNum}}行的开头到{{GPUCompilationMessage/message}}对应的子字符串的点或开头的偏移量，以UTF-16代码单元为单位。值是one-based，这样{{GPUCompilationMessage/linePos}}为1表示该行的第一个字符。

        如果{{GPUCompilationMessage/message}}对应于子字符串，则它指向子字符串的第一个UTF-16代码单元。如果消息不对应着色器代码中的任何特定点，则必须为0。

    : <dfn>offset</dfn>
    ::
        从UTF-16代码单元中的着色器{{GPUShaderModuleDescriptor/code}}的开头到{{GPUCompilationMessage/message}}对应的子字符串的点或开头的偏移量。必须引用与{{GPUCompilationMessage/lineNum}}和{{GPUCompilationMessage/linePos}}相同的位置。如果{{GPUCompilationMessage/message}}不对应着色器{{GPUShaderModuleDescriptor/code}}中的任何特定点，则必须为0。

    : <dfn>length</dfn>
    ::
        {{GPUCompilationMessage/message}}对应的子字符串中UTF-16代码单元的数量。如果消息与子字符串不对应，则{{GPUCompilationMessage/length}}必须为0。
</dl>

注意：{{GPUCompilationMessage}}.{{GPUCompilationMessage/lineNum}}和
{{GPUCompilationMessage}}.{{GPUCompilationMessage/linePos}}是one-based，因为它们最常见的用途是打印人类可读的消息，这些消息可以与许多文本编辑器中显示的行号和列号相关联。

注意：{{GPUCompilationMessage}}.{{GPUCompilationMessage/offset}}和{{GPUCompilationMessage}}.{{GPUCompilationMessage/length}}适合传递给 `substr()` 以检索{{GPUCompilationMessage/message}}对应的着色器{{GPUShaderModuleDescriptor/code}}的子字符串。

<dl dfn-type=method dfn-for=GPUShaderModule>
    : <dfn>compilationInfo()</dfn>
    ::
        返回{{GPUShaderModule}}编译时产生的任何消息。

        <div algorithm=GPUShaderModule.compilationInfo>
            **Called on:** {{GPUShaderModule}} this.

            **Returns:** {{Promise}}&lt;{{GPUCompilationInfo}}&gt;

            问题：描述{{GPUShaderModule/compilationInfo()}}算法步骤。
        </div>
</dl>


# 管道 # {#pipelines}

一个 <dfn dfn>pipeline</dfn>，无论是 {{GPUComputePipeline}} 还是 {{GPURenderPipeline}}，
表示由 GPU 硬件、驱动程序、
和用户代理，以绑定和顶点缓冲区的形式处理输入数据，
并产生一些输出，如输出渲染目标中的颜色。

在结构上，[=pipeline=] 由一系列可编程阶段（着色器）组成
和固定功能状态，例如混合模式。

注意：在内部，取决于目标平台，
驱动程序可能会将一些固定功能状态转换为着色器代码，
并将其与用户提供的着色器链接在一起。
这种链接是将对象作为一个整体创建的原因之一。

此组合状态创建为单个对象
（通过 {{GPUDevice/createComputePipeline(descriptor)|GPUDevice.createComputePipeline()}} 或 {{GPUDevice/createRenderPipeline(descriptor)|GPUDevice.createRenderPipeline()}}），
并切换为一个
（相应地通过 {{GPUComputePassEncoder/setPipeline(pipeline)|GPUComputePassEncoder.setPipeline}} 或 {{GPURenderEncoderBase/setPipeline(pipeline)|GPURenderEncoderBase.setPipeline}}）。

## 基础管道 ## {#pipeline-base}

<script type=idl>
dictionary GPUPipelineDescriptorBase : GPUObjectDescriptorBase {
    GPUPipelineLayout layout;
};

interface mixin GPUPipelineBase {
    GPUBindGroupLayout getBindGroupLayout(unsigned long index);
};
</script>

{{GPUPipelineBase}} 有以下内部插槽:

<dl dfn-type=attribute dfn-for="GPUPipelineBase">
    : <dfn>\[[layout]]</dfn> of type `GPUPipelineLayout`.
    ::
        可以与 `this` 一起使用的资源布局的定义.
</dl>

{{GPUPipelineBase}} 有以下方法:

<dl dfn-type=method dfn-for=GPUPipelineBase>
    : <dfn>getBindGroupLayout(index)</dfn>
    ::
        获取一个 {{GPUBindGroupLayout}}，它与 `index` 处的 {{GPUPipelineBase}} 的 {{GPUBindGroupLayout}} 兼容。

        <div algorithm=GPUPipelineBase.getBindGroupLayout>
            **调用:** {{GPUPipelineBase}} |this|.

            **参数:**
            <pre class=argumentdef for="GPUPipelineBase/getBindGroupLayout(index)">
                |index|: 对管道布局的 {{GPUPipelineLayout/[[bindGroupLayouts]]}} 序列的索引。
            </pre>

            **返回:** {{GPUBindGroupLayout}}

            1. 如果 |index| &ge;
                |this|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxBindGroups}}:
                1. 抛出一个 {{RangeError}}.

            1. 如果 |this| 不是 [=valid=]:
                1. 返回一个新的错误的 {{GPUBindGroupLayout}}.

            1. 返回一个新的 {{GPUBindGroupLayout}} 对象引用相同的内部对象
                |this|.{{GPUPipelineBase/[[layout]]}}.{{GPUPipelineLayout/[[bindGroupLayouts]]}}[|index|].

            问题：一旦我们拥有 {{GPUBindGroupLayout}} 的内部对象，请更正确地指定此项。
            或者，只有规范作为 [=group-equivalent=] 的新内部对象

            注意：仅返回新的 {{GPUBindGroupLayout}} 对象可确保 [=Content timeline=] 和 [=Device timeline=] 之间不需要同步。
        </div>
</dl>

### 默认管道布局 ### {#default-pipeline-layout}

在没有 {{GPUPipelineDescriptorBase/layout}} 的情况下创建的 {{GPUPipelineBase}} 对象具有创建和使用的默认布局。

<div algorithm="default pipeline layout creation">

要为 {{GPUPipelineBase}} |pipeline| 创建 <dfn abstract-op>default pipeline layout</dfn>，
运行以下步骤：

    1. 让 |groupDescs| 是一系列 |device|.{{device/[[limits]]}}.{{supported limits/maxBindGroups}}
        新的 {{GPUBindGroupLayoutDescriptor}} 对象。
    1. 对于每个在 |groupDescs| 中的 |groupDesc|:

        1. 设置 |groupDesc|.{{GPUBindGroupLayoutDescriptor/entries}} 为一个空序列。

    1. 对于每个 {{GPUProgrammableStage}} |stageDesc| 在用于创建 |pipeline| 的描述符中:

        1. 让 |stageInfo| 是 |stageDesc| 的“反射信息”。

            问题：定义反射信息概念，以便此规范可以与 WGSL 规范接口，并获取特定入口点的 {{GPUShaderModule}} 接口的信息。

        1. 让 |shaderStage| 成为 |stageDesc|.{{GPUProgrammableStage/module}} 中
            |stageDesc|.{{GPUProgrammableStage/entryPoint}} 的 {{GPUShaderStageFlags}}。
        1. 对于每个资源 |resource| 在 |stageInfo| 的资源接口中：

            1. 让 |group| 成为 |resource| 的 “group” 装饰。
            1. 让 |binding| 成为 |resource| 的 "binding" 装饰。
            1. 让 |entry| 成为一个新的 {{GPUBindGroupLayoutEntry}}.
            1. 设定 |entry|.{{GPUBindGroupLayoutEntry/binding}} 为 |binding|.
            1. 设定 |entry|.{{GPUBindGroupLayoutEntry/visibility}} 为 |shaderStage|.
            1. 如果 |resource| 用于采样器绑定:

                1. 让 |samplerLayout| 成为一个新的 {{GPUSamplerBindingLayout}}.
                1. 设置 |entry|.{{GPUBindGroupLayoutEntry/sampler}} 为 |samplerLayout|.

            1. 如果 |resource| 用于比较采样器绑定:

                1. 让 |samplerLayout| 成为一个新的 {{GPUSamplerBindingLayout}}.
                1. 设置 |samplerLayout|.{{GPUSamplerBindingLayout/type}} 为 {{GPUSamplerBindingType/"comparison"}}.
                1. 设置 |entry|.{{GPUBindGroupLayoutEntry/sampler}} 为 |samplerLayout|.

            1. 如果 |resource| 用于缓冲区绑定:

                1. 让 |bufferLayout| 成为一个新的 {{GPUBufferBindingLayout}}.

                1. 设置 |bufferLayout|.{{GPUBufferBindingLayout/minBindingSize}} 为 |resource| 的缓冲区绑定大小的最小值.

                    问题：链接到“反射信息”中“最小缓冲区绑定大小”的定义。

                1. 如果 |resource| 用于只读存储缓冲区:

                    1. 设定 |bufferLayout|.{{GPUBufferBindingLayout/type}} 为 {{GPUBufferBindingType/"read-only-storage"}}.

                1. 如果 |resource| 用于存储缓冲区:

                    1. 设置 |bufferLayout|.{{GPUBufferBindingLayout/type}} 为 {{GPUBufferBindingType/"storage"}}.

                1. 设置 |entry|.{{GPUBindGroupLayoutEntry/buffer}} 为 |bufferLayout|.

            1. 如果 |resource| 用于采样纹理绑定:

                1. 设置 |textureLayout| 为一个新的 {{GPUTextureBindingLayout}}.

                1. 如果 |resource| 用于深度采样纹理绑定:
                    - 设置 |textureLayout|.{{GPUTextureBindingLayout/sampleType}} 为 {{GPUTextureSampleType/"depth"}}

                    如果 |resource| 的采样类型是:

                    -
                        <dl class=switch>
                            : `f32` 并且 |resource| 与着色器中内置的 textureSample* 静态使用
                            :: 设置 |textureLayout|.{{GPUTextureBindingLayout/sampleType}} 为 {{GPUTextureSampleType/"float"}}
                            : `f32`
                            :: 设置 |textureLayout|.{{GPUTextureBindingLayout/sampleType}} 为 {{GPUTextureSampleType/"unfilterable-float"}}
                            : `i32`
                            :: 设置 |textureLayout|.{{GPUTextureBindingLayout/sampleType}} 为 {{GPUTextureSampleType/"sint"}}
                            : `u32`
                            :: 设置 |textureLayout|.{{GPUTextureBindingLayout/sampleType}} 为 {{GPUTextureSampleType/"uint"}}
                        </dl>

                1. 设置 |textureLayout|.{{GPUTextureBindingLayout/viewDimension}} 为 |resource| 的维度。
                1. 如果 |resource| 用于多重采样纹理:

                    1. 设置 |textureLayout|.{{GPUTextureBindingLayout/multisampled}} 为 `true`.

                1. 设置 |entry|.{{GPUBindGroupLayoutEntry/texture}} 为 |textureLayout|.

            1. 如果 |resource| 用于存储纹理绑定:

                1. 让 |storageTextureLayout| 成为一个新的 {{GPUStorageTextureBindingLayout}}。
                1. 设置 |storageTextureLayout|.{{GPUStorageTextureBindingLayout/format}} 为 |resource| 的格式。
                1. 设置 |storageTextureLayout|.{{GPUStorageTextureBindingLayout/viewDimension}} 为 |resource| 的维度。

                1. 如果 |resource| 用于只写存储纹理:

                    1. 设置 |storageTextureLayout|.{{GPUStorageTextureBindingLayout/access}} 为 {{GPUStorageTextureAccess/"write-only"}}。

                1. 设置 |entry|.{{GPUBindGroupLayoutEntry/storageTexture}} 为 |storageTextureLayout|。

            1. 如果 |groupDescs|[|group|] 有一个条目 |previousEntry| {{GPUBindGroupLayoutEntry/binding}} 等于 |binding|：

                1. 如果 |entry| 具有与 |previousEntry| 不同的 {{GPUBindGroupLayoutEntry/visibility}}:

                    1. 将 |entry|.{{GPUBindGroupLayoutEntry/visibility}} 中设置的位添加到 |previousEntry|.{{GPUBindGroupLayoutEntry/visibility}}

                1. 如果 |resource| 用于缓冲区绑定和 |entry| 有比 |previousEntry| 更大的
                    {{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/minBindingSize}}:

                    1. 设置 |previousEntry|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/minBindingSize}}
                        为 |entry|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/minBindingSize}}。

                1. 如果 |resource| 是一个采样的纹理绑定和 |entry| 具有与 |previousEntry| 不同的 {{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/sampleType}}
                    并且两者 |entry| 和 |previousEntry| 有 {{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/sampleType}}
                    或 {{GPUTextureSampleType/"float"}} 或 {{GPUTextureSampleType/"unfilterable-float"}}：
                    1. 设置 |previousEntry|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/sampleType}} 为
                        {{GPUTextureSampleType/"float"}}.

                1. 如果任何其他属性在 |entry| 之间不相等 和 |previousEntry|:

                    1. 返回 `null`（这将导致管道的创建失败）。

            1. 其他

                1. 附加 |entry| 到 |groupDescs|[|group|]。

    1. 让 |groupLayouts| 成为一个新的序列。
    1. 对于每一个在 |groupDescs| 中的 |groupDesc|:

        1. 让 |bindGroupLayout| 成为调用 |device|.{{GPUDevice/createBindGroupLayout()}}(|groupDesc|) 的结果。
        1. 设置 |bindGroupLayout|.{{GPUBindGroupLayout/[[exclusivePipeline]]}} 为 |pipeline|。
        1. 附加 |bindGroupLayout| 到 |groupLayouts|。

    1. 让 |desc| 成为一个新的 {{GPUPipelineLayoutDescriptor}}。
    1. 设置 |desc|.{{GPUPipelineLayoutDescriptor/bindGroupLayouts}} 为 |groupLayouts|。
    1. 返回 |device|.{{GPUDevice/createPipelineLayout()}}(|desc|)。

    问题：这会用空的绑定组填充管道布局。 一旦指定了空绑定组的行为，请重新访问。

</div>

### <dfn dictionary>GPUProgrammableStage</dfn> ### {#GPUProgrammableStage}

{{GPUProgrammableStage}} 描述了用户提供的 {{GPUShaderModule}} 中的入口点，该入口点控制 [=pipeline=] 的可编程阶段之一。

<script type=idl>
dictionary GPUProgrammableStage {
    required GPUShaderModule module;
    required USVString entryPoint;
    record<USVString, GPUPipelineConstantValue> constants;
};

typedef double GPUPipelineConstantValue; // May represent WGSL's bool, f32, i32, u32.
</script>

<dl dfn-for=GPUProgrammableStage dfn-type=dict-member>
    : <dfn>constants</dfn>
    ::
        指定着色器模块 {{GPUProgrammableStage/module}} 中 [=pipeline-overridable=] 常量的值。

        每个这样的 [=pipeline-overridable=] 常量都由单个 [=pipeline-overridable constant identifier string==]
         唯一标识（表示常量的数字 ID，如果指定了一个，否则表示常量的标识符名称）。

        每个键值对的键必须等于一个这样的常量的标识符字符串。
        执行管道时，该常量将具有指定的值。

        值被指定为 <dfn typedef for=>GPUPipelineConstantValue</dfn>，它是一个 `double`，
        它被转换为相应管道可覆盖常量的 WGSL 数据类型（`bool`、`i32`、`u32`、 或 `f32`) 通过 [=converted to an IDL value|an IDL value=|一个 IDL 值=]
        {{boolean}}、{{long}}、{{unsigned long}} 或 {{float}}）。

        <div class=example>
            Pipeline-overridable constants defined in WGSL:

            <pre highlight=rust>
                [[override(0)]]    let has_point_light: bool = true; // 算法控制。
                [[override(1200)]] let specular_param: f32 = 2.3;    // 数字控制。
                [[override(1300)]] let gain: f32;                    // 必须被覆盖。
                [[override]]       let width: f32 = 0.0;             // 在 API 级别指定
                                                                     //   使用名称“宽度”。
                [[override]]       let depth: f32;                   // 在 API 级别指定
                                                                     //   使用名称“深度”。.
                                                                     //   必须被覆盖。
            </pre>

            相应的 JavaScript 代码，仅提供所需的覆盖
            （没有默认值）：

            <pre highlight=js>
                {
                    // ...
                    constants: {
                        1300: 2.0,  // "gain"
                        depth: -1,  // "depth"
                    }
                }
            </pre>

            Corresponding JavaScript code, overriding all constants:

            <pre highlight=js>
                {
                    // ...
                    constants: {
                        0: false,   // "has_point_light"
                        1200: 3.0,  // "specular_param"
                        1300: 2.0,  // "gain"
                        width: 20,  // "width"
                        depth: -1,  // "depth"
                    }
                }
            </pre>
        </div>
</dl>

<div algorithm>
    <dfn abstract-op>validating GPUProgrammableStage</dfn>(stage, descriptor, layout)

    **参数:**
    - {{GPUShaderStage}} |stage|
    - {{GPUProgrammableStage}} |descriptor|
    - {{GPUPipelineLayout}} |layout|

    如果满足以下所有条件，则返回 `true`：

    - |descriptor|.{{GPUProgrammableStage/module}} 必须是一个 [=valid=] {{GPUShaderModule}}.
    - |descriptor|.{{GPUProgrammableStage/module}} 必须包含
        一个入口点，用于着色器阶段 |stage|，
        名为 |descriptor|.{{GPUProgrammableStage/entryPoint}}。
    - 对于每个 |binding| 即着色器入口点的 [=statically used=] ：
        - [$validating shader binding$](|binding|, |layout|) 必须返回 `true`。
    - 对于入口点 [=statically used=] 的每个纹理采样着色器调用:
        1. 让 |texture| 是与调用中的采样纹理对应的 {{GPUBindGroupLayoutEntry}}。
        1. 让 |sampler| 是与调用中使用的采样器对应的 {{GPUBindGroupLayoutEntry}}。
        1. 如果 |sampler|.{{GPUSamplerBindingLayout/type}} 是 {{GPUSamplerBindingType/"filtering"}},
            那么 |texture|.{{GPUTextureBindingLayout/sampleType}} 必须不是
            {{GPUTextureSampleType/"unfilterable-float"}}。
    - 对于每个 |key| 在 |descriptor|.{{GPUProgrammableStage/constants}} 的 [=map/get the keys|the keys=] 中：
        - |key| 必须等于着色器模块中定义的某些 [=pipeline-overridable=] 的 [=pipeline-overridable constant identifier string=] |descriptor|.{{GPUProgrammableStage/module}}。
    - 对于每个 [=pipeline-overridable constant identifier string=] |key| 这是着色器入口点的 [=statically accessed=]：
        - 如果由 |key| 标识的管道可覆盖常量
            [=pipeline-overridable constant has a default value|does not have a default value=],
            |descriptor|.{{GPUProgrammableStage/constants}} 必须 [=map/contain=] |key|。
</div>

<div algorithm>
    <dfn abstract-op>validating shader binding</dfn>(binding, layout)

    **参数:**
        - 着色器绑定声明|变量|，从着色器模块反射的模块范围变量声明
        - {{GPUPipelineLayout}} |layout|

    让 |bindGroup| 是绑定组索引，和 |bindIndex| 是着色器绑定声明 |variable| 的绑定索引。

    如果满足以下所有条件，则返回 `true`：

        - |layout|.{{GPUPipelineLayout/[[bindGroupLayouts]]}}[|bindGroup|] 包含
            一个 {{GPUBindGroupLayoutEntry}} |entry| 其中 |entry|.{{GPUBindGroupLayoutEntry/binding}} == |bindIndex|.
        - 如果对于 |entry| 被定义的 [=binding member=] 是:
            <dl class=switch>
                : {{GPUBindGroupLayoutEntry/buffer}}
                ::
                    如果 |entry|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/type}} 是:
                    <dl class=switch>
                        : {{GPUBufferBindingType/"uniform"}}
                        :: |variable| 使用存储类 `uniform` 声明。
                        : {{GPUBufferBindingType/"storage"}}
                        :: |variable| 使用存储类 `storage` 和访问模式 `read_write` 声明。
                        : {{GPUBufferBindingType/"read-only-storage"}}
                        :: |variable| 使用存储类 `storage` 和访问模式 `read` 声明。
                    </dl>
                ::
                    如果 |entry|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/minBindingSize}} 不是 `0`:
                    - 如果着色器中定义的相应结构体的最后一个字段具有无界数组类型，
                        然后是 |entry|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/minBindingSize}} 的值
                        必须大于或等于该字段的字节偏移量加上无界数组的步幅。
                    - 如果相应的着色器结构没有以无界数组类型结尾，
                        然后是 |entry|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/minBindingSize}} 的值
                        必须大于或等于结构的大小。

                : {{GPUBindGroupLayoutEntry/sampler}}
                ::
                    如果 |entry|.{{GPUBindGroupLayoutEntry/sampler}}.{{GPUSamplerBindingLayout/type}} 是:
                    <dl class=switch>
                        : {{GPUSamplerBindingType/"filtering"}} 或者 {{GPUSamplerBindingType/"non-filtering"}}
                        :: |variable| 是 `sampler` 类型
                        : {{GPUSamplerBindingType/"comparison"}}
                        :: |variable| 是 `comparison_sampler` 类型。
                    </dl>

                : {{GPUBindGroupLayoutEntry/texture}}
                ::
                    当且仅当，
                    |entry|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/multisampled}}
                    是 `true`，|变量| 类型为 `texture_multisampled_2d<T>` 或 `texture_depth_multisampled_2d<T>`。
                ::
                    如果 |entry|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/sampleType}} 是:
                    <dl class=switch>
                        : {{GPUTextureSampleType/"float"}}, {{GPUTextureSampleType/"unfilterable-float"}},
                            {{GPUTextureSampleType/"sint"}} 或 {{GPUTextureSampleType/"uint"}}
                        ::
                            |variable| 是类型 `texture_1d<T>`, `texture_2d<T>`, `texture_2d_array<T>`,
                            `texture_cube<T>`, `texture_cube_array<T>`, `texture_3d<T>`, 或
                            `texture_multisampled_2d<T>`.
                        ::
                            如果 |entry|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/sampleType}} 是:
                            <dl class=switch>
                                : {{GPUTextureSampleType/"float"}} or {{GPUTextureSampleType/"unfilterable-float"}}
                                :: 采样类型 `T` 是 `f32`.
                                : {{GPUTextureSampleType/"sint"}}
                                :: 采样类型 `T` 是 `i32`.
                                : {{GPUTextureSampleType/"uint"}}
                                :: 采样类型 `T` 是 `u32`.
                            </dl>

                        : {{GPUTextureSampleType/"depth"}}
                        ::
                            |variable| 是类型 `texture_depth_2d`, `texture_depth_2d_array`,
                            `texture_depth_cube`, `texture_depth_cube_array`, 或 `texture_depth_multisampled_2d`.
                    </dl>
                ::
                    如果 |entry|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/viewDimension}} 是:
                    <dl class=switch>
                        : {{GPUTextureViewDimension/"1d"}}
                        :: |variable| 是类型 `texture_1d<T>`.
                        : {{GPUTextureViewDimension/"2d"}}
                        :: |variable| 是类型 `texture_2d<T>` 或 `texture_multisampled_2d<T>`.
                        : {{GPUTextureViewDimension/"2d-array"}}
                        :: |variable| 是类型 `texture_2d_array<T>`.
                        : {{GPUTextureViewDimension/"cube"}}
                        :: |variable| 是类型 `texture_cube<T>`.
                        : {{GPUTextureViewDimension/"cube-array"}}
                        :: |variable| 是类型 `texture_cube_array<T>`.
                        : {{GPUTextureViewDimension/"3d"}}
                        :: |variable| 是类型 `texture_3d<T>`.
                    </dl>

                : {{GPUBindGroupLayoutEntry/storageTexture}}
                ::
                    如果 |entry|.{{GPUBindGroupLayoutEntry/storageTexture}}.{{GPUStorageTextureBindingLayout/viewDimension}} 是:
                    <dl class=switch>
                        : {{GPUTextureViewDimension/"1d"}}
                        :: |variable| 是类型 `texture_storage_1d<T, A>`.
                        : {{GPUTextureViewDimension/"2d"}}
                        :: |variable| 是类型 `texture_storage_2d<T, A>`.
                        : {{GPUTextureViewDimension/"2d-array"}}
                        :: |variable| 是类型 `texture_storage_2d_array<T, A>`.
                        : {{GPUTextureViewDimension/"3d"}}
                        :: |variable| 是类型 `texture_storage_3d<T, A>`.
                    </dl>
                ::
                    如果 |entry|.{{GPUBindGroupLayoutEntry/storageTexture}}.{{GPUStorageTextureBindingLayout/access}} 是:
                    <dl class=switch>
                        : {{GPUStorageTextureAccess/"write-only"}}
                        :: 访问模式“A”是“写”。
                    </dl>
                ::
                    纹素格式 `T` 等于
                    |entry|.{{GPUBindGroupLayoutEntry/storageTexture}}.{{GPUStorageTextureBindingLayout/format}}.
            </dl>
</div>

资源绑定被视为由着色器入口点<dfn dfn>statically used</dfn>
当且仅当着色器模块的控制流图可以访问它，从入口点开始。

## <dfn interface>GPUComputePipeline</dfn> ## {#compute-pipeline}

{{GPUComputePipeline}} 是一种 [=pipeline=] 控制计算着色器阶段，
并且可以在 {{GPUComputePassEncoder}} 中使用。

计算输入和输出都包含在绑定中，
根据给定的 {{GPUPipelineLayout}}。
输出对应于类型为 {{GPUBufferBindingType/"storage"}} 的 {{GPUBindGroupLayoutEntry/buffer}} 绑定
和 {{GPUBindGroupLayoutEntry/storageTexture}} 绑定类型为 {{GPUStorageTextureAccess/"write-only"}}。

计算 [=pipeline=] 的阶段:
  1. 计算着色器

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUComputePipeline {
};
GPUComputePipeline includes GPUObjectBase;
GPUComputePipeline includes GPUPipelineBase;
</script>

### 创建 ### {#compute-pipeline-creation}

<script type=idl>
dictionary GPUComputePipelineDescriptor : GPUPipelineDescriptorBase {
    required GPUProgrammableStage compute;
};
</script>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createComputePipeline(descriptor)</dfn>
    ::
        创建一个 {{GPUComputePipeline}}。

        <div algorithm=GPUDevice.createComputePipeline>
            **调用:** {{GPUDevice}} |this|.

            **参数:**
            <pre class=argumentdef for="GPUDevice/createComputePipeline(descriptor)">
                |descriptor|: Description of the {{GPUComputePipeline}} to create.
            </pre>

            **返回:** {{GPUComputePipeline}}

            1. 让 |pipeline| 成一个新的有效的 {{GPUComputePipeline}} 对象.
            1. 在 |this| 的 [=Device timeline=] 上发出以下步骤:
                <div class=device-timeline>
                    1. 如果不满足以下任一条件：
                        <div class=validusage>
                            - |descriptor|.{{GPUPipelineDescriptorBase/layout}} 是 [$valid to use with$] |this|.
                            - [$validating GPUProgrammableStage$]({{GPUShaderStage/COMPUTE}},
                                |descriptor|.{{GPUComputePipelineDescriptor/compute}},
                                |descriptor|.{{GPUPipelineDescriptorBase/layout}}) 成功。
                            - |descriptor|.{{GPUComputePipelineDescriptor/compute}} 使用 &le;
                                |device|.limits.{{supported limits/maxComputeWorkgroupStorageSize}} 工作组存储的字节。

                                问题：更好地定义使用静态使用等。
                            - |descriptor|.{{GPUComputePipelineDescriptor/compute}} 使用 &le;
                                |device|.limits.{{supported limits/maxComputeInvocationsPerWorkgroup}} 每一个工作组。

                            - |descriptor|.{{GPUComputePipelineDescriptor/compute}} 的 `workgroup_size` 属性具有每个组件 &le; 对应的组件
                                [|device|.limits.{{supported limits/maxComputeWorkgroupSizeX}}，
                                |device|.limits.{{supported limits/maxComputeWorkgroupSizeY}}，
                                |device|.limits.{{supported limits/maxComputeWorkgroupSizeZ}}]。
                        </div>

                        Then:
                            1. 在当前范围内生成带有适当错误消息的 {{GPUValidationError}} 。
                            1. 使 |pipeline| [=invalid=].

                    1. 如果 |descriptor|.{{GPUPipelineDescriptorBase/layout}} 是 `undefined`:
                        1. 为 |pipeline| 设置 |pipeline|.{{GPUPipelineBase/[[layout]]}} 为一个新的 [$default pipeline layout$]。

                        否则设置|pipeline|.{{GPUPipelineBase/[[layout]]}} 为 |descriptor|.{{GPUPipelineDescriptorBase/layout}}。
                </div>
            1. 返回 |pipeline|.

        </div>

    : <dfn>createComputePipelineAsync(descriptor)</dfn>
    ::
        创建一个 {{GPUComputePipeline}}。 返回的 {{Promise}} 在创建的管道准备好使用时解析，没有额外的延迟。

        如果管道创建失败，则返回的 {{Promise}} 会以 {{OperationError}} 拒绝。

        注意：尽可能使用此方法，因为它可以防止阻塞管道编译中的 [=queue timeline=] 工作。

        <div algorithm=GPUDevice.createComputePipelineAsync>
            **调用:** {{GPUDevice}} |this|.

            **参数:**
            <pre class=argumentdef for="GPUDevice/createComputePipelineAsync(descriptor)">
                |descriptor|: 要创建的 {{GPUComputePipeline}} 的描述。
            </pre>

            **返回:** {{Promise}}&lt;{{GPUComputePipeline}}&gt;

            1. 让 |promise| 为 [=a new promise=].
            1. 在 |this| 的 [=Device timeline=] 上发出以下步骤:
                <div class=device-timeline>
                    1. 让 |pipeline| 是一个新的 {{GPUComputePipeline}}，就像 |this| 一样。
                        {{GPUDevice/createComputePipeline()}} 是用 |descriptor| 调用的;

                    1. 当 |pipeline| 已准备好使用，[=resolve=] |promise| 与|pipeline|。
                </div>
            1. 返回 |promise|.
        </div>
</dl>

## <dfn interface>GPURenderPipeline</dfn> ## {#render-pipeline}

{{GPURenderPipeline}} 是一种控制顶点和片段着色器阶段的 [=pipeline=]，
可以在 {{GPURenderPassEncoder}} 以及 {{GPURenderBundleEncoder}} 中使用。

渲染 [=pipeline=] 输入是：
   - 绑定，根据给定的 {{GPUPipelineLayout}}
   - 顶点和索引缓冲区，由 {{GPUVertexState}} 描述
   - 颜色附件，由 {{GPUColorTargetState}} 描述
   - 可选的，深度模板附件，由 {{GPUDepthStencilState}} 描述

渲染 [=pipeline=] 输出是：
   - {{GPUBindGroupLayoutEntry/buffer}} 与 {{GPUBufferBindingLayout/type}} 的 {{GPUBufferBindingType/"storage"}} 绑定
   - {{GPUBindGroupLayoutEntry/storageTexture}} 与 {{GPUStorageTextureBindingLayout/access}} 的 {{GPUStorageTextureAccess/"write-only"}} 绑定
   - 颜色附件，由 {{GPUColorTargetState}} 描述
   - 可选的，深度模板附件，由 {{GPUDepthStencilState}} 描述

渲染 [=pipeline=] 由以下 <dfn dfn>render stages</dfn>组成：
   1. 顶点获取，由{{GPUVertexState/buffers|GPUVertexState.buffers}}控制
   2. 顶点着色器，由{{GPUVertexState}}控制
   3. 原始组装，由{{GPUPrimitiveState}}控制
   4. 光栅化，由{{GPUPrimitiveState}}、{{GPUDepthStencilState}}和{{GPUMultisampleState}}控制
   5. 片段着色器，由{{GPUFragmentState}}控制
   6. Stencil 测试和操作，由 {{GPUDepthStencilState}} 控制
   7. 深度测试和写入，由{{GPUDepthStencilState}}控制
   8. 输出合并，由{{GPUFragmentState/targets|GPUFragmentState.targets}}控制

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPURenderPipeline {
};
GPURenderPipeline includes GPUObjectBase;
GPURenderPipeline includes GPUPipelineBase;
</script>

{{GPURenderPipeline}} 有以下内部插槽：

<dl dfn-type=attribute dfn-for=GPURenderPipeline>
    : <dfn>\[[descriptor]]</dfn>, {{GPURenderPipelineDescriptor}} 类型
    ::
        {{GPURenderPipelineDescriptor}} 用来描述这个管道。

        {{GPURenderPipelineDescriptor}} 的所有可选字段都已定义。

    : <dfn>\[[strip_index_format]]</dfn>, {{GPUIndexFormat}} 类型?
    ::
        如果使用条带原语拓扑，则此管道需要的格式索引数据，
        初始化为 `undefined`。

    : <dfn>\[[writesDepth]]</dfn>, boolean 类型
    :: 如果管道写入深度/模板附件的深度组件，则为True

    : <dfn>\[[writesStencil]]</dfn>, boolean 类型
    :: 如果管道写入深度/模板附件的模板组件，则为True
</dl>

### 创建 ### {#render-pipeline-creation}

<script type=idl>
dictionary GPURenderPipelineDescriptor : GPUPipelineDescriptorBase {
    required GPUVertexState vertex;
    GPUPrimitiveState primitive = {};
    GPUDepthStencilState depthStencil;
    GPUMultisampleState multisample = {};
    GPUFragmentState fragment;
};
</script>

{{GPURenderPipelineDescriptor}} 通过配置每个 [=render stage=] 来描述渲染 [=pipeline=] 的状态。
有关详细信息，请参阅 [[#rendering-operations]]。

- {{GPURenderPipelineDescriptor/vertex}} 描述
     [=pipeline=] 的顶点着色器入口点及其输入缓冲区布局。
- {{GPURenderPipelineDescriptor/primitive}} 描述了
     [=pipeline=] 的原始相关属性。
- {{GPURenderPipelineDescriptor/depthStencil}} 描述
     可选的深度模板属性，包括测试、操作和偏差。
- {{GPURenderPipelineDescriptor/multisample}} 描述
     [=pipeline=] 的多重采样特性。
- {{GPURenderPipelineDescriptor/fragment}} 描述
     [=pipeline=] 的片段着色器入口点及其输出颜色。
     如果它是 `null`，则启用 [[#no-color-output]] 模式。

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createRenderPipeline(descriptor)</dfn>
    ::
        创建一个 {{GPURenderPipeline}}.

        <div algorithm=GPUDevice.createRenderPipeline>
            **调用:** {{GPUDevice}} |this|.

            **参数:**
            <pre class=argumentdef for="GPUDevice/createRenderPipeline(descriptor)">
                |descriptor|: Description of the {{GPURenderPipeline}} to create.
            </pre>

            **返回:** {{GPURenderPipeline}}

            1. 让 |pipeline| 为一个新的可用的 {{GPURenderPipeline}} 对象。
            1. 在 |this| 的 [=Device timeline=] 上发出以下步骤：
                <div class=device-timeline>
                    1. 如果不满足以下任一条件：
                        <div class=validusage>
                            - |descriptor|.{{GPUPipelineDescriptorBase/layout}} 是 [$valid to use with$] |this|。
                            - [$validating GPURenderPipelineDescriptor$](|descriptor|, |this|) 成功。
                        </div>

                        Then:
                            1. 在当前范围内生成带有适当错误消息的 {{GPUValidationError}}。
                            1. 使 |pipeline| [=invalid=]。

                    1. 设置 |pipeline|.{{GPURenderPipeline/[[descriptor]]}} 为 |descriptor|。
                    1. 设置 |pipeline|.{{GPURenderPipeline/[[strip_index_format]]}} 为
                        |descriptor|.{{GPURenderPipelineDescriptor/primitive}}.{{GPUPrimitiveState/stripIndexFormat}}。
                    1. 设置 |pipeline|.{{GPURenderPipeline/[[writesDepth]]}} 为 false.
                    1. 设置 |pipeline|.{{GPURenderPipeline/[[writesStencil]]}} 为 false.
                    1. 让 |depthStencil| 是 |descriptor|.{{GPURenderPipelineDescriptor/depthStencil}}.
                    1. 如果 |depthStencil| 不是 null:
                        1. 设置 |pipeline|.{{GPURenderPipeline/[[writesDepth]]}} 为 |depthStencil|.{{GPUDepthStencilState/depthWriteEnabled}}.
                        1. 如果 |depthStencil|.{{GPUDepthStencilState/stencilWriteMask}} 不是 0:
                            1. 让 |stencilFront| 为 |depthStencil|.{{GPUDepthStencilState/stencilFront}}.
                            1. 让 |stencilBack| 为 |depthStencil|.{{GPUDepthStencilState/stencilBack}}.
                            1. 让 |cullMode| 为 |descriptor|.{{GPURenderPipelineDescriptor/primitive}}.{{GPUPrimitiveState/cullMode}}.
                            1. 如果 |cullMode| 不是 {{GPUCullMode/"front"}}, 并且 |stencilFront|.{{GPUStencilFaceState/passOp}},
                                |stencilFront|.{{GPUStencilFaceState/depthFailOp}}, 或 |stencilFront|.{{GPUStencilFaceState/failOp}}
                                其中之一不是 {{GPUStencilOperation/"keep"}}:
                                1. 设置 |pipeline|.{{GPURenderPipeline/[[writesStencil]]}} 为 true.
                            1. 如果 |cullMode| 不是 {{GPUCullMode/"back"}}, 并且 |stencilBack|.{{GPUStencilFaceState/passOp}},
                                |stencilBack|.{{GPUStencilFaceState/depthFailOp}}, 或 |stencilBack|.{{GPUStencilFaceState/failOp}}
                                其中之一不是 {{GPUStencilOperation/"keep"}}:
                                1. 设置 |pipeline|.{{GPURenderPipeline/[[writesStencil]]}} 为 true.
                    1. 如果 |descriptor|.{{GPUPipelineDescriptorBase/layout}} 是 `undefined`:
                        1. 为 |pipeline| 设置 |pipeline|.{{GPUPipelineBase/[[layout]]}} 为一个新的 [$default pipeline layout$]。

                        否则设置 |pipeline|.{{GPUPipelineBase/[[layout]]}} 为 |descriptor|.{{GPUPipelineDescriptorBase/layout}}.
                </div>
            1. 返回 |pipeline|.

            问题：需要渲染状态的描述。
        </div>

    : <dfn>createRenderPipelineAsync(descriptor)</dfn>
    ::
        创建一个 {{GPURenderPipeline}}。 返回的 {{Promise}} 在创建的管道准备好使用时解析，没有额外的延迟。

        如果管道创建失败，则返回的 {{Promise}} 会以 {{OperationError}} 拒绝。

        注意：最好尽可能使用此方法，因为它可以防止阻塞
        [=queue timeline=] 致力于管道编译。

        <div algorithm=GPUDevice.createRenderPipelineAsync>
            **调用:** {{GPUDevice}} |this|.

            **参数:**
            <pre class=argumentdef for="GPUDevice/createRenderPipelineAsync(descriptor)">
                |descriptor|: 要创建的 {{GPURenderPipeline}} 的描述。
            </pre>

            **返回:** {{Promise}}&lt;{{GPURenderPipeline}}&gt;

            1. 让 |promise| 为 [=a new promise=].
            1. 在 |this| 的 [=device timeline=] 上发出以下步骤:
                <div class=device-timeline>
                    1. 让 |pipeline| 是一个新创建的 {{GPURenderPipeline}}，
                        就好像 |this|.{{GPUDevice/createRenderPipeline()}} 是用 |descriptor| 调用的一样;

                    1. 当|pipeline| 已准备好使用， 用 |pipeline| [=resolve=] |promise|。
                </div>
            1. 返回 |promise|.
        </div>
</dl>

<div algorithm>
    <dfn abstract-op>validating GPURenderPipelineDescriptor</dfn>(descriptor, device)
        **参数:**
            - {{GPURenderPipelineDescriptor}} |descriptor|
            - {{GPUDevice}} |device|

        如果满足以下所有条件，则返回 `true`：

            - [$validating GPUProgrammableStage$]({{GPUShaderStage/VERTEX}},
                |descriptor|.{{GPURenderPipelineDescriptor/vertex}},
                |descriptor|.{{GPUPipelineDescriptorBase/layout}}) 成功。
            - [$validating GPUVertexState$](|device|, |descriptor|.{{GPURenderPipelineDescriptor/vertex}},
                |descriptor|.{{GPURenderPipelineDescriptor/vertex}}) 成功。
            - 如果 |descriptor|.{{GPURenderPipelineDescriptor/fragment}} 不是 `null`:
                - [$validating GPUProgrammableStage$]({{GPUShaderStage/FRAGMENT}},
                    |descriptor|.{{GPURenderPipelineDescriptor/fragment}},
                    |descriptor|.{{GPUPipelineDescriptorBase/layout}}) 成功。
                - [$validating GPUFragmentState$](|descriptor|.{{GPURenderPipelineDescriptor/fragment}}) 成功。
                - 如果 "sample_mask" [=builtin=] 是 |descriptor|.{{GPURenderPipelineDescriptor/fragment}} 的 [=pipeline output=]:
                    - |descriptor|.{{GPURenderPipelineDescriptor/multisample}}.{{GPUMultisampleState/alphaToCoverageEnabled}} 是 `false`。
            - [$validating GPUPrimitiveState$](|descriptor|.{{GPURenderPipelineDescriptor/primitive}}, |device|.{{device/[[features]]}}) 成功。
            - 如果 |descriptor|.{{GPURenderPipelineDescriptor/depthStencil}} 不是 `null`:
                - [$validating GPUDepthStencilState$](|descriptor|.{{GPURenderPipelineDescriptor/depthStencil}}) 成功。
            - [$validating GPUMultisampleState$](|descriptor|.{{GPURenderPipelineDescriptor/multisample}}) 成功。
            - 对于每个用户定义的输出
                |descriptor|.{{GPURenderPipelineDescriptor/vertex}} 必须有
                是用户定义的输入
                |descriptor|.{{GPURenderPipelineDescriptor/fragment}} 即
                匹配
                [=location=],
                类型，和
                [=interpolation=]
                的输出。
            - 对于每个用户定义的输入
                |descriptor|.{{GPURenderPipelineDescriptor/fragment}} 在那里
                必须是用户定义的输出
                |descriptor|.{{GPURenderPipelineDescriptor/vertex}} 即
                [=location=],
                类型，和
                [=interpolation=]
                的输入。
            - |descriptor|.{{GPURenderPipelineDescriptor/vertex}} 的用户定义输出组件少于
                |device|.limits.{{supported limits/maxInterStageShaderComponents}} 组件。
            - |descriptor|.{{GPURenderPipelineDescriptor/fragment}} 的用户定义输入的组件少于
                |device|.limits.{{supported limits/maxInterStageShaderComponents}} 组件。
</div>

问题：我们应该验证点和线的 `cullMode` 是 none 吗？

问题：定义渲染目标格式的“兼容”意味着什么。

问题：需要适当限制颜色目标的最大数量。

### 原始状态 ### {#primitive-state}

<script type=idl>
enum GPUPrimitiveTopology {
    "point-list",
    "line-list",
    "line-strip",
    "triangle-list",
    "triangle-strip"
};
</script>

<script type=idl>
dictionary GPUPrimitiveState {
    GPUPrimitiveTopology topology = "triangle-list";
    GPUIndexFormat stripIndexFormat;
    GPUFrontFace frontFace = "ccw";
    GPUCullMode cullMode = "none";

    // Enable depth clamping (requires "depth-clamping" feature)
    boolean clampDepth = false;
};
</script>

<div algorithm>
    <dfn abstract-op>validating GPUPrimitiveState</dfn>(|descriptor|, |features|)
        **参数:**
            - {{GPUPrimitiveState}} |descriptor|
            - [=list=]&lt;{{GPUFeatureName}}&gt; |features|

        如果满足以下所有条件，则返回 `true`：
            - 如果 |descriptor|.{{GPUPrimitiveState/topology}} 是:
                <dl class="switch">
                    : {{GPUPrimitiveTopology/"line-strip"}} 或
                        {{GPUPrimitiveTopology/"triangle-strip"}}
                    :: |descriptor|.{{GPUPrimitiveState/stripIndexFormat}} 不是 `undefined`
                    : 否则
                    :: |descriptor|.{{GPUPrimitiveState/stripIndexFormat}} 是 `undefined`
                </dl>
            - 如果 |descriptor|.{{GPUPrimitiveState/clampDepth}} 是 `true`:
                - |features| 必须 [=list/contain=] {{GPUFeatureName/"depth-clamping"}}.
</div>

<script type=idl>
enum GPUFrontFace {
    "ccw",
    "cw"
};
</script>

<script type=idl>
enum GPUCullMode {
    "none",
    "front",
    "back"
};
</script>

### 多重采样状态 ### {#multisample-state}

<script type=idl>
dictionary GPUMultisampleState {
    GPUSize32 count = 1;
    GPUSampleMask mask = 0xFFFFFFFF;
    boolean alphaToCoverageEnabled = false;
};
</script>

<div algorithm>
    <dfn abstract-op>validating GPUMultisampleState</dfn>(|descriptor|)
        **参数:**
            - {{GPUMultisampleState}} |descriptor|

        如果满足以下所有条件，则返回 `true`:
            - 如果 |descriptor|.{{GPUMultisampleState/alphaToCoverageEnabled}} 是 `true`:
                - |descriptor|.{{GPUMultisampleState/count}} 比 1 大。
</div>

### 片段状态 ### {#fragment-state}

<script type=idl>
dictionary GPUFragmentState: GPUProgrammableStage {
    required sequence<GPUColorTargetState> targets;
};
</script>

<div algorithm>
    <dfn abstract-op>validating GPUFragmentState</dfn>(|descriptor|)
        如果满足以下所有要求，则返回 `true`：

        - |descriptor|.{{GPUFragmentState/targets}}.length 必须 &le; 8.
        - 对于每个 |colorState| 列表中的布局描述符 |descriptor|.{{GPUFragmentState/targets}}:
            - |colorState|.{{GPUColorTargetState/format}} 必须在具有
                {{GPUTextureUsage/RENDER_ATTACHMENT}} 功能的 [[#plain-color-formats]] 中列出。
            - 如果 |colorState|.{{GPUColorTargetState/blend}} 不是 `undefined`:
                - |colorState|.{{GPUColorTargetState/format}} 必须是可过滤的
                    根据 [[#plain-color-formats]] 表。
                - |colorState|.{{GPUColorTargetState/blend}}.{{GPUBlendState/color}}
                    必须是 [=valid GPUBlendComponent=].
                - |colorState|.{{GPUColorTargetState/blend}}.{{GPUBlendState/alpha}}
                    必须是 [=valid GPUBlendComponent=].
            - |colorState|.{{GPUColorTargetState/writeMask}} 必须是 &lt; 16.
            - 如果 |descriptor|.{{GPUProgrammableStage/entryPoint}} 有一个 [=pipeline output=] 值，
                [=location=] 属性等于 |colorState| 的索引 在 |descriptor|.{{GPUFragmentState/targets}} 列表中：
                - [=pipeline output=] 类型必须与 |colorState|.{{GPUColorTargetState/format}} 兼容。

                否则:
                - |colorState|.{{GPUColorTargetState/writeMask}} 必须为 0。
</div>

<div algorithm>
    |component| 如果满足以下要求，则是 <dfn>valid GPUBlendComponent</dfn>：
    - 如果 |component|.{{GPUBlendComponent/operation}} 是
        {{GPUBlendOperation/"min"}} 或 {{GPUBlendOperation/"max"}}:
        - |component|.{{GPUBlendComponent/srcFactor}} 和
            |component|.{{GPUBlendComponent/dstFactor}} 必须都是 {{GPUBlendFactor/"one"}}。
</div>

问题：定义 `GPUProgrammableStage` 的“静态使用”事物的范围

### 颜色目标状态 ### {#color-target-state}

<script type=idl>
dictionary GPUColorTargetState {
    required GPUTextureFormat format;

    GPUBlendState blend;
    GPUColorWriteFlags writeMask = 0xF;  // GPUColorWrite.ALL
};
</script>

<script type=idl>
dictionary GPUBlendState {
    required GPUBlendComponent color;
    required GPUBlendComponent alpha;
};
</script>

<script type=idl>
typedef [EnforceRange] unsigned long GPUColorWriteFlags;
[Exposed=(Window, DedicatedWorker)]
namespace GPUColorWrite {
    const GPUFlagsConstant RED   = 0x1;
    const GPUFlagsConstant GREEN = 0x2;
    const GPUFlagsConstant BLUE  = 0x4;
    const GPUFlagsConstant ALPHA = 0x8;
    const GPUFlagsConstant ALL   = 0xF;
};
</script>

#### 混合状态 #### {#blend-state}

<script type=idl>
dictionary GPUBlendComponent {
    GPUBlendOperation operation = "add";
    GPUBlendFactor srcFactor = "one";
    GPUBlendFactor dstFactor = "zero";
};
</script>

<script type=idl>
enum GPUBlendFactor {
    "zero",
    "one",
    "src",
    "one-minus-src",
    "src-alpha",
    "one-minus-src-alpha",
    "dst",
    "one-minus-dst",
    "dst-alpha",
    "one-minus-dst-alpha",
    "src-alpha-saturated",
    "constant",
    "one-minus-constant"
};
</script>

<script type=idl>
enum GPUBlendOperation {
    "add",
    "subtract",
    "reverse-subtract",
    "min",
    "max"
};
</script>

### 深度/模板状态 ### {#depth-stencil-state}

<script type=idl>
dictionary GPUDepthStencilState {
    required GPUTextureFormat format;

    boolean depthWriteEnabled = false;
    GPUCompareFunction depthCompare = "always";

    GPUStencilFaceState stencilFront = {};
    GPUStencilFaceState stencilBack = {};

    GPUStencilValue stencilReadMask = 0xFFFFFFFF;
    GPUStencilValue stencilWriteMask = 0xFFFFFFFF;

    GPUDepthBias depthBias = 0;
    float depthBiasSlopeScale = 0;
    float depthBiasClamp = 0;
};
</script>

<script type=idl>
dictionary GPUStencilFaceState {
    GPUCompareFunction compare = "always";
    GPUStencilOperation failOp = "keep";
    GPUStencilOperation depthFailOp = "keep";
    GPUStencilOperation passOp = "keep";
};
</script>

<script type=idl>
enum GPUStencilOperation {
    "keep",
    "zero",
    "replace",
    "invert",
    "increment-clamp",
    "decrement-clamp",
    "increment-wrap",
    "decrement-wrap"
};
</script>

<div algorithm>
    <dfn abstract-op>validating GPUDepthStencilState</dfn>(descriptor)
    **参数:**
        - {{GPUDepthStencilState}} |descriptor|

    返回 `true`，当且仅当满足以下所有条件：

        - |descriptor|.{{GPUDepthStencilState/format}} 在 [[#depth-formats]] 列表中：
        - 如果 |descriptor|.{{GPUDepthStencilState/depthWriteEnabled}} 是 `true` 或者
            |descriptor|.{{GPUDepthStencilState/depthCompare}} 不是 {{GPUCompareFunction/"always"}}:
            - |descriptor|.{{GPUDepthStencilState/format}} 必须有一个深度组件。
        - 如果 |descriptor|.{{GPUDepthStencilState/stencilFront}} 或者
            |descriptor|.{{GPUDepthStencilState/stencilBack}} 都不是默认值：
            - |descriptor|.{{GPUDepthStencilState/format}} 必须有一个模板组件。

    问题：该算法如何支持在扩展中添加的深度/模板格式？
</div>

### 顶点状态 ### {#vertex-state}

<script type=idl>
enum GPUIndexFormat {
    "uint16",
    "uint32"
};
</script>

索引格式决定了缓冲区中索引值的数据类型，当与带状基元拓扑（{{GPUPrimitiveTopology/"line-strip"}} 或
{{GPUPrimitiveTopology/"triangle-strip"}}) 还指定了图元重启值。
<dfn dfn>primitive restart value</dfn> 指示哪个索引值指示应该启动新的图元，而不是继续使用先前索引的顶点构造三角形条。

{{GPUPrimitiveState}} 指定条带基元拓扑必须指定 {{GPUPrimitiveState/stripIndexFormat}}
以便在管道创建时知道将使用的 [=primitive restart value=]。
指定列表基元拓扑的 {{GPUPrimitiveState}} 必须将 {{GPUPrimitiveState/stripIndexFormat}} 设置为 `undefined`，
并且在渲染时将使用传递给 {{GPURenderEncoderBase/setIndexBuffer()}} 的索引格式。

<table class="data">
  <thead>
    <tr>
      <th>Index format</th>
      <th>Byte size</th>
      <th>Primitive restart value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>{{GPUIndexFormat/"uint16"}}</td>
      <td>2</td>
      <td>0xFFFF</td>
    </tr>
    <tr>
      <td>{{GPUIndexFormat/"uint32"}}</td>
      <td>4</td>
      <td>0xFFFFFFFF</td>
    </tr>
  </tbody>
</table>

#### 顶点格式 #### {#vertex-formats}

格式的名称指定了组件的顺序、每个组件的位数、
和组件的<dfn dfn>vertex data type</dfn>。

  * `unorm` = unsigned normalized
  * `snorm` = signed normalized
  * `uint` = unsigned int
  * `sint` = signed int
  * `float` = floating point

<script type=idl>
enum GPUVertexFormat {
    "uint8x2",
    "uint8x4",
    "sint8x2",
    "sint8x4",
    "unorm8x2",
    "unorm8x4",
    "snorm8x2",
    "snorm8x4",
    "uint16x2",
    "uint16x4",
    "sint16x2",
    "sint16x4",
    "unorm16x2",
    "unorm16x4",
    "snorm16x2",
    "snorm16x4",
    "float16x2",
    "float16x4",
    "float32",
    "float32x2",
    "float32x3",
    "float32x4",
    "uint32",
    "uint32x2",
    "uint32x3",
    "uint32x4",
    "sint32",
    "sint32x2",
    "sint32x3",
    "sint32x4",
};
</script>

多分量格式指定“x”后的分量数。
因此，{{GPUVertexFormat/"sint32x3"}} 表示着色器中 `i32` 值的 3 分量向量。

<script type=idl>
enum GPUVertexStepMode {
    "vertex",
    "instance"
};
</script>

步进模式配置如何根据当前顶点或实例索引计算顶点缓冲区数据的地址：
<dl class="switch">
    : {{GPUVertexStepMode/"vertex"}}
    :: 每个顶点的地址前移 {{GPUVertexBufferLayout/arrayStride}}，
        并在实例之间重置。
    : {{GPUVertexStepMode/"instance"}}
    :: 每个实例的地址都增加了 {{GPUVertexBufferLayout/arrayStride}}。
</dl>

<script type=idl>
dictionary GPUVertexState: GPUProgrammableStage {
    sequence<GPUVertexBufferLayout?> buffers = [];
};
</script>

从概念上讲，<dfn dfn>vertex buffer</dfn> 是将缓冲区内存视为*结构数组* 的视图。
{{GPUVertexBufferLayout/arrayStride}} 是该数组的 *elements* 之间的步幅（以字节为单位）。
顶点缓冲区的每个元素就像一个*结构*，其内存布局由其定义
{{GPUVertexBufferLayout/attributes}}，描述结构的*成员*。

每个 {{GPUVertexAttribute}} 描述了它的
{{GPUVertexAttribute/format}} 及其
{{GPUVertexAttribute/offset}}，以字节为单位，在结构中。

每个属性在顶点着色器中显示为单独的输入，每个属性都由数字 *location* 绑定，
由 {{GPUVertexAttribute/shaderLocation}} 指定。
{{GPUVertexState}} 中的每个位置都必须是唯一的。

<script type=idl>
dictionary GPUVertexBufferLayout {
    required GPUSize64 arrayStride;
    GPUVertexStepMode stepMode = "vertex";
    required sequence<GPUVertexAttribute> attributes;
};
</script>

<script type=idl>
dictionary GPUVertexAttribute {
    required GPUVertexFormat format;
    required GPUSize64 offset;

    required GPUIndex32 shaderLocation;
};
</script>

<div algorithm>
    <dfn abstract-op>validating GPUVertexBufferLayout</dfn>(device, descriptor, vertexStage)
    **参数:**
        - {{GPUDevice}} |device|
        - {{GPUVertexBufferLayout}} |descriptor|
        - {{GPUProgrammableStage}} |vertexStage|

    返回 `true`，当且仅当满足以下所有条件：

        - |descriptor|.{{GPUVertexBufferLayout/arrayStride}} &le;
            |device|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxVertexBufferArrayStride}}.
        - |descriptor|.{{GPUVertexBufferLayout/arrayStride}} 是 4 的倍数/
        - 对于每个属性 |attrib| 在列表中 |descriptor|.{{GPUVertexBufferLayout/attributes}}:
            - 如果 |descriptor|.{{GPUVertexBufferLayout/arrayStride}} 是 0:
                - |attrib|.{{GPUVertexAttribute/offset}} + sizeof(|attrib|.{{GPUVertexAttribute/format}}) &le;
                    |device|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxVertexBufferArrayStride}}.

                否则:
                - |attrib|.{{GPUVertexAttribute/offset}} + sizeof(|attrib|.{{GPUVertexAttribute/format}}) &le;
                    |descriptor|.{{GPUVertexBufferLayout/arrayStride}}.
            - |attrib|.{{GPUVertexAttribute/offset}} 是 4 和 sizeof(|attrib|.{{GPUVertexAttribute/format}}) 中最小值的倍数。
            - |attrib|.{{GPUVertexAttribute/shaderLocation}} 比
                |device|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxVertexAttributes}} 小。
        - 对于 |vertexStage|.{{GPUProgrammableStage/module}} 的着色器反射中的每个顶点属性，
            即 |vertexStage|.{{GPUProgrammableStage/entryPoint}} 的 [=pipeline input=]，
            都有一个对应的 |attrib| |descriptor|.{{GPUVertexBufferLayout/attributes}} 的元素满足以下所有条件：
            - 着色器格式与 |attrib| 兼容。{{GPUVertexAttribute/format}} 的 [=vertex data type=]:
                <dl class="switch">
                    : "unorm", "snorm", 或 "float"
                    :: 着色器格式必须为 `f32` 或 `vecN<f32>`。
                    : "uint"
                    :: 着色器格式必须为 `u32` 或 `vecN<u32>`。
                    : "sint"
                    :: 着色器格式必须为 `i32` or `vecN<i32>`。
                </dl>
            - 着色器的地址为 |attrib|.{{GPUVertexAttribute/shaderLocation}}.
</div>

<div algorithm>
    <dfn abstract-op>validating GPUVertexState</dfn>(device, descriptor)
    **参数:**
        - {{GPUDevice}} |device|
        - {{GPUVertexState}} |descriptor|

    返回 `true`，当且仅当满足以下所有条件：

        - |descriptor|.{{GPUVertexState/buffers}}.length 小于或等于
            |device|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxVertexBuffers}}.
        - 每个 |vertexBuffer| 列表中的布局描述符 |descriptor|.{{GPUVertexState/buffers}}
            通过 [$validating GPUVertexBufferLayout$](|device|, |vertexBuffer|, |descriptor|)
        - |vertexBuffer|.{{GPUVertexBufferLayout/attributes}}.length 在
            |descriptor|.{{GPUVertexState/buffers}} 中的每个 |vertexBuffer| 上的总和，
            小于或等于 |device|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxVertexAttributes}}。
        - 每个|attrib| 在 |descriptor|.{{GPUVertexState/buffers}} 的所有 {{GPUVertexAttribute}} 的联合中，有一个不同的
            |attrib|.{{GPUVertexAttribute/shaderLocation}} 值。
</div>


# 命令缓冲区 # {#command-buffers}

命令缓冲区是预先记录的[=GPU command=]列表，可以提交给{{GPUQueue}}执行。每个<dfn dfn>GPU command</dfn>代表一个要在GPU上执行的任务，例如设置状态、绘图、复制资源等。

## <dfn interface>GPUCommandBuffer</dfn> ## {#command-buffer}

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUCommandBuffer {
    readonly attribute Promise<double> executionTime;
};
GPUCommandBuffer includes GPUObjectBase;
</script>

{{GPUCommandBuffer}}有以下属性:

<dl dfn-type=attribute dfn-for="GPUCommandBuffer">
    : <dfn>executionTime</dfn>
    ::
        GPU执行此命令缓冲所消耗的总时间，以秒为单位。

        注意：如果{{GPUCommandEncoderDescriptor/measureExecutionTime}}为 `true`，这在命令缓冲区执行之后resolves，否则，这会以一个{{OperationError}}rejects。

        <div class=issue>
            指定promise的创建和解决。

            在{{GPUCommandEncoder/finish()}}中，应该指定一个新的promise被创建并存储在这个属性中。如果{{GPUCommandEncoderDescriptor/measureExecutionTime}}为 `false`，则promise开始被拒绝。如果finish()失败，则promise resolves为0。

            在{{GPUQueue/submit()}}中，应该指定（如果设置了{{GPUCommandEncoderDescriptor/measureExecutionTime}}），work被发出以读回执行时间，并且在完成时，promise resolves返回该值。如果submit()失败，则promise resolves为0。
        </div>
</dl>

{{GPUCommandBuffer}}有以下内部插槽:

<dl dfn-type=attribute dfn-for="GPUCommandBuffer">
    : <dfn>\[[command_list]]</dfn> of type [=list=]&lt;[=GPU command=]&gt;.
    ::
        当这个命令缓冲被提交时，一个[=GPU command=]的[=list=]会在[=Queue timeline=]上被执行。
</dl>

### 创建 ### {#command-buffer-creation}

<script type=idl>
dictionary GPUCommandBufferDescriptor : GPUObjectDescriptorBase {
};
</script>


# 命令编码 # {#command-encoding}

## <dfn interface>GPUCommandEncoder</dfn> ## {#command-encoder}

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUCommandEncoder {
    GPURenderPassEncoder beginRenderPass(GPURenderPassDescriptor descriptor);
    GPUComputePassEncoder beginComputePass(optional GPUComputePassDescriptor descriptor = {});

    undefined copyBufferToBuffer(
        GPUBuffer source,
        GPUSize64 sourceOffset,
        GPUBuffer destination,
        GPUSize64 destinationOffset,
        GPUSize64 size);

    undefined copyBufferToTexture(
        GPUImageCopyBuffer source,
        GPUImageCopyTexture destination,
        GPUExtent3D copySize);

    undefined copyTextureToBuffer(
        GPUImageCopyTexture source,
        GPUImageCopyBuffer destination,
        GPUExtent3D copySize);

    undefined copyTextureToTexture(
        GPUImageCopyTexture source,
        GPUImageCopyTexture destination,
        GPUExtent3D copySize);

    undefined pushDebugGroup(USVString groupLabel);
    undefined popDebugGroup();
    undefined insertDebugMarker(USVString markerLabel);

    undefined writeTimestamp(GPUQuerySet querySet, GPUSize32 queryIndex);

    undefined resolveQuerySet(
        GPUQuerySet querySet,
        GPUSize32 firstQuery,
        GPUSize32 queryCount,
        GPUBuffer destination,
        GPUSize64 destinationOffset);

    GPUCommandBuffer finish(optional GPUCommandBufferDescriptor descriptor = {});
};
GPUCommandEncoder includes GPUObjectBase;
</script>

{{GPUCommandEncoder}}有以下内部插槽:

<dl dfn-type=attribute dfn-for="GPUCommandEncoder">
    : <dfn>\[[command_list]]</dfn>，类型为[=list=]&lt;[=GPU command=]&gt;。
    ::
        此编码器生成的{{GPUCommandBuffer}}被提交时，一个[=GPU command=][=list=]在队列时间线上被执行。

    : <dfn>\[[state]]</dfn>，类型为{{encoder state}}。
    ::
        {{GPUCommandEncoder}}的当前状态, 初始时被设置为{{encoder state/open}}。

    : <dfn>\[[debug_group_stack]]</dfn>，类型为[=stack=]&lt;{{USVString}}&gt;。
    ::
        一个激活的调试组标签栈。
</dl>

每个{{GPUCommandEncoder}}在[=Content timeline=]上都有一个当前<dfn dfn-type="enum">encoder state</dfn>，值为以下之一：

<dl dfn-type="enum-value" dfn-for="encoder state">
    : "<dfn>open</dfn>"
    ::
        指{{GPUCommandEncoder}}可用于开始新操作。在{{GPUCommandEncoder}}有效且没有激活的{{GPURenderPassEncoder}}或{{GPUComputePassEncoder}}时，{{GPUCommandEncoder/[[state]]}}处于{{encoder state/open}}状态。

    : "<dfn>encoding a render pass</dfn>"
    ::
        指{{GPUCommandEncoder}}具有激活的{{GPURenderPassEncoder}}。一旦{{GPUCommandEncoder/beginRenderPass()}}被调用成功，{{GPUCommandEncoder/[[state]]}}就变成{{encoder state/encoding a render pass}}状态，直到在返回的{{GPURenderPassEncoder}}上调用{{GPURenderPassEncoder/endPass()}}，此时{{GPUCommandEncoder/[[state]]}}（如果编码器仍然有效）恢复为{{encoder state/open}}状态。

    : "<dfn>encoding a compute pass</dfn>"
    ::
        指{{GPUCommandEncoder}}具有激活的{{GPUComputePassEncoder}}。一旦{{GPUCommandEncoder/beginComputePass()}}被调用成功，{{GPUCommandEncoder/[[state]]}}就变成{{encoder state/encoding a compute pass}}状态，直到在返回的{{GPUComputePassEncoder}}上调用{{GPUComputePassEncoder/endPass()}}，此时{{GPUCommandEncoder/[[state]]}}（如果编码器仍然有效）恢复为{{encoder state/open}}状态。

    : "<dfn>closed</dfn>"
    ::
        指{{GPUCommandEncoder}}已经不可用作任何操作。一旦{{GPUCommandEncoder/finish()}}被调用或{{GPUCommandEncoder}}变无效，{{GPUCommandEncoder/[[state]]}}变为{{encoder state/closed}}状态。
</dl>

### 创建 ### {#command-encoder-creation}

<script type=idl>
dictionary GPUCommandEncoderDescriptor : GPUObjectDescriptorBase {
    boolean measureExecutionTime = false;
};
</script>

<dl dfn-type=dict-member dfn-for=GPUCommandEncoderDescriptor>
    : <dfn>measureExecutionTime</dfn>
    ::
        启用对全部命令缓冲区的GPU执行时间的测量。
</dl>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createCommandEncoder(descriptor)</dfn>
    ::
        创建一个{{GPUCommandEncoder}}。

        <div algorithm=GPUDevice.createCommandEncoder>
            **Called on:** {{GPUDevice}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/createCommandEncoder(descriptor)">
                descriptor: 要创建的{{GPUCommandEncoder}}的描述。
            </pre>

            **Returns:** {{GPUCommandEncoder}}

            问题：描述{{GPUDevice/createCommandEncoder()}}算法步骤。
        </div>
</dl>

## 通道编码 ## {#command-encoder-pass-encoding}

<dl dfn-type=method dfn-for=GPUCommandEncoder>
    : <dfn>beginRenderPass(descriptor)</dfn>
    ::
        Begins encoding a render pass described by |descriptor|.

        <div algorithm=GPUCommandEncoder.beginRenderPass>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/beginRenderPass(descriptor)">
                |descriptor|: 要创建的{{GPURenderPassEncoder}}的描述。
            </pre>

            **Returns:** {{GPURenderPassEncoder}}

            在|this|的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                1. 使|pass|为一个新的{{GPURenderPassEncoder}}对象。
                2. 如果以下任何条件没有满足，产生一个校验错误并停止。
                    <div class=validusage>
                        - |this|.{{GPUCommandEncoder/[[state]]}}为{{encoder state/open}}。
                        - |descriptor|满足[$GPURenderPassDescriptor/Valid Usage$]规则。
                    </div>
                3. 设置|this|.{{GPUCommandEncoder/[[state]]}}为{{encoder state/encoding a render pass}}。
                4. 对每个|descriptor|.{{GPURenderPassDescriptor/colorAttachments}}中的|colorAttachment|:
                    1. |colorAttachment|.{{GPURenderPassColorAttachment/view}}看到的[=texture subresource=]被视为在渲染通道期间用作[=internal usage/attachment=]。
                5. 设置|depthStencilAttachment|为|descriptor|.{{GPURenderPassDescriptor/depthStencilAttachment}}。
                6. 如果|depthStencilAttachment|不是 `null`:
                    1. 设置|depthStencilView|为|depthStencilAttachment|.{{GPURenderPassDepthStencilAttachment/view}}。
                    2. 如果|depthStencilAttachment|.{{GPURenderPassDepthStencilAttachment/depthReadOnly}}和{{GPURenderPassDepthStencilAttachment/stencilReadOnly}}被设置了值：
                        1. |depthStencilView|看到的[=texture subresource=]被视为在渲染通道期间用作[=internal usage/attachment-read=]。
                    3. 否则, |depthStencilView|看到的[=texture subresource=]被视为在渲染通道期间用作[=internal usage/attachment=]。
                    4. 设置|pass|.{{GPURenderEncoderBase/[[depthReadOnly]]}}为|depthStencilAttachment|.{{GPURenderPassDepthStencilAttachment/depthReadOnly}}。
                    5. 设置|pass|.{{GPURenderEncoderBase/[[stencilReadOnly]]}}为|depthStencilAttachment|.{{GPURenderPassDepthStencilAttachment/stencilReadOnly}}。
                7. 设置|pass|.{{GPURenderEncoderBase/[[layout]]}}为[$derive render targets layout from pass$](|descriptor|)。
                8. 返回|pass|。
            </div>

            问题：指定只读深度/模板的行为。
            问题：入队附件负载(with loadOp clear)。
        </div>

    : <dfn>beginComputePass(descriptor)</dfn>
    ::
        开始对|descriptor|描述的compute pass进行编码。

        <div algorithm=GPUCommandEncoder.beginComputePass>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/beginComputePass(descriptor)">
                descriptor:
            </pre>

            **Returns:** {{GPUComputePassEncoder}}

            在|this|的[=Device timeline=]上发起如下步骤：
            <div class=device-timeline>
                1. 如果以下任何条件没有满足，产生一个校验错误并停止。
                    <div class=validusage>
                        - |this|.{{GPUCommandEncoder/[[state]]}}为{{encoder state/open}}。
                    </div>
                2. 设置|this|.{{GPUCommandEncoder/[[state]]}}为{{encoder state/encoding a compute pass}}。
                3. 设置|pass|为一个新的{{GPUComputePassEncoder}}对象。
                4. 返回|pass|。
            </div>
        </div>
</dl>

## 拷贝命令 ## {#copy-commands}

问题：这些字典定义应该在图像副本部分内。

### <dfn dictionary>GPUImageDataLayout</dfn> ### {#gpu-image-data-layout}

<script type=idl>
dictionary GPUImageDataLayout {
    GPUSize64 offset = 0;
    GPUSize32 bytesPerRow;
    GPUSize32 rowsPerImage;
};
</script>

{{GPUImageDataLayout}}是一些线性内存中的图像（<dfn dfn>images</dfn>）布局。它在[=texture=]和[=buffer=]之间复制数据时使用，或者在调度{{GPUQueue}}[=texture=]写入时使用。

  - 对于{{GPUTextureDimension/2d}}纹理，数据在一个或多个毗邻的[=images=]和[=array layers=]之间复制。
  - 对于{{GPUTextureDimension/3d}}纹理，数据在一个或多个毗邻的[=images=]和深度[=slices=]之间复制。

在字节数组和纹理之间复制的操作始终适用于[=texel block=]的行，我们将其称为<dfn dfn>block row</dfn>。不能只更新[=texel block=]的一部分。

问题：更精确地定义图像。特别是，将它们定义为由[=texel block=]组成。

问题：通过参考复制方法共享的通用算法，定义精确的复制语义。

<dl dfn-type=dict-member dfn-for=GPUImageDataLayout>
    : <dfn>bytesPerRow</dfn>
    ::
        每个[=block row=]的开头和后续[=block row=]之间的步幅（以字节为单位）。

        如果有多个[=block row=]则为必须项(即，高度或深度大于一块)。

    : <dfn>rowsPerImage</dfn>
    ::
        每个纹理图像的[=block row=]数。{{GPUImageDataLayout/rowsPerImage}} &times;
        {{GPUImageDataLayout/bytesPerRow}}是每个数据[=images=]的开头和后续[=images=]之间的步幅（以字节为单位）。

        如果有多个[=images=]则为必须项(即，高度大于一)。
</dl>

### <dfn dictionary>GPUImageCopyBuffer</dfn> ### {#gpu-image-copy-buffer}

在图像复制操作中，{{GPUImageCopyBuffer}}定义了一个{{GPUBuffer}}，并与 `copySize` 一起，定义了图像数据在缓冲区内存中如何布局（请参阅 GPUImageDataLayout）。

<script type=idl>
dictionary GPUImageCopyBuffer : GPUImageDataLayout {
    required GPUBuffer buffer;
};
</script>

<div algorithm class=validusage>
<dfn abstract-op>validating GPUImageCopyBuffer</dfn>

  **Arguments:**
    - {{GPUImageCopyBuffer}} |imageCopyBuffer|

  **Returns:** {{boolean}}

  当且仅当所有以下条件都满足时，返回 `true`。
    - |imageCopyBuffer|.{{GPUImageCopyBuffer/buffer}}必须是一个[=valid=]{{GPUBuffer}}。
    - |imageCopyBuffer|.{{GPUImageDataLayout/bytesPerRow}}必须是256的倍数。

</div>

### <dfn dictionary>GPUImageCopyTexture</dfn> ### {#gpu-image-copy-texture}

在图像复制操作中，{{GPUImageCopyTexture}}定义了一个{{GPUTexture}}，并与 `copySize` 一起定义了纹理的子区域（跨越相同 mip-map 级别的一个或多个连续[=texture subresource=]）。

<script type=idl>
dictionary GPUImageCopyTexture {
    required GPUTexture texture;
    GPUIntegerCoordinate mipLevel = 0;
    GPUOrigin3D origin = {};
    GPUTextureAspect aspect = "all";
};
</script>

<dl dfn-type=dict-member dfn-for=GPUImageCopyTexture>
    : <dfn>texture</dfn>
    ::
        要复制到/从的纹理。

    : <dfn>mipLevel</dfn>
    ::
        要复制到/从的{{GPUImageCopyTexture/texture}}的Mip-map级别。

    : <dfn>origin</dfn>
    ::
        定义复制的原点 - 要复制到/从的纹理子区域的最小角。与 `copySize` 一起定义完整复制子区域。

    : <dfn>aspect</dfn>
    ::
        定义要复制到/从纹理的宽高比。
</dl>

<div algorithm class=validusage>
<dfn abstract-op>validating GPUImageCopyTexture</dfn>

  **Arguments:**
    - {{GPUImageCopyTexture}} |imageCopyTexture|
    - {{GPUExtent3D}} |copySize|

  **Returns:** {{boolean}}

  使:
  - |blockWidth|为|imageCopyTexture|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/format}}的[=texel block width=]。
  - |blockHeight|为|imageCopyTexture|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/format}}的[=texel block height=]。

  当且仅当以下所有条件都满足时，返回 `true`：
  - |imageCopyTexture|.{{GPUImageCopyTexture/texture}}必须为一个[=valid=]{{GPUTexture}}.
  - |imageCopyTexture|.{{GPUImageCopyTexture/mipLevel}}必须小于|imageCopyTexture|.{{GPUImageCopyTexture/texture}}的{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/mipLevelCount}}。
  - |imageCopyTexture|.{{GPUImageCopyTexture/origin}}.[=Origin3D/x=]必须是|blockWidth|的倍数。
  - |imageCopyTexture|.{{GPUImageCopyTexture/origin}}.[=Origin3D/y=]必须是|blockHeight|的倍数。
  - 如果满足以下任一条件，则|imageCopyTexture|的[=imageCopyTexture subresource size=]等于|copySize|：
        - |imageCopyTexture|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/format}}是一个depth-stencil格式。
        - |imageCopyTexture|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/sampleCount}}大于1。

</div>

问题(gpuweb/gpuweb#69)：使用{{GPUTextureDimension/1d}}和{{GPUTextureDimension/3d}}纹理定义副本。

### <dfn dictionary>GPUImageCopyTextureTagged</dfn> ### {#gpu-image-copy-texture-tagged}

WebGPU纹理保存原始数字数据，并且没有用描述颜色的语义元数据标记。 但是，{{GPUQueue/copyExternalImageToTexture()}}从描述颜色的来源进行复制。

一个{{GPUImageCopyTextureTagged}}是一个{{GPUImageCopyTexture}}，它额外标记了颜色空间/编码和alpha预乘元数据，以便可以在复制期间保留语义颜色数据。此元数据仅影响{{GPUQueue/copyExternalImageToTexture()}}调用的语义。

<script type=idl>
dictionary GPUImageCopyTextureTagged : GPUImageCopyTexture {
    GPUPredefinedColorSpace colorSpace = "srgb";
    boolean premultipliedAlpha = false;
};
</script>

<dl dfn-type=dict-member dfn-for=GPUImageCopyTextureTagged>
    : <dfn>colorSpace</dfn>
    ::
        描述用于将数据编码到目标纹理中的颜色空间和编码。

        Note:
        注意：如果{{GPUImageCopyTextureTagged/colorSpace}}与源图像匹配，则不会发生转换。 {{ImageBitmap}}颜色空间标记和转换可以通过{{ImageBitmapOptions}}进行控制。

    : <dfn>premultipliedAlpha</dfn>
    ::
        描述写入纹理的数据是否应将其RGB通道预乘以Alpha通道。

        如果此选项设置为 `true`并且{{GPUImageCopyExternalImage/source}}也预乘，则即使源RGB值超过其相应的alpha值，也必须保留它们。

        注意：如果{{GPUImageCopyTextureTagged/premultipliedAlpha}}与源图像匹配，则不会发生转换。2d画布html#premultiplied-alpha-and-the-2d-rendering-context|总是预乘，而WebGL画布可以通过<l spec=html>[=WebGLContextAttributes=]</l>控制。{{ImageBitmap}}预乘可以通过{{ImageBitmapOptions}}控制。
</dl>

问题：将颜色值的编码定义（并测试）为{{GPUQueue/copyExternalImageToTexture()}}允许的各种编码。

### <dfn dictionary>GPUImageCopyExternalImage</dfn> ### {#gpu-image-copy-external-image}

<script type=idl>
dictionary GPUImageCopyExternalImage {
    required (ImageBitmap or HTMLCanvasElement or OffscreenCanvas) source;
    GPUOrigin2D origin = {};
};
</script>

{{GPUImageCopyExternalImage}}有以下成员：

<dl dfn-type=dict-member dfn-for=GPUImageCopyExternalImage>
    : <dfn>source</dfn>
    ::
        图像副本的来源。源数据副本在发出{{GPUQueue/copyExternalImageToTexture()}}时被捕获。

    : <dfn>origin</dfn>
    ::
        定义副本的原点 - 要从中复制的源子区域的最小角。与 `copySize` 一起定义完整子区域副本。
</dl>

### 缓冲区副本 ### {#buffer-copies}

<dl dfn-type=method dfn-for=GPUCommandEncoder>
    : <dfn>copyBufferToBuffer(source, sourceOffset, destination, destinationOffset, size)</dfn>
    ::
        将命令编码到{{GPUCommandEncoder}}中，将数据从{{GPUBuffer}}的子区域复制到另一个{{GPUBuffer}}的子区域。

        <div algorithm=GPUCommandEncoder.copyBufferToBuffer>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/copyBufferToBuffer(source, sourceOffset, destination, destinationOffset, size)">
                |source|: 要复制的{{GPUBuffer}}.
                |sourceOffset|: 到要复制的|source|中的字节偏移量。
                |destination|: 要复制到的{{GPUBuffer}}.
                |destinationOffset|: 到要复制到的的|destination|中的字节偏移量。
                |size|: 要复制的字节大小。
            </pre>

            **Returns:** {{undefined}}

            如果以下任何条件未满足，产生一个校验错误并停止。
            <div class=validusage>
                - |this|.{{GPUCommandEncoder/[[state]]}}为{{encoder state/open}}状态。
                - |source|可以和|this|一起有效使用。
                - |destination|可以和|this|一起有效使用。
                - |source|.{{GPUBuffer/[[usage]]}}包含{{GPUBufferUsage/COPY_SRC}}。
                - |destination|.{{GPUBuffer/[[usage]]}}包含{{GPUBufferUsage/COPY_DST}}。
                - |size|是4的倍数。
                - |sourceOffset|是4的倍数。
                - |destinationOffset|是4的倍数。
                - (|sourceOffset| + |size|)不会溢出{{GPUSize64}}。
                - (|destinationOffset| + |size|)不会溢出{{GPUSize64}}。
                - |source|.{{GPUBuffer/[[size]]}}大于等于(|sourceOffset| + |size|)。
                - |destination|.{{GPUBuffer/[[size]]}}大于等于(|destinationOffset| + |size|)。
                - |source|和|destination|不是同一个{{GPUBuffer}}。
            </div>

            问题(gpuweb/gpuweb#21)：为GPUCommandEncoder定义状态机。

            问题(gpuweb/gpuweb#69)：指出如何处理规范中的溢出。
        </div>
</dl>

### 图像副本 ### {#image-copies}

WebGPU提供{{GPUCommandEncoder/copyBufferToTexture()}}以buffer-to-texture拷贝，以及{{GPUCommandEncoder/copyTextureToBuffer()}} 以texture-to-buffer拷贝。

以下定义和校验规则对{{GPUCommandEncoder/copyBufferToTexture()}}和{{GPUCommandEncoder/copyTextureToBuffer()}}都应用。

[=imageCopyTexture subresource size=]和[=Valid Texture Copy Range=]同样对
{{GPUCommandEncoder/copyTextureToTexture()}}应用。

<div algorithm="imageCopyTexture subresource size">

<dfn dfn>imageCopyTexture subresource size</dfn>

  **Arguments:**
    - {{GPUImageCopyTexture}} |imageCopyTexture|

  **Returns:** {{GPUExtent3D}}

  |imageCopyTexture|的[=imageCopyTexture subresource size=]计算如下:

  它的[=Extent3D/width=], [=Extent3D/height=]和[=Extent3D/depthOrArrayLayers=]分别为=mipmap level=] |imageCopyTexture|.{{GPUImageCopyTexture/mipLevel}}上的|imageCopyTexture|.{{GPUImageCopyTexture/texture}} [=subresource=] [=physical size=]的宽度，高度，和深度。

</div>

问题：将此定义为具有 (texture, mipmapLevel) 参数的算法，并使用调用语法而不是通过标签引用定义。

<div>
    校验线性纹理数据（<dfn abstract-op>validating linear texture data</dfn>(layout, byteSize, format, copyExtent)）

    **Arguments:**
    : {{GPUImageDataLayout}} |layout|
    :: 线性纹理数据的布局。
    : {{GPUSize64}} |byteSize|
    :: 显性数据的总大小，以字节为单位。
    : {{GPUTextureFormat}} |format|
    :: 纹理格式。
    : {{GPUExtent3D}} |copyExtent|
    :: 要复制的纹理的范围。

    1. 使|blockWidth|, |blockHeight|, and |blockSize|为|格式|的[=texel block width=]，[=texel block height|height=]，和[=texel block size|size=]。

    2. 假设|copyExtent|.[=Extent3D/width=]为|blockWidth|的倍数并且|copyExtent|.[=Extent3D/height=]为|blockHeight|的倍数。使:
            - |widthInBlocks|为|copyExtent|.[=Extent3D/width=] &divide; |blockWidth|.
            - |heightInBlocks|为|copyExtent|.[=Extent3D/height=] &divide; |blockHeight|.
            - |bytesInLastRow|为|blockSize| &times; |widthInBlocks|.

    3. 如果以下条件未满足则失败：
        <div class=validusage>
            - 如果|heightInBlocks| &gt; 1，|layout|.{{GPUImageDataLayout/bytesPerRow}}需要被指定。
            - 如果|copyExtent|.[=Extent3D/depthOrArrayLayers=] &gt; 1,
                |layout|.{{GPUImageDataLayout/bytesPerRow}}和|layout|.{{GPUImageDataLayout/rowsPerImage}}需要被指定。
            - 如果被指定，|layout|.{{GPUImageDataLayout/bytesPerRow}}必须大于或等于|bytesInLastRow|。
            - 如果被指定，|layout|.{{GPUImageDataLayout/rowsPerImage}}必须大于或等于|heightInBlocks|。
        </div>

    4. 使|requiredBytesInCopy|为0。

    5. 如果copyExtent|.[=Extent3D/depthOrArrayLayers=] &gt; 1:
        1. 使|bytesPerImage|为
            |layout|.{{GPUImageDataLayout/bytesPerRow}} &times;
            |layout|.{{GPUImageDataLayout/rowsPerImage}}。
        1. 使|bytesBeforeLastImage|为
            |bytesPerImage| &times; (|copyExtent|.[=Extent3D/depthOrArrayLayers=] &minus; 1)。
        1. 将|bytesBeforeLastImage|加至|requiredBytesInCopy|。

    6. 如果|copyExtent|.[=Extent3D/depthOrArrayLayers=] &gt; 0:

        1. 如果|heightInBlocks| &gt; 1, 将
            |layout|.{{GPUImageDataLayout/bytesPerRow}} &times;
            (|heightInBlocks| &minus; 1)
            加至|requiredBytesInCopy|。

        1. 如果|heightInBlocks| &gt; 0, 将
            |bytesInLastRow|加至|requiredBytesInCopy|。

    7. 如果以下条件未满足则失败：
        <div class=validusage>
            - |layout|.{{GPUImageDataLayout/offset}} + |requiredBytesInCopy| &le; |byteSize|。
        </div>
</div>

<div algorithm class=validusage>

<dfn dfn>Valid Texture Copy Range</dfn>

给定一个{{GPUImageCopyTexture}} |imageCopyTexture|和一个{{GPUExtent3D}} |copySize|，使：
  - |blockWidth|为|imageCopyTexture|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/format}}的[=texel block width=]。
  - |blockHeight|为|imageCopyTexture|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/format}}的[=texel block height=]。

以下校验规则应用:

  - 如果|imageCopyTexture|.{{GPUImageCopyTexture/texture}}的{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/dimension}}为{{GPUTextureDimension/1d}}：
    - |copySize|.[=Extent3D/height=]和[=Extent3D/depthOrArrayLayers=]都为1。
  - 如果|imageCopyTexture|.{{GPUImageCopyTexture/texture}}的{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/dimension}}为
    {{GPUTextureDimension/2d}}：
     -  (|imageCopyTexture|.{{GPUImageCopyTexture/origin}}.[=Origin3D/x=] + |copySize|.[=Extent3D/width=])，
        (|imageCopyTexture|.{{GPUImageCopyTexture/origin}}.[=Origin3D/y=] + |copySize|.[=Extent3D/height=])，和
        (|imageCopyTexture|.{{GPUImageCopyTexture/origin}}.[=Origin3D/z=] + |copySize|.[=Extent3D/depthOrArrayLayers=])需要分别小于或等于|imageCopyTexture|[=imageCopyTexture subresource size=]的[=Extent3D/width=]，[=Extent3D/height=]，和[=Extent3D/depthOrArrayLayers=]。
  - |copySize|.[=Extent3D/width=]必须为|blockWidth|的倍数。
  - |copySize|.[=Extent3D/height=]必须为|blockHeight|的倍数。

</div>

问题(gpuweb/gpuweb#69)：使用{{GPUTextureDimension/1d}}和{{GPUTextureDimension/3d}}纹理定义副本。

问题(gpuweb/gpuweb#537)：对rowsPerImage附加的限制，如果需要。

问题(gpuweb/gpuweb#652): 定义{{GPUTextureFormat/"depth24plus"}},
{{GPUTextureFormat/"depth24plus-stencil8"}}, 和{{GPUTextureFormat/"stencil8"}}的副本。

问题: 将“Valid Texture Copy Range”转换成带参数的算法，类似于“validating linear texture data”。

<dl dfn-type=method dfn-for=GPUCommandEncoder>
    : <dfn>copyBufferToTexture(source, destination, copySize)</dfn>
    ::
        将命令编码到{{GPUCommandEncoder}}中，将数据从{{GPUBuffer}}的子区域复制到一个或多个连续[=texture subresource=]的子区域。

        <div algorithm=GPUCommandEncoder.copyBufferToTexture>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/copyBufferToTexture(source, destination, copySize)">
                |source|: 结合|copySize|，定义源缓冲区的区域。
                |destination|: 结合复制大小，定义目标[=texture subresource=]的区域。
                |copySize|:
            </pre>

            **Returns:** {{undefined}}

            如果以下任何条件未满足，则产生一个校验错误并停止。
            <div class=validusage>
                - 使|dstTextureDesc|为|destination|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}。
                - |this|.{{GPUCommandEncoder/[[state]]}}为{{encoder state/open}}。
                - [$validating GPUImageCopyBuffer$](|source|)返回 `true`。
                - |source|.{{GPUImageCopyBuffer/buffer}}.{{GPUBuffer/[[usage]]}}包含{{GPUBufferUsage/COPY_SRC}}。
                - [$validating GPUImageCopyTexture$](|destination|, |copySize|)返回 `true`。
                - |dstTextureDesc|.{{GPUTextureDescriptor/usage}}包含{{GPUTextureUsage/COPY_DST}}。
                - |dstTextureDesc|.{{GPUTextureDescriptor/sampleCount}}为1。
                - 如果|dstTextureDesc|.{{GPUTextureDescriptor/format}}为depth-stencil格式：
                    - |destination|.{{GPUImageCopyTexture/aspect}}必须指向一个|dstTextureDesc|.{{GPUTextureDescriptor/format}}的单个可拷贝宽高比。详见[[#depth-formats|depth-formats]]。
                - 如果|dstTextureDesc|.{{GPUTextureDescriptor/format}}不是depth/stencil格式：
                    - |source|.{{GPUImageDataLayout/offset}}为|dstTextureDesc|.{{GPUTextureDescriptor/format}}的[=texel block size=]的倍数。
                - 如果|dstTextureDesc|.{{GPUTextureDescriptor/format}}是depth/stencil格式：
                    - |source|.{{GPUImageDataLayout/offset}}为4的倍数。
                - [$validating linear texture data$](|source|,
                    |source|.{{GPUImageCopyBuffer/buffer}}.{{GPUBuffer/[[size]]}},
                    |dstTextureDesc|.{{GPUTextureDescriptor/format}},
                    |copySize|)成功。
            </div>
        </div>

    : <dfn>copyTextureToBuffer(source, destination, copySize)</dfn>
    ::
        将命令编码到{{GPUCommandEncoder}}中，将数据从一个或多个连续[=texture subresource=]的子区域复制到{{GPUBuffer}}的子区域。

        <div algorithm=GPUCommandEncoder.copyTextureToBuffer>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/copyTextureToBuffer(source, destination, copySize)">
                |source|: 结合|copySize|，定义源[=texture subresource=]的区域。
                |destination|: 结合|copySize|，定义目标缓冲区的区域。
                |copySize|:
            </pre>

            **Returns:** {{undefined}}

            如果以下任何条件未满足，则产生一个校验错误并停止。
            <div class=validusage>
                - Let |srcTextureDesc|为|source|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}。
                - |this|.{{GPUCommandEncoder/[[state]]}}为{{encoder state/open}}。
                - [$validating GPUImageCopyTexture$](|source|, |copySize|)返回 `true`。
                - |srcTextureDesc|.{{GPUTextureDescriptor/usage}}包含{{GPUTextureUsage/COPY_SRC}}。
                - |srcTextureDesc|.{{GPUTextureDescriptor/sampleCount}}为1。
                - 如果|srcTextureDesc|.{{GPUTextureDescriptor/format}}为depth-stencil格式:
                    - |source|.{{GPUImageCopyTexture/aspect}}必须指向一个|srcTextureDesc|.{{GPUTextureDescriptor/format}}的可拷贝宽高比。详见[[#depth-formats|depth-formats]]。
                - [$validating GPUImageCopyBuffer$](|destination|)返回 `true`。
                - |destination|.{{GPUImageCopyBuffer/buffer}}.{{GPUBuffer/[[usage]]}}包含{{GPUBufferUsage/COPY_DST}}。
                - [=Valid Texture Copy Range=]应用至|source|和|copySize|。
                - 如果|srcTextureDesc|.{{GPUTextureDescriptor/format}}不是depth/stencil格式：
                    - |destination|.{{GPUImageDataLayout/offset}}|srcTextureDesc|.{{GPUTextureDescriptor/format}}的[=texel block size=]的倍数。
                - 如果|srcTextureDesc|.{{GPUTextureDescriptor/format}}是depth/stencil格式：
                    - |destination|.{{GPUImageDataLayout/offset}}是4的倍数。
                - [$validating linear texture data$](|destination|,
                    |destination|.{{GPUImageCopyBuffer/buffer}}.{{GPUBuffer/[[size]]}},
                    |srcTextureDesc|.{{GPUTextureDescriptor/format}},
                    |copySize|)成功。
            </div>
        </div>

    : <dfn>copyTextureToTexture(source, destination, copySize)</dfn>
    ::
        将命令编码到{{GPUCommandEncoder}}中，该命令将数据从一个或多个连续[=texture subresource=]的子区域复制到一个或多个连续[=texture subresource=]的另一个子区域。

        <div algorithm=GPUCommandEncoder.copyTextureToTexture>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/copyTextureToTexture(source, destination, copySize)">
                |source|: 结合|copySize|，定义源[=texture subresource=]的区域。
                |destination|: 结合|copySize|，定义目标[=texture subresource=]的区域。
                |copySize|:
            </pre>

            **Returns:** {{undefined}}

            1. 如果以下任何条件未满足，则产生一个校验错误并停止。
                <div class=validusage>
                    - 使|srcTextureDesc|为|source|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}。
                    - 使|dstTextureDesc|为|destination|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}。
                    - |this|.{{GPUCommandEncoder/[[state]]}}为{{encoder state/open}}。
                    - [$validating GPUImageCopyTexture$](|source|, |copySize|)返回 `true`。
                    - |srcTextureDesc|.{{GPUTextureDescriptor/usage}}包含{{GPUTextureUsage/COPY_SRC}}。
                    - [$validating GPUImageCopyTexture$](|destination|, |copySize|)返回 `true`。
                    - |dstTextureDesc|.{{GPUTextureDescriptor/usage}}包含{{GPUTextureUsage/COPY_DST}}。
                    - |srcTextureDesc|.{{GPUTextureDescriptor/sampleCount}}等于|dstTextureDesc|.{{GPUTextureDescriptor/sampleCount}}。
                    - 如果|srcTextureDesc|.{{GPUTextureDescriptor/format}}不等于|dstTextureDesc|.{{GPUTextureDescriptor/format}}:
                        - [=copies of depth and stencil textures|copy configuration被允许=]
                    - 如果|srcTextureDesc|.{{GPUTextureDescriptor/format}}是depth-stencil格式：
                        - |source|.{{GPUImageCopyTexture/aspect}}和|destination|.{{GPUImageCopyTexture/aspect}}必须都分别指向|srcTextureDesc|.{{GPUTextureDescriptor/format}}和|dstTextureDesc|.{{GPUTextureDescriptor/format}}的全部宽高比。
                    - [=Valid Texture Copy Range=]应用至|source|和|copySize|.
                    - [=Valid Texture Copy Range=]应用至|destination|和|copySize|.
                    - [$set of subresources for texture copy$](|source|, |copySize|)和[$set of subresources for texture copy$](|destination|, |copySize|)是不相交的。
                </div>
        </div>
</dl>

<div>
    The <dfn abstract-op>set of subresources for texture copy</dfn>(|imageCopyTexture|, |copySize|)
    是一个包含如下内容的集合：

      - 如果|imageCopyTexture|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/dimension}}为{{GPUTextureDimension/"2d"}}:
          - 每个|copySize|.[=Extent3D/depthOrArrayLayers=] [=array layers=]的|arrayLayer|从|imageCopyTexture|.{{GPUImageCopyTexture/origin}}.[=Origin3D/z=]开始：
              - |imageCopyTexture|.{{GPUImageCopyTexture/texture}}的The [=subresource=]在[=mipmap level=] |imageCopyTexture|.{{GPUImageCopyTexture/mipLevel}}和[=array layer=] |arrayLayer|处。
      - 否则：
          - |imageCopyTexture|.{{GPUImageCopyTexture/texture}}的[=subresource=]在[=mipmap level=] |imageCopyTexture|.{{GPUImageCopyTexture/mipLevel}}处。
</div>

## 调试标记 ## {#command-encoder-debug-markers}

命令编码器和可编程传递编码器都提供了将调试标签应用于命令组或将单个标签插入命令序列的方法。调试组可以嵌套以创建标记命令的层次结构。 这些标签可能会传递给原生API后端以供工具使用，也可能由用户代理的内部工具使用，或者在此类工具不可用或不适用时可能是空操作。

{{GPUCommandEncoder}}或{{GPUProgrammablePassEncoder}}中的调试组必须为良好嵌套的。

<dl dfn-type=method dfn-for=GPUCommandEncoder>
    : <dfn>pushDebugGroup(groupLabel)</dfn>
    ::
        为{{GPUCommandEncoder}}标记一个命令标签组的起始位置。

        <div algorithm=GPUCommandEncoder.pushDebugGroup>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/pushDebugGroup(groupLabel)">
                |groupLabel|: 命令组的标签。
            </pre>

            **Returns:** {{undefined}}

            在|this|的[=Device timeline=]上发起如下步骤：
            <div class=device-timeline>
                - 如果以下任何条件未满足，使|this|[=invalid=]并停止。
                    <div class=validusage>
                        - |this|.{{GPUCommandEncoder/[[state]]}}为{{encoder state/open}}。
                    </div>
                - 把|groupLabel|[=stack/push=]到|this|.{{GPUCommandEncoder/[[debug_group_stack]]}}上。
            </div>
        </div>

    : <dfn>popDebugGroup()</dfn>
    ::
        为{{GPUCommandEncoder}}标记一个命令标签组的结束位置。

        <div algorithm=GPUCommandEncoder.popDebugGroup>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Returns:** {{undefined}}

            在|this|的[=Device timeline=]上发起如下步骤：
            <div class=device-timeline>
                - 如果以下任何条件未满足，使|this|[=invalid=]并停止。
                    <div class=validusage>
                        - |this|.{{GPUCommandEncoder/[[state]]}}为{{encoder state/open}}。
                        - |this|.{{GPUCommandEncoder/[[debug_group_stack]]}}'s [=stack/size=]大于0。
                    </div>
                - 从|this|.{{GPUCommandEncoder/[[debug_group_stack]]}}中[=stack/pop=]出一项。
            </div>
        </div>

    : <dfn>insertDebugMarker(markerLabel)</dfn>
    ::
        用一个标签字符串标记一个命令流中的点。

        <div algorithm=GPUCommandEncoder.insertDebugMarker>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/insertDebugMarker(markerLabel)">
                markerLabel: 要插入的标签。
            </pre>

            **Returns:** {{undefined}}

            在|this|的[=Device timeline=]上发起如下步骤：
            <div class=device-timeline>
                - 如果以下任何条件未满足，使|this|[=invalid=]并停止。
                    <div class=validusage>
                        - |this|.{{GPUCommandEncoder/[[state]]}}为{{encoder state/open}}。
                    </div>
            </div>
        </div>
</dl>

## 查询 ## {#command-encoder-queries}

<dl dfn-type=method dfn-for=GPUCommandEncoder>
    : <dfn>writeTimestamp(querySet, queryIndex)</dfn>
    ::
        当所有先前命令被全部执行时，向|querySet|写入一个时间戳值。

        <div algorithm=GPUCommandEncoder.writeTimestamp>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/writeTimestamp(querySet, queryIndex)">
                |querySet|: 存放时间戳的查询集合。
                |queryIndex|: 查询集合的查询索引。
            </pre>

            **Returns:** {{undefined}}

            1. 如果|this|.{{GPUObjectBase/[[device]]}}.{{device/[[features]]}}不为[=list/contain=]
                {{GPUFeatureName/"timestamp-query"}}，抛出一个{{TypeError}}。
            2. 如果以下任何条件未满足，产生一个校验错误并停止。
                <div class=validusage>
                    - |this|.{{GPUCommandEncoder/[[state]]}}为{{encoder state/open}}。
                    - |querySet|可以与|this|一起有效使用。
                    - |querySet|.{{GPUQuerySet/[[descriptor]]}}.{{GPUQuerySetDescriptor/type}}为{{GPUQueryType/"timestamp"}}。
                    - |queryIndex| &lt; |querySet|.{{GPUQuerySet/[[descriptor]]}}.{{GPUQuerySetDescriptor/count}}。
                </div>

            问题: 描述{{GPUCommandEncoder/writeTimestamp()}}算法步骤。
        </div>

    : <dfn>resolveQuerySet(querySet, firstQuery, queryCount, destination, destinationOffset)</dfn>
    ::

        <div algorithm=GPUCommandEncoder.resolveQuerySet>
            **Called on:** {{GPUCommandEncoder}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/resolveQuerySet(querySet, firstQuery, queryCount, destination, destinationOffset)">
                querySet:
                firstQuery:
                queryCount:
                destination:
                destinationOffset:
            </pre>

            **Returns:** {{undefined}}

            如果以下任何条件未满足，产生一个{{GPUValidationError}}并停止。
            <div class=validusage>
                - |this|.{{GPUCommandEncoder/[[state]]}}为{{encoder state/open}}。
                - |querySet|为[$valid to use with$] |this|。
                - |destination|为[$valid to use with$] |this|。
                - |destination|.{{GPUBuffer/[[usage]]}}包含{{GPUBufferUsage/QUERY_RESOLVE}}。
                - |firstQuery|小于|querySet|中的查询数量。
                - (|firstQuery| + |queryCount|)小于等于|querySet|中的查询数量。
                - |destinationOffset|是256的倍数。
                - |destinationOffset| + 8 &times; |queryCount| &le; |destination|.{{GPUBuffer/[[size]]}}。
            </div>

            问题: 描述{{GPUCommandEncoder/resolveQuerySet()}}算法步骤。
        </div>
</dl>

## 结尾 ## {#command-encoder-finalization}

可以通过调用{{GPUCommandEncoder/finish()}}来创建包含{{GPUCommandEncoder}}记录的命令的{{GPUCommandBuffer}}。 一旦{{GPUCommandEncoder/finish()}}被调用，命令编码器就不能再使用了。

<dl dfn-type=method dfn-for=GPUCommandEncoder>
    : <dfn>finish(descriptor)</dfn>
    ::
        停止记录命令序列并返回一个对应的{{GPUCommandBuffer}}。

        <div algorithm=GPUCommandEncoder.finish>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/finish(descriptor)">
                descriptor:
            </pre>

            **Returns:** {{GPUCommandBuffer}}

            1. 使|commandBuffer|为一个新的{{GPUCommandBuffer}}。
            2. 在|this|的[=Device timeline=]上发起如下步骤：
                <div class=device-timeline>
                    1. 如果以下任何条件未满足，产生一个校验错误并停止。
                        <div class=validusage>
                            - |this|为[=valid=]的。
                            - |this|.{{GPUCommandEncoder/[[debug_group_stack]]}}'s [=stack/size=]为0。
                            - |this|.{{GPUCommandEncoder/[[state]]}}为{{encoder state/open}}。
                            - 每个包含在|this|中的[=usage scope=]满足[=usage scope validation=]。
                        </div>

                    2. 设置|this|.{{GPUCommandEncoder/[[state]]}}为{{encoder state/closed}}.
                    3. 使|commandBuffer|.{{GPUCommandBuffer/[[command_list]]}}为一个|this|.{{GPUCommandEncoder/[[command_list]]}}的[=list/clone=]。
                </div>

            3. 返回|commandBuffer|。
        </div>
</dl>

# Programmable Passes # {#programmable-passes}

<script type=idl>

interface mixin GPUProgrammablePassEncoder {
    undefined setBindGroup(GPUIndex32 index, GPUBindGroup bindGroup,
                      optional sequence<GPUBufferDynamicOffset> dynamicOffsets = []);

    undefined setBindGroup(GPUIndex32 index, GPUBindGroup bindGroup,
                      Uint32Array dynamicOffsetsData,
                      GPUSize64 dynamicOffsetsDataStart,
                      GPUSize32 dynamicOffsetsDataLength);

    undefined pushDebugGroup(USVString groupLabel);
    undefined popDebugGroup();
    undefined insertDebugMarker(USVString markerLabel);
};
</script>

{{GPUProgrammablePassEncoder}} has the following internal slots:

<dl dfn-type=attribute dfn-for="GPUProgrammablePassEncoder">
    : <dfn>\[[command_encoder]]</dfn> of type {{GPUCommandEncoder}}.
    ::
        The {{GPUCommandEncoder}} that created this programmable pass.

    : <dfn>\[[debug_group_stack]]</dfn> of type [=stack=]&lt;{{USVString}}&gt;.
    ::
        A stack of active debug group labels.

    : <dfn>\[[bind_groups]]</dfn>, of type [=ordered map=]&lt;{{GPUIndex32}}, {{GPUBindGroup}}&gt;
    ::
        The current {{GPUBindGroup}} for each index, initially empty.
</dl>

## 绑定组 ## {#programmable-passes-bind-groups}

<dl dfn-type=method dfn-for=GPUProgrammablePassEncoder>
    : <dfn>setBindGroup(index, bindGroup, dynamicOffsets)</dfn>
    ::
        为给定索引设置当前 {{GPUBindGroup}}。

        <div algorithm=GPUProgrammablePassEncoder.setBindGroup>
            **调用:** {{GPUProgrammablePassEncoder}} this.

            **参数:**
            <pre class=argumentdef for="GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)">
                |index|: 设置绑定组的索引。
                |bindGroup|: 绑定组以用于后续渲染或计算命令。

                <!--|dynamicOffsets|: 包含 |bindGroup| 中每个条目的缓冲区偏移量（以字节为单位）的数组
                标记为 {{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/hasDynamicOffset}}。-->
            </pre>

            **返回:** {{undefined}}

            在  |this|.{{GPUObjectBase/[[device]]}} 的 [=Device timeline=] 发布一下步骤 :
            <div class=device-timeline>
                1. 如果不满足以下任一条件，则使 |this| [=invalid=] 并停止。
                    <div class=validusage>
                        - |bindGroup| 与|this| 一起使用是有效的。
                        - |index| &lt; |this|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxBindGroups}}.
                        - |dynamicOffsets|.length 是
                            |bindGroup|.{{GPUBindGroup/[[layout]]}}.{{GPUBindGroupLayout/[[dynamicOffsetCount]]}}.

                        - 迭代 |bindGroup| 中的每个动态绑定偏移量 并为每个 |bufferBinding|、|bufferLayout| 和 |dynamicOffsetIndex| 运行以下步骤:

                            - 让 |bufferDynamicOffset| 为 |dynamicOffsets|[|dynamicOffsetIndex|].
                            - |bufferBinding|.{{GPUBufferBinding/offset}} + |bufferDynamicOffset| +
                                |bufferLayout|.{{GPUBufferBindingLayout/minBindingSize}} &le;
                                |bufferBinding|.{{GPUBufferBinding/buffer}}.{{GPUBuffer/[[size]]}}.
                            - 如果 |bufferLayout|.{{GPUBufferBindingLayout/type}} 是 {{GPUBufferBindingType/"uniform"}}:

                                - |dynamicOffset| 是 {{supported limits/minUniformBufferOffsetAlignment}} 的倍数。

                            - 如果 |bufferLayout|.{{GPUBufferBindingLayout/type}} 是 {{GPUBufferBindingType/"storage"}}
                                或 {{GPUBufferBindingType/"read-only-storage"}}:

                                - |dynamicOffset| 是 {{supported limits/minStorageBufferOffsetAlignment}} 的倍数。

                    </div>
                1. 设置 |this|.{{GPUProgrammablePassEncoder/[[bind_groups]]}}[|index| 为 |bindGroup|.
            </div>
        </div>

    : <dfn>setBindGroup(index, bindGroup, dynamicOffsetsData, dynamicOffsetsDataStart, dynamicOffsetsDataLength)</dfn>
    ::
        为给定索引设置当前 {{GPUBindGroup}}，将动态偏移指定为 {{Uint32Array}} 的子集。

        <div algorithm=GPUProgrammablePassEncoder.setBindGroup2>
            **调用:** {{GPUProgrammablePassEncoder}} |this|.

            **参数:**
            <pre class=argumentdef for="GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsetsData, dynamicOffsetsDataStart, dynamicOffsetsDataLength)">
                |index|: 设置绑定组的索引。
                |bindGroup|: 绑定组以用于后续渲染或计算命令。
                |dynamicOffsetsData|: 包含 |bindGroup| 中每个条目的缓冲区偏移量（以字节为单位）的数组
                    标记为 {{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/hasDynamicOffset}}。
                |dynamicOffsetsDataStart|: 将元素偏移到 |dynamicOffsetsData| 缓冲区偏移数据开始的地方。
                |dynamicOffsetsDataLength|: 要从 |dynamicOffsetsData| 读取的缓冲区偏移量数。
            </pre>

            **返回:** {{undefined}}

            1. 如果未满足以下任何要求，则抛出 {{RangeError}} 并停止。
                <div class=validusage>
                    - |dynamicOffsetsDataStart| 必须 &ge; 0.
                    - |dynamicOffsetsDataStart| + |dynamicOffsetsDataLength| 必须 &le;
                        |dynamicOffsetsData|.`length`.
                </div>
            1. 让 |dynamicOffsets| 成为一个 [=list=] 包含一个范围， 从获取缓冲区源的副本|dynamicOffsetsData| 的元素
                |dynamicOffsetsDataLength| 的索引 |dynamicOffsetsDataStart| 开始。
            1. 调用 |this|.{{GPUProgrammablePassEncoder/setBindGroup(index,
                bindGroup, dynamicOffsets)|setBindGroup}}(|index|, |bindGroup|, |dynamicOffsets|)。
</dl>

<div algorithm>
    <dfn abstract-op>迭代给定{{GPUBindGroup}}中的每个动态绑定偏移</dfn> |bindGroup| 使用给定的 |steps| 为每个动态偏移执行：

    1. 让 |dynamicOffsetIndex| 为 `0`。
    1. 让 |layout| 为 |bindGroup|.{{GPUBindGroup/[[layout]]}}。
    1. 对于每个 |bindGroup|.{{GPUBindGroup/[[entries]]}} 中的 {{GPUBindGroupEntry}} |entry|:
        1. 让 |bindingDescriptor| 成为 {{GPUBindGroupLayoutEntry}} 在
            |layout|.{{GPUBindGroupLayout/[[entryMap]]}}[|entry|.{{GPUBindGroupEntry/binding}}]:
        1. 如果 |bindingDescriptor|.{{GPUBindGroupLayoutEntry/buffer}} 不是 `undefined` 并且
            |bindingDescriptor|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/hasDynamicOffset}} 是 `true`:
            1. 让 |bufferBinding| 为 |entry|.{{GPUBindGroupEntry/resource}}。
            1. 让 |bufferLayout| 为 |bindingDescriptor|.{{GPUBindGroupLayoutEntry/buffer}}。
            1. 调用 |steps| 使用 |bufferBinding|， |bufferLayout|，和 |dynamicOffsetIndex|。
            1. 让 |dynamicOffsetIndex| 是 |dynamicOffsetIndex| + `1`
</div>

<div algorithm>
    <dfn abstract-op>Validate encoder bind groups</dfn>(encoder, pipeline)

    **参数:**
    : {{GPUProgrammablePassEncoder}} |encoder|
    :: 正在验证绑定组的编码器。
    : {{GPUPipelineBase}} |pipeline|
    :: 用于验证 |encoder|s 绑定组是否兼容的管道。

    如果不满足以下任何一个条件，则返回 `false`:
        <div class=validusage>
            - |pipeline| 不可以是 `null`。
            - 对于在|pipeline|.{{GPUPipelineBase/[[layout]]}}.{{GPUPipelineLayout/[[bindGroupLayouts]]}}({{GPUIndex32}}
                中的每一对 |index|, {{GPUBindGroupLayout}} |bindGroupLayout|) 。
                - 让 |bindGroup| 为 |encoder|.{{GPUProgrammablePassEncoder/[[bind_groups]]}}[|index|].
                - |bindGroup| 不可以是 `null`。
                - |bindGroup|.{{GPUBindGroup/[[layout]]}} 必须是与 |bindGroupLayout| [=group-equivalent=]。

            问题：如果存在，请检查针对 `minBindingSize` 的缓冲区绑定。
        </div>

    否则返回 `true`。
</div>

## 调试标记 ## {#programmable-passes-debug-markers}

可编程传递编码器的调试标记方法提供与
[[#command-encoder-debug-markers|command encoder debug markers]] 同时记录一个可编程通道。

<dl dfn-type=method dfn-for=GPUProgrammablePassEncoder>
    : <dfn>pushDebugGroup(groupLabel)</dfn>
    ::
        标记 {{GPUProgrammablePassEncoder}} 的标记命令组的开始。

        <div algorithm=GPUProgrammablePassEncoder.pushDebugGroup>
            **调用:** {{GPUProgrammablePassEncoder}} |this|.

            **参数:**
            <pre class=argumentdef for="GPUProgrammablePassEncoder/pushDebugGroup(groupLabel)">
                |groupLabel|: 命令组的标签。
            </pre>

            **返回:** {{undefined}}

            在 |this| 的 [=Device timeline=] 上发出以下步骤：
            <div class=device-timeline>
                1. [=stack/Push=] |groupLabel| 到 |this|.{{GPUProgrammablePassEncoder/[[debug_group_stack]]}}.
            </div>
        </div>

    : <dfn>popDebugGroup()</dfn>
    ::
        标记 {{GPUProgrammablePassEncoder}} 的标记命令组的结束。

        <div algorithm=GPUProgrammablePassEncoder.popDebugGroup>
            **调用:** {{GPUProgrammablePassEncoder}} |this|.

            **返回:** {{undefined}}

            在 |this| 的 [=Device timeline=] 上发出以下步骤：
            <div class=device-timeline>
                1. 如果不满足以下任何条件，则生成验证错误并停止。
                    <div class=validusage>
                        - |this|.{{GPUProgrammablePassEncoder/[[debug_group_stack]]}} 的 [=stack/size=] 大于 0.
                    </div>
                1. [=stack/Pop=] |this|.{{GPUProgrammablePassEncoder/[[debug_group_stack]]}} 的一个条目。
            </div>
        </div>

    : <dfn>insertDebugMarker(markerLabel)</dfn>
    ::
        将单个调试标记标签插入到 {{GPUProgrammablePassEncoder}} 的命令序列中。

        <div algorithm=GPUProgrammablePassEncoder.insertDebugMarker>
            *调用:** {{GPUProgrammablePassEncoder}} this.

            **参数:**
            <pre class=argumentdef for="GPUProgrammablePassEncoder/insertDebugMarker(markerLabel)">
                markerLabel: 要插入的标签。
            </pre>

            **返回:** {{undefined}}
        </div>
</dl>


# 计算通道 # {#compute-passes}

## <dfn interface>GPUComputePassEncoder</dfn> ## {#compute-pass-encoder}

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUComputePassEncoder {
    undefined setPipeline(GPUComputePipeline pipeline);
    undefined dispatch(GPUSize32 x, optional GPUSize32 y = 1, optional GPUSize32 z = 1);
    undefined dispatchIndirect(GPUBuffer indirectBuffer, GPUSize64 indirectOffset);

    undefined beginPipelineStatisticsQuery(GPUQuerySet querySet, GPUSize32 queryIndex);
    undefined endPipelineStatisticsQuery();

    undefined writeTimestamp(GPUQuerySet querySet, GPUSize32 queryIndex);

    undefined endPass();
};
GPUComputePassEncoder includes GPUObjectBase;
GPUComputePassEncoder includes GPUProgrammablePassEncoder;
</script>

{{GPUComputePassEncoder}}有以下内部插槽：

<dl dfn-type=attribute dfn-for="GPUComputePassEncoder">
    : <dfn>\[[pipeline]]</dfn>, of type {{GPUComputePipeline}}
    ::
        当前{{GPUComputePipeline}}，初始为 `null`。
</dl>

### 创建 ### {#compute-pass-encoder-creation}

<script type=idl>
dictionary GPUComputePassDescriptor : GPUObjectDescriptorBase {
};
</script>

### 调度 ### {#compute-pass-encoder-dispatch}

<dl dfn-type=method dfn-for=GPUComputePassEncoder>
    : <dfn>setPipeline(pipeline)</dfn>
    ::
        设置当前{{GPUComputePipeline}}。

        <div algorithm="GPUComputePassEncoder.setPipeline">
            **Called on:** {{GPUComputePassEncoder}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUComputePassEncoder/setPipeline(pipeline)">
                |pipeline|: 用于后续调度命令的计算管道。
            </pre>

            **Returns:** {{undefined}}

            在|this|.{{GPUObjectBase/[[device]]}}的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                1. 如果以下任何条件未满足，使|this| [=invalid=]并且停止。
                    <div class=validusage>
                        - |pipeline|可以和|this|一起有效使用。
                    </div>
                1. 设置|this|.{{GPUComputePassEncoder/[[pipeline]]}}为|pipeline|。
            </div>
        </div>

    : <dfn>dispatch(x, y, z)</dfn>
    ::
        使用当前{{GPUComputePipeline}}执行的调度工作。有关详细规范，请参阅[[#computing-operations]]。

        <div algorithm="GPUComputePassEncoder.dispatch">
            **Called on:** {{GPUComputePassEncoder}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUComputePassEncoder/dispatch(x, y, z)">
                |x|: 要调度的工作组网格的X维度。
                |y|: 要调度的工作组网格的Y维度。
                |z|: 要调度的工作组网格的Z维度。
            </pre>

            **Returns:** {{undefined}}

            在|this|.{{GPUObjectBase/[[device]]}}的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                1. 如果以下任何条件未满足，使|this| [=invalid=]并停止。
                    <div class=validusage>
                        - [$Validate encoder bind groups$](|this|, |this|.{{GPUComputePassEncoder/[[pipeline]]}})为 `true`。
                        - |x|，|y|，和|z|都小于|this|.device.limits.{{supported limits/maxComputeWorkgroupsPerDimension}}。
                    </div>

                2. [=list/Append=]一个[=GPU command=]至|this|.{{GPUProgrammablePassEncoder/[[command_encoder]]}}.{{GPUCommandEncoder/[[command_list]]}}，它捕获|this|的{{GPUComputePassEncoder}}状态作为|passState|，并在执行时在适当的[=Queue timeline=]上发起以下步骤：
                        1. 使用|passState|.{{GPUComputePassEncoder/[[pipeline]]}}与|passState|.{{GPUProgrammablePassEncoder/[[bind_groups]]}}调度维度为[|x|, |y|, |z|]的工作组网格。
                    </div>
            </div>
        </div>

    : <dfn>dispatchIndirect(indirectBuffer, indirectOffset)</dfn>
    ::
        使用从{{GPUBuffer}}读取的参数调度要与当前{{GPUComputePipeline}一起执行的工作。有关详细规范，请参阅[[#computing-operations]]。

        缓冲区中<dfn dfn for=>indirect dispatch parameters</dfn>必须是三个**32位无符号整数值（共12个字节）**的紧密打包块，以与{{GPUComputePassEncoder/dispatch()}}的参数相同的顺序给出。例如：

        <pre highlight="js">
            let dispatchIndirectParameters = new Uint32Array(3);
            dispatchIndirectParameters[0] = x;
            dispatchIndirectParameters[1] = y;
            dispatchIndirectParameters[2] = z;
        </pre>

        <div algorithm="GPUComputePassEncoder.dispatchIndirect">
            **Called on:** {{GPUComputePassEncoder}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUComputePassEncoder/dispatchIndirect(indirectBuffer, indirectOffset)">
                |indirectBuffer|: Buffer containing the [=indirect dispatch parameters=].
                |indirectOffset|: Offset in bytes into |indirectBuffer| where the dispatch data begins.
            </pre>

            **Returns:** {{undefined}}

            在|this|.{{GPUObjectBase/[[device]]}}的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                1. 如果以下任何条件未满足, 使|this| [=invalid=]并停止。
                    <div class=validusage>
                        - [$Validate encoder bind groups$](|this|, |this|.{{GPUComputePassEncoder/[[pipeline]]}})为 `true`。
                        - |indirectBuffer|为[$valid to use with$] |this|。
                        - |indirectBuffer|.{{GPUBuffer/[[usage]]}}包含{{GPUBufferUsage/INDIRECT}}。
                        - |indirectOffset| + sizeof([=indirect dispatch parameters=]) &le;
                            |indirectBuffer|.{{GPUBuffer/[[size]]}}。
                        - |indirectOffset|是4的倍数。
                    </div>
                1. 使|indirectBuffer|作为{{GPUBufferUsage/INDIRECT}}加至[=usage scope=]。
            </div>

            问题：添加一些与{{supported limits/maxComputeWorkgroupsPerDimension}}有关的校验。
        </div>
</dl>

### 查询 ### {#compute-pass-encoder-queries}

<dl dfn-type=method dfn-for=GPUComputePassEncoder>
    : <dfn>beginPipelineStatisticsQuery(querySet, queryIndex)</dfn>
    ::

        <div algorithm="GPUComputePassEncoder.beginPipelineStatisticsQuery">
            **Called on:** {{GPUComputePassEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUComputePassEncoder/beginPipelineStatisticsQuery(querySet, queryIndex)">
                querySet:
                queryIndex:
            </pre>

            **Returns:** {{undefined}}

            1. 如果this|.{{GPUObjectBase/[[device]]}}.{{device/[[features]]}}未[=list/contain=]
                {{GPUFeatureName/"pipeline-statistics-query"}}，抛出一个{{TypeError}}。

            问题：描述{{GPUComputePassEncoder/beginPipelineStatisticsQuery()}}算法步骤。
        </div>

    : <dfn>endPipelineStatisticsQuery()</dfn>
    ::

        <div algorithm="GPUComputePassEncoder.endPipelineStatisticsQuery">
            **Called on:** {{GPUComputePassEncoder}} |this|.

            **Returns:** {{undefined}}

            1. 如果|this|.{{GPUObjectBase/[[device]]}}.{{device/[[features]]}}未[=list/contain=]
                {{GPUFeatureName/"pipeline-statistics-query"}}，抛出一个{{TypeError}}。

            问题：描述{{GPUComputePassEncoder/endPipelineStatisticsQuery()}}算法步骤。
        </div>

    : <dfn>writeTimestamp(querySet, queryIndex)</dfn>
    ::
        当所有先前命令被全部执行时，在|querySet|中写入一个时间戳。

        <div algorithm="GPUComputePassEncoder.writeTimestamp">
            **Called on:** {{GPUComputePassEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUComputePassEncoder/writeTimestamp(querySet, queryIndex)">
                |querySet|: 存储时间戳值的查询集合。
                |queryIndex|: 查询集合中的查询索引。
            </pre>

            **Returns:** {{undefined}}

            1. 如果|this|.{{GPUObjectBase/[[device]]}}.{{device/[[features]]}}未[=list/contain=]
                {{GPUFeatureName/"timestamp-query"}}, 抛出一个{{TypeError}}。
            2. 如果以下任何条件未满足，产生一个校验错误并停止。
                <div class=validusage>
                    - |querySet|可以和|this|一起有效使用。
                    - |querySet|.{{GPUQuerySet/[[descriptor]]}}.{{GPUQuerySetDescriptor/type}}为{{GPUQueryType/"timestamp"}}。
                    - |queryIndex| &lt; |querySet|.{{GPUQuerySet/[[descriptor]]}}.{{GPUQuerySetDescriptor/count}}。
                </div>

            问题：描述{{GPUComputePassEncoder/writeTimestamp()}}算法步骤。
        </div>
</dl>

### 结尾 ### {#compute-pass-encoder-finalization}

用户完成记录命令后，可以通过调用{{GPUComputePassEncoder/endPass()}}来结束计算通道编码器。一旦{{GPUComputePassEncoder/endPass()}}被调用，计算通道编码器就不能再使用了。

<dl dfn-type=method dfn-for=GPUComputePassEncoder>
    : <dfn>endPass()</dfn>
    ::
        完成计算通道命令序列的记录。

        <div algorithm="GPUComputePassEncoder.endPass">
            **Called on:** {{GPUComputePassEncoder}} |this|.

            **Returns:** {{undefined}}

            在|this|的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                1. 如果以下任何条件未满足，产生一个校验错误并停止。
                    <div class=validusage>
                        - |this|.{{GPUProgrammablePassEncoder/[[debug_group_stack]]}}'s [=stack/size=]为0。

                        问题：添加剩余校验。
                    </div>
            </div>
        </div>
</dl>

# 渲染通道 # {#render-passes}

## <dfn interface>GPURenderPassEncoder</dfn> ## {#render-pass-encoder}

<script type=idl>
interface mixin GPURenderEncoderBase {
    undefined setPipeline(GPURenderPipeline pipeline);

    undefined setIndexBuffer(GPUBuffer buffer, GPUIndexFormat indexFormat, optional GPUSize64 offset = 0, optional GPUSize64 size);
    undefined setVertexBuffer(GPUIndex32 slot, GPUBuffer buffer, optional GPUSize64 offset = 0, optional GPUSize64 size);

    undefined draw(GPUSize32 vertexCount, optional GPUSize32 instanceCount = 1,
              optional GPUSize32 firstVertex = 0, optional GPUSize32 firstInstance = 0);
    undefined drawIndexed(GPUSize32 indexCount, optional GPUSize32 instanceCount = 1,
                     optional GPUSize32 firstIndex = 0,
                     optional GPUSignedOffset32 baseVertex = 0,
                     optional GPUSize32 firstInstance = 0);

    undefined drawIndirect(GPUBuffer indirectBuffer, GPUSize64 indirectOffset);
    undefined drawIndexedIndirect(GPUBuffer indirectBuffer, GPUSize64 indirectOffset);
};

[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPURenderPassEncoder {
    undefined setViewport(float x, float y,
                     float width, float height,
                     float minDepth, float maxDepth);

    undefined setScissorRect(GPUIntegerCoordinate x, GPUIntegerCoordinate y,
                        GPUIntegerCoordinate width, GPUIntegerCoordinate height);

    undefined setBlendConstant(GPUColor color);
    undefined setStencilReference(GPUStencilValue reference);

    undefined beginOcclusionQuery(GPUSize32 queryIndex);
    undefined endOcclusionQuery();

    undefined beginPipelineStatisticsQuery(GPUQuerySet querySet, GPUSize32 queryIndex);
    undefined endPipelineStatisticsQuery();

    undefined writeTimestamp(GPUQuerySet querySet, GPUSize32 queryIndex);

    undefined executeBundles(sequence<GPURenderBundle> bundles);
    undefined endPass();
};
GPURenderPassEncoder includes GPUObjectBase;
GPURenderPassEncoder includes GPUProgrammablePassEncoder;
GPURenderPassEncoder includes GPURenderEncoderBase;
</script>

  * 在间接绘制调用中，基本实例字段（在间接缓冲区数据内）必须设置为零。

{{GPURenderEncoderBase}}有以下内部插槽：

<dl dfn-type=attribute dfn-for="GPURenderEncoderBase">
    : <dfn>\[[layout]]</dfn>, of type {{GPURenderPassLayout}}
    ::
        渲染通道的布局。

    : <dfn>\[[depthReadOnly]]</dfn>, of type boolean?
    ::
        如果存在，该标识表示深度分量未被修改。

    : <dfn>\[[stencilReadOnly]]</dfn>, of type boolean?
    ::
        如果存在，该标识表示模板组件未被修改。

    : <dfn>\[[pipeline]]</dfn>, of type {{GPURenderPipeline}}
    ::
        当前{{GPURenderPipeline}}, 初始为 `null`。

    : <dfn>\[[index_buffer]]</dfn>, of type {{GPUBuffer}}
    ::
        从中读取索引数据的当前缓冲区，初始为 `null`。

    : <dfn>\[[index_format]]</dfn>, of type {{GPUIndexFormat}}
    ::
        {{GPURenderEncoderBase/[[index_buffer]]}}中的索引数据的格式。

    : <dfn>\[[index_buffer_size]]</dfn>, of type {{GPUSize64}}
    ::
        当前设置的{{GPURenderEncoderBase/[[index_buffer]]}}节的字节大小，初始为0。

    : <dfn>\[[vertex_buffers]]</dfn>, of type [=ordered map=]&lt;slot, {{GPUBuffer}}&gt;
    ::
        当前要从每个插槽读取顶点数据的{{GPUBuffer}}s，初始为空。

    : <dfn>\[[vertex_buffer_sizes]]</dfn>, of type [=ordered map=]&lt;slot, {{GPUSize64}}&gt;
    ::
        当前为每个插槽设置的{{GPUBuffer}}部分的大小（以字节为单位），初始为空。
</dl>

{{GPURenderPassEncoder}} has the following internal slots:

<dl dfn-type=attribute dfn-for="GPURenderPassEncoder">
    : <dfn>\[[attachment_size]]</dfn>
    ::
        设置为以下范围：
            - `width, height` = 通道渲染附件的维度。

    : <dfn>\[[occlusion_query_set]]</dfn>, of type {{GPUQuerySet}}.
    ::
        用于存储通道的阻塞查询结果的{{GPUQuerySet}}，在通道创建时使用{{GPURenderPassDescriptor}}.{{GPURenderPassDescriptor/occlusionQuerySet}}进行初始化。

    : <dfn>\[[occlusion_query_active]]</dfn>, of type {{boolean}}.
    ::
        通道的{{GPURenderPassEncoder/[[occlusion_query_set]]}}是否被写入。

    : <dfn>\[[viewport]]</dfn>
    ::  当前视口矩形和深度范围。
</dl>

当{{GPURenderPassEncoder}}被创建，它有以下默认状态：
  * {{GPURenderPassEncoder/[[viewport]]}}:
      * `x, y` = `0.0, 0.0`
      * `width, height` = 通道渲染目标的维度
      * `minDepth, maxDepth` = `0.0, 1.0`
  * 裁剪矩形:
      * `x, y` = `0, 0`
      * `width, height` = 通道渲染目标的维度

### 创建 ### {#render-pass-encoder-creation}

<script type=idl>
dictionary GPURenderPassDescriptor : GPUObjectDescriptorBase {
    required sequence<GPURenderPassColorAttachment> colorAttachments;
    GPURenderPassDepthStencilAttachment depthStencilAttachment;
    GPUQuerySet occlusionQuerySet;
};
</script>

<dl dfn-type=dict-member dfn-for=GPURenderPassDescriptor>
    : <dfn>colorAttachments</dfn>
    ::
        此序列中的{{GPURenderPassColorAttachment}}值集，定义了在执行此渲染通道时将输出到哪些颜色附件。

    : <dfn>depthStencilAttachment</dfn>
    ::
        {{GPURenderPassDepthStencilAttachment}}值，定义了深度/模板附件，在执行此渲染通道时将输出到该附件并对其进行测试。

    : <dfn>occlusionQuerySet</dfn>
    ::
        {{GPUQuerySet}}值，定义了此通道的的阻塞查询结果将存储在哪里。
</dl>

<div class=validusage dfn-for=GPURenderPassDescriptor>
    <dfn abstract-op>Valid Usage</dfn>

    给定一个{{GPURenderPassDescriptor}} |this|，应用以下校验规则：

    1. |this|.{{GPURenderPassDescriptor/colorAttachments}}.length小于或等于8。
    2. |this|.{{GPURenderPassDescriptor/colorAttachments}}.length必须大于 `0` 或|this|.{{GPURenderPassDescriptor/depthStencilAttachment}}必须不为 `null`。
    3. 对每个|this|.{{GPURenderPassDescriptor/colorAttachments}}中的|colorAttachment|：

        1. |colorAttachment|必须满足[$GPURenderPassColorAttachment/GPURenderPassColorAttachment Valid Usage$]规则。

    4. 如果|this|.{{GPURenderPassDescriptor/depthStencilAttachment}}不为 `null`：

        1. |this|.{{GPURenderPassDescriptor/depthStencilAttachment}}必须满足[$GPURenderPassDepthStencilAttachment/GPURenderPassDepthStencilAttachment Valid Usage$]规则。

    5. 所有|this|.{{GPURenderPassDescriptor/colorAttachments}}中的{{GPURenderPassColorAttachment/view}}，以及|this|.{{GPURenderPassDescriptor/depthStencilAttachment}}.{{GPURenderPassDepthStencilAttachment/view}}，
        如果存在，必须有相等的{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/sampleCount}}。

    6. 对每个|this|.{{GPURenderPassDescriptor/colorAttachments}}中的{{GPURenderPassColorAttachment/view}}以及|this|.{{GPURenderPassDescriptor/depthStencilAttachment}}.{{GPURenderPassDepthStencilAttachment/view}}，
        如果存在，{{GPUTextureView/[[renderExtent]]}}必须匹配。

    7. 如果|this|.{{GPURenderPassDescriptor/occlusionQuerySet}}不为 `null`：

        1. |this|.{{GPURenderPassDescriptor/occlusionQuerySet}}.{{GPUQuerySet/[[descriptor]]}}.{{GPUQuerySetDescriptor/type}}必须为{{GPUQueryType/occlusion}}。

    问题(gpuweb/gpuweb#503)：支持无附件。
</div>

<div algorithm="GPURenderPassDescriptor accessors" dfn-for=RenderPassDescriptor>
    对一个给定{{GPURenderPassDescriptor}}值的|descriptor|，句法：

      - |descriptor|.<dfn dfn>renderExtent</dfn>指任何{{GPUTextureView/[[descriptor]]}}中的{{GPUTextureView/[[renderExtent]]}}在|descriptor|.{{GPURenderPassDescriptor/depthStencilAttachment}}.{{GPURenderPassDepthStencilAttachment/view}}或任何|descriptor|.{{GPURenderPassDescriptor/colorAttachments}}中的{{GPURenderPassColorAttachment/view}}中。

    问题：一旦我们从其他地方引用它，就定义它。

    注意：[$GPURenderPassDescriptor/Valid Usage$]保证附件的所有渲染范围都是相同的，因此我们可以采用其中的任何一个，假设描述符是有效的。
</div>

#### 颜色附件 #### {#color-attachments}

<script type=idl>
dictionary GPURenderPassColorAttachment {
    required GPUTextureView view;
    GPUTextureView resolveTarget;

    required (GPULoadOp or GPUColor) loadValue;
    required GPUStoreOp storeOp;
};
</script>

<dl dfn-type=dict-member dfn-for=GPURenderPassColorAttachment>
    : <dfn>view</dfn>
    ::
        {{GPUTextureView}}描述将为此颜色附件输出到的纹理[=subresource=]。

    : <dfn>resolveTarget</dfn>
    ::
        一个{{GPUTextureView}}描述纹理[=subresource=]，如果{{GPURenderPassColorAttachment/view}}是多采样的，它将接收此颜色附件的解析输出。

    : <dfn>loadValue</dfn>
    ::
        如果是{{GPULoadOp}}，则指示在执行渲染通道之前要在{{GPURenderPassColorAttachment/view}}上执行的加载操作。如果是{{GPUColor}}，则指示在执行渲染通道之前清除{{GPURenderPassColorAttachment/view}}的值。

        注意：建议选择clear-value；见{{GPULoadOp/"load"}}。

    : <dfn>storeOp</dfn>
    ::
        执行渲染通道后对{{GPURenderPassColorAttachment/view}}执行的存储操作。
</dl>

<div class=validusage dfn-for=GPURenderPassColorAttachment>
    <dfn abstract-op>GPURenderPassColorAttachment Valid Usage</dfn>

    给定一个{{GPURenderPassColorAttachment}} |this|，应用以下校验规则：

    1. 使|renderTextureDesc|为|this|.{{GPURenderPassColorAttachment/view}}.{{GPUTextureView/[[texture]]}}.{{GPUTexture/[[descriptor]]}}。
    2. 使|resolveTextureDesc|为|this|.{{GPURenderPassColorAttachment/resolveTarget}}.{{GPUTextureView/[[texture]]}}.{{GPUTexture/[[descriptor]]}}。
    3. |this|.{{GPURenderPassColorAttachment/view}}必须有一个[=color renderable format=]。
    4. |renderTextureDesc|.{{GPUTextureDescriptor/usage}必须包含{{GPUTextureUsage/RENDER_ATTACHMENT}}。
    5. |this|.{{GPURenderPassColorAttachment/view}}必须为一个单个[=subresource=]视图。
    6. 如果|this|.{{GPURenderPassColorAttachment/resolveTarget}}不为 `null`：

        1. |this|.{{GPURenderPassColorAttachment/view}}必须为多重采样。
        2. |this|.{{GPURenderPassColorAttachment/resolveTarget}}必须不为多重采样。
        3. |resolveTextureDesc|.{{GPUTextureDescriptor/usage}}必须包含{{GPUTextureUsage/RENDER_ATTACHMENT}}。
        4. |this|.{{GPURenderPassColorAttachment/resolveTarget}}必须为一个单个[=subresource=]视图。

        5. 被|this|.{{GPURenderPassColorAttachment/resolveTarget}}和|this|.{{GPURenderPassColorAttachment/view}}所见的[=subresource=]维度必须匹配。
        6. |resolveTextureDesc|.{{GPUTextureDescriptor/format}}必须匹配|renderTextureDesc|.{{GPUTextureDescriptor/format}}.
        7. 问题：描述任何剩余的resolveTarget校验。

    问题：描述此类型的其余校验规则。
</div>

#### 深度/模板附件 #### {#depth-stencil-attachments}

<script type=idl>
dictionary GPURenderPassDepthStencilAttachment {
    required GPUTextureView view;

    required (GPULoadOp or float) depthLoadValue;
    required GPUStoreOp depthStoreOp;
    boolean depthReadOnly = false;

    required (GPULoadOp or GPUStencilValue) stencilLoadValue;
    required GPUStoreOp stencilStoreOp;
    boolean stencilReadOnly = false;
};
</script>

<dl dfn-type=dict-member dfn-for=GPURenderPassDepthStencilAttachment>
    : <dfn>view</dfn>
    ::
        一个描述纹理[=subresource=]的{{GPUTextureView}}，它将输出至此深度/模板附件，以及从此深度/模板附件中读取。

    : <dfn>depthLoadValue</dfn>
    ::
        如果是{{GPULoadOp}}，则指示在执行渲染通道之前要对视图的深度组件执行的加载操作。如果是 `float`，则表示在执行渲染通道之前清除视图深度组件的值。

        注意：建议选择clear-value；见{{GPULoadOp/"load"}}。

    : <dfn>depthStoreOp</dfn>
    ::
        执行渲染通道后对{{GPURenderPassDepthStencilAttachment/view}}深度组件执行的存储操作。

        注意：建议选择clear-value；见{{GPULoadOp/"load"}}。

    : <dfn>depthReadOnly</dfn>
    ::
        指{{GPURenderPassDepthStencilAttachment/view}}的深度组件，只读。

    : <dfn>stencilLoadValue</dfn>
    ::
        如果是{{GPULoadOp}}，则指在执行渲染通道之前要在{{GPURenderPassDepthStencilAttachment/view}}的模板组件上执行的加载操作。如果是{{GPUStencilValue}}，则指在执行渲染通道之前将{{GPURenderPassDepthStencilAttachment/view}}的模板组件清除到的值。

    : <dfn>stencilStoreOp</dfn>
    ::
        执行渲染通道后在{{GPURenderPassDepthStencilAttachment/view}}的模板组件上执行的存储操作。

    : <dfn>stencilReadOnly</dfn>
    ::
        指{{GPURenderPassDepthStencilAttachment/view}}的模板组件，只读。
</dl>

<div class=validusage dfn-for=GPURenderPassDepthStencilAttachment>
    <dfn abstract-op>GPURenderPassDepthStencilAttachment Valid Usage</dfn>

    给定一个{{GPURenderPassDepthStencilAttachment}} |this|，应用以下校验规则：

    - |this|.{{GPURenderPassDepthStencilAttachment/view}}必须有一个[=depth or stencil renderable
        format=].
    - |this|.{{GPURenderPassDepthStencilAttachment/view}}必须为一个单个[=mipmap level=], single [=array layer=], 和所有纹理中 [=aspects=]的视图。
    - |this|.{{GPURenderPassDepthStencilAttachment/view}}.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/usage}}必须包含{{GPUTextureUsage/RENDER_ATTACHMENT}}。
    - 如果|this|.{{GPURenderPassDepthStencilAttachment/view}}.{{GPUTextureView/[[descriptor]]}}.{{GPUTextureViewDescriptor/format}}既包含深度宽高比又包含模板宽高比（见[[#depth-formats|depth-stencil formats]]）：
        - |this|.{{GPURenderPassDepthStencilAttachment/depthReadOnly}}必须等于|this|.{{GPURenderPassDepthStencilAttachment/stencilReadOnly}}
    - 如果|this|.{{GPURenderPassDepthStencilAttachment/depthReadOnly}}为 `true`：
        - |this|.{{GPURenderPassDepthStencilAttachment/depthLoadValue}}必须为{{GPULoadOp/"load"}}。
        - |this|.{{GPURenderPassDepthStencilAttachment/depthStoreOp}}必须为{{GPUStoreOp/"store"}}。
    - 如果|this|.{{GPURenderPassDepthStencilAttachment/stencilReadOnly}}为 `true`:
        - |this|.{{GPURenderPassDepthStencilAttachment/stencilLoadValue}}必须为{{GPULoadOp/"load"}}。
        - |this|.{{GPURenderPassDepthStencilAttachment/stencilStoreOp}}必须为{{GPUStoreOp/"store"}}。

    问题：描述此类型的其余校验规则。
</div>

#### 加载&amp;存储操作 #### {#load-and-store-ops}

<script type=idl>
enum GPULoadOp {
    "load"
};
</script>

<dl dfn-type=enum-value dfn-for=GPULoadOp>
    : <dfn>"load"</dfn>
    ::
        将此附件的现有值加载到渲染通道中。

        注意：在某些GPU硬件（主要是移动设备）上，提供clear-value的成本要低得多，因为它避免了将数据从主内存加载到tile-local内存中。在其他GPU硬件上，没有显着差异。因此，在初始值无关紧要的情况下（例如，将使用天空盒清除渲染目标），建议使用清除值，而不是{{GPULoadOp/"load"}}。
</dl>

<script type=idl>
enum GPUStoreOp {
    "store",
    "discard"
};
</script>

#### 渲染通道布局 #### {#render-pass-layout}

{{GPURenderPassLayout}}包含当前通道渲染目标的布局，它决定了通道与渲染管线的兼容性。

<script type=idl>
dictionary GPURenderPassLayout: GPUObjectDescriptorBase {
    required sequence<GPUTextureFormat> colorFormats;
    GPUTextureFormat depthStencilFormat;
    GPUSize32 sampleCount = 1;
};
</script>

<div>
    从通道派生渲染目标布局（<dfn abstract-op>derive render targets layout from pass</dfn>）

    **Arguments:**
    - {{GPURenderPassDescriptor}} |descriptor|

    **Returns:** {{GPURenderPassLayout}}

    1. 使|layout|为一个新的{{GPURenderPassLayout}}对象。
    2. 对每个|descriptor|.{{GPURenderPassDescriptor/colorAttachments}}中的|colorAttachment|：
        1. 设置|layout|.{{GPURenderPassLayout/sampleCount}}为|colorAttachment|.{{GPURenderPassColorAttachment/view}}.{{GPUTextureView/[[texture]]}}.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/sampleCount}}。
        2. 将|colorAttachment|.{{GPURenderPassColorAttachment/view}}.{{GPUTextureView/[[descriptor]]}}.{{GPUTextureViewDescriptor/format}}添加至|layout|.{{GPURenderPassLayout/colorFormats}}。
    3. 使|depthStencilAttachment|为|descriptor|.{{GPURenderPassDescriptor/depthStencilAttachment}}.
    4. 如果|depthStencilAttachment|不为 `null`：
        1. 使|view|为|depthStencilAttachment|.{{GPURenderPassDepthStencilAttachment/view}}
        2. 使|layout|.{{GPURenderPassLayout/sampleCount}}为|view|.{{GPUTextureView/[[texture]]}}.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/sampleCount}}。
        3. 使|layout|.{{GPURenderPassLayout/depthStencilFormat}}为|view|.{{GPUTextureView/[[descriptor]]}}.{{GPUTextureViewDescriptor/format}}。
    5. 返回|layout|。

</div>

<div>
    从管线派生渲染目标布局（<dfn abstract-op>derive render targets layout from pipeline</dfn>）

    **Arguments:**
    - {{GPURenderPipelineDescriptor}} |descriptor|

    **Returns:** {{GPURenderPassLayout}}

    1. 使|layout|为一个新的{{GPURenderPassLayout}}对象。
    2. 设置|layout|.{{GPURenderPassLayout/sampleCount}}为|descriptor|.{{GPURenderPipelineDescriptor/multisample}}.{{GPUMultisampleState/count}}。
    3. 如果|descriptor|.{{GPURenderPipelineDescriptor/depthStencil}}不为 `null`：
        1. 设置|layout|.{{GPURenderPassLayout/depthStencilFormat}}为|descriptor|.{{GPURenderPipelineDescriptor/depthStencil}}/{{GPUDepthStencilState/format}}。
    4. 如果|descriptor|.{{GPURenderPipelineDescriptor/fragment}}不为 `null`:
        1. 对每个|descriptor|.{{GPURenderPipelineDescriptor/fragment}}.{{GPUFragmentState/targets}}中的|colorTarget|：
            1. 添加|colorTarget|.{{GPUColorTargetState/format}}至|layout|.{{GPURenderPassLayout/colorFormats}}
    5. 返回|layout|。

</div>

### 绘制 ### {#render-pass-encoder-drawing}

<dl dfn-type=method dfn-for=GPURenderEncoderBase>
    : <dfn>setPipeline(pipeline)</dfn>
    ::
        设置当前{{GPURenderPipeline}}。

        <div algorithm="GPURenderEncoderBase.setPipeline">
            **Called on:** {{GPURenderEncoderBase}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderEncoderBase/setPipeline(pipeline)">
                |pipeline|: 后续绘制命令使用的渲染管线。
            </pre>

            **Returns:** {{undefined}}

            在|this|.{{GPUObjectBase/[[device]]}}的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                1. 使|pipelineTargetsLayout|为[$derive render targets layout from pipeline$](|pipeline|.{{GPURenderPipeline/[[descriptor]]}})。
                2. 如果以下任何条件未满足, 使|this| [=invalid=]并停止。
                    <div class=validusage>
                        - |pipeline|可以同|this|一起有效使用。
                        - |this|.{{GPURenderEncoderBase/[[layout]]}}等于|pipelineTargetsLayout|。
                        - 如果|pipeline|.{{GPURenderPipeline/[[writesDepth]]}}：
                            |this|.{{GPURenderEncoderBase/[[depthReadOnly]]}}必须为 `false`。
                        - If |pipeline|.{{GPURenderPipeline/[[writesStencil]]}}：
                            |this|.{{GPURenderEncoderBase/[[stencilReadOnly]]}}必须为 `false`。
                    </div>
                3. 设置|this|.{{GPURenderEncoderBase/[[pipeline]]}}为|pipeline|。

                问题：定义对于这里的{{GPURenderPassLayout}}"等于"的含义。
            </div>
        </div>

    : <dfn>setIndexBuffer(buffer, indexFormat, offset, size)</dfn>
    ::
        设置当前索引缓冲区。

        <div algorithm="GPURenderEncoderBase.setIndexBuffer">
            **Called on:** {{GPURenderEncoderBase}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderEncoderBase/setIndexBuffer(buffer, indexFormat, offset, size)">
                |buffer|: 包含后续绘制命令所使用的索引数据的缓冲区。
                |indexFormat|: |buffer|中包含的索引数据的格式。
                |offset|: 以字节为单位在索引数据开始的|缓冲区|中的偏移量。默认为 `0`。
                |size|: |缓冲区|中索引数据的大小（以字节为单位）。默认为缓冲区的大小减去偏移量。
            </pre>

            **Returns:** {{undefined}}

            在|this|.{{GPUObjectBase/[[device]]}}的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                1. 如果|size|缺失，设置|size|为|buffer|.{{GPUBuffer/[[size]]}} - |offset|。
                1. 如果以下任何条件未满足，使|this| [=invalid=]并停止。
                    <div class=validusage>
                        - |buffer|可以和|this|一起有效使用。
                        - |buffer|.{{GPUBuffer/[[usage]]}}包含{{GPUBufferUsage/INDEX}}。
                        - |offset|是|indexFormat|字节大小的倍数。
                        - |offset| + |size| &le; |buffer|.{{GPUBuffer/[[size]]}}。
                    </div>
                1. 将|buffer|作为[=internal usage/input=]加至[=usage scope=]。
                1. 设置|this|.{{GPURenderEncoderBase/[[index_buffer]]}}为|buffer|。
                1. 设置|this|.{{GPURenderEncoderBase/[[index_format]]}}为|indexFormat|。
                1. 设置|this|.{{GPURenderEncoderBase/[[index_buffer_size]]}}为|size|。
            </div>
        </div>

    : <dfn>setVertexBuffer(slot, buffer, offset, size)</dfn>
    ::
        设置给定槽的当前顶点缓冲区。

        <div algorithm="GPURenderEncoderBase.setVertexBuffer">
            **Called on:** {{GPURenderEncoderBase}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderEncoderBase/setVertexBuffer(slot, buffer, offset, size)">
                |slot|: 要为其设置顶点缓冲区的顶点缓冲区插槽。
                |buffer|: 包含用于后续绘图命令的顶点数据的缓冲区。
                |offset|: 以字节为单位在顶点数据开始的|缓冲区|中的偏移量。默认为 0。
                |size|: |缓冲区|中顶点数据的大小（以字节为单位）。默认为|缓冲区|的大小减去偏移量。
            </pre>

            **Returns:** {{undefined}}

            在|this|.{{GPUObjectBase/[[device]]}}的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                1. 如果|size|缺失, 设置|size|为|buffer|.{{GPUBuffer/[[size]]}} - |offset|.
                2. 如果以下任何条件未满足，使|this| [=invalid=]并且停止。
                    <div class=validusage>
                        - |buffer|可以和|this|一起有效使用。
                        - |buffer|.{{GPUBuffer/[[usage]]}}包含{{GPUBufferUsage/VERTEX}}。
                        - |slot| &lt; |this|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxVertexBuffers}}。
                        - |offset|是4的倍数。
                        - |offset| + |size| &le; |buffer|.{{GPUBuffer/[[size]]}}。
                    </div>
                3. 将|缓冲区|作为[=internal usage/input=]加至[=usage scope=]。
                4. 设置|this|.{{GPURenderEncoderBase/[[vertex_buffers]]}}[|slot|]为|buffer|。
                5. 设置|this|.{{GPURenderEncoderBase/[[vertex_buffer_sizes]]}}[|slot|]为|size|。
            </div>
        </div>

    : <dfn>draw(vertexCount, instanceCount, firstVertex, firstInstance)</dfn>
    ::
        绘制图元。见[[#rendering-operations]]。

        <div algorithm="GPURenderEncoderBase.draw">
            **Called on:** {{GPURenderEncoderBase}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderEncoderBase/draw(vertexCount, instanceCount, firstVertex, firstInstance)">
                |vertexCount|: 绘制顶点数。
                |instanceCount|: 绘制实例数。
                |firstVertex|: 开始绘制的位置，以定点为单位的定点缓冲区偏移量。
                |firstInstance|: 第一个绘制实例。
            </pre>

            **Returns:** {{undefined}}

            在|this|.{{GPUObjectBase/[[device]]}}的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                如果以下任何条件未满足，使|this| [=invalid=]并停止。
                <div class=validusage>
                    - 可以和|this|一起有效绘制。
                    - 使|buffers|为|this|.{{GPURenderEncoderBase/[[pipeline]]}}.{{GPURenderPipeline/[[descriptor]]}}.{{GPURenderPipelineDescriptor/vertex}}.{{GPUVertexState/buffers}}.
                    - 对每个{{GPUIndex32}} |slot| `0`至|buffers|.length：
                        - 使|bufferSize|为|this|.{{GPURenderEncoderBase/[[vertex_buffer_sizes]]}}[|slot|]。
                        - 使|stride|为|buffers|[|slot|].{{GPUVertexBufferLayout/arrayStride}}。
                        - 如果|stride|为零：
                            - 对每个|this|.{{GPURenderEncoderBase/[[pipeline]]}}.{{GPURenderPipeline/[[descriptor]]}}.{{GPURenderPipelineDescriptor/vertex}}.{{GPUVertexState/buffers}}.{{GPUVertexBufferLayout/attributes}}列表中|attrib|属性：
                                - |attrib|.{{GPUVertexAttribute/offset}} + sizeof(|attrib|.{{GPUVertexAttribute/format}}) &le;
                                    |bufferSize|

                            否则：

                            - 如果|buffers|[|slot|].{{GPUVertexBufferLayout/stepMode}}为：
                                <dl class="switch">
                                    : {{GPUVertexStepMode/"vertex"}}
                                    :: (|firstVertex| + |vertexCount|) * |stride| &le; |bufferSize|.
                                    : {{GPUVertexStepMode/"instance"}}
                                    :: (|firstInstance| + |instanceCount|) * |stride| &le; |bufferSize|.
                                </dl>
                </div>
            </div>
        </div>

    : <dfn>drawIndexed(indexCount, instanceCount, firstIndex, baseVertex, firstInstance)</dfn>
    ::
        绘制索引图元。见[[#rendering-operations]]。

        <div algorithm="GPURenderEncoderBase.drawIndexed">
            **Called on:** {{GPURenderEncoderBase}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderEncoderBase/drawIndexed(indexCount, instanceCount, firstIndex, baseVertex, firstInstance)">
                |indexCount|: 要绘制的索引数。
                |instanceCount|: 要绘制的实例数。
                |firstIndex|: 开始绘制时，在索引缓冲区中的索引偏移量。
                baseVertex: 在索引到顶点缓冲区之前添加到每个索引值。
                |firstInstance|: 第一个绘制实例。
            </pre>

            **Returns:** {{undefined}}

            在|this|.{{GPUObjectBase/[[device]]}}的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                如果以下任何条件未满足，使this| [=invalid=]并停止。
                <div class=validusage>
                    - 可以和|this|一起有效绘制索引。
                    - |firstIndex| + |indexCount| &le; |this|.{{GPURenderEncoderBase/[[index_buffer_size]]}}
                        &div; |this|.{{GPURenderEncoderBase/[[index_format]]}}'s byte size;
                    - 使|buffers|为|this|.{{GPURenderEncoderBase/[[pipeline]]}}.{{GPURenderPipeline/[[descriptor]]}}.{{GPURenderPipelineDescriptor/vertex}}.{{GPUVertexState/buffers}}。
                    - 对每个{{GPUIndex32}} |slot| `0`至|buffers|.length：
                        - 使|bufferSize|为|this|.{{GPURenderEncoderBase/[[vertex_buffer_sizes]]}}[|slot|]。
                        - 使|stride|为|buffers|[|slot|].{{GPUVertexBufferLayout/arrayStride}}。
                        - 如果|stride|为零：
                            - 对每个|this|.{{GPURenderEncoderBase/[[pipeline]]}}.{{GPURenderPipeline/[[descriptor]]}}.{{GPURenderPipelineDescriptor/vertex}}.{{GPUVertexState/buffers}}.{{GPUVertexBufferLayout/attributes}}列表中的|attrib|属性：
                                - |attrib|.{{GPUVertexAttribute/offset}} + sizeof(|attrib|.{{GPUVertexAttribute/format}}) &le;
                                    |bufferSize|

                            否则：

                            - 如果|buffers|[|slot|].{{GPUVertexBufferLayout/stepMode}}为{{GPUVertexStepMode/"instance"}}:
                                - (|firstInstance| + |instanceCount|) * |stride| &le; |bufferSize|.
                </div>
            </div>
        </div>

    : <dfn>drawIndirect(indirectBuffer, indirectOffset)</dfn>
    ::
        使用从{{GPUBuffer}}中读取的参数的绘制图元。见[[#rendering-operations]]。

        缓冲区中编码的<dfn dfn for=>indirect draw parameters</dfn>必须是一个由**四个32位无符号整数值（总共16个字节）**组成的紧密压缩块，以与{{GPURenderEncoderBase/draw()}}的参数相同的顺序给出。比如：

        <pre highlight="js">
            let drawIndirectParameters = new Uint32Array(4);
            drawIndirectParameters[0] = vertexCount;
            drawIndirectParameters[1] = instanceCount;
            drawIndirectParameters[2] = firstVertex;
            drawIndirectParameters[3] = 0; // firstInstance. Must be 0.
        </pre>

        对应 `firstInstance` 的值被保留以备日后使用，并且必须为零。如果它不为零则{{GPURenderEncoderBase/drawIndirect()}}调用被视作一个no-op。
        <div algorithm="GPURenderEncoderBase.drawIndirect">
            **Called on:** {{GPURenderEncoderBase}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderEncoderBase/drawIndirect(indirectBuffer, indirectOffset)">
                |indirectBuffer|: 包含[=indirect draw parameters=]的缓冲区。
                |indirectOffset|: 到绘图数据开始的|indirectBuffer|的以字节为单位的偏移量。
            </pre>

            **Returns:** {{undefined}}

            在|this|.{{GPUObjectBase/[[device]]}}的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                1. 如果以下任何条件未满足，使|this| [=invalid=]并停止。
                    <div class=validusage>
                        - 它可以和|this|一起有效绘制。
                        - |indirectBuffer|可以和|this|一起有效使用。
                        - |indirectBuffer|.{{GPUBuffer/[[usage]]}}包含{{GPUBufferUsage/INDIRECT}}。
                        - |indirectOffset| + sizeof([=indirect draw parameters=]) &le;
                            |indirectBuffer|.{{GPUBuffer/[[size]]}}。
                        - |indirectOffset|是4的倍数。
                    </div>
                2. 将|indirectBuffer|加至[=usage scope=] as [=internal usage/input=]。
            </div>
        </div>

    : <dfn>drawIndexedIndirect(indirectBuffer, indirectOffset)</dfn>
    ::
        使用从{{GPUBuffer}}读取的参数的绘制索引图元。见[[#rendering-operations]]。

        缓冲区中编码的<dfn dfn for=>indirect drawIndexed parameters</dfn>必须是由**五个32位无符号整数值（共 20 个字节）**组成的紧密压缩块，其顺序与{{GPURenderEncoderBase/drawIndexed()}}的参数相同。比如：

        <pre highlight="js">
            let drawIndexedIndirectParameters = new Uint32Array(5);
            drawIndexedIndirectParameters[0] = indexCount;
            drawIndexedIndirectParameters[1] = instanceCount;
            drawIndexedIndirectParameters[2] = firstIndex;
            drawIndexedIndirectParameters[3] = baseVertex;
            drawIndexedIndirectParameters[4] = 0; // firstInstance. Must be 0.
        </pre>

        对应 `firstInstance` 的值被保留以备日后使用并且必须为零。如果它不为零，则{{GPURenderEncoderBase/drawIndexedIndirect()}}调用被视作一个no-op。

        <div algorithm="GPURenderEncoderBase.drawIndexedIndirect">
            **Called on:** {{GPURenderEncoderBase}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderEncoderBase/drawIndexedIndirect(indirectBuffer, indirectOffset)">
                |indirectBuffer|: 包含[=indirect drawIndexed parameters=]的缓冲区。
                |indirectOffset|: 绘制数据开始处|indirectBuffer|中的字节偏移量。
            </pre>

            **Returns:** {{undefined}}

            在|this|.{{GPUObjectBase/[[device]]}}的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                1. 如果以下任何条件未满足，使|this| [=invalid=]并且停止。
                    <div class=validusage>
                        - 可以和|this|一起有效绘制索引。
                        - |indirectBuffer|可以和|this|一起有效使用。
                        - |indirectBuffer|.{{GPUBuffer/[[usage]]}}包含{{GPUBufferUsage/INDIRECT}}.
                        - |indirectOffset| + sizeof([=indirect drawIndexed parameters=]) &le;
                            |indirectBuffer|.{{GPUBuffer/[[size]]}}.
                        - |indirectOffset|是4的倍数。
                    </div>
                2. 将|indirectBuffer|添加至[=usage scope=] as [=internal usage/input=]。
            </div>
        </div>
</dl>

注意：最初禁用为间接绘制调用设置 `firstInstance` 的功能，以扩展支持WebGPU的硬件。它很可能在未来与其他新的间接绘图功能一起作为一个特性添加。

<div>
    要确定使用{{GPURenderEncoderBase}}|编码器|是否<dfn abstract-op>valid to draw</dfn>，运行以下步骤：

    如果以下任何条件未满足，返回 `false`：
        <div class=validusage>
            - [$Validate encoder bind groups$](|encoder|, |encoder|.{{GPURenderEncoderBase/[[pipeline]]}})必须为 `true`。

            - 使|pipelineDescriptor|为|encoder|.{{GPURenderEncoderBase/[[pipeline]]}}.{{GPURenderPipeline/[[descriptor]]}}。
            - 对每个{{GPUIndex32}} |slot| `0`至|pipelineDescriptor|.{{GPURenderPipelineDescriptor/vertex}}.{{GPUVertexState/buffers}}.length:
                - |encoder|.{{GPURenderEncoderBase/[[vertex_buffers]]}}[|slot|]必须不为 `null`。
        </div>

    否则返回 `true`。
</div>

<div>
    要确定使用{{GPURenderEncoderBase}}|编码器|进行索引绘制（<dfn abstract-op>valid to draw indexed</dfn>）是否有效，请运行以下步骤：

    如果以下任何条件未满足, 返回 `false`：
        <div class=validusage>
            - 使用编码器绘制必须有效。

            - |encoder|.{{GPURenderEncoderBase/[[index_buffer]]}}必须不为 `null`。
            - 使|stripIndexFormat|为|encoder|.{{GPURenderEncoderBase/[[pipeline]]}}.{{GPURenderPipeline/[[strip_index_format]]}}。
            - 如果|stripIndexFormat|不是 `undefined`：
                - |encoder|.{{GPURenderEncoderBase/[[index_format]]}}必须为|stripIndexFormat|。
        </div>

    否则返回 `true`。
</div>

### 光栅化状态 ### {#render-pass-encoder-rasterization-state}

{{GPURenderPassEncoder}}有几种方法会影响绘制命令如何光栅化到此编码器使用的附件。

<dl dfn-type=method dfn-for=GPURenderPassEncoder>
    : <dfn>setViewport(x, y, width, height, minDepth, maxDepth)</dfn>
    ::
        将光栅化阶段使用的视口设置为从标准化设备坐标线性映射到视口坐标。

        <div algorithm="GPURenderPassEncoder.setViewport">
            **Called on:** {{GPURenderPassEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPURenderPassEncoder/setViewport(x, y, width, height, minDepth, maxDepth)">
                |x|: 视口最小X像素值。
                |y|: 视口最小Y像素值。
                |width|: 视口宽度像素值。
                |height|: 视口高度像素值。
                |minDepth|: 视口最小深度。
                |maxDepth|: 视口最大深度。
            </pre>

            **Returns:** {{undefined}}

            在|this|的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                1. 如果以下任何条件未满足，产生一个校验错误并停止。
                    <div class=validusage>
                        - |x|大于等于 `0`。
                        - |y|大于等于 `0`。
                        - |width|大于等于 `0`。
                        - |height|大于等于 `0`。
                        - |x| + |width|小于等于|this|.{{GPURenderPassEncoder/[[attachment_size]]}}.width.
                        - |y| + |height|小于等于|this|.{{GPURenderPassEncoder/[[attachment_size]]}}.height.
                        - |minDepth|大于等于 `0.0`，小于等于 `1.0`。
                        - |maxDepth|大于等于 `0.0`，小于等于 `1.0`。
                        - |maxDepth|大于|minDepth|。
                    </div>
                2. 设置|this|.{{GPURenderPassEncoder/[[viewport]]}}为范围|x|, |y|, |width|, |height|, |minDepth|, 和|maxDepth|。
            </div>

            问题：允许GPU使用固定点或环绕视口坐标。
        </div>

    : <dfn>setScissorRect(x, y, width, height)</dfn>
    ::
        设置在光栅化阶段使用的裁剪矩形。转换为视口坐标后，任何落在裁剪矩形之外的片元都将被丢弃。

        <div algorithm="GPURenderPassEncoder.setScissorRect">
            **Called on:** {{GPURenderPassEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPURenderPassEncoder/setScissorRect(x, y, width, height)">
                |x|: 裁剪矩形的最小X值，以像素为单位。
                |y|: 裁剪矩形的最小Y值，以像素为单位。
                |width|: 裁剪矩形的宽度，以像素为单位。
                |height|: 裁剪矩形的高度，以像素为单位。
            </pre>

            **Returns:** {{undefined}}

            在|this|的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                1. 如果以下任何条件未满足，产生一个校验错误并停止。
                    <div class=validusage>
                        - |x|+|width|小于或等于|this|.{{GPURenderPassEncoder/[[attachment_size]]}}.width。
                        - |y|+|height|小于或等于|this|.{{GPURenderPassEncoder/[[attachment_size]]}}.height。
                    </div>
                2. 设置裁剪矩形范围为|x|, |y|, |width|, 和|height|。
            </div>
        </div>

    : <dfn>setBlendConstant(color)</dfn>
    ::
        设置与{{GPUBlendFactor/"constant"}}和“{{GPUBlendFactor/"one-minus-constant"}}”{{GPUBlendFactor}}一起使用的常量混合颜色和alpha值。

        <div algorithm="GPURenderPassEncoder.setBlendConstant">
            **Called on:** {{GPURenderPassEncoder}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderPassEncoder/setBlendConstant(color)">
                color: 混合时所使用的颜色。
            </pre>
        </div>

    : <dfn>setStencilReference(reference)</dfn>
    ::
        使用{{GPUStencilOperation/"replace"}} {{GPUStencilOperation}}设置模板测试期间使用的模板参考值。

        <div algorithm="GPURenderPassEncoder.setStencilReference">
            **Called on:** {{GPURenderPassEncoder}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderPassEncoder/setStencilReference(reference)">
                reference: 模板参考值。
            </pre>
        </div>
</dl>

### 查询 ### {#render-pass-encoder-queries}

<dl dfn-type=method dfn-for=GPURenderPassEncoder>
    : <dfn>beginOcclusionQuery(queryIndex)</dfn>
    ::

        <div algorithm="GPURenderPassEncoder.beginOcclusionQuery">
            **Called on:** {{GPURenderPassEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPURenderPassEncoder/beginOcclusionQuery(queryIndex)">
                |queryIndex|: 查询集合中的查询索引。
            </pre>

            **Returns:** {{undefined}}

            在|this|.{{GPUObjectBase/[[device]]}}的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                1. 如果以下任何条件未满足，产生一个校验错误并停止。
                    <div class=validusage>
                        - |this|.{{GPURenderPassEncoder/[[occlusion_query_set]]}}不为 `null`。
                        - |queryIndex| &lt; |this|.{{GPURenderPassEncoder/[[occlusion_query_set]]}}.{{GPUQuerySet/[[descriptor]]}}.{{GPUQuerySetDescriptor/count}}。
                        - 同一|queryIndex|的查询必须没有被事先写入此通道。
                        - |this|.{{GPURenderPassEncoder/[[occlusion_query_active]]}}为 `false`。
                    </div>

                2. 设置|this|.{{GPURenderPassEncoder/[[occlusion_query_active]]}}为 `true`。
            </div>
        </div>

    : <dfn>endOcclusionQuery()</dfn>
    ::

        <div algorithm="GPURenderPassEncoder.endOcclusionQuery">
            **Called on:** {{GPURenderPassEncoder}} this.

            **Returns:** {{undefined}}

            在|this|.{{GPUObjectBase/[[device]]}}的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                1. 如果以下任何条件未满足，产生一个校验错误并停止。
                    <div class=validusage>
                        - |this|.{{GPURenderPassEncoder/[[occlusion_query_active]]}}为 `true`。
                    </div>

                2. 设置|this|.{{GPURenderPassEncoder/[[occlusion_query_active]]}}为 `false`。
            </div>
        </div>

    : <dfn>beginPipelineStatisticsQuery(querySet, queryIndex)</dfn>
    ::

        <div algorithm="GPURenderPassEncoder.beginPipelineStatisticsQuery">
            **Called on:** {{GPURenderPassEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPURenderPassEncoder/beginPipelineStatisticsQuery(querySet, queryIndex)">
                querySet:
                queryIndex:
            </pre>

            **Returns:** {{undefined}}

            1. 如果|this|.{{GPUObjectBase/[[device]]}}.{{device/[[features]]}}不[=list/contain=]
                {{GPUFeatureName/"pipeline-statistics-query"}}，抛出一个{{TypeError}}。

            问题：描述{{GPURenderPassEncoder/beginPipelineStatisticsQuery()}}算法步骤。
        </div>

    : <dfn>endPipelineStatisticsQuery()</dfn>
    ::

        <div algorithm="GPURenderPassEncoder.endPipelineStatisticsQuery">
            **Called on:** {{GPURenderPassEncoder}} |this|.

            **Returns:** {{undefined}}

            1. 如果|this|.{{GPUObjectBase/[[device]]}}.{{device/[[features]]}}不[=list/contain=]
                {{GPUFeatureName/"pipeline-statistics-query"}}，抛出一个{{TypeError}}。

            问题：描述{{GPURenderPassEncoder/endPipelineStatisticsQuery()}}算法步骤。
        </div>

    : <dfn>writeTimestamp(querySet, queryIndex)</dfn>
    ::
        当所有先前命令全部被执行时，向|querySet|中写入一个时间戳值。

        <div algorithm="GPURenderPassEncoder.writeTimestamp">
            **Called on:** {{GPURenderPassEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPURenderPassEncoder/writeTimestamp(querySet, queryIndex)">
                querySet: 将储存时间戳值的查询集合。
                queryIndex: 查询集合中的查询索引。
            </pre>

            **Returns:** {{undefined}}

            1. 如果|this|.{{GPUObjectBase/[[device]]}}.{{device/[[features]]}}不[=list/contain=]
                {{GPUFeatureName/"timestamp-query"}}，抛出一个{{TypeError}}。
            2. 如果以下任何条件未满足，产生一个校验错误并停止。
                <div class=validusage>
                    - |querySet|可以和|this|一起有效使用。
                    - |querySet|.{{GPUQuerySet/[[descriptor]]}}.{{GPUQuerySetDescriptor/type}}为{{GPUQueryType/"timestamp"}}。
                    - |queryIndex| &lt; |querySet|.{{GPUQuerySet/[[descriptor]]}}.{{GPUQuerySetDescriptor/count}}。
                    - |querySet|中在|queryIndex|位置的查询，在此渲染通道中，之前没有被写入。
                </div>

            问题：描述{{GPURenderPassEncoder/writeTimestamp()}}算法步骤。
        </div>
</dl>

### 捆绑 ### {#render-pass-encoder-bundles}

<dl dfn-type=method dfn-for=GPURenderPassEncoder>
    : <dfn>executeBundles(bundles)</dfn>
    ::
        执行先前记录到给定{{GPURenderBundle}}中的命令，作为此渲染通道的一部分。

        当执行{{GPURenderBundle}}时，它不会继承渲染通道的管线、绑定组或顶点和索引缓冲区。在{{GPURenderBundle}}执行后，渲染通道的管线、绑定组以及顶点和索引缓冲区被清除。

        注意：状态被清除，哪怕当零{{GPURenderBundle|GPURenderBundles}}被执行。

        Note: state is cleared even if zero {{GPURenderBundle|GPURenderBundles}} are executed.

        <div algorithm="GPURenderPassEncoder.executeBundles">
            **Called on:** {{GPURenderPassEncoder}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderPassEncoder/executeBundles(bundles)">
                bundles: 要执行的渲染捆绑列表。
            </pre>

            **Returns:** {{undefined}}

            问题：描述{{GPURenderPassEncoder/executeBundles()}}算法步骤。
        </div>
</dl>

### 结尾 ### {#render-pass-encoder-finalization}

用户完成记录命令后，可以通过调用{{GPURenderPassEncoder/endPass()}}来结束渲染通道编码器。 一旦{{GPURenderPassEncoder/endPass()}}被调用，渲染通道编码器就不能再使用了。

<dl dfn-type=method dfn-for=GPURenderPassEncoder>
    : <dfn>endPass()</dfn>
    ::
        完全记录渲染通道命令序列。

        <div algorithm="GPURenderPassEncoder.endPass">
            **Called on:** {{GPURenderPassEncoder}} |this|.

            **Returns:** {{undefined}}

            在|this|的[=Device timeline=]上发起以下步骤：
            <div class=device-timeline>
                1. 如果以下任何条件未满足，产生一个校验错误并停止。
                    <div class=validusage>
                        - |this|.{{GPUProgrammablePassEncoder/[[debug_group_stack]]}}的[=stack/size=]为0。
                        - |this|.{{GPURenderPassEncoder/[[occlusion_query_active]]}}为 `false`。

                        Issue: Add remaining validation.
                    </div>

                Issue: Enqueue the attachment stores (with storeOp clear).
            </div>
        </div>
</dl>

# Bundles # {#bundles}

## <dfn interface>GPURenderBundle</dfn> ## {#render-bundle}

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPURenderBundle {
};
GPURenderBundle includes GPUObjectBase;
</script>

### 创建 ### {#render-bundle-creation}

<script type=idl>
dictionary GPURenderBundleDescriptor : GPUObjectDescriptorBase {
};
</script>

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPURenderBundleEncoder {
    GPURenderBundle finish(optional GPURenderBundleDescriptor descriptor = {});
};
GPURenderBundleEncoder includes GPUObjectBase;
GPURenderBundleEncoder includes GPUProgrammablePassEncoder;
GPURenderBundleEncoder includes GPURenderEncoderBase;
</script>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createRenderBundleEncoder(descriptor)</dfn>
    ::
        创建 {{GPURenderBundleEncoder}}.

        <div algorithm=GPUDevice.createRenderBundleEncoder>
            **调用:** {{GPUDevice}} |this|.

            **参数:**
            <pre class=argumentdef for="GPUDevice/createRenderBundleEncoder(descriptor)">
                |descriptor|: Description of the {{GPURenderBundleEncoder}} to create.
            </pre>

            **返回:** {{GPURenderBundleEncoder}}

            在 |this| 的 [=Device timeline=] 上发出以下步骤:
            <div class=device-timeline>
                1. 如果不满足以下任何条件，则生成验证错误并停止。
                    <div class=validusage>
                        Issue: Add remaining validation.
                    </div>
                1. 让 |e| 成为一个新的 {{GPURenderBundleEncoder}} 对象。
                1. 设定 |e|.{{GPURenderEncoderBase/[[layout]]}} 为 |descriptor|.{{GPURenderPassLayout}}.
                1. 设定 |e|.{{GPURenderEncoderBase/[[depthReadOnly]]}} 为 |descriptor|.{{GPURenderBundleEncoderDescriptor/depthReadOnly}}.
                1. 设定 |e|.{{GPURenderEncoderBase/[[stencilReadOnly]]}} 为 |descriptor|.{{GPURenderBundleEncoderDescriptor/stencilReadOnly}}.
                1. 返回 |e|.

                问题：描述 {{GPUDevice/createRenderBundleEncoder()}} 的步骤重置。
            </div>
        </div>
</dl>

### 编码 ### {#render-bundle-encoding}

<script type=idl>
dictionary GPURenderBundleEncoderDescriptor : GPURenderPassLayout {
    boolean depthReadOnly = false;
    boolean stencilReadOnly = false;
};
</script>

### 定稿 ### {#render-bundle-finalization}

<dl dfn-type=method dfn-for=GPURenderBundleEncoder>
    : <dfn>finish(descriptor)</dfn>
    ::
        完成渲染包命令序列的记录。

        <div algorithm="GPURenderBundleEncoder.finish">
            **调用:** {{GPURenderBundleEncoder}} this.

            **参数:**
            <pre class=argumentdef for="GPURenderBundleEncoder/finish(descriptor)">
                descriptor:
            </pre>

            **返回:** {{GPURenderBundle}}

            问题：描述 {{GPURenderBundleEncoder/finish()}} 算法步骤。
        </div>
</dl>

# 队列 # {#queues}

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUQueue {
    undefined submit(sequence<GPUCommandBuffer> commandBuffers);

    Promise<undefined> onSubmittedWorkDone();

    undefined writeBuffer(
        GPUBuffer buffer,
        GPUSize64 bufferOffset,
        [AllowShared] BufferSource data,
        optional GPUSize64 dataOffset = 0,
        optional GPUSize64 size);

    undefined writeTexture(
      GPUImageCopyTexture destination,
      [AllowShared] BufferSource data,
      GPUImageDataLayout dataLayout,
      GPUExtent3D size);

    undefined copyExternalImageToTexture(
        GPUImageCopyExternalImage source,
        GPUImageCopyTextureTagged destination,
        GPUExtent3D copySize);
};
GPUQueue includes GPUObjectBase;
</script>

{{GPUQueue}} 有以下方法:

<dl dfn-type=method dfn-for=GPUQueue>
    : <dfn>writeBuffer(buffer, bufferOffset, data, dataOffset, size)</dfn>
    ::
        将提供的数据写入 {{GPUBuffer}}。

        <div algorithm=GPUQueue.writeBuffer>
            **调用:** {{GPUQueue}} |this|.

            **参数:**
            <pre class=argumentdef for="GPUQueue/writeBuffer(buffer, bufferOffset, data, dataOffset, size)">
                |buffer|: The buffer to write to.
                |bufferOffset|: Offset in bytes into |buffer| to begin writing at.
                |data|: Data to write into |buffer|.
                |dataOffset|: Offset in into |data| to begin writing from. Given in elements if
                    |data| is a `TypedArray` and bytes otherwise.
                |size|: Size of content to write from |data| to |buffer|. Given in elements if
                    |data| is a `TypedArray` and bytes otherwise.
            </pre>

            **返回:** {{undefined}}

            1.如果 |data| 是一个 {{ArrayBuffer}} 或 {{DataView}}，让元素类型为“byte”。
                否则，|data| 是一个 TypedArray； 让元素类型为 TypedArray 的类型。
            1. 让 |dataSize| 是 |data| 的大小，以元素为单位。
            1. 如果 |size| 不见了，
                让 |contentsSize| 为 |dataSize| &minus; |dataOffset|。
                否则， 让 |contentsSize| 为 |size|。
            1. 如果不满足以下任何一个条件，
                抛出 {{OperationError}} 并停止。
                <!-- 注意：在此处内联编写有效的使用规则是最容易的，因为它们取决于上面的 contentsSize。 -->
                <div class=validusage>
                    - |contentsSize| &ge; 0.
                    - |dataOffset| + |contentsSize| &le; |dataSize|.
                    - |contentsSize|，转换为字节，是 4 字节的倍数。
                </div>
            1. 让 |dataContents| 为 获取缓冲区源的副本|缓冲区源所持有的字节的副本。
            1. 让 |contents| 是 |dataContents| 元素的 |contentsSize| 从 |dataOffset| 的偏移量开始。
            1. 在 |this| 的 [=Queue timeline=] 上发出以下步骤:
                <div class=queue-timeline>
                    1. 如果不满足以下任何条件，则生成验证错误并停止。
                        <div class=validusage>
                            - |buffer| 是  [$valid to use with$] |this|.
                            - |buffer|.{{GPUBuffer/[[state]]}} 是 [=buffer state/unmapped=]。
                            - |buffer|.{{GPUBuffer/[[usage]]}} 包含 {{GPUBufferUsage/COPY_DST}}。
                            - |bufferOffset|，转换为字节，是 4 字节的倍数。
                            - |bufferOffset| + |contentsSize| ，转换为字节 &le; |buffer|.{{GPUBuffer/[[size]]}} 字节。
                        </div>
                    1. 将 |contents| 写入 |buffer| 从 |bufferOffset| 开始。
                </div>
        </div>

    : <dfn>writeTexture(destination, data, dataLayout, size)</dfn>
    ::
        将提供的数据写入 {{GPUTexture}}。

        <div algorithm=GPUQueue.writeTexture>
            **调用:** {{GPUQueue}} |this|.

            **参数:**
            <pre class=argumentdef for="GPUQueue/writeTexture(destination, data, dataLayout, size)">
                |destination|: [=texture subresource=] 和要写入的来源。
                |data|: 要写入 |destination| 的数据。
                |dataLayout|: |data| 中内容的布局。
                |size|: 要从 |data| 写入的内容的范围 到 |destination|。
            </pre>

            **返回:** {{undefined}}

            1. 让 |dataBytes| 为获取缓冲区源的副本|缓冲区源所持有的字节的副本 |data|.
            1. 让 |dataByteSize| 是 |dataBytes| 中的字节数。
            1. 让 |textureDesc| 为 |destination|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}。
            1. 如果不满足以下任何一个条件，
                抛出 {{OperationError}} 并停止。
                <div class=validusage>
                    - [$validating linear texture data$](|dataLayout|,
                        |dataByteSize|,
                        |textureDesc|.{{GPUTextureDescriptor/format}},
                        |size|) succeeds.
                </div>
            1. 让 |contents| 是通过查看 |dataBytes| 看到的 [=images=] 的内容 与 |dataLayout| 和 |size|。

                问题：更正式地指定。
            1. 在 |this| 的 [=Queue timeline=] 上发出以下步骤:
                <div class=queue-timeline>
                    1. 如果不满足以下任何条件，则生成验证错误并停止。
                        <div class=validusage>
                            - [$validating GPUImageCopyTexture$](|destination|, |size|) 返回 `true`。
                            - |textureDesc|.{{GPUTextureDescriptor/usage}} 包含 {{GPUTextureUsage/COPY_DST}}。
                            - |textureDesc|.{{GPUTextureDescriptor/sampleCount}} 是 1。
                            - 满足 [=Valid Texture Copy Range=](|destination|, |size|)。
                            - |destination|.{{GPUImageCopyTexture/aspect}} 指的是 |textureDesc|.{{GPUTextureDescriptor/format}} 的单个可复制方面。 参见 [[#depth-formats|depth-formats]]。

                            注意：与 {{GPUCommandEncoder}}.{{GPUCommandEncoder/copyBufferToTexture()}} 不同，
                            |dataLayout|.{{GPUImageDataLayout/bytesPerRow}} 或 |dataLayout|.{{GPUImageDataLayout/offset}} 没有对齐要求。
                        </div>
                    1. 将 |contents| 写入 |destination|。

                </div>
        </div>

    : <dfn>copyExternalImageToTexture(source, destination, copySize)</dfn>
    ::
        将平台图像/画布的内容复制到目标纹理中。

        复制到 `-srgb` 纹理会产生相同的纹理字节，而不是相同的解码值，与复制到相应的非 `-srgb` 格式相同。
        因此，在复制操作之后，根据其格式是否为 `-srgb`，对目标纹理进行采样会产生不同的结果，其他一切都保持不变。

        问题：如果添加了 srgb 线性色彩空间，请在此处解释它是如何交互的。

        <div algorithm=GPUQueue.copyExternalImageToTexture>
            **调用:** {{GPUQueue}} |this|.

            **参数:**
            <pre class=argumentdef for="GPUQueue/copyExternalImageToTexture(source, destination, copySize)">
                |source|: 要复制到 |destination| 的源图像和来源。
                |destination|: [=texture subresource=] 和要写入的来源，及其编码元数据。
                |copySize|: 要从 |source| 到 |destination| 写入的内容的范围。
            </pre>

            **返回:** {{undefined}}

            1. 让 |sourceImage| 为 |source|.{{GPUImageCopyExternalImage/source}}。
            1. 运行 [=Check the usability of the image argument=](|sourceImage|).
                如果抛出异常，则停止。
                如果没有返回 `good`，抛出一个 {{InvalidStateError}} 并停止。
            1. 如果 |sourceImage| <l spec=html>[=is not origin-clean=]</l>,
                抛出一个 {{SecurityError}} 并停止。
            1. 如果未满足以下任何要求，则抛出 {{OperationError}} 并停止。
                <div class=validusage>
                    - 如果 |source|.{{GPUImageCopyExternalImage/source}} 是一个 {{HTMLCanvasElement}}:
                        它的 [=canvas context mode=] 必须是 `"2d"`， `"webgl"`， 或 `"webgl2"`。
                    - 如果 |source|.{{GPUImageCopyExternalImage/source}} 是一个 {{OffscreenCanvas}}:
                        它的 [=OffscreenCanvas context mode=] 必须是 `"2d"`， `"webgl"`， 或 `"webgl2"`。
                    - |source|.|origin|.[=Origin3D/x=] + |copySize|.[=Extent3D/width=]
                        必须 &le; |sourceImage| 的宽度。
                    - |source|.|origin|.[=Origin3D/y=] + |copySize|.[=Extent3D/height=]
                        必须 &le; |sourceImage| 的高度。
                    - |source|.|origin|.[=Origin3D/z=] + |copySize|.[=Extent3D/depthOrArrayLayers=]
                        必须 &le; 1。
                </div>
            1. 在 |this| 的 [=Device timeline=] 上发出以下步骤:
                <div class=device-timeline>
                    1. 让 |textureDesc| 为 |destination|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}。
                    1. 如果未满足以下任何要求，则生成验证错误并停止。
                        <div class=validusage>
                            - |destination|.{{GPUImageCopyTexture/texture}} 必须 [$valid to use with$] |this|。
                            - [$validating GPUImageCopyTexture$](destination, copySize) 必须返回 tru。.
                            - 必须满足 [=Valid Texture Copy Range=](destination, copySize)。
                            - |textureDesc|.{{GPUTextureDescriptor/usage}} 必须同时包含
                                {{GPUTextureUsage/RENDER_ATTACHMENT}} 和 {{GPUTextureUsage/COPY_DST}}。
                            - |textureDesc|.{{GPUTextureDescriptor/dimension}} 必须是 {{GPUTextureDimension/"2d"}}。
                            - |textureDesc|.{{GPUTextureDescriptor/sampleCount}} 必须是 1。
                            - |textureDesc|.{{GPUTextureDescriptor/format}} 必须是以下之一:
                                - {{GPUTextureFormat/"rgba8unorm"}}
                                - {{GPUTextureFormat/"rgba8unorm-srgb"}}
                                - {{GPUTextureFormat/"bgra8unorm"}}
                                - {{GPUTextureFormat/"bgra8unorm-srgb"}}
                                - {{GPUTextureFormat/"rgb10a2unorm"}}
                                - {{GPUTextureFormat/"rg8unorm"}}

                                问题：评估向此列表添加其他格式。
                                请注意，任何表示 0 到 1 之外的值的格式都与色彩空间（例如，clamped-srgb 与 extended-srgb）有交互作用。
                        </div>
                    1. 问题：进行实际复制。
                </div>
        </div>

    : <dfn>submit(commandBuffers)</dfn>
    ::
        调度 GPU 在此队列上执行命令缓冲区。

        <div algorithm=GPUQueue.submit>
            **调用:** {{GPUQueue}} this.

            **参数:**
            <pre class=argumentdef for="GPUQueue/submit(commandBuffers)">
                |commandBuffers|:
            </pre>

            **返回:** {{undefined}}

            在 |this| 的 [=Device timeline=] 上发出以下步骤:
            <div class=device-timeline>
                1. 如果不满足以下任何条件，则生成验证错误并停止。
                    <div class=validusage>
                        - |commandBuffers| 的任何元素中引用的每个 {{GPUBuffer}} 处于 `“unmapped”`[=buffer state=]。
                        - |commandBuffers| 的任何元素中的命令中引用的每个 {{GPUQuerySet}} 处于 [=query set state/available=] 状态。
                            对于遮挡查询，
                            {{GPUCommandEncoder/beginRenderPass()} 中的 {{GPURenderPassDescriptor/occlusionQuerySet}} 不构成参考，
                            而 {{GPURenderPassEncoder/beginOcclusionQuery()}} 则构成参考。
                    </div>

                1. 在 |this| 的 [=Queue timeline=] 上发出以下步骤:
                    <div class=queue-timeline>
                        1. 对于每个 |commandBuffer| 在 |commandBuffers| 中:
                            1. 执行 |commandBuffer|.{{GPUCommandBuffer/[[command_list]]}}中的每个命令。
                    </div>
            </div>
        </div>

    : <dfn>onSubmittedWorkDone()</dfn>
    ::
        返回一个 {{Promise}} ，一旦这个队列完成处理所有提交的工作，这个时刻就会解决。

        <div algorithm="GPUQueue.onSubmittedWorkDone">
            **调用:** {{GPUQueue}} this.

            **参数:**
            <pre class=argumentdef for="GPUQueue/onSubmittedWorkDone()">
            </pre>

            **返回:** {{Promise}}&lt;{{undefined}}&gt;

            问题：描述 {{GPUQueue/onSubmittedWorkDone()}} 算法步骤。
        </div>
</dl>

查询 {#queries}
================

## <dfn interface>GPUQuerySet</dfn> ## {#queryset}

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUQuerySet {
    undefined destroy();
};
GPUQuerySet includes GPUObjectBase;
</script>

{{GPUQuerySet}} 有以下内部插槽:

<dl dfn-type=attribute dfn-for="GPUQuerySet">
    : <dfn>\[[descriptor]]</dfn>， {{GPUQuerySetDescriptor}} 类型
    ::
        描述此查询集的 {{GPUQuerySetDescriptor}}。

        {{GPUTextureViewDescriptor}} 的所有可选字段都已定义。

    : <dfn>\[[state]]</dfn> 【=query set state=] 类型。
    ::
        {{GPUQuerySet}} 的当前状态。
</dl>

每个 {{GPUQuerySet}} 在 [=Device Timeline=] 上都有一个当前的 <dfn dfn>query set state</dfn>，它是以下之一：

 - "<dfn dfn for="query set state">available</dfn>" 其中 {{GPUQuerySet}} 可用于对其内容进行 GPU 操作。
 - "<dfn dfn for="query set state">destroyed</dfn>" 其中 {{GPUQuerySet}} 不再可用于除 {{GPUQuerySet/destroy}} 之外的任何操作。

### 查询集创建 ### {#queryset-creation}

{{GPUQuerySetDescriptor}} 指定用于创建 {{GPUQuerySet}} 的选项。

<script type=idl>
dictionary GPUQuerySetDescriptor : GPUObjectDescriptorBase {
    required GPUQueryType type;
    required GPUSize32 count;
    sequence<GPUPipelineStatisticName> pipelineStatistics = [];
};
</script>

<dl dfn-type=dict-member dfn-for=GPUQuerySetDescriptor>
    : <dfn>type</dfn>
    ::
        {{GPUQuerySet}} 管理的查询类型。

    : <dfn>count</dfn>
    ::
        {{GPUQuerySet}} 管理的查询数量。

    : <dfn>pipelineStatistics</dfn>
    ::
        此序列中的 {{GPUPipelineStatisticName}} 值集定义将在新查询集中返回哪些管道统计信息。
</dl>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createQuerySet(descriptor)</dfn>
    ::
        创建一个 {{GPUQuerySet}}.

        <div algorithm=GPUDevice.createQuerySet>
            **调用:** {{GPUDevice}} this.

            **参数:**
            <pre class=argumentdef for="GPUDevice/createQuerySet(descriptor)">
                descriptor: 要创建的 {{GPUQuerySet}} 的描述。
            </pre>

            **返回:** {{GPUQuerySet}}

            1. 如果 |descriptor|.{{GPUQuerySetDescriptor/type}} 是 {{GPUQueryType/"pipeline-statistics"}}，
                但是 |this|.{{GPUObjectBase/[[device]]}}.{{device/[[features]]}} 不包含 [=list/contain=]
                {{GPUFeatureName/"pipeline-statistics-query"}}，抛出一个 {{TypeError}}。
            1. 如果 |descriptor|.{{GPUQuerySetDescriptor/type}} 是 {{GPUQueryType/"timestamp"}}，
                但是 |this|.{{GPUObjectBase/[[device]]}}.{{device/[[features]]}} 不包含 [=list/contain=]
                {{GPUFeatureName/"timestamp-query"}}， 抛出一个 {{TypeError}}。
            1. 如果未满足以下任何要求，则返回错误查询集并停止。
                <div class=validusage>
                    - |this| 必须是一个 [=valid=] {{GPUDevice}}.
                    - |descriptor|.{{GPUQuerySetDescriptor/count}} 必须 &le; 8192.
                    - 如果 |descriptor|.{{GPUQuerySetDescriptor/type}} 是
                        {{GPUQueryType/"pipeline-statistics"}}:

                        - |descriptor|.{{GPUQuerySetDescriptor/pipelineStatistics}} 必须不能包含重复条目。

                        否则:

                        - |descriptor|.{{GPUQuerySetDescriptor/pipelineStatistics}} 必须是
                            [=list/empty=].
                </div>
            1. 让 |q| 成为一个新的 {{GPUQuerySet}} 对象。
            1. 设置 |q|.{{GPUQuerySet/[[descriptor]]}} 为 |descriptor|。
            1. 设置 |q|.{{GPUQuerySet/[[state]]}} 为 [=query set state/available=]。
            1. 返回 |q|。
        </div>
</dl>

### 查询集销毁 ### {#queryset-destruction}

不再需要 {{GPUQuerySet}} 的应用程序可以通过调用 {{GPUQuerySet/destroy()}} 选择在垃圾收集之前失去对它的访问权限。

<dl dfn-type=method dfn-for=GPUQuerySet>
    : <dfn>destroy()</dfn>
    ::
        销毁 {{GPUQuerySet}}。

        <div algorithm="GPUQuerySet.destroy">
            **调用:** {{GPUQuerySet}} |this|.

            **返回:** {{undefined}}

            1. 设置 |this|.{{GPUQuerySet/[[state]]}} 为 [=query set state/destroyed=]。
        </div>
</dl>

## 查询类型 ## {#querytype}

<script type=idl>
enum GPUQueryType {
    "occlusion",
    "pipeline-statistics",
    "timestamp"
};
</script>

## 遮挡查询 ## {#occlusion}

遮挡查询仅在渲染过程中可用，用于查询通过一组绘图命令的所有每个片段测试的片段样本数量，包括剪刀、样本蒙版、覆盖率、模板和深度测试。
查询的任何非零结果值表示至少有一个样本通过了测试并到达了渲染管道的输出合并阶段，0 表示没有样本通过测试。

开始渲染过程时，{{GPURenderPassDescriptor}}.{{GPURenderPassDescriptor/occlusionQuerySet}} 必须设置为能够在过程中使用遮挡查询。
遮挡查询开始和结束是通过成对调用 {{GPURenderPassEncoder/beginOcclusionQuery()}} 和 {{GPURenderPassEncoder/endOcclusionQuery()}}，不能嵌套。

## 管道统计查询 ## {#pipeline-statistics}

<script type=idl>
enum GPUPipelineStatisticName {
    "vertex-shader-invocations",
    "clipper-invocations",
    "clipper-primitives-out",
    "fragment-shader-invocations",
    "compute-shader-invocations"
};
</script>

解析pipeline统计查询时，将每个结果写入{{GPUSize64}}，
写入GPU缓冲区的结果数量和顺序与 {{GPUQuerySetDescriptor/pipelineStatistics}} 中指定的 {{GPUPipelineStatisticName}} 的数量和顺序匹配。

{{GPURenderPassEncoder/beginPipelineStatisticsQuery()}} 和 {{GPURenderPassEncoder/endPipelineStatisticsQuery()}}
（在 {{GPUComputePassEncoder}} 和 {{GPURenderPassEncoder}} 上）不能嵌套。 一个管道统计查询必须在开始另一个查询之前结束。

管道统计查询需要设备上可用的 {{GPUFeatureName/pipeline-statistics-query}}。

## 时间戳查询 ## {#timestamp}

时间戳查询允许应用程序通过在 {{GPUComputePassEncoder}} 或 {{GPURenderPassEncoder}} 或 {{GPUCommandEncoder}} 上调用
{{GPURenderPassEncoder/writeTimestamp()}} 将时间戳值写入 {{GPUQuerySet}}，
然后解析时间戳值 在 **nanoseconds**（{{GPUSize64}} 的类型）到 {{GPUBuffer}}（使用 {{GPUCommandEncoder/resolveQuerySet()}}）。

时间戳查询需要 {{GPUFeatureName/timestamp-query}} 在设备上可用。

注意：如果物理设备重置时间戳计数器，时间戳值可能为零，请忽略它和以下值。

问题：编写有关时间戳值重置的规范文本。

问题：由于时间戳查询提供高分辨率的 GPU 时间戳，我们需要确定其可用性受到哪些限制（如果有的话）。

# 画布渲染 # {#canvas-rendering}

## {{HTMLCanvasElement/getContext()|HTMLCanvasElement.getContext()}} ## {#canvas-getcontext}

{{GPUCanvasContext}} 对象可以通过 {{HTMLCanvasElement/getContext()}} 获得
{{HTMLCanvasElement}} 实例的方法，通过将字符串文字 `'webgpu'` 作为其 `contextType` 参数传递。

<div class="example">
    Get a {{GPUCanvasContext}} from an offscreen {{HTMLCanvasElement}}:
    <pre highlight="js">
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('webgpu');
        context.configure(/* ... */);
        // ...
    </pre>
</div>

## GPUCanvasContext ## {#canvas-context}

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUCanvasContext {
    readonly attribute (HTMLCanvasElement or OffscreenCanvas) canvas;

    undefined configure(GPUCanvasConfiguration configuration);
    undefined unconfigure();

    GPUTextureFormat getPreferredFormat(GPUAdapter adapter);
    GPUTexture getCurrentTexture();
};
</script>

{{GPUCanvasContext}} 具有以下属性:

<dl dfn-type=attribute dfn-for=GPUCanvasContext>
    : <dfn>canvas</dfn>
    ::
        创建此上下文的画布。
</dl>

{{GPUCanvasContext}} 有以下内部插槽:

<dl dfn-type=attribute dfn-for="GPUCanvasContext">
    : <dfn>\[[validConfiguration]]</dfn> boolean 类型， 初始化为 `false`。
    ::
        指示上下文当前是否具有有效配置。

    : <dfn>\[[configuration]]</dfn> {{GPUCanvasConfiguration}} 类型， 初始化为 `null`。
    ::
        配置此上下文的选项。 设置为 `null` 如果上下文尚未配置或配置已被删除。

    : <dfn>\[[size]]</dfn> {{GPUExtent3D}} 类型
    ::
        从该上下文返回的 {{GPUTexture}} 的大小。[=Extent3D/depthOrArrayLayers=] 始终为 `1`。

    : <dfn>\[[currentTexture]]</dfn> {{GPUTexture}} 类型， 初始化为 `null`
    ::
        调用 {{GPUCanvasContext/getCurrentTexture()}} 时上下文将返回的当前纹理，以及下一个要合成到文档中的纹理。
        最初设置为此上下文 [$allocating a new context texture$] 的结果。
</dl>

{{GPUCanvasContext}} 有以下方法:

<dl dfn-type=method dfn-for=GPUCanvasContext>
    : <dfn>configure(configuration)</dfn>
    ::
        配置此画布的上下文。 销毁使用先前配置生成的任何纹理。

        <div algorithm="GPUCanvasContext.configure">
            **调用:** {{GPUCanvasContext}} |this|.

            **参数:**
            <pre class=argumentdef for="GPUCanvasContext/configure(configuration)">
                |configuration|: 所需的上下文配置。
            </pre>

            **返回:** undefined

            1. 设定 |this|.{{GPUCanvasContext/[[validConfiguration]]}} 为 `false`.
            1. 设定 |this|.{{GPUCanvasContext/[[configuration]]}} 为 |configuration|.
            1. 如果 |this|.{{GPUCanvasContext/[[currentTexture]]}} 不是 `null` 在
                |this|.{{GPUCanvasContext/[[currentTexture]]}} 上调用 {{GPUTexture/destroy()}}。
            1. 设定 |this|.{{GPUCanvasContext/[[currentTexture]]}} 为 `null`.
            1. 让 |device| 为 |configuration|.{{GPUCanvasConfiguration/device}}。
            1. 让 |canvas| 为 |this|.{{GPUCanvasContext/canvas}}。
            1. 如果 |configuration|.{{GPUCanvasConfiguration/size}} 是 `undefined`， 设定
                |this|.{{GPUCanvasContext/[[size]]}} 为 [|canvas|.width, |canvas|.height, 1],
                否则设定 |this|.{{GPUCanvasContext/[[size]]}} 为
                |configuration|.{{GPUCanvasConfiguration/size}}。

            1. 在 |device| 的 [=Device Timeline=] 上执行以下步骤:
                <div class=device-timeline>
                    1. 如果不满足以下任一条件：
                        <div class=validusage>
                            - |device| 是一个 [=valid=] {{GPUDevice}}。
                            - [=Supported context formats=] [=set/contains=]
                                |configuration|.{{GPUCanvasConfiguration/format}}.
                            - |this|.{{GPUCanvasContext/[[size]]}}.[=Extent3D/width=] &gt; 0.
                            - |this|.{{GPUCanvasContext/[[size]]}}.[=Extent3D/width=] &le;
                                |device|.{{GPUDevice/limits}}.{{GPUSupportedLimits/maxTextureDimension2D}}.
                            - |this|.{{GPUCanvasContext/[[size]]}}.[=Extent3D/height=] &gt; 0.
                            - |this|.{{GPUCanvasContext/[[size]]}}.[=Extent3D/height=] &le;
                                |device|.{{GPUDevice/limits}}.{{GPUSupportedLimits/maxTextureDimension2D}}.
                            - |this|.{{GPUCanvasContext/[[size]]}}.[=Extent3D/depthOrArrayLayers=]
                                是 1;
                        </div>

                        Then:
                            1. 在当前范围内生成带有适当错误消息的 {{GPUValidationError}}。
                            1. 返回。
                </div>
            1. 设定 |this|.{{GPUCanvasContext/[[validConfiguration]]}} 为 `true`。
        </div>

    : <dfn>unconfigure()</dfn>
    ::
        删除上下文配置。 销毁配置时产生的任何纹理。

        <div algorithm="GPUCanvasContext.unconfigure">
            **调用:** {{GPUCanvasContext}} |this|。

            **返回:** undefined

            1. 设定 |this|.{{GPUCanvasContext/[[validConfiguration]]}} 为 `false`。
            1. 设定 |this|.{{GPUCanvasContext/[[configuration]]}} 为 `null`。
            1. 如果 |this|.{{GPUCanvasContext/[[currentTexture]]}} 不是 `null` 调用
                 |this|.{{GPUCanvasContext/[[currentTexture]]}} 上的 {{GPUTexture/destroy()}}。
            1. 设定 |this|.{{GPUCanvasContext/[[currentTexture]]}} 为 `null`。
        </div>

    : <dfn>getPreferredFormat(adapter)</dfn>
    ::
        返回最佳 {{GPUTextureFormat}} 以用于此上下文和从给定适配器创建的设备。

        <div algorithm="GPUCanvasContext.getPreferredFormat">
            **调用:** {{GPUCanvasContext}} this.

            **参数:**
            <pre class=argumentdef for="GPUCanvasContext/getPreferredFormat(adapter)">
                |adapter|: 应查询格式的适配器。
            </pre>

            **返回:** {{GPUTextureFormat}}

            <div class=content-timeline>
                1. 返回最佳 {{GPUTextureFormat}} 以在使用给定的 |adapter| 调用 {{GPUCanvasContext/configure()}} 时使用。 必须是 [=supported context formats=] 之一。
            </div>
        </div>

    : <dfn>getCurrentTexture()</dfn>
    ::
        获取将通过 {{GPUCanvasContext}} 合成到文档中的 {{GPUTexture}}。

        <div algorithm="GPUCanvasContext.getCurrentTexture">
            **调用:** {{GPUCanvasContext}} |this|。

            **返回:** {{GPUTexture}}

            1. 如果 |this|.{{GPUCanvasContext/[[configuration]]}} 是 `null`:
                1. 抛出一个 {{OperationError}} 并且停止。
            1. 如果 |this|.{{GPUCanvasContext/[[currentTexture]]}} 是 `null` 或者
                |this|.{{GPUCanvasContext/[[currentTexture]]}}.{{GPUTexture/[[destroyed]]}} 是 true:
                1. 设定 |this|.{{GPUCanvasContext/[[currentTexture]]}} 为 |this| 的 [$allocating
                    a new context texture$] 的结果。
            1. 返回 |this|.{{GPUCanvasContext/[[currentTexture]]}}。
        </div>

        注意：开发人员可以期望在同一帧内（即在 [=Update the rendering=] 的调用之间）每次调用 {{GPUCanvasContext/getCurrentTexture()}}
        都会返回相同的 {{GPUTexture}} 对象，除非 { {GPUCanvasContext/configure()}} 被调用。
</dl>

<div algorithm>
    在“[=Update the rendering=]”HTML 处理模型的“更新的 `Document` 渲染”步骤期间，
    每个{{GPUCanvasContext}} |context| 必须通过运行以下步骤将上下文内容呈现给画布<dfn abstract-op>present the context content to the </dfn>：

    1. 如果 |context|.{{GPUCanvasContext/[[currentTexture]]}} 不是 `null` 并且
        |context|.{{GPUCanvasContext/[[currentTexture]]}}.{{GPUTexture/[[destroyed]]}} 是 `false`:
        1. 让 |imageContents| 为 |context| 的
            [$get a copy of the image contents of a context|a copy of the image contents$]。
        1. 更新 |context|.{{GPUCanvasContext/canvas}} 使用 |imageContents|。
        1. 调用 |context|.{{GPUCanvasContext/[[currentTexture]]}}.{{GPUTexture/destroy()}}。
    1. 设定 |context|.{{GPUCanvasContext/[[currentTexture]]}} 为 `null`。
</div>

<div algorithm="transferToImageBitmap from WebGPU">
    当在带有 {{GPUCanvasContext}} |context| 的画布上调用 {{OffscreenCanvas/transferToImageBitmap()}} 时:

    1. 让 |imageContents| 为 |context| 的
        [$get a copy of the image contents of a context|a copy of the image contents$]。
    1. 如果 |context|.{{GPUCanvasContext/[[currentTexture]]}} 不是 `null`:
        1. 调用 |context|.{{GPUCanvasContext/[[currentTexture]]}}.{{GPUTexture/destroy()}}。
    1. 设定 |context|.{{GPUCanvasContext/[[currentTexture]]}} 为 `null`。
    1. 返回一个新的包含 |imageContents| 的 {{ImageBitmap}}。
</div>

<div algorithm>
当使用其他 Web API 读取 WebGPU 画布内容时，例如 {{CanvasDrawImage/drawImage()}}、
`texImage2D()`、`texSubImage2D()`、{{HTMLCanvasElement/toDataURL()}}、{{HTMLCanvasElement/toBlob()}}，
依此类推，他们得到一个上下文图像内容的副本<dfn abstract-op>get a copy of the image contents of a context</dfn>:

    **参数:**
    |context|: {{GPUCanvasContext}}

    **返回:** 图像内容

    1. 让 |texture| 为 |context|.{{GPUCanvasContext/[[currentTexture]]}}。
    1. 如果不满足以下任何要求，则返回大小为 |context|.{{GPUCanvasContext/[[size]]}} 的透明黑色图像并停止。
        <div class=validusage>
            - |texture| 不可以是 `null`。
            - |texture|.{{GPUTexture/[[destroyed]]}} 必须是 false。
            - 如果 |context|.{{GPUCanvasContext/canvas}} 是一个 {{OffscreenCanvas}},
                它不可以被连接到 [=placeholder canvas element=]。

                问题：如果添加，画布也不得“不同步”.
        </div>
    1. 确保所有提交的工作项（例如队列提交）都已完成写入 |texture|。
    1. 返回 |texture| 的内容，标记为具有 alpha 预乘，
        并返回有颜色空间 |context|.{{GPUCanvasContext/[[configuration]]}}.{{GPUCanvasConfiguration/colorSpace}}。

        问题(gpuweb/gpuweb#1847): compositingAlphaMode=opaque 是否会返回不透明的内容？
</div>

<div algorithm>
    为 {{GPUCanvasContext}} |context| 分配新的上下文纹理 <dfn abstract-op lt='allocating a new context texture'>allocate a new context texture</dfn> 运行以下步骤：

        1. 让 |device| 为 |context|.{{GPUCanvasContext/[[configuration]]}}.{{GPUCanvasConfiguration/device}}.
        1. 如果 |context|.{{GPUCanvasContext/[[validConfiguration]]}} 是 `false`:
            1. 在 |device| 的当前范围内生成 {{GPUValidationError}} 带有适当的错误消息。
            1. 返回一个新的 [=invalid=] {{GPUTexture}}。
        1. 让 |textureDescriptor| 为一个新的 {{GPUTextureDescriptor}}。
        1. 设定 |textureDescriptor|.{{GPUTextureDescriptor/size}} 为 |context|.{{GPUCanvasContext/[[size]]}}。
        1. 设定 |textureDescriptor|.{{GPUTextureDescriptor/format}} 为
            |context|.{{GPUCanvasContext/[[configuration]]}}.{{GPUCanvasConfiguration/format}}。
        1. 设定 |textureDescriptor|.{{GPUTextureDescriptor/usage}} 为
            |context|.{{GPUCanvasContext/[[configuration]]}}.{{GPUCanvasConfiguration/usage}}。
        1. 让 |texture| 为一个新的 {{GPUTexture}} 就像 |device|.{{GPUDevice/createTexture()}} 一样被创建，
            是用 |textureDescriptor| 调用的。
            <div class='note'>如果先前呈现的纹理来自 |context| 符合要求的标准，其 GPU 内存可能会被重复使用。</div>
        1. 确保 |texture| 被清空为  `(0, 0, 0, 0)`。
        1. 返回 |texture|。
</div>

## GPUCanvasConfiguration ## {#canvas-configuration}

<dfn dfn>supported context formats</dfn> 是 {{GPUTextureFormat}} 的一个 [=set=]，
不管给定的 {{GPUCanvasConfiguration}}.{{GPUCanvasConfiguration/device}} 的是什么，
当指定一个 {{GPUCanvasConfiguration}}.{{GPUCanvasConfiguration/format}} 它都必须支持，
初始设定为: &laquo;{{GPUTextureFormat/"bgra8unorm"}}, {{GPUTextureFormat/"bgra8unorm-srgb"}},
{{GPUTextureFormat/"rgba8unorm"}}, {{GPUTextureFormat/"rgba8unorm-srgb"}}&raquo;。

<script type=idl>

enum GPUCanvasCompositingAlphaMode {
    "opaque",
    "premultiplied",
};

dictionary GPUCanvasConfiguration {
    required GPUDevice device;
    required GPUTextureFormat format;
    GPUTextureUsageFlags usage = 0x10;  // GPUTextureUsage.RENDER_ATTACHMENT
    GPUPredefinedColorSpace colorSpace = "srgb";
    GPUCanvasCompositingAlphaMode compositingAlphaMode = "opaque";
    GPUExtent3D size;
};
</script>

问题：对于 SDR，“srgb”的默认颜色空间是表示extended-srgb 还是clamped-srgb 并不重要。 但是，当我们添加 HDR 画布输出（表示像素值 > 1）时，
我们需要选择这两个中的哪一个是默认值。 目前上游规范还没有解决这个问题。

### 画布上下文大小 ### {#context-sizing}

{{GPUCanvasContext}} 的 {{GPUCanvasContext/[[size]]}} 由传递给 {{GPUCanvasContext/configure()}} 的 {{GPUCanvasConfiguration}} 设置，
并保持不变直到 {{GPUCanvasContext/configure()}} 以新的大小再次调用。
如果未指定 {{GPUCanvasConfiguration/size}}，则将使用 {{GPUCanvasContext}}.{{GPUCanvasContext/canvas}}
在调用 {{GPUCanvasContext/configure()}} 时的宽度和高度属性 .
如果 {{GPUCanvasContext}}.{{GPUCanvasContext/[[size]]}} 与画布的尺寸不匹配，{{GPUCanvasContext}} 生成的纹理将被缩放以适合画布元素。

<div class="note">
    注意：与 `'webgl'` 或 `'2d'` 上下文不同，具有 `'webgpu'` 上下文的画布的 `width` 和 `height` 属性仅影响:
    - 默认布局大小，如果没有被 CSS 覆盖。
    - 调用 {{GPUCanvasContext/configure()}} 时， 默认 {{GPUCanvasConfiguration}}.{{GPUCanvasConfiguration/size}}，如果没有被覆盖。
</div>

如果需要在调整大小后匹配画布的尺寸，则必须通过使用新尺寸再次调用 {{GPUCanvasContext/configure()}} 来重新配置 {{GPUCanvasContext}}。

<div class="example">
    重新配置 {{GPUCanvasContext}} 以响应画布调整大小，使用 [ResizeObserver](https://www.w3.org/TR/resize-observer/) 进行监控以获取画布的确切像素尺寸:

    <pre highlight="js">
        const canvas = document.createElement('canvas');
        const context =  canvas.getContext('webgpu');

        const resizeObserver = new ResizeObserver(entries => {
            for (const entry of entries) {
                if (entry != canvas) { continue; }
                context.configure({
                    device: someDevice,
                    format: context.getPreferredFormat(someDevice.adapter),
                    size: {
                        // 这以像素为单位报告画布元素的大小
                        width: entry.devicePixelContentBoxSize[0].inlineSize,
                        height: entry.devicePixelContentBoxSize[0].blockSize,
                    }
                });
            }
        });
        resizeObserver.observe(canvas);
    </pre>
</div>

## <dfn dfn-type=enum-value dfn-for=GPUCanvasCompositingAlphaMode>GPUCanvasCompositingAlphaMode</dfn> ## {#GPUCanvasCompositingAlphaMode}

这个 enum 选择画布上下文的内容将如何绘制到页面上。

<table class='data'>
    <thead>
        <tr>
            <th>GPUCanvasCompositingAlphaMode
            <th>Description
            <th>dst.rgb
            <th>dst.a
    </thead>
    <tr>
        <td>{{GPUCanvasCompositingAlphaMode/opaque}}
        <td>将 RGB 绘制为不透明并忽略 alpha 值。
            如果内容尚未不透明，则实现可能需要在演示期间将 alpha 清除为不透明。
        <td>|dst.rgb = src.rgb|
        <td>|dst.a = 1|
    <tr>
        <td>{{GPUCanvasCompositingAlphaMode/premultiplied}}
        <td>复合假设颜色值预先乘以它们的 alpha 值。
            100% 红色 50% 不透明是 [0.5, 0, 0, 0.5]。
            颜色值必须小于或等于它们的 alpha 值。
            [1.0, 0, 0, 0.5] 是“超亮”，无法可靠显示。
        <td>|dst.rgb = src.rgb + dst.rgb*(1-src.a)|
        <td>|dst.a = src.a + dst.a*(1-src.a)|
</table>

# 错误 &amp; 调试 # {#errors-and-debugging}

## 致命错误 ## {#fatal-errors}

<script type=idl>
enum GPUDeviceLostReason {
    "destroyed",
};

[Exposed=(Window, DedicatedWorker)]
interface GPUDeviceLostInfo {
    readonly attribute (GPUDeviceLostReason or undefined) reason;
    readonly attribute DOMString message;
};

partial interface GPUDevice {
    readonly attribute Promise<GPUDeviceLostInfo> lost;
};
</script>


## 错误范围 ## {#error-scopes}

<script type=idl>
enum GPUErrorFilter {
    "out-of-memory",
    "validation"
};
</script>

<script type=idl>
[Exposed=(Window, DedicatedWorker)]
interface GPUOutOfMemoryError {
    constructor();
};

[Exposed=(Window, DedicatedWorker)]
interface GPUValidationError {
    constructor(DOMString message);
    readonly attribute DOMString message;
};

typedef (GPUOutOfMemoryError or GPUValidationError) GPUError;
</script>

<script type=idl>
partial interface GPUDevice {
    undefined pushErrorScope(GPUErrorFilter filter);
    Promise<GPUError?> popErrorScope();
};
</script>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>pushErrorScope(filter)</dfn>
    ::
        问题：定义 pushErrorScope。

    : <dfn>popErrorScope()</dfn>
    ::
        问题：定义 popErrorScope。

        用 {{OperationError}} 拒绝，如果:

        - 设备丢失。
        - 堆栈上没有错误范围。
</dl>

## 遥测 ## {#telemetry}

<script type=idl>
[
    Exposed=(Window, DedicatedWorker)
]
interface GPUUncapturedErrorEvent : Event {
    constructor(
        DOMString type,
        GPUUncapturedErrorEventInit gpuUncapturedErrorEventInitDict
    );
    [SameObject] readonly attribute GPUError error;
};

dictionary GPUUncapturedErrorEventInit : EventInit {
    required GPUError error;
};
</script>

<script type=idl>
partial interface GPUDevice {
    [Exposed=(Window, DedicatedWorker)]
    attribute EventHandler onuncapturederror;
};
</script>


# 详细操作 # {#detailed-operations}

本节介绍各种GPU操作的详细信息。

## 转移 ## {#transfer-operations}

问题：描述高级别的转移。

## 计算 ## {#computing-operations}

计算提供对GPU可编程硬件的直接访问的操作。计算没有管线输入或输出的着色器，它们的结果是将数据写入绑定为{{GPUBufferBindingType/"storage"|GPUBufferBindingType."storage"}}和{{GPUStorageTextureBindingLayout}}的存储绑定的副作用。这些操作在{{GPUComputePassEncoder}}中编码为：
  - {{GPUComputePassEncoder/dispatch()}}
  - {{GPUComputePassEncoder/dispatchIndirect()}}

问题：描述计算算法。

## 渲染 ## {#rendering-operations}

渲染由一组GPU操作完成，这些操作在{{GPURenderPassEncoder}}中执行，并导致纹理数据的修改，由渲染通道附件查看。这些操作编码为：
  - {{GPURenderEncoderBase/draw()}}
  - {{GPURenderEncoderBase/drawIndexed()}},
  - {{GPURenderEncoderBase/drawIndirect()}}
  - {{GPURenderEncoderBase/drawIndexedIndirect()}}.

注意：渲染是GPU的传统用途，由硬件中的多个固定功能块支持。

<dfn dfn>RenderState</dfn>是一个在命令编码时表示当前{{GPURenderPassEncoder}}状态的内部对象。[=RenderState=]是以下定义的规范命名空间：
<div algorithm="RenderState accessors" dfn-for=RenderState>
    对一个给定的{{GPURenderPassEncoder}} |pass|，句法：

      - |pass|.<dfn dfn>indexBuffer</dfn>指通过{{GPURenderEncoderBase/setIndexBuffer()}}绑定的索引缓冲区，如果有的话。
      - |pass|.<dfn dfn>vertexBuffers</dfn>指通过{{GPURenderEncoderBase/setVertexBuffer()}}绑定的[=list=]&lt;vertex buffer&gt;。
      - |pass|.<dfn dfn>bindGroups</dfn>指通过{{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)}}绑定的[=list=]&lt;{{GPUBindGroup}}&gt;。
</div>

主渲染算法：

<div>
    <dfn abstract-op>render</dfn>(descriptor, drawCall, state)

        **Arguments:**
            - |descriptor|: 当前{{GPURenderPipeline}}的描述。
            - |drawCall|: 绘制调用参数。
            - |state|: 发出绘制调用的{{GPURenderEncoderBase}}的[=RenderState=]。

        1. **Resolve indices**. 见[[#index-resolution]]。

            使|vertexList|为[$resolve indices$](|drawCall|, |state|)的结果。

        2. **Process vertices**. See [[#vertex-processing]].

            执行[$process vertices$](|vertexList|, |drawCall|, |descriptor|.{{GPURenderPipelineDescriptor/vertex}}, |state|)。

        3. **Assemble primitives**.

            执行assemble primitives(|vertexList|, |drawCall|, |descriptor|.{{GPURenderPipelineDescriptor/primitive}})。

        4. **Clip primitives**.

        5. 光栅化。
        6. 处理片元。
            问题：完成此节。
        7. 处理深度/模板。
            问题：完成此节。
        8. 写入像素。
            问题：完成此节。
</div>

### 索引分辨率 ### {#index-resolution}

在渲染的第一阶段，管道会为每个实例构建一个要处理的顶点列表。
<div>
    <dfn abstract-op>resolve indices</dfn>(drawCall, state)

    **Arguments:**
    - |drawCall|: 绘制调用参数。
    - |state|: 激活的[=RenderState=]。

    **Returns:** 整数索引列表。

    1. 使|vertexIndexList|为一个空的索引列表。
    2. 如果|drawCall|是一个索引绘制调用：
        1. 使用|drawCall|.indexCount整数初始化|vertexIndexList|。
        2. 对0 .. |drawCall|.indexCount (non-inclusive)范围内的|i|：
            1. 使|relativeVertexIndex| be [$fetch index$](|i| + |drawCall|.`firstIndex`,
                |state|.[=RenderState/indexBuffer=])。
            2. 如果|relativeVertexIndex|有 `"out of bounds"` 的具体值，停止并返回空列表。

                注意：当发生这种情况时，实现可能会选择显示警告，特别是当它很容易检测时（如在非间接索引绘制调用中）。
            3. 将|drawCall|.`baseVertex` + |relativeVertexIndex|添加至|vertexIndexList|。
    3. Otherwise:
        1. 使用|drawCall|.vertexCount整数初始化|vertexIndexList|。
        2. 设置每个|vertexIndexList| item |i|为值|drawCall|.firstVertex + |i|。
    4. 返回|vertexIndexList|。

    注意：在间接绘制调用的情况下，从间接缓冲区而不是绘制命令本身读取indexCount、vertexCount 和|drawCall|的其他属性。

    问题：更好地细化间接命令。
</div>

<div>
    <dfn abstract-op>fetch index</dfn>(i, buffer, offset, format)

    **Arguments:**
    - |i|: 要获取的顶点索引的索引。
    - |indexBufferState|: [=RenderState/indexBuffer=] (buffer, format, offset, and size)的值。

    **Returns:** 无符号整数或 `"out of bounds"`

    1. 使|indexSize|被indexBufferState|.`format`定义：
        <dl class="switch">
            : {{GPUIndexFormat/"uint16"}}
            :: 2
            : {{GPUIndexFormat/"uint32"}}
            :: 4
        </dl>
    2. 如果|indexBufferState|.`offset` + |i + 1| &times; |indexSize| &gt; |indexBufferState|.`size`，返回特殊值 `"out of bounds"`。
    3. 将|indexBufferState|.`buffer`中的数据从偏移量|indexBufferState|.`offset` + |i| &times; |indexSize|开始，大小为|indexSize|字节，解释为一个无符号整数并返回它。
</div>

### 顶点处理 ### {#vertex-processing}

顶点处理阶段是渲染[=pipeline=]的一个可编程阶段，它处理顶点属性数据，并为#primitive-clipping生成剪辑空间位置，以及为[[#fragment-processing]]片元处理生成其他数据。

<div>
    <dfn abstract-op>process vertices</dfn>(vertexIndexList, drawCall, desc, state)

    **Arguments:**
    - |vertexIndexList|: 要处理的定点索引列表（可变，通过引用传递）。
    - |desc|: 类型{{GPUVertexState}}的描述符。
    - |state|: 激活的[=RenderState=]。

    每个|vertexIndexList|中的顶点|vertexIndex|，在索引|rawInstanceIndex|的每个实例中，都是独立处理的。|rawInstanceIndex|的范围是从0到|drawCall|.instanceCount - 1，包括这两个值。此处理并行发生，任何副作用，例如写入{{GPUBufferBindingType/"storage"|GPUBufferBindingType."storage"}}绑定，都可能以任何顺序发生。

    1. 使|instanceIndex|为|rawInstanceIndex| + |drawCall|.firstInstance.
    2. 对每个列表|desc|.{{GPUVertexState/buffers}}中的non-`null` |vertexBufferLayout|：
        1. 使|i|为此列表中缓冲区布局的索引值。
        2. 使|vertexBuffer|，|vertexBufferOffset|，和|vertexBufferBindingSize|为buffer，offset，和|state|.[=RenderState/vertexBuffers=]的|i|处大小。
        3. 使|vertexElementIndex|依赖于|vertexBufferLayout|.{{GPUVertexBufferLayout/stepMode}}:
            <dl class="switch">
                : {{GPUVertexStepMode/"vertex"}}
                :: |vertexIndex|
                : {{GPUVertexStepMode/"instance"}}
                :: |instanceIndex|
            </dl>
        4. 对每个|vertexBufferLayout|.{{GPUVertexBufferLayout/attributes}}中的|attributeDesc|：
            1. 使|attributeOffset|为|vertexBufferOffset| +
                |vertexElementIndex| * |vertexBufferLayout|.{{GPUVertexBufferLayout/arrayStride}} +
                |attributeDesc|.{{GPUVertexAttribute/offset}}。
            2. 从|vertexBuffer|偏移量|attributeOffset|开始，加载格式|attributeDesc|.{{GPUVertexAttribute/format}}的属性数据。 组件按 x、y、z、w 的顺序从缓冲区内存中加载。

                如果这导致越界访问，则结果值根据WGSL的[=invalid memory reference=]行为确定。
            3. **Optionally (implementation-defined):**
                如果|attributeOffset| + sizeof(|attributeDesc|.{{GPUVertexAttribute/format}}) &gt;
                |vertexBufferOffset| + |vertexBufferBindingSize|,
                [=list/empty=] |vertexIndexList|并且停止，取消绘制调用。

                注意：这允许实现在发出绘制调用之前检测索引缓冲区中的越界值，而不是使用[=invalid memory reference=]行为。
            4. 根据[=channel formats=]规则，将|数据|转换为着色器可见的格式。
                <div class="example">
                    在WGSL中，{{GPUVertexFormat/"snorm8x2"}}类型的属性和字节值 `[0x70, 0xD0]` 将转换为 `vec2<f32>(0.88, -0.24)`。
                </div>
            5. 调整|数据|大小至着色器类型：
                - 如果都是标量，或者都是相同维度的向量，则不需要调整。
                - 如果|数据|是向量但是着色器类型为标量，则只提取第一个分量。
                - 如果两者都是向量，并且|数据|具有更高的维度，则删除额外的组件。
                    <div class="example">
                        如果需要2-component vector，则类型为{{GPUVertexFormat/"float32x3"}}且值为 `vec3<f32>(1.0, 2.0, 3.0)` 的属性将作为 `vec2<f32>(1.0, 2.0)`暴露给着色器。
                    </div>
                - 如果着色器类型是更高维度的向量，或者|数据|是标量，则以 `vec4<*>(0, 0, 0, 1)` 值填充缺失的组件。
                    <div class="example">
                        如果需要4-component vector，则类型为{{GPUVertexFormat/"sint32"}}且值为5的属性将作为 `vec4<i32>(5, 0, 0, 1)`暴露给着色器。
                    </div>
            6. 将|数据|绑定到顶点着色器输入位置|attributeDesc|.{{GPUVertexAttribute/shaderLocation}}。
    3. 对每个|state|.[=RenderState/bindGroups=]中的{{GPUBindGroup}}组：
        1. 对每个绑定组中的资源{{GPUBindingResource}}：
            1. 使|entry|为此资源对应的{{GPUBindGroupLayoutEntry}}。
            2. 如果|entry|.{{GPUBindGroupLayoutEntry}}.visibility包含{{GPUShaderStage/VERTEX}}:
                - 绑定资源至|索引|组下的着色器并绑定{{GPUBindGroupLayoutEntry/binding|GPUBindGroupLayoutEntry.binding}}.
    4. 设置着色器[=builtins=]:
        - 将vertex_index内置，如果有的话，设置为|vertexIndex|。
        - 将instance_index内置，如果有的话，设置为|instanceIndex|。
    5. 调用由|desc|描述的顶点着色器入口点。

        注意：目标平台缓存顶点着色器调用的结果。不能保证任何重复多次的|vertexIndex|会导致多次调用。同样，不能保证单个|vertexIndex|只会被处理一次。
</div>

### 图元装配 ### {#primitive-assembly}

图元由GPU的固定功能阶段组装。

<div>
    <dfn abstract-op>assemble primitives</dfn>(vertexIndexList, drawCall, desc)

        **Arguments:**
            - |vertexIndexList|: 要处理的顶点索引列表。
            - |drawCall|: 绘制调用参数。
            - |desc|: 类型{{GPUPrimitiveState}}的描述符。

        对于每个实例，图元都是根据|vertexIndexList|从着色器处理过的顶点组装而成的。

        1. 首先，如果|desc|.{{GPUPrimitiveState/stripIndexFormat}}不为null(这意味着图元拓扑是一个strip)，并且|drawCall|已被索引。|vertexIndexList|被拆分为子列表，使用此索引格式的最大值作为分隔符。

            示例：一个类型为{{GPUIndexFormat/"uint16"}}，值为 `[1, 2, 65535, 4, 5, 6]`的|vertexIndexList|将被拆分为子列表：`[1, 2]`和 `[4, 5, 6]`。

        2. 对于每个子列表|vl|，根据|desc|.{{GPUPrimitiveState/topology}}进行图元生成：
            <dl class="switch">
                : {{GPUPrimitiveTopology/"line-list"}}
                ::
                    线图元由(|vl|.0, |vl|.1)，然后(|vl|.2, |vl|.3)，然后(|vl|.4, |vl|.5)等组成。每个后续图元采用2个顶点。

                : {{GPUPrimitiveTopology/"line-strip"}}
                ::
                    线图元由(|vl|.0, |vl|.1)，然后(|vl|.1, |vl|.2)，然后(|vl|.2, |vl|.3)等组成。每个后续图元采用1个顶点。

                : {{GPUPrimitiveTopology/"triangle-list"}}
                ::
                    三角形图元由(|vl|.0, |vl|.1, |vl|.2)，然后(|vl|.3, |vl|.4, |vl|.5)，然后(|vl|.6, |vl|.7, |vl|.8)等组成。每个后续图元采用3个顶点。

                : {{GPUPrimitiveTopology/"triangle-strip"}}
                ::
                    三角形图元由(|vl|.0, |vl|.1, |vl|.2)，然后(|vl|.2, |vl|.1, |vl|.3)，然后(|vl|.2, |vl|.3, |vl|.4)，然后(|vl|.4, |vl|.3, |vl|.5)等组成。每个后续图元采用1个顶点。
            </dl>

            问题：这应该更正式地定义吗？

            未完成的图元被删除。

</div>

### 图元剪裁 ### {#primitive-clipping}

顶点着色器必须创建一个内置的“position”（类型为 vec4<f32>），表示顶点的<dfn dfn>clip position</dfn>。

问题：连接至WGSL内置项。

图元被剪裁到<dfn dfn>clip volume</dfn>，对于图元内的任何剪裁位置p，它由以下不等式定义：
  - &minus;|p|.w &le; |p|.x &le; |p|.w
  - &minus;|p|.w &le; |p|.y &le; |p|.w
  - 0 &le; |p|.z &le; |p|.w (<dfn dfn>depth clipping</dfn>)

如果descriptor|.{{GPURenderPipelineDescriptor/primitive}}.{{GPUPrimitiveState/clampDepth}}为true，则不应用对[=clip volume=]的[=depth clipping=]限制。

如果图元的每条边都完全位于[=clip volume=]内，则图元不变地通过此阶段。如果图元的边与剪辑体积的边界相交，则相交的边将通过位于[=clip volume=]边界的新边重新连接。对于三角形图元（|descriptor|.{{GPURenderPipelineDescriptor/primitive}}.{{GPUPrimitiveState/topology}}是{{GPUPrimitiveTopology/"triangle-list"}}或{{GPUPrimitiveTopology/"triangle-strip"}}），这种重新连接可能会导致在多边形内部引入新的顶点。

如果图元与[=clip volume=]边界的一条边相交，则裁剪的多边形必须包含一个在该边界边上的点。

如果顶点着色器输出其他浮点值（标量和向量），用“透视”插值限定，它们也会被裁剪。与位于裁剪体积内的顶点关联的输出值不受裁剪的影响。然而，如果一个图元被裁剪，分配给裁剪产生的顶点的输出值也会被裁剪。

考虑顶点|a|和|b|之间的边被剪裁，导致顶点|c|，让我们定义|t|为边顶点之间的比率：|c|.p = |t| &times; |a|.p &plus; (1 &minus; |t|) &times; |b|.p，其中|x|.p是顶点|x|的输出[=clip position=]。

对于具有相应片元输入的每个顶点输出值“v”，|a|.v和|b|.v将分别是|a|和|b|顶点的输出。裁剪着色器输出|c|.v是基于插值限定符生成的：
<dl class="switch">
    : "flat"
    ::
        flat插值不受影响，并且基于<dfn dfn>provoking vertex</dfn>，即图元中的第一个顶点。 整个图元的输出值相同，并且与[=provoking vertex=]的顶点输出匹配：|c|.v = [=provoking vertex=].v。

    : "linear"
    ::
        插值率根据[=clip position=]的透视坐标调整，所以的差值结果在屏幕空间中为线性的。

        问题：在这里提供更多细节，如果可能。

    : "perspective"
    ::
        该值在裁剪空间中线性插值，产生透视正确的值：

        |c|.v = |t| &times; |a|.v &plus; (1 &minus; |t|) &times; |b|.v
</dl>

问题：链接到WGSL中的插值限定符。

### 光栅化 ### {#rasterization}

光栅化是硬件处理阶段，将生成的图元映射到<dfn dfn>framebuffer</dfn>的二维渲染区域——当前{{GPURenderPassEncoder}}中的渲染附件集。 该渲染区域被分成均匀的像素网格。

光栅化确定受图元影响的像素集。在多重采样的情况下，每个像素被进一步拆分为|descriptor|.{{GPURenderPipelineDescriptor/multisample}}.{{GPUMultisampleState/count}}个样本。每个像素的样本位置都相同，但在本规范中未定义。

问题：我们需要强制启用Vulkan中的"Standard sample locations"吗？

[=framebuffer=]坐标从渲染目标的左上角开始。 每个单元正好对应一个像素。有关更多信息，请参阅[[#coordinate-systems]]坐标系。

1. 首先，裁剪的顶点被转换为<dfn dfn>NDC</dfn>-归一化设备坐标。给定输出位置|p|，[=NDC=]坐标计算如下：

    ndc(|p|) = vector(|p|.x &divide; |p|.w, |p|.y &divide; |p|.w, |p|.z &divide; |p|.w)

2. 使|viewport|为当前渲染通道的{{GPURenderPassEncoder/[[viewport]]}}。然后根据渲染目标的大小将[=NDC=]坐标|n|转换为[=framebuffer=]坐标：

    framebufferCoords(n) = vector(|viewport|.`x` &plus; 0.5&times;(|n|.x&plus;1)&times;|viewport|.width, |viewport|.y &plus; 0.5&times;(|n|.y&plus;1)&times;|viewport|.height)

3. 具体光栅化算法依赖于{{GPURenderPipelineDescriptor/primitive}}.{{GPUPrimitiveState/topology}}：
    <dl class="switch">
        : {{GPUPrimitiveTopology/"point-list"}}
        :: 点, 如果未被#primitive-clipping过滤, 则进入[[#point-rasterization]]。
        : {{GPUPrimitiveTopology/"line-list"}}或{{GPUPrimitiveTopology/"line-strip"}}
        :: 被#primitive-clipping裁剪的线段，进入[[#line-rasterization]]。
        : {{GPUPrimitiveTopology/"triangle-list"}}或{{GPUPrimitiveTopology/"triangle-strip"}}
        :: #primitive-clipping产生的多边形，进入[[#polygon-rasterization]]。
    </dl>

Issue: 更改"goes into"部分的措辞。

让我们将<dfn dfn>fragment destination</dfn>定义为像素位置与样本索引的组合，以防[[#sample-frequency-shading]]处于激活状态。

光栅化的结果为一个点集，每个点带有以下数据：
  - [=fragment destination=]
  - multisample coverage mask (see [[#sample-masking]])
  - depth, in NDC coordinates.
  - barycentric coordinates

问题：定义barycentric coordinates。
问题：定义深度计算算法。

#### 点光栅化 #### {#point-rasterization}

单个[=fragment destination=]在包含点的framebuffer坐标的像素内被选择。

coverage mask依赖于多重采样模式:
<dl class="switch">
    : sample-frequency
    :: coverageMask = 1 &Lt; `sampleIndex`
    : pixel-frequency multi-sampling
    :: coverageMask = 1 &Lt; |descriptor|.{{GPURenderPipelineDescriptor/multisample}}.{{GPUMultisampleState/count}} &minus; 1
    : no multi-sampling
    :: coverageMask = 1
</dl>

#### 线光栅化 #### {#line-rasterization}

问题：补充本章节。

#### 多边形光栅化 #### {#polygon-rasterization}

令v(i)为对|n|个顶点的光栅化多边形裁剪顶点编号|i|（从1开始）的framebuffer坐标。

注意：本节以术语“多边形”替代“三角形”，由于#primitive-clipping阶段可能介绍了其他顶点。这不会被应用程序发现。

多边形光栅化的第一步是确定多边形是<dfn dfn>front-facing</dfn>还是<dfn dfn>back-facing</dfn>。这取决于framebuffer坐标中多边形所占|区域|的符号：

|area| = 0.5 &times; ((|v|<sub>1</sub>.x &times; |v|<sub>|n|</sub>.y &minus; |v|<sub>|n|</sub>.x &times; |v|<sub>1</sub>.y) &plus; &sum; (|v|<sub>|i|&plus;1</sub>.x &times; |v|<sub>|i|</sub>.y &minus; |v|<sub>|i|</sub>.x &times; |v|<sub>|i|&plus;1</sub>.y))

|区域|的符号是根据{{GPURenderPipelineDescriptor/primitive}}.{{GPUPrimitiveState/frontFace}}解释的：
<dl class="switch">
    : {{GPUFrontFace/"ccw"}}
    :: |area| &gt; 0被当作[=front-facing=], 否则为[=back-facing=]
    : {{GPUFrontFace/"cw"}}
    :: |area| &lt; 0被当作[=front-facing=], 否则为[=back-facing=]
    : "linear"
    ::
</dl>

多边形可以被{{GPURenderPipelineDescriptor/primitive}}.{{GPUPrimitiveState/cullMode}}剔除：
<dl class="switch">
    : {{GPUCullMode/"none"}}
    :: 所有通过此测试的多边形。
    : {{GPUCullMode/"front"}}
    :: [=front-facing=]多边形将被丢弃，并且不会在渲染管线的后期阶段进行处理。
    : {{GPUCullMode/"back"}}
    :: [=back-facing=]多边形将被丢弃。
</dl>

下一步是在帧缓冲区空间中确定多边形内的一组<dfn dfn>fragments</dfn>-这些是为每个片元操作安排的位置。最终确认是基于|descriptor|.{{GPURenderPipelineDescriptor/multisample}}的：
<dl class="switch">
    : disabled
    :: [=Fragment=]与像素中心相关联。也就是说，包含在多边形中的framebuffer空间中坐标为C的所有点（其中fract(|C|) = vector2(0.5, 0.5)）都包括在内。如果像素中心位于多边形的边缘，则是否包含它未定义。

        注意：这成为光栅化器的精度问题。

    : enabled
    :: 每个像素都与|descriptor|.{{GPURenderPipelineDescriptor/multisample}}.{{GPUMultisampleState/count}}位置相关联，这些位置是实现定义的。位置是有序的，并且列表对于framebuffer的每个像素都是相同的。每个位置对应于多采样framebuffer中的一个片元。

       光栅化器构建每个像素内被击中的位置的掩码，并提供作为片元着色器内置的“样本掩码”。

</dl>

### 片元处理 ### {#fragment-processing}

问题：补充此章节。

### 无颜色输出 ### {#no-color-output}

在no-color-output模式下，[=pipeline=]不产生任何颜色附件输出。

[=pipeline=]仍然执行光栅化并根据顶点位置输出生成深度值。深度测试和模板操作仍然可以使用。

### Alpha覆盖 ### {#alpha-to-coverage}

在alpha-to-coverage模式下, 根据{GPURenderPipelineDescriptor/fragment}}.{{GPUFragmentState/targets}}[0]的片元着色器输出|alpha|组件，产生一个另外的MSAA样本的<dfn dfn>alpha-to-coverage mask</dfn>。

生成额外掩码的算法取决于平台，并且可能因不同像素而异。它保证：
  - 如果|alpha|为0.0或更小，结果为0x0。
  - 如果|alpha|为1.0或更大，结果为0xFFFFFFFF。
  - 如果|alpha|比一些其他的|alpha1|更大，则生成的样本掩码设置为1的位数至少和|alpha1|的掩码一样多。
    then the produced sample mask has at least as many bits set to 1 as the mask for |alpha1|

### 采样频率着色 ### {#sample-frequency-shading}

问题：补充此章节。

### 采样遮掩 ### {#sample-masking}

一个像素的<dfn dfn>final sample mask</dfn>计算为：
[=rasterization mask=] & {{GPUMultisampleState/mask}} & [=shader-output mask=]

仅考虑掩码的较低{{GPUMultisampleState/count}}位。

如果[=final sample mask=]的位置|N|处的最低有效位的值为“0”，则丢弃到片段着色器的所有附件的样本颜色输出（对应于样本|N|）。 此外，不会对深度模板附件的相关样本执行深度测试或模板操作。

注意：样本|N|的颜色输出是由片段着色器执行产生的，当前像素的 SV_SampleIndex == |N|。如果片元着色器不使用此语义，则每个像素仅执行一次。

<dfn dfn>rasterization mask</dfn>由光栅化阶段根据光栅化多边形的形状生成。包含在形状中的样本在掩码中获得相关位1。

<dfn dfn>shader-output mask</dfn>采用片元着色器中内置的“sample_mask”的输出值。如果内置函数不是从片元着色器输出的，并且启用了{{GPUMultisampleState/alphaToCoverageEnabled}}，则[=shader-output mask=]将成为[=alpha-to-coverage mask=]。否则，它默认为0xFFFFFFFF。

# 类型定义 # {#type-definitions}

<script type=idl>
typedef [EnforceRange] unsigned long GPUBufferDynamicOffset;
typedef [EnforceRange] unsigned long GPUStencilValue;
typedef [EnforceRange] unsigned long GPUSampleMask;
typedef [EnforceRange] long GPUDepthBias;

typedef [EnforceRange] unsigned long long GPUSize64;
typedef [EnforceRange] unsigned long GPUIntegerCoordinate;
typedef [EnforceRange] unsigned long GPUIndex32;
typedef [EnforceRange] unsigned long GPUSize32;
typedef [EnforceRange] long GPUSignedOffset32;

typedef unsigned long GPUFlagsConstant;
</script>

## 颜色 &amp; 向量 ## {#colors-and-vectors}

<script type=idl>
dictionary GPUColorDict {
    required double r;
    required double g;
    required double b;
    required double a;
};
typedef (sequence<double> or GPUColorDict) GPUColor;
</script>

注意：`double`足够大以精确保存32位有符号/无符号整数和单精度浮点数。

<script type=idl>
dictionary GPUOrigin2DDict {
    GPUIntegerCoordinate x = 0;
    GPUIntegerCoordinate y = 0;
};
typedef (sequence<GPUIntegerCoordinate> or GPUOrigin2DDict) GPUOrigin2D;
</script>

<dfn dfn>Origin2D</dfn>是一个{{GPUOrigin2D}}。
[=Origin2D=]是以下定义的规范命名空间：
<!-- This is silly, but provides convenient syntax for the spec. -->

<div algorithm="GPUOrigin2D accessors" dfn-for=Origin2D>
    对一个给定{{GPUOrigin2D}}值的|origin|，根据其类型，句法：

      - |origin|.<dfn dfn>x</dfn>指{{GPUOrigin2DDict}}.{{GPUOrigin2DDict/x}}或序列的第一项，如果不存在则为0。
      - |origin|.<dfn dfn>y</dfn>指{{GPUOrigin2DDict}}.{{GPUOrigin2DDict/y}}或序列的第二项，如果不存在则为0。
</div>

<script type=idl>
dictionary GPUOrigin3DDict {
    GPUIntegerCoordinate x = 0;
    GPUIntegerCoordinate y = 0;
    GPUIntegerCoordinate z = 0;
};
typedef (sequence<GPUIntegerCoordinate> or GPUOrigin3DDict) GPUOrigin3D;
</script>

<dfn dfn>Origin3D</dfn>是一个{{GPUOrigin3D}}。
[=Origin3D=]是以下定义的规范命名空间：
<!-- This is silly, but provides convenient syntax for the spec. -->

<div algorithm="GPUOrigin3D accessors" dfn-for=Origin3D>
    对于给定{{GPUOrigin3D}}值的|origin|，根据它的类型，句法：

      - |origin|.<dfn dfn>x</dfn>指{{GPUOrigin3DDict}}.{{GPUOrigin3DDict/x}}或序列的第一项，如果不存在则为0。
      - |origin|.<dfn dfn>y</dfn>指{{GPUOrigin3DDict}}.{{GPUOrigin3DDict/y}}或序列的第二项，如果不存在则为0。
      - |origin|.<dfn dfn>z</dfn>指{{GPUOrigin3DDict}}.{{GPUOrigin3DDict/z}}或序列的第三项，如果不存在则为0。
</div>

<script type=idl>
dictionary GPUExtent3DDict {
    required GPUIntegerCoordinate width;
    GPUIntegerCoordinate height = 1;
    GPUIntegerCoordinate depthOrArrayLayers = 1;
};
typedef (sequence<GPUIntegerCoordinate> or GPUExtent3DDict) GPUExtent3D;
</script>

<dfn dfn>Extent3D</dfn>是一个{{GPUExtent3D}}.
[=Extent3D=]为以下定义的规范命名空间：
<!-- This is silly, but provides convenient syntax for the spec. -->

<div algorithm="GPUExtent3D accessors" dfn-for=Extent3D>
    For a given {{GPUExtent3D}} value |extent|, depending on its type, the syntax:

      - |extent|.<dfn dfn>width</dfn>指{{GPUExtent3DDict}}.{{GPUExtent3DDict/width}}或序列的第一项，如果不存在则为1。
      - |extent|.<dfn dfn>height</dfn>指{{GPUExtent3DDict}}.{{GPUExtent3DDict/height}}或序列的第二项，如果不存在则为1。
      - |extent|.<dfn dfn>depthOrArrayLayers</dfn>指{{GPUExtent3DDict}}.{{GPUExtent3DDict/depthOrArrayLayers}}或序列的第三项，如果不存在则为1。
</div>

# 特性索引 # {#feature-index}

## <dfn dfn-type=enum-value dfn-for=GPUFeatureName>"depth-clamping"</dfn> ## {#depth-clamping}

问题：当{{GPUFeatureName/"depth-clamping"}} [=feature=]被启用时定义功能。

**特性字典值**

以下字典值当且仅当{{GPUFeatureName/"depth-clamping"}}
[=feature=]启用时被支持，否则必须设置为它们的默认值：

<dl>
    : {{GPUPrimitiveState}}
    ::
        * {{GPUPrimitiveState/clampDepth}}
</dl>

## <dfn dfn-type=enum-value dfn-for=GPUFeatureName>"depth24unorm-stencil8"</dfn> ## {#depth24unorm-stencil8}

允许明确创建{{GPUTextureFormat/"depth24unorm-stencil8"}}格式的纹理。

**特性枚举**

以下枚举当且仅当{{GPUFeatureName/"depth24unorm-stencil8"}}
[=feature=]启用时被支持：

<dl>
    : {{GPUTextureFormat}}
    ::
        * {{GPUTextureFormat/"depth24unorm-stencil8"}}
</dl>

## <dfn dfn-type=enum-value dfn-for=GPUFeatureName>"depth32float-stencil8"</dfn> ## {#depth32float-stencil8}

允许明确创建{{GPUTextureFormat/"depth32float-stencil8"}}格式的纹理。

**特性枚举**

以下枚举当且仅当{{GPUFeatureName/"depth32float-stencil8"}} [=feature=]启用时被支持。

<dl>
    : {{GPUTextureFormat}}
    ::
        * {{GPUTextureFormat/"depth32float-stencil8"}}
</dl>

## <dfn dfn-type=enum-value dfn-for=GPUFeatureName>"pipeline-statistics-query"</dfn> ## {#pipeline-statistics-query}

问题：当{{GPUFeatureName/"pipeline-statistics-query"}} [=feature=]启用时定义功能。

**特性枚举**

以下枚举当且仅当{{GPUFeatureName/"pipeline-statistics-query"}}
[=feature=]启用时被支持：

<dl>
    : {{GPUQueryType}}
    ::
        * {{GPUQueryType/"pipeline-statistics"}}
</dl>


## <dfn dfn-type=enum-value dfn-for=GPUFeatureName>"texture-compression-bc"</dfn> ## {#texture-compression-bc}

允许明确创建BC压缩格式的纹理。

**特性枚举**

以下枚举当且仅当{{GPUFeatureName/"texture-compression-bc"}}
[=feature=]启用时被支持：

<dl>
    : {{GPUTextureFormat}}
    ::
        * {{GPUTextureFormat/"bc1-rgba-unorm"}}
        * {{GPUTextureFormat/"bc1-rgba-unorm-srgb"}}
        * {{GPUTextureFormat/"bc2-rgba-unorm"}}
        * {{GPUTextureFormat/"bc2-rgba-unorm-srgb"}}
        * {{GPUTextureFormat/"bc3-rgba-unorm"}}
        * {{GPUTextureFormat/"bc3-rgba-unorm-srgb"}}
        * {{GPUTextureFormat/"bc4-r-unorm"}}
        * {{GPUTextureFormat/"bc4-r-snorm"}}
        * {{GPUTextureFormat/"bc5-rg-unorm"}}
        * {{GPUTextureFormat/"bc5-rg-snorm"}}
        * {{GPUTextureFormat/"bc6h-rgb-ufloat"}}
        * {{GPUTextureFormat/"bc6h-rgb-float"}}
        * {{GPUTextureFormat/"bc7-rgba-unorm"}}
        * {{GPUTextureFormat/"bc7-rgba-unorm-srgb"}}
</dl>

## <dfn dfn-type=enum-value dfn-for=GPUFeatureName>"texture-compression-etc2"</dfn> ## {#texture-compression-etc}

允许明确创建ETC2压缩格式的纹理。

**特性枚举**

以下枚举当且仅当{{GPUFeatureName/"texture-compression-etc2"}}
[=feature=]启用时被支持：

<dl>
    : {{GPUTextureFormat}}
    ::
        * {{GPUTextureFormat/"etc2-rgb8unorm"}}
        * {{GPUTextureFormat/"etc2-rgb8unorm-srgb"}}
        * {{GPUTextureFormat/"etc2-rgb8a1unorm"}}
        * {{GPUTextureFormat/"etc2-rgb8a1unorm-srgb"}}
        * {{GPUTextureFormat/"etc2-rgba8unorm"}}
        * {{GPUTextureFormat/"etc2-rgba8unorm-srgb"}}
        * {{GPUTextureFormat/"eac-r11unorm"}}
        * {{GPUTextureFormat/"eac-r11snorm"}}
        * {{GPUTextureFormat/"eac-rg11unorm"}}
        * {{GPUTextureFormat/"eac-rg11snorm"}}
</dl>

## <dfn dfn-type=enum-value dfn-for=GPUFeatureName>"texture-compression-astc"</dfn> ## {#texture-compression-astc}

允许明确创建ASTC压缩格式的纹理。

**特性枚举**

以下枚举当且仅当{{GPUFeatureName/"texture-compression-astc"}}
[=feature=]启用时被支持：

<dl>
    : {{GPUTextureFormat}}
    ::
        * {{GPUTextureFormat/"astc-4x4-unorm"}}
        * {{GPUTextureFormat/"astc-4x4-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-5x4-unorm"}}
        * {{GPUTextureFormat/"astc-5x4-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-5x5-unorm"}}
        * {{GPUTextureFormat/"astc-5x5-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-6x5-unorm"}}
        * {{GPUTextureFormat/"astc-6x5-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-6x6-unorm"}}
        * {{GPUTextureFormat/"astc-6x6-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-8x5-unorm"}}
        * {{GPUTextureFormat/"astc-8x5-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-8x6-unorm"}}
        * {{GPUTextureFormat/"astc-8x6-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-8x8-unorm"}}
        * {{GPUTextureFormat/"astc-8x8-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-10x5-unorm"}}
        * {{GPUTextureFormat/"astc-10x5-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-10x6-unorm"}}
        * {{GPUTextureFormat/"astc-10x6-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-10x8-unorm"}}
        * {{GPUTextureFormat/"astc-10x8-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-10x10-unorm"}}
        * {{GPUTextureFormat/"astc-10x10-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-12x10-unorm"}}
        * {{GPUTextureFormat/"astc-12x10-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-12x12-unorm"}}
        * {{GPUTextureFormat/"astc-12x12-unorm-srgb"}}
</dl>

## <dfn dfn-type=enum-value dfn-for=GPUFeatureName>"timestamp-query"</dfn> ## {#timestamp-query}

问题：当{{GPUFeatureName/"timestamp-query"}} [=feature=]启用时定义功能。

**特性枚举**

以下枚举当且仅当{{GPUFeatureName/"timestamp-query"}}
[=feature=]启用时被支持。

<dl>
    : {{GPUQueryType}}
    ::
        * {{GPUQueryType/"timestamp"}}
</dl>

# 附录 # {#appendices}

## 纹理格式功能 ## {#texture-format-caps}

### 纯色格式 ### {#plain-color-formats}

所有纯色格式支持{{GPUTextureUsage/COPY_SRC}}, {{GPUTextureUsage/COPY_DST}}, 和{{GPUTextureUsage/TEXTURE_BINDING}}用法。

只有具有{{GPUTextureSampleType}} {{GPUTextureSampleType/"float"}}才能被混合。

列{{GPUTextureUsage/RENDER_ATTACHMENT}}和{{GPUTextureUsage/STORAGE_BINDING}}分别指定对{{GPUTextureUsage/RENDER_ATTACHMENT|GPUTextureUsage.RENDER_ATTACHMENT}}和{{GPUTextureUsage/STORAGE_BINDING|GPUTextureUsage.STORAGE_BINDING}}用法的支持。

<table class='data'>
    <thead class=stickyheader>
        <tr>
            <th>Format
            <th>{{GPUTextureSampleType}}
            <th>{{GPUTextureUsage/RENDER_ATTACHMENT}}
            <th>{{GPUTextureUsage/STORAGE_BINDING}}
    </thead>
    <tr><th class=stickyheader>8-bit per component<th><th><th>
    <tr>
        <td>{{GPUTextureFormat/r8unorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/r8snorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>
        <td>
    <tr>
        <td>{{GPUTextureFormat/r8uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/r8sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/rg8unorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/rg8snorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>
        <td>
    <tr>
        <td>{{GPUTextureFormat/rg8uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/rg8sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/rgba8unorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rgba8unorm-srgb}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/rgba8snorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rgba8uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rgba8sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/bgra8unorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/bgra8unorm-srgb}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>
    <tr><th class=stickyheader>16-bit per component<th><th><th>
    <tr>
        <td>{{GPUTextureFormat/r16uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/r16sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/r16float}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/rg16uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/rg16sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/rg16float}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td><!-- Vulkan -->
    <tr>
        <td>{{GPUTextureFormat/rgba16uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rgba16sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rgba16float}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&checkmark;
    <tr><th class=stickyheader>32-bit per component<th><th><th>
    <tr>
        <td>{{GPUTextureFormat/r32uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/r32sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/r32float}}
        <td>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rg32uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rg32sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rg32float}}
        <td>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rgba32uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rgba32sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rgba32float}}
        <td>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&checkmark;
    <tr><th class=stickyheader>mixed component width<th><th><th>
    <tr>
        <td>{{GPUTextureFormat/rgb10a2unorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/rg11b10ufloat}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td><!-- Vulkan -->
        <td>

</table>

### 深度/模板格式 ### {#depth-formats}

所有深度格式都支持{{GPUTextureUsage/COPY_SRC}}，{{GPUTextureUsage/COPY_DST}}，{{GPUTextureUsage/TEXTURE_BINDING}}，和{{GPUTextureUsage/RENDER_ATTACHMENT}}用法。但是，源/目标受格式限制。

没有深度格式可以被过滤。

<table class='data'>
    <thead>
        <tr>
            <th>Format
            <th>Bytes per texel
            <th>Aspect
            <th>{{GPUTextureSampleType}}
            <th>Returned in shaders as...
            <th>Copy aspect from Buffer
            <th>Copy aspect into Buffer
    </thead>
    <tr>
        <td>{{GPUTextureFormat/stencil8}}
        <td>1 &minus; 4
        <td>stencil
        <td>{{GPUTextureSampleType/"uint"}}
        <td>`vec4<u32>(S, X, X, X)`
        <td colspan=2>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/depth16unorm}}
        <td>2
        <td>depth
        <td>{{GPUTextureSampleType/"depth"}}
        <td>`f32(D)`
        <td colspan=2>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/depth24plus}}
        <td>4
        <td>depth
        <td>{{GPUTextureSampleType/"depth"}}
        <td>`f32(D)`
        <td colspan=2>&cross;
    <tr>
        <td rowspan=2 style='white-space:nowrap'>{{GPUTextureFormat/depth24plus-stencil8}}
        <td rowspan=2>4 &minus; 8
        <td>depth
        <td>{{GPUTextureSampleType/"depth"}}
        <td>`f32(D)`
        <td colspan=2>&cross;
    <tr>
        <td>stencil
        <td>{{GPUTextureSampleType/"uint"}}
        <td>`vec4<u32>(S, X, X, X)`
        <td colspan=2>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/depth32float}}
        <td>4
        <td>depth
        <td>{{GPUTextureSampleType/"depth"}}
        <td>`f32(D)`
        <td colspan=1>&cross;
        <td colspan=1>&checkmark;
</table>

模板格式必须采样为 `vec4<u32>(S, X, X, X)`，其中S是模板值，每个X是实现定义的未指定值。作者不能依赖这些.y、.z和.w组件，因为它们的行为是不可移植的。

注意：如果没有添加新的更受约束的模板采样器类型（如深度），实现有效地掩盖模板读取的驱动程序差异是不可行的。由于这不是WebGL的可移植性痛点，因此预计在WebGPU中不会有问题。实际上，根据硬件，需要 `vec4<u32>(S, S, S, S)` 或 `vec4<u32>(S, 0, 0, 1)`。

<dfn dfn>Copies of depth and stencil textures</dfn>只能在以下格式集内发生：
  - {{GPUTextureFormat/stencil8}}, {{GPUTextureFormat/depth24plus-stencil8}} (模板组件), {{GPUTextureFormat/r8uint}}
  - {{GPUTextureFormat/depth16unorm}}, {{GPUTextureFormat/r16uint}}
  - {{GPUTextureFormat/depth24plus}}, {{GPUTextureFormat/depth24plus-stencil8}} (深度宽高比)

另外，{{GPUTextureFormat/depth32float}}纹理可以被拷贝至{{GPUTextureFormat/depth32float}}和{{GPUTextureFormat/r32float}}纹理。

注意：{{GPUTextureFormat/depth32float}}纹素值的范围有限。因此，复制到{{GPUTextureFormat/depth32float}}纹理仅对其他{{GPUTextureFormat/depth32float}}纹理有效。

问题：阐明 `depth24plus-stencil8` 是否可以被复制到所有目标后端API中的 `depth24plus`。

### 打包格式 ### {#packed-formats}

所有打包纹理格式支持{{GPUTextureUsage/COPY_SRC}}, {{GPUTextureUsage/COPY_DST}}, 和{{GPUTextureUsage/TEXTURE_BINDING}}用法。所有这些有{{GPUTextureSampleType/"float"}}类型的格式可以在采样时被过滤。

<table class='data'>
    <thead class=stickyheader>
        <tr>
            <th>Format
            <th>Bytes per block
            <th>{{GPUTextureSampleType}}
            <th>Block Size
            <th>[=Feature=]
    </thead>
    <tr>
        <td>{{GPUTextureFormat/rgb9e5ufloat}}
        <td>4
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>1 &times; 1
        <td>
    <tr>
        <td>{{GPUTextureFormat/bc1-rgba-unorm}}
        <td rowspan=2>8
        <td rowspan=14>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td rowspan=14>4 &times; 4
        <td rowspan=14>{{GPUFeatureName/texture-compression-bc}}
    <tr>
        <td>{{GPUTextureFormat/bc1-rgba-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/bc2-rgba-unorm}}
        <td rowspan=2>16
    <tr>
        <td>{{GPUTextureFormat/bc2-rgba-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/bc3-rgba-unorm}}
        <td rowspan=2>16
    <tr>
        <td>{{GPUTextureFormat/bc3-rgba-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/bc4-r-unorm}}
        <td rowspan=2>8
    <tr>
        <td>{{GPUTextureFormat/bc4-r-snorm}}
    <tr>
        <td>{{GPUTextureFormat/bc5-rg-unorm}}
        <td rowspan=2>16
    <tr>
        <td>{{GPUTextureFormat/bc5-rg-snorm}}
    <tr>
        <td>{{GPUTextureFormat/bc6h-rgb-ufloat}}
        <td rowspan=2>16
    <tr>
        <td>{{GPUTextureFormat/bc6h-rgb-float}}
    <tr>
        <td>{{GPUTextureFormat/bc7-rgba-unorm}}
        <td rowspan=2>16
    <tr>
        <td>{{GPUTextureFormat/bc7-rgba-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/etc2-rgb8unorm}}
        <td rowspan=2>8
        <td rowspan=10>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td rowspan=10>4 &times; 4
        <td rowspan=10>{{GPUFeatureName/texture-compression-etc2}}
    <tr>
        <td>{{GPUTextureFormat/etc2-rgb8unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/etc2-rgb8a1unorm}}
        <td rowspan=2>8
    <tr>
        <td>{{GPUTextureFormat/etc2-rgb8a1unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/etc2-rgba8unorm}}
        <td rowspan=2>16
    <tr>
        <td>{{GPUTextureFormat/etc2-rgba8unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/eac-r11unorm}}
        <td rowspan=2>8
    <tr>
        <td>{{GPUTextureFormat/eac-r11snorm}}
    <tr>
        <td>{{GPUTextureFormat/eac-rg11unorm}}
        <td rowspan=2>16
    <tr>
        <td>{{GPUTextureFormat/eac-rg11snorm}}
    <tr>
        <td>{{GPUTextureFormat/astc-4x4-unorm}}
        <td rowspan=2>16
        <td rowspan=28>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td rowspan=2>4 &times; 4
        <td rowspan=28>{{GPUFeatureName/texture-compression-astc}}
    <tr>
        <td>{{GPUTextureFormat/astc-4x4-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-5x4-unorm}}
        <td rowspan=2>16
        <td rowspan=2>5 &times; 4
    <tr>
        <td>{{GPUTextureFormat/astc-5x4-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-5x5-unorm}}
        <td rowspan=2>16
        <td rowspan=2>5 &times; 5
    <tr>
        <td>{{GPUTextureFormat/astc-5x5-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-6x5-unorm}}
        <td rowspan=2>16
        <td rowspan=2>6 &times; 5
    <tr>
        <td>{{GPUTextureFormat/astc-6x5-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-6x6-unorm}}
        <td rowspan=2>16
        <td rowspan=2>6 &times; 6
    <tr>
        <td>{{GPUTextureFormat/astc-6x6-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-8x5-unorm}}
        <td rowspan=2>16
        <td rowspan=2>8 &times; 5
    <tr>
        <td>{{GPUTextureFormat/astc-8x5-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-8x6-unorm}}
        <td rowspan=2>16
        <td rowspan=2>8 &times; 6
    <tr>
        <td>{{GPUTextureFormat/astc-8x6-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-8x8-unorm}}
        <td rowspan=2>16
        <td rowspan=2>8 &times; 8
    <tr>
        <td>{{GPUTextureFormat/astc-8x8-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-10x5-unorm}}
        <td rowspan=2>16
        <td rowspan=2>10 &times; 5
    <tr>
        <td>{{GPUTextureFormat/astc-10x5-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-10x6-unorm}}
        <td rowspan=2>16
        <td rowspan=2>10 &times; 6
    <tr>
        <td>{{GPUTextureFormat/astc-10x6-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-10x8-unorm}}
        <td rowspan=2>16
        <td rowspan=2>10 &times; 8
    <tr>
        <td>{{GPUTextureFormat/astc-10x8-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-10x10-unorm}}
        <td rowspan=2>16
        <td rowspan=2>10 &times; 10
    <tr>
        <td>{{GPUTextureFormat/astc-10x10-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-12x10-unorm}}
        <td rowspan=2>16
        <td rowspan=2>12 &times; 10
    <tr>
        <td>{{GPUTextureFormat/astc-12x10-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-12x12-unorm}}
        <td rowspan=2>16
        <td rowspan=2>12 &times; 12
    <tr>
        <td>{{GPUTextureFormat/astc-12x12-unorm-srgb}}
</table>

## 非导出dfns的临时使用 ## {#temp-dfn-usages}

[=Origin2D/x=] [=Origin2D/y=]
[=RenderPassDescriptor/renderExtent=]

最终这些将被删除，但目前它们对避免构建此规范文档时的编译警告仍然有用。

[=vertex buffer=]
